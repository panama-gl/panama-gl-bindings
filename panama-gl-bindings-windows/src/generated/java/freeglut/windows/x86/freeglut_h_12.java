// Generated by jextract

package freeglut.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class freeglut_h_12 extends freeglut_h_13 {

    freeglut_h_12() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETICMMODE
     * }
     */
    public static final AddressLayout PEMRSETICMMODE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETTEXTALIGN
     * }
     */
    public static final AddressLayout PEMRSETTEXTALIGN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETMITERLIMIT {
     *     EMR emr;
     *     FLOAT eMiterLimit;
     * } *PEMRSETMITERLIMIT
     * }
     */
    public static final AddressLayout PEMRSETMITERLIMIT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRRESTOREDC {
     *     EMR emr;
     *     LONG iRelative;
     * } *PEMRRESTOREDC
     * }
     */
    public static final AddressLayout PEMRRESTOREDC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETARCDIRECTION {
     *     EMR emr;
     *     DWORD iArcDirection;
     * } *PEMRSETARCDIRECTION
     * }
     */
    public static final AddressLayout PEMRSETARCDIRECTION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETMAPPERFLAGS {
     *     EMR emr;
     *     DWORD dwFlags;
     * } *PEMRSETMAPPERFLAGS
     * }
     */
    public static final AddressLayout PEMRSETMAPPERFLAGS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETTEXTCOLOR {
     *     EMR emr;
     *     COLORREF crColor;
     * } *PEMRSETBKCOLOR
     * }
     */
    public static final AddressLayout PEMRSETBKCOLOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETTEXTCOLOR {
     *     EMR emr;
     *     COLORREF crColor;
     * } *PEMRSETTEXTCOLOR
     * }
     */
    public static final AddressLayout PEMRSETTEXTCOLOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTOBJECT {
     *     EMR emr;
     *     DWORD ihObject;
     * } *PEMRSELECTOBJECT
     * }
     */
    public static final AddressLayout PEMRSELECTOBJECT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTOBJECT {
     *     EMR emr;
     *     DWORD ihObject;
     * } *PEMRDELETEOBJECT
     * }
     */
    public static final AddressLayout PEMRDELETEOBJECT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     * } *PEMRSELECTPALETTE
     * }
     */
    public static final AddressLayout PEMRSELECTPALETTE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRRESIZEPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     *     DWORD cEntries;
     * } *PEMRRESIZEPALETTE
     * }
     */
    public static final AddressLayout PEMRRESIZEPALETTE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETPALETTEENTRIES {
     *     EMR emr;
     *     DWORD ihPal;
     *     DWORD iStart;
     *     DWORD cEntries;
     *     PALETTEENTRY aPalEntries[1];
     * } *PEMRSETPALETTEENTRIES
     * }
     */
    public static final AddressLayout PEMRSETPALETTEENTRIES = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORADJUSTMENT {
     *     EMR emr;
     *     COLORADJUSTMENT ColorAdjustment;
     * } *PEMRSETCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout PEMRSETCOLORADJUSTMENT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGDICOMMENT {
     *     EMR emr;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGDICOMMENT
     * }
     */
    public static final AddressLayout PEMRGDICOMMENT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREOF {
     *     EMR emr;
     *     DWORD nPalEntries;
     *     DWORD offPalEntries;
     *     DWORD nSizeLast;
     * } *PEMREOF
     * }
     */
    public static final AddressLayout PEMREOF = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRLINETO {
     *     EMR emr;
     *     POINTL ptl;
     * } *PEMRLINETO
     * }
     */
    public static final AddressLayout PEMRLINETO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRLINETO {
     *     EMR emr;
     *     POINTL ptl;
     * } *PEMRMOVETOEX
     * }
     */
    public static final AddressLayout PEMRMOVETOEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMROFFSETCLIPRGN {
     *     EMR emr;
     *     POINTL ptlOffset;
     * } *PEMROFFSETCLIPRGN
     * }
     */
    public static final AddressLayout PEMROFFSETCLIPRGN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRFILLPATH
     * }
     */
    public static final AddressLayout PEMRFILLPATH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRSTROKEANDFILLPATH
     * }
     */
    public static final AddressLayout PEMRSTROKEANDFILLPATH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRSTROKEPATH
     * }
     */
    public static final AddressLayout PEMRSTROKEPATH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXCLUDECLIPRECT {
     *     EMR emr;
     *     RECTL rclClip;
     * } *PEMREXCLUDECLIPRECT
     * }
     */
    public static final AddressLayout PEMREXCLUDECLIPRECT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXCLUDECLIPRECT {
     *     EMR emr;
     *     RECTL rclClip;
     * } *PEMRINTERSECTCLIPRECT
     * }
     */
    public static final AddressLayout PEMRINTERSECTCLIPRECT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETVIEWPORTORGEX
     * }
     */
    public static final AddressLayout PEMRSETVIEWPORTORGEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETWINDOWORGEX
     * }
     */
    public static final AddressLayout PEMRSETWINDOWORGEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETBRUSHORGEX
     * }
     */
    public static final AddressLayout PEMRSETBRUSHORGEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTEXTEX {
     *     EMR emr;
     *     SIZEL szlExtent;
     * } *PEMRSETVIEWPORTEXTEX
     * }
     */
    public static final AddressLayout PEMRSETVIEWPORTEXTEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTEXTEX {
     *     EMR emr;
     *     SIZEL szlExtent;
     * } *PEMRSETWINDOWEXTEX
     * }
     */
    public static final AddressLayout PEMRSETWINDOWEXTEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSCALEVIEWPORTEXTEX {
     *     EMR emr;
     *     LONG xNum;
     *     LONG xDenom;
     *     LONG yNum;
     *     LONG yDenom;
     * } *PEMRSCALEVIEWPORTEXTEX
     * }
     */
    public static final AddressLayout PEMRSCALEVIEWPORTEXTEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSCALEVIEWPORTEXTEX {
     *     EMR emr;
     *     LONG xNum;
     *     LONG xDenom;
     *     LONG yNum;
     *     LONG yDenom;
     * } *PEMRSCALEWINDOWEXTEX
     * }
     */
    public static final AddressLayout PEMRSCALEWINDOWEXTEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETWORLDTRANSFORM {
     *     EMR emr;
     *     XFORM xform;
     * } *PEMRSETWORLDTRANSFORM
     * }
     */
    public static final AddressLayout PEMRSETWORLDTRANSFORM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRMODIFYWORLDTRANSFORM {
     *     EMR emr;
     *     XFORM xform;
     *     DWORD iMode;
     * } *PEMRMODIFYWORLDTRANSFORM
     * }
     */
    public static final AddressLayout PEMRMODIFYWORLDTRANSFORM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETPIXELV {
     *     EMR emr;
     *     POINTL ptlPixel;
     *     COLORREF crColor;
     * } *PEMRSETPIXELV
     * }
     */
    public static final AddressLayout PEMRSETPIXELV = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTFLOODFILL {
     *     EMR emr;
     *     POINTL ptlStart;
     *     COLORREF crColor;
     *     DWORD iMode;
     * } *PEMREXTFLOODFILL
     * }
     */
    public static final AddressLayout PEMREXTFLOODFILL = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRELLIPSE {
     *     EMR emr;
     *     RECTL rclBox;
     * } *PEMRELLIPSE
     * }
     */
    public static final AddressLayout PEMRELLIPSE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRELLIPSE {
     *     EMR emr;
     *     RECTL rclBox;
     * } *PEMRRECTANGLE
     * }
     */
    public static final AddressLayout PEMRRECTANGLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRROUNDRECT {
     *     EMR emr;
     *     RECTL rclBox;
     *     SIZEL szlCorner;
     * } *PEMRROUNDRECT
     * }
     */
    public static final AddressLayout PEMRROUNDRECT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRARC
     * }
     */
    public static final AddressLayout PEMRARC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRARCTO
     * }
     */
    public static final AddressLayout PEMRARCTO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRCHORD
     * }
     */
    public static final AddressLayout PEMRCHORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRPIE
     * }
     */
    public static final AddressLayout PEMRPIE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRANGLEARC {
     *     EMR emr;
     *     POINTL ptlCenter;
     *     DWORD nRadius;
     *     FLOAT eStartAngle;
     *     FLOAT eSweepAngle;
     * } *PEMRANGLEARC
     * }
     */
    public static final AddressLayout PEMRANGLEARC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYLINE
     * }
     */
    public static final AddressLayout PEMRPOLYLINE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYBEZIER
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYGON
     * }
     */
    public static final AddressLayout PEMRPOLYGON = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYBEZIERTO
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIERTO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYLINETO
     * }
     */
    public static final AddressLayout PEMRPOLYLINETO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYLINE16
     * }
     */
    public static final AddressLayout PEMRPOLYLINE16 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYBEZIER16
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIER16 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYGON16
     * }
     */
    public static final AddressLayout PEMRPOLYGON16 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYBEZIERTO16
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIERTO16 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYLINETO16
     * }
     */
    public static final AddressLayout PEMRPOLYLINETO16 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYDRAW {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     *     BYTE abTypes[1];
     * } *PEMRPOLYDRAW
     * }
     */
    public static final AddressLayout PEMRPOLYDRAW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYDRAW16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     *     BYTE abTypes[1];
     * } *PEMRPOLYDRAW16
     * }
     */
    public static final AddressLayout PEMRPOLYDRAW16 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cptl;
     *     DWORD aPolyCounts[1];
     *     POINTL aptl[1];
     * } *PEMRPOLYPOLYLINE
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYLINE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cptl;
     *     DWORD aPolyCounts[1];
     *     POINTL aptl[1];
     * } *PEMRPOLYPOLYGON
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYGON = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cpts;
     *     DWORD aPolyCounts[1];
     *     POINTS apts[1];
     * } *PEMRPOLYPOLYLINE16
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYLINE16 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cpts;
     *     DWORD aPolyCounts[1];
     *     POINTS apts[1];
     * } *PEMRPOLYPOLYGON16
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYGON16 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRINVERTRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     BYTE RgnData[1];
     * } *PEMRINVERTRGN
     * }
     */
    public static final AddressLayout PEMRINVERTRGN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRINVERTRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     BYTE RgnData[1];
     * } *PEMRPAINTRGN
     * }
     */
    public static final AddressLayout PEMRPAINTRGN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     DWORD ihBrush;
     *     BYTE RgnData[1];
     * } *PEMRFILLRGN
     * }
     */
    public static final AddressLayout PEMRFILLRGN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFRAMERGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     DWORD ihBrush;
     *     SIZEL szlStroke;
     *     BYTE RgnData[1];
     * } *PEMRFRAMERGN
     * }
     */
    public static final AddressLayout PEMRFRAMERGN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTSELECTCLIPRGN {
     *     EMR emr;
     *     DWORD cbRgnData;
     *     DWORD iMode;
     *     BYTE RgnData[1];
     * } *PEMREXTSELECTCLIPRGN
     * }
     */
    public static final AddressLayout PEMREXTSELECTCLIPRGN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     EMRTEXT emrtext;
     * } *PEMREXTTEXTOUTA
     * }
     */
    public static final AddressLayout PEMREXTTEXTOUTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     EMRTEXT emrtext;
     * } *PEMREXTTEXTOUTW
     * }
     */
    public static final AddressLayout PEMREXTTEXTOUTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     LONG cStrings;
     *     EMRTEXT aemrtext[1];
     * } *PEMRPOLYTEXTOUTA
     * }
     */
    public static final AddressLayout PEMRPOLYTEXTOUTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     LONG cStrings;
     *     EMRTEXT aemrtext[1];
     * } *PEMRPOLYTEXTOUTW
     * }
     */
    public static final AddressLayout PEMRPOLYTEXTOUTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRBITBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     * } *PEMRBITBLT
     * }
     */
    public static final AddressLayout PEMRBITBLT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSTRETCHBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRSTRETCHBLT
     * }
     */
    public static final AddressLayout PEMRSTRETCHBLT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRMASKBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG xMask;
     *     LONG yMask;
     *     DWORD iUsageMask;
     *     DWORD offBmiMask;
     *     DWORD cbBmiMask;
     *     DWORD offBitsMask;
     *     DWORD cbBitsMask;
     * } *PEMRMASKBLT
     * }
     */
    public static final AddressLayout PEMRMASKBLT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPLGBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     POINTL aptlDest[3];
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG xMask;
     *     LONG yMask;
     *     DWORD iUsageMask;
     *     DWORD offBmiMask;
     *     DWORD cbBmiMask;
     *     DWORD offBitsMask;
     *     DWORD cbBitsMask;
     * } *PEMRPLGBLT
     * }
     */
    public static final AddressLayout PEMRPLGBLT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETDIBITSTODEVICE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     DWORD iUsageSrc;
     *     DWORD iStartScan;
     *     DWORD cScans;
     * } *PEMRSETDIBITSTODEVICE
     * }
     */
    public static final AddressLayout PEMRSETDIBITSTODEVICE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSTRETCHDIBITS {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     DWORD iUsageSrc;
     *     DWORD dwRop;
     *     LONG cxDest;
     *     LONG cyDest;
     * } *PEMRSTRETCHDIBITS
     * }
     */
    public static final AddressLayout PEMRSTRETCHDIBITS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTCREATEFONTINDIRECTW {
     *     EMR emr;
     *     DWORD ihFont;
     *     EXTLOGFONTW elfw;
     * } *PEMREXTCREATEFONTINDIRECTW
     * }
     */
    public static final AddressLayout PEMREXTCREATEFONTINDIRECTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     *     LOGPALETTE lgpl;
     * } *PEMRCREATEPALETTE
     * }
     */
    public static final AddressLayout PEMRCREATEPALETTE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEPEN {
     *     EMR emr;
     *     DWORD ihPen;
     *     LOGPEN lopn;
     * } *PEMRCREATEPEN
     * }
     */
    public static final AddressLayout PEMRCREATEPEN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTCREATEPEN {
     *     EMR emr;
     *     DWORD ihPen;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     *     EXTLOGPEN32 elp;
     * } *PEMREXTCREATEPEN
     * }
     */
    public static final AddressLayout PEMREXTCREATEPEN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEBRUSHINDIRECT {
     *     EMR emr;
     *     DWORD ihBrush;
     *     LOGBRUSH32 lb;
     * } *PEMRCREATEBRUSHINDIRECT
     * }
     */
    public static final AddressLayout PEMRCREATEBRUSHINDIRECT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEMONOBRUSH {
     *     EMR emr;
     *     DWORD ihBrush;
     *     DWORD iUsage;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     * } *PEMRCREATEMONOBRUSH
     * }
     */
    public static final AddressLayout PEMRCREATEMONOBRUSH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEDIBPATTERNBRUSHPT {
     *     EMR emr;
     *     DWORD ihBrush;
     *     DWORD iUsage;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     * } *PEMRCREATEDIBPATTERNBRUSHPT
     * }
     */
    public static final AddressLayout PEMRCREATEDIBPATTERNBRUSHPT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFORMAT {
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD cbData;
     *     DWORD offData;
     * } *PEMRFORMAT
     * }
     */
    public static final AddressLayout PEMRFORMAT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGLSRECORD {
     *     EMR emr;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGLSRECORD
     * }
     */
    public static final AddressLayout PEMRGLSRECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGLSBOUNDEDRECORD {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGLSBOUNDEDRECORD
     * }
     */
    public static final AddressLayout PEMRGLSBOUNDEDRECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPIXELFORMAT {
     *     EMR emr;
     *     PIXELFORMATDESCRIPTOR pfd;
     * } *PEMRPIXELFORMAT
     * }
     */
    public static final AddressLayout PEMRPIXELFORMAT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATECOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     *     LOGCOLORSPACEA lcs;
     * } *PEMRCREATECOLORSPACE
     * }
     */
    public static final AddressLayout PEMRCREATECOLORSPACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRSETCOLORSPACE
     * }
     */
    public static final AddressLayout PEMRSETCOLORSPACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRSELECTCOLORSPACE
     * }
     */
    public static final AddressLayout PEMRSELECTCOLORSPACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRDELETECOLORSPACE
     * }
     */
    public static final AddressLayout PEMRDELETECOLORSPACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMREXTESCAPE
     * }
     */
    public static final AddressLayout PEMREXTESCAPE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMRDRAWESCAPE
     * }
     */
    public static final AddressLayout PEMRDRAWESCAPE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRNAMEDESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbDriver;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMRNAMEDESCAPE
     * }
     */
    public static final AddressLayout PEMRNAMEDESCAPE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILE
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILEA
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILEW
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATECOLORSPACEW {
     *     EMR emr;
     *     DWORD ihCS;
     *     LOGCOLORSPACEW lcs;
     *     DWORD dwFlags;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRCREATECOLORSPACEW
     * }
     */
    public static final AddressLayout PEMRCREATECOLORSPACEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORMATCHTOTARGET {
     *     EMR emr;
     *     DWORD dwAction;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRCOLORMATCHTOTARGET
     * }
     */
    public static final AddressLayout PEMRCOLORMATCHTOTARGET = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORCORRECTPALETTE {
     *     EMR emr;
     *     DWORD ihPalette;
     *     DWORD nFirstEntry;
     *     DWORD nPalEntries;
     *     DWORD nReserved;
     * } *PEMRCOLORCORRECTPALETTE
     * }
     */
    public static final AddressLayout PEMRCOLORCORRECTPALETTE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRALPHABLEND {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRALPHABLEND
     * }
     */
    public static final AddressLayout PEMRALPHABLEND = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGRADIENTFILL {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nVer;
     *     DWORD nTri;
     *     ULONG ulMode;
     *     TRIVERTEX Ver[1];
     * } *PEMRGRADIENTFILL
     * }
     */
    public static final AddressLayout PEMRGRADIENTFILL = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRTRANSPARENTBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRTRANSPARENTBLT
     * }
     */
    public static final AddressLayout PEMRTRANSPARENTBLT = freeglut_h.C_POINTER;

    private static class wglCopyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglCopyContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static FunctionDescriptor wglCopyContext$descriptor() {
        return wglCopyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static MethodHandle wglCopyContext$handle() {
        return wglCopyContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static MemorySegment wglCopyContext$address() {
        return wglCopyContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static int wglCopyContext(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wglCopyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCopyContext", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglCreateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static FunctionDescriptor wglCreateContext$descriptor() {
        return wglCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static MethodHandle wglCreateContext$handle() {
        return wglCreateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static MemorySegment wglCreateContext$address() {
        return wglCreateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static MemorySegment wglCreateContext(MemorySegment x0) {
        var mh$ = wglCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCreateContext", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglCreateLayerContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglCreateLayerContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static FunctionDescriptor wglCreateLayerContext$descriptor() {
        return wglCreateLayerContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static MethodHandle wglCreateLayerContext$handle() {
        return wglCreateLayerContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static MemorySegment wglCreateLayerContext$address() {
        return wglCreateLayerContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static MemorySegment wglCreateLayerContext(MemorySegment x0, int x1) {
        var mh$ = wglCreateLayerContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCreateLayerContext", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglDeleteContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglDeleteContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static FunctionDescriptor wglDeleteContext$descriptor() {
        return wglDeleteContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static MethodHandle wglDeleteContext$handle() {
        return wglDeleteContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static MemorySegment wglDeleteContext$address() {
        return wglDeleteContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static int wglDeleteContext(MemorySegment x0) {
        var mh$ = wglDeleteContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglDeleteContext", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetCurrentContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglGetCurrentContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static FunctionDescriptor wglGetCurrentContext$descriptor() {
        return wglGetCurrentContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static MethodHandle wglGetCurrentContext$handle() {
        return wglGetCurrentContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static MemorySegment wglGetCurrentContext$address() {
        return wglGetCurrentContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static MemorySegment wglGetCurrentContext() {
        var mh$ = wglGetCurrentContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetCurrentContext");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetCurrentDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglGetCurrentDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static FunctionDescriptor wglGetCurrentDC$descriptor() {
        return wglGetCurrentDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static MethodHandle wglGetCurrentDC$handle() {
        return wglGetCurrentDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static MemorySegment wglGetCurrentDC$address() {
        return wglGetCurrentDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static MemorySegment wglGetCurrentDC() {
        var mh$ = wglGetCurrentDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetCurrentDC");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglGetProcAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static FunctionDescriptor wglGetProcAddress$descriptor() {
        return wglGetProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static MethodHandle wglGetProcAddress$handle() {
        return wglGetProcAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static MemorySegment wglGetProcAddress$address() {
        return wglGetProcAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static MemorySegment wglGetProcAddress(MemorySegment x0) {
        var mh$ = wglGetProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetProcAddress", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglMakeCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglMakeCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static FunctionDescriptor wglMakeCurrent$descriptor() {
        return wglMakeCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static MethodHandle wglMakeCurrent$handle() {
        return wglMakeCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static MemorySegment wglMakeCurrent$address() {
        return wglMakeCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static int wglMakeCurrent(MemorySegment x0, MemorySegment x1) {
        var mh$ = wglMakeCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglMakeCurrent", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglShareLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglShareLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static FunctionDescriptor wglShareLists$descriptor() {
        return wglShareLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static MethodHandle wglShareLists$handle() {
        return wglShareLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static MemorySegment wglShareLists$address() {
        return wglShareLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static int wglShareLists(MemorySegment x0, MemorySegment x1) {
        var mh$ = wglShareLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglShareLists", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontBitmapsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglUseFontBitmapsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static FunctionDescriptor wglUseFontBitmapsA$descriptor() {
        return wglUseFontBitmapsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MethodHandle wglUseFontBitmapsA$handle() {
        return wglUseFontBitmapsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MemorySegment wglUseFontBitmapsA$address() {
        return wglUseFontBitmapsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static int wglUseFontBitmapsA(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = wglUseFontBitmapsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontBitmapsA", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontBitmapsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglUseFontBitmapsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static FunctionDescriptor wglUseFontBitmapsW$descriptor() {
        return wglUseFontBitmapsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MethodHandle wglUseFontBitmapsW$handle() {
        return wglUseFontBitmapsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MemorySegment wglUseFontBitmapsW$address() {
        return wglUseFontBitmapsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static int wglUseFontBitmapsW(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = wglUseFontBitmapsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontBitmapsW", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwapBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SwapBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static FunctionDescriptor SwapBuffers$descriptor() {
        return SwapBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static MethodHandle SwapBuffers$handle() {
        return SwapBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static MemorySegment SwapBuffers$address() {
        return SwapBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static int SwapBuffers(MemorySegment x0) {
        var mh$ = SwapBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwapBuffers", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _POINTFLOAT {
     *     FLOAT x;
     *     FLOAT y;
     * } *PPOINTFLOAT
     * }
     */
    public static final AddressLayout PPOINTFLOAT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICSFLOAT {
     *     FLOAT gmfBlackBoxX;
     *     FLOAT gmfBlackBoxY;
     *     POINTFLOAT gmfptGlyphOrigin;
     *     FLOAT gmfCellIncX;
     *     FLOAT gmfCellIncY;
     * } *PGLYPHMETRICSFLOAT
     * }
     */
    public static final AddressLayout PGLYPHMETRICSFLOAT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICSFLOAT {
     *     FLOAT gmfBlackBoxX;
     *     FLOAT gmfBlackBoxY;
     *     POINTFLOAT gmfptGlyphOrigin;
     *     FLOAT gmfCellIncX;
     *     FLOAT gmfCellIncY;
     * } *LPGLYPHMETRICSFLOAT
     * }
     */
    public static final AddressLayout LPGLYPHMETRICSFLOAT = freeglut_h.C_POINTER;

    private static class wglUseFontOutlinesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglUseFontOutlinesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static FunctionDescriptor wglUseFontOutlinesA$descriptor() {
        return wglUseFontOutlinesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MethodHandle wglUseFontOutlinesA$handle() {
        return wglUseFontOutlinesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MemorySegment wglUseFontOutlinesA$address() {
        return wglUseFontOutlinesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static int wglUseFontOutlinesA(MemorySegment x0, int x1, int x2, int x3, float x4, float x5, int x6, MemorySegment x7) {
        var mh$ = wglUseFontOutlinesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontOutlinesA", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontOutlinesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglUseFontOutlinesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static FunctionDescriptor wglUseFontOutlinesW$descriptor() {
        return wglUseFontOutlinesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MethodHandle wglUseFontOutlinesW$handle() {
        return wglUseFontOutlinesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MemorySegment wglUseFontOutlinesW$address() {
        return wglUseFontOutlinesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static int wglUseFontOutlinesW(MemorySegment x0, int x1, int x2, int x3, float x4, float x5, int x6, MemorySegment x7) {
        var mh$ = wglUseFontOutlinesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontOutlinesW", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagLAYERPLANEDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerPlane;
     *     BYTE bReserved;
     *     COLORREF crTransparent;
     * } *PLAYERPLANEDESCRIPTOR
     * }
     */
    public static final AddressLayout PLAYERPLANEDESCRIPTOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLAYERPLANEDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerPlane;
     *     BYTE bReserved;
     *     COLORREF crTransparent;
     * } *LPLAYERPLANEDESCRIPTOR
     * }
     */
    public static final AddressLayout LPLAYERPLANEDESCRIPTOR = freeglut_h.C_POINTER;

    private static class wglDescribeLayerPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglDescribeLayerPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static FunctionDescriptor wglDescribeLayerPlane$descriptor() {
        return wglDescribeLayerPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static MethodHandle wglDescribeLayerPlane$handle() {
        return wglDescribeLayerPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static MemorySegment wglDescribeLayerPlane$address() {
        return wglDescribeLayerPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static int wglDescribeLayerPlane(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglDescribeLayerPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglDescribeLayerPlane", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglSetLayerPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglSetLayerPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static FunctionDescriptor wglSetLayerPaletteEntries$descriptor() {
        return wglSetLayerPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static MethodHandle wglSetLayerPaletteEntries$handle() {
        return wglSetLayerPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static MemorySegment wglSetLayerPaletteEntries$address() {
        return wglSetLayerPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static int wglSetLayerPaletteEntries(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglSetLayerPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSetLayerPaletteEntries", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetLayerPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglGetLayerPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static FunctionDescriptor wglGetLayerPaletteEntries$descriptor() {
        return wglGetLayerPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static MethodHandle wglGetLayerPaletteEntries$handle() {
        return wglGetLayerPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static MemorySegment wglGetLayerPaletteEntries$address() {
        return wglGetLayerPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static int wglGetLayerPaletteEntries(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglGetLayerPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetLayerPaletteEntries", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglRealizeLayerPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglRealizeLayerPalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static FunctionDescriptor wglRealizeLayerPalette$descriptor() {
        return wglRealizeLayerPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static MethodHandle wglRealizeLayerPalette$handle() {
        return wglRealizeLayerPalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static MemorySegment wglRealizeLayerPalette$address() {
        return wglRealizeLayerPalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static int wglRealizeLayerPalette(MemorySegment x0, int x1, int x2) {
        var mh$ = wglRealizeLayerPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglRealizeLayerPalette", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglSwapLayerBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglSwapLayerBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static FunctionDescriptor wglSwapLayerBuffers$descriptor() {
        return wglSwapLayerBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static MethodHandle wglSwapLayerBuffers$handle() {
        return wglSwapLayerBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static MemorySegment wglSwapLayerBuffers$address() {
        return wglSwapLayerBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static int wglSwapLayerBuffers(MemorySegment x0, int x1) {
        var mh$ = wglSwapLayerBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSwapLayerBuffers", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WGLSWAP {
     *     HDC hdc;
     *     UINT uiFlags;
     * } *PWGLSWAP
     * }
     */
    public static final AddressLayout PWGLSWAP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WGLSWAP {
     *     HDC hdc;
     *     UINT uiFlags;
     * } *LPWGLSWAP
     * }
     */
    public static final AddressLayout LPWGLSWAP = freeglut_h.C_POINTER;

    private static class wglSwapMultipleBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wglSwapMultipleBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static FunctionDescriptor wglSwapMultipleBuffers$descriptor() {
        return wglSwapMultipleBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static MethodHandle wglSwapMultipleBuffers$handle() {
        return wglSwapMultipleBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static MemorySegment wglSwapMultipleBuffers$address() {
        return wglSwapMultipleBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static int wglSwapMultipleBuffers(int x0, MemorySegment x1) {
        var mh$ = wglSwapMultipleBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSwapMultipleBuffers", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef HANDLE HDWP
     * }
     */
    public static final AddressLayout HDWP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID LPMENUTEMPLATEA
     * }
     */
    public static final AddressLayout LPMENUTEMPLATEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID LPMENUTEMPLATEW
     * }
     */
    public static final AddressLayout LPMENUTEMPLATEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMENUTEMPLATEA LPMENUTEMPLATE
     * }
     */
    public static final AddressLayout LPMENUTEMPLATE = freeglut_h.C_POINTER;

    private static class wvsprintfA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wvsprintfA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static FunctionDescriptor wvsprintfA$descriptor() {
        return wvsprintfA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static MethodHandle wvsprintfA$handle() {
        return wvsprintfA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static MemorySegment wvsprintfA$address() {
        return wvsprintfA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static int wvsprintfA(MemorySegment x0, MemorySegment x1, MemorySegment arglist) {
        var mh$ = wvsprintfA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wvsprintfA", x0, x1, arglist);
            }
            return (int)mh$.invokeExact(x0, x1, arglist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wvsprintfW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wvsprintfW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static FunctionDescriptor wvsprintfW$descriptor() {
        return wvsprintfW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static MethodHandle wvsprintfW$handle() {
        return wvsprintfW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static MemorySegment wvsprintfW$address() {
        return wvsprintfW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static int wvsprintfW(MemorySegment x0, MemorySegment x1, MemorySegment arglist) {
        var mh$ = wvsprintfW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wvsprintfW", x0, x1, arglist);
            }
            return (int)mh$.invokeExact(x0, x1, arglist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wsprintfA(LPSTR, LPCSTR, ...)
     * }
     */
    public static class wsprintfA {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                freeglut_h.C_INT,
                freeglut_h.C_POINTER,
                freeglut_h.C_POINTER
            );
        private static final MemorySegment ADDR = freeglut_h.findOrThrow("wsprintfA");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wsprintfA(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wsprintfA(LPSTR, LPCSTR, ...)
         * }
         */
        public static wsprintfA makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wsprintfA(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wsprintfA", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wsprintfW(LPWSTR, LPCWSTR, ...)
     * }
     */
    public static class wsprintfW {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                freeglut_h.C_INT,
                freeglut_h.C_POINTER,
                freeglut_h.C_POINTER
            );
        private static final MemorySegment ADDR = freeglut_h.findOrThrow("wsprintfW");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wsprintfW(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wsprintfW(LPWSTR, LPCWSTR, ...)
         * }
         */
        public static wsprintfW makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wsprintfW(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wsprintfW", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCBT_CREATEWNDA {
     *     struct tagCREATESTRUCTA *lpcs;
     *     HWND hwndInsertAfter;
     * } *LPCBT_CREATEWNDA
     * }
     */
    public static final AddressLayout LPCBT_CREATEWNDA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCBT_CREATEWNDW {
     *     struct tagCREATESTRUCTW *lpcs;
     *     HWND hwndInsertAfter;
     * } *LPCBT_CREATEWNDW
     * }
     */
    public static final AddressLayout LPCBT_CREATEWNDW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCBT_CREATEWNDA LPCBT_CREATEWND
     * }
     */
    public static final AddressLayout LPCBT_CREATEWND = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCBTACTIVATESTRUCT {
     *     BOOL fMouse;
     *     HWND hWndActive;
     * } *LPCBTACTIVATESTRUCT
     * }
     */
    public static final AddressLayout LPCBTACTIVATESTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWTSSESSION_NOTIFICATION {
     *     DWORD cbSize;
     *     DWORD dwSessionId;
     * } *PWTSSESSION_NOTIFICATION
     * }
     */
    public static final AddressLayout PWTSSESSION_NOTIFICATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     HWND hwnd;
     *     RECT rc;
     * } *LPSHELLHOOKINFO
     * }
     */
    public static final AddressLayout LPSHELLHOOKINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *PEVENTMSGMSG
     * }
     */
    public static final AddressLayout PEVENTMSGMSG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *NPEVENTMSGMSG
     * }
     */
    public static final AddressLayout NPEVENTMSGMSG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *LPEVENTMSGMSG
     * }
     */
    public static final AddressLayout LPEVENTMSGMSG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *PEVENTMSG
     * }
     */
    public static final AddressLayout PEVENTMSG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *NPEVENTMSG
     * }
     */
    public static final AddressLayout NPEVENTMSG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *LPEVENTMSG
     * }
     */
    public static final AddressLayout LPEVENTMSG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *PCWPSTRUCT
     * }
     */
    public static final AddressLayout PCWPSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *NPCWPSTRUCT
     * }
     */
    public static final AddressLayout NPCWPSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *LPCWPSTRUCT
     * }
     */
    public static final AddressLayout LPCWPSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *PCWPRETSTRUCT
     * }
     */
    public static final AddressLayout PCWPRETSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *NPCWPRETSTRUCT
     * }
     */
    public static final AddressLayout NPCWPRETSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *LPCWPRETSTRUCT
     * }
     */
    public static final AddressLayout LPCWPRETSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKBDLLHOOKSTRUCT {
     *     DWORD vkCode;
     *     DWORD scanCode;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPKBDLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPKBDLLHOOKSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKBDLLHOOKSTRUCT {
     *     DWORD vkCode;
     *     DWORD scanCode;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PKBDLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout PKBDLLHOOKSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSLLHOOKSTRUCT {
     *     POINT pt;
     *     DWORD mouseData;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMSLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPMSLLHOOKSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSLLHOOKSTRUCT {
     *     POINT pt;
     *     DWORD mouseData;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PMSLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout PMSLLHOOKSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *PDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout PDEBUGHOOKINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *NPDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout NPDEBUGHOOKINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *LPDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout LPDEBUGHOOKINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCT {
     *     POINT pt;
     *     HWND hwnd;
     *     UINT wHitTestCode;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMOUSEHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPMOUSEHOOKSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCT {
     *     POINT pt;
     *     HWND hwnd;
     *     UINT wHitTestCode;
     *     ULONG_PTR dwExtraInfo;
     * } *PMOUSEHOOKSTRUCT
     * }
     */
    public static final AddressLayout PMOUSEHOOKSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCTEX {
     *     DWORD mouseData;
     * } *LPMOUSEHOOKSTRUCTEX
     * }
     */
    public static final AddressLayout LPMOUSEHOOKSTRUCTEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCTEX {
     *     DWORD mouseData;
     * } *PMOUSEHOOKSTRUCTEX
     * }
     */
    public static final AddressLayout PMOUSEHOOKSTRUCTEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREHOOKSTRUCT {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     * } *LPHARDWAREHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPHARDWAREHOOKSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREHOOKSTRUCT {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     * } *PHARDWAREHOOKSTRUCT
     * }
     */
    public static final AddressLayout PHARDWAREHOOKSTRUCT = freeglut_h.C_POINTER;

    private static class LoadKeyboardLayoutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadKeyboardLayoutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static FunctionDescriptor LoadKeyboardLayoutA$descriptor() {
        return LoadKeyboardLayoutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static MethodHandle LoadKeyboardLayoutA$handle() {
        return LoadKeyboardLayoutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutA$address() {
        return LoadKeyboardLayoutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutA(MemorySegment pwszKLID, int Flags) {
        var mh$ = LoadKeyboardLayoutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadKeyboardLayoutA", pwszKLID, Flags);
            }
            return (MemorySegment)mh$.invokeExact(pwszKLID, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadKeyboardLayoutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadKeyboardLayoutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static FunctionDescriptor LoadKeyboardLayoutW$descriptor() {
        return LoadKeyboardLayoutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static MethodHandle LoadKeyboardLayoutW$handle() {
        return LoadKeyboardLayoutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutW$address() {
        return LoadKeyboardLayoutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutW(MemorySegment pwszKLID, int Flags) {
        var mh$ = LoadKeyboardLayoutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadKeyboardLayoutW", pwszKLID, Flags);
            }
            return (MemorySegment)mh$.invokeExact(pwszKLID, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ActivateKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ActivateKeyboardLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static FunctionDescriptor ActivateKeyboardLayout$descriptor() {
        return ActivateKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static MethodHandle ActivateKeyboardLayout$handle() {
        return ActivateKeyboardLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static MemorySegment ActivateKeyboardLayout$address() {
        return ActivateKeyboardLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static MemorySegment ActivateKeyboardLayout(MemorySegment hkl, int Flags) {
        var mh$ = ActivateKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ActivateKeyboardLayout", hkl, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hkl, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToUnicodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ToUnicodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor ToUnicodeEx$descriptor() {
        return ToUnicodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static MethodHandle ToUnicodeEx$handle() {
        return ToUnicodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static MemorySegment ToUnicodeEx$address() {
        return ToUnicodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static int ToUnicodeEx(int wVirtKey, int wScanCode, MemorySegment lpKeyState, MemorySegment pwszBuff, int cchBuff, int wFlags, MemorySegment dwhkl) {
        var mh$ = ToUnicodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToUnicodeEx", wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags, dwhkl);
            }
            return (int)mh$.invokeExact(wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnloadKeyboardLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static FunctionDescriptor UnloadKeyboardLayout$descriptor() {
        return UnloadKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static MethodHandle UnloadKeyboardLayout$handle() {
        return UnloadKeyboardLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static MemorySegment UnloadKeyboardLayout$address() {
        return UnloadKeyboardLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static int UnloadKeyboardLayout(MemorySegment hkl) {
        var mh$ = UnloadKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadKeyboardLayout", hkl);
            }
            return (int)mh$.invokeExact(hkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKeyboardLayoutNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutNameA$descriptor() {
        return GetKeyboardLayoutNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static MethodHandle GetKeyboardLayoutNameA$handle() {
        return GetKeyboardLayoutNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static MemorySegment GetKeyboardLayoutNameA$address() {
        return GetKeyboardLayoutNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static int GetKeyboardLayoutNameA(MemorySegment pwszKLID) {
        var mh$ = GetKeyboardLayoutNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutNameA", pwszKLID);
            }
            return (int)mh$.invokeExact(pwszKLID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKeyboardLayoutNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutNameW$descriptor() {
        return GetKeyboardLayoutNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static MethodHandle GetKeyboardLayoutNameW$handle() {
        return GetKeyboardLayoutNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static MemorySegment GetKeyboardLayoutNameW$address() {
        return GetKeyboardLayoutNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static int GetKeyboardLayoutNameW(MemorySegment pwszKLID) {
        var mh$ = GetKeyboardLayoutNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutNameW", pwszKLID);
            }
            return (int)mh$.invokeExact(pwszKLID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKeyboardLayoutList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutList$descriptor() {
        return GetKeyboardLayoutList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static MethodHandle GetKeyboardLayoutList$handle() {
        return GetKeyboardLayoutList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static MemorySegment GetKeyboardLayoutList$address() {
        return GetKeyboardLayoutList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static int GetKeyboardLayoutList(int nBuff, MemorySegment lpList) {
        var mh$ = GetKeyboardLayoutList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutList", nBuff, lpList);
            }
            return (int)mh$.invokeExact(nBuff, lpList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKeyboardLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayout$descriptor() {
        return GetKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static MethodHandle GetKeyboardLayout$handle() {
        return GetKeyboardLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static MemorySegment GetKeyboardLayout$address() {
        return GetKeyboardLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static MemorySegment GetKeyboardLayout(int idThread) {
        var mh$ = GetKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayout", idThread);
            }
            return (MemorySegment)mh$.invokeExact(idThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEMOVEPOINT {
     *     int x;
     *     int y;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PMOUSEMOVEPOINT
     * }
     */
    public static final AddressLayout PMOUSEMOVEPOINT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEMOVEPOINT {
     *     int x;
     *     int y;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMOUSEMOVEPOINT
     * }
     */
    public static final AddressLayout LPMOUSEMOVEPOINT = freeglut_h.C_POINTER;

    private static class GetMouseMovePointsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMouseMovePointsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static FunctionDescriptor GetMouseMovePointsEx$descriptor() {
        return GetMouseMovePointsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static MethodHandle GetMouseMovePointsEx$handle() {
        return GetMouseMovePointsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static MemorySegment GetMouseMovePointsEx$address() {
        return GetMouseMovePointsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static int GetMouseMovePointsEx(int cbSize, MemorySegment lppt, MemorySegment lpptBuf, int nBufPoints, int resolution) {
        var mh$ = GetMouseMovePointsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMouseMovePointsEx", cbSize, lppt, lpptBuf, nBufPoints, resolution);
            }
            return (int)mh$.invokeExact(cbSize, lppt, lpptBuf, nBufPoints, resolution);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDesktopA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateDesktopA$descriptor() {
        return CreateDesktopA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateDesktopA$handle() {
        return CreateDesktopA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopA$address() {
        return CreateDesktopA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopA(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateDesktopA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopA", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDesktopW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateDesktopW$descriptor() {
        return CreateDesktopW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateDesktopW$handle() {
        return CreateDesktopW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopW$address() {
        return CreateDesktopW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopW(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateDesktopW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopW", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDesktopExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static FunctionDescriptor CreateDesktopExA$descriptor() {
        return CreateDesktopExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MethodHandle CreateDesktopExA$handle() {
        return CreateDesktopExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExA$address() {
        return CreateDesktopExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExA(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa, int ulHeapSize, MemorySegment pvoid) {
        var mh$ = CreateDesktopExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopExA", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDesktopExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static FunctionDescriptor CreateDesktopExW$descriptor() {
        return CreateDesktopExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MethodHandle CreateDesktopExW$handle() {
        return CreateDesktopExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExW$address() {
        return CreateDesktopExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExW(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa, int ulHeapSize, MemorySegment pvoid) {
        var mh$ = CreateDesktopExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopExW", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenDesktopA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenDesktopA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenDesktopA$descriptor() {
        return OpenDesktopA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenDesktopA$handle() {
        return OpenDesktopA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopA$address() {
        return OpenDesktopA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopA(MemorySegment lpszDesktop, int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenDesktopA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenDesktopA", lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenDesktopW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenDesktopW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenDesktopW$descriptor() {
        return OpenDesktopW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenDesktopW$handle() {
        return OpenDesktopW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopW$address() {
        return OpenDesktopW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopW(MemorySegment lpszDesktop, int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenDesktopW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenDesktopW", lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenInputDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenInputDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenInputDesktop$descriptor() {
        return OpenInputDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenInputDesktop$handle() {
        return OpenInputDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenInputDesktop$address() {
        return OpenInputDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenInputDesktop(int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenInputDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenInputDesktop", dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDesktopsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopsA$descriptor() {
        return EnumDesktopsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopsA$handle() {
        return EnumDesktopsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumDesktopsA$address() {
        return EnumDesktopsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumDesktopsA(MemorySegment hwinsta, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumDesktopsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopsA", hwinsta, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hwinsta, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDesktopsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopsW$descriptor() {
        return EnumDesktopsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopsW$handle() {
        return EnumDesktopsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumDesktopsW$address() {
        return EnumDesktopsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumDesktopsW(MemorySegment hwinsta, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumDesktopsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopsW", hwinsta, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hwinsta, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDesktopWindows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopWindows$descriptor() {
        return EnumDesktopWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopWindows$handle() {
        return EnumDesktopWindows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumDesktopWindows$address() {
        return EnumDesktopWindows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static int EnumDesktopWindows(MemorySegment hDesktop, MemorySegment lpfn, long lParam) {
        var mh$ = EnumDesktopWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopWindows", hDesktop, lpfn, lParam);
            }
            return (int)mh$.invokeExact(hDesktop, lpfn, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SwitchDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor SwitchDesktop$descriptor() {
        return SwitchDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle SwitchDesktop$handle() {
        return SwitchDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static MemorySegment SwitchDesktop$address() {
        return SwitchDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static int SwitchDesktop(MemorySegment hDesktop) {
        var mh$ = SwitchDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor SetThreadDesktop$descriptor() {
        return SetThreadDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle SetThreadDesktop$handle() {
        return SetThreadDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static MemorySegment SetThreadDesktop$address() {
        return SetThreadDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static int SetThreadDesktop(MemorySegment hDesktop) {
        var mh$ = SetThreadDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor CloseDesktop$descriptor() {
        return CloseDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle CloseDesktop$handle() {
        return CloseDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static MemorySegment CloseDesktop$address() {
        return CloseDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static int CloseDesktop(MemorySegment hDesktop) {
        var mh$ = CloseDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static FunctionDescriptor GetThreadDesktop$descriptor() {
        return GetThreadDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static MethodHandle GetThreadDesktop$handle() {
        return GetThreadDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static MemorySegment GetThreadDesktop$address() {
        return GetThreadDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static MemorySegment GetThreadDesktop(int dwThreadId) {
        var mh$ = GetThreadDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadDesktop", dwThreadId);
            }
            return (MemorySegment)mh$.invokeExact(dwThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowStationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateWindowStationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateWindowStationA$descriptor() {
        return CreateWindowStationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateWindowStationA$handle() {
        return CreateWindowStationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationA$address() {
        return CreateWindowStationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationA(MemorySegment lpwinsta, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateWindowStationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowStationA", lpwinsta, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpwinsta, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowStationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateWindowStationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateWindowStationW$descriptor() {
        return CreateWindowStationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateWindowStationW$handle() {
        return CreateWindowStationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationW$address() {
        return CreateWindowStationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationW(MemorySegment lpwinsta, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateWindowStationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowStationW", lpwinsta, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpwinsta, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWindowStationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenWindowStationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenWindowStationA$descriptor() {
        return OpenWindowStationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenWindowStationA$handle() {
        return OpenWindowStationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationA$address() {
        return OpenWindowStationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationA(MemorySegment lpszWinSta, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenWindowStationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWindowStationA", lpszWinSta, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszWinSta, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWindowStationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenWindowStationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenWindowStationW$descriptor() {
        return OpenWindowStationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenWindowStationW$handle() {
        return OpenWindowStationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationW$address() {
        return OpenWindowStationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationW(MemorySegment lpszWinSta, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenWindowStationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWindowStationW", lpszWinSta, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszWinSta, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumWindowStationsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumWindowStationsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumWindowStationsA$descriptor() {
        return EnumWindowStationsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumWindowStationsA$handle() {
        return EnumWindowStationsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumWindowStationsA$address() {
        return EnumWindowStationsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumWindowStationsA(MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumWindowStationsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumWindowStationsA", lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumWindowStationsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumWindowStationsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumWindowStationsW$descriptor() {
        return EnumWindowStationsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumWindowStationsW$handle() {
        return EnumWindowStationsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumWindowStationsW$address() {
        return EnumWindowStationsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumWindowStationsW(MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumWindowStationsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumWindowStationsW", lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseWindowStation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static FunctionDescriptor CloseWindowStation$descriptor() {
        return CloseWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MethodHandle CloseWindowStation$handle() {
        return CloseWindowStation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MemorySegment CloseWindowStation$address() {
        return CloseWindowStation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static int CloseWindowStation(MemorySegment hWinSta) {
        var mh$ = CloseWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseWindowStation", hWinSta);
            }
            return (int)mh$.invokeExact(hWinSta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessWindowStation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static FunctionDescriptor SetProcessWindowStation$descriptor() {
        return SetProcessWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MethodHandle SetProcessWindowStation$handle() {
        return SetProcessWindowStation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MemorySegment SetProcessWindowStation$address() {
        return SetProcessWindowStation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static int SetProcessWindowStation(MemorySegment hWinSta) {
        var mh$ = SetProcessWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessWindowStation", hWinSta);
            }
            return (int)mh$.invokeExact(hWinSta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessWindowStation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static FunctionDescriptor GetProcessWindowStation$descriptor() {
        return GetProcessWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static MethodHandle GetProcessWindowStation$handle() {
        return GetProcessWindowStation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static MemorySegment GetProcessWindowStation$address() {
        return GetProcessWindowStation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static MemorySegment GetProcessWindowStation() {
        var mh$ = GetProcessWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessWindowStation");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetUserObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static FunctionDescriptor SetUserObjectSecurity$descriptor() {
        return SetUserObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static MethodHandle SetUserObjectSecurity$handle() {
        return SetUserObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static MemorySegment SetUserObjectSecurity$address() {
        return SetUserObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static int SetUserObjectSecurity(MemorySegment hObj, MemorySegment pSIRequested, MemorySegment pSID) {
        var mh$ = SetUserObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserObjectSecurity", hObj, pSIRequested, pSID);
            }
            return (int)mh$.invokeExact(hObj, pSIRequested, pSID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectSecurity$descriptor() {
        return GetUserObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectSecurity$handle() {
        return GetUserObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetUserObjectSecurity$address() {
        return GetUserObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectSecurity(MemorySegment hObj, MemorySegment pSIRequested, MemorySegment pSID, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectSecurity", hObj, pSIRequested, pSID, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, pSIRequested, pSID, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagUSEROBJECTFLAGS {
     *     BOOL fInherit;
     *     BOOL fReserved;
     *     DWORD dwFlags;
     * } *PUSEROBJECTFLAGS
     * }
     */
    public static final AddressLayout PUSEROBJECTFLAGS = freeglut_h.C_POINTER;

    private static class GetUserObjectInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserObjectInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectInformationA$descriptor() {
        return GetUserObjectInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectInformationA$handle() {
        return GetUserObjectInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetUserObjectInformationA$address() {
        return GetUserObjectInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectInformationA(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectInformationA", hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserObjectInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserObjectInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectInformationW$descriptor() {
        return GetUserObjectInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectInformationW$handle() {
        return GetUserObjectInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetUserObjectInformationW$address() {
        return GetUserObjectInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectInformationW(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectInformationW", hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserObjectInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetUserObjectInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static FunctionDescriptor SetUserObjectInformationA$descriptor() {
        return SetUserObjectInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MethodHandle SetUserObjectInformationA$handle() {
        return SetUserObjectInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MemorySegment SetUserObjectInformationA$address() {
        return SetUserObjectInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static int SetUserObjectInformationA(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength) {
        var mh$ = SetUserObjectInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserObjectInformationA", hObj, nIndex, pvInfo, nLength);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserObjectInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetUserObjectInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static FunctionDescriptor SetUserObjectInformationW$descriptor() {
        return SetUserObjectInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MethodHandle SetUserObjectInformationW$handle() {
        return SetUserObjectInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MemorySegment SetUserObjectInformationW$address() {
        return SetUserObjectInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static int SetUserObjectInformationW(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength) {
        var mh$ = SetUserObjectInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserObjectInformationW", hObj, nIndex, pvInfo, nLength);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXA {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     *     HICON hIconSm;
     * } *PWNDCLASSEXA
     * }
     */
    public static final AddressLayout PWNDCLASSEXA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXA {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     *     HICON hIconSm;
     * } *NPWNDCLASSEXA
     * }
     */
    public static final AddressLayout NPWNDCLASSEXA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXA {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     *     HICON hIconSm;
     * } *LPWNDCLASSEXA
     * }
     */
    public static final AddressLayout LPWNDCLASSEXA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXW {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     *     HICON hIconSm;
     * } *PWNDCLASSEXW
     * }
     */
    public static final AddressLayout PWNDCLASSEXW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXW {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     *     HICON hIconSm;
     * } *NPWNDCLASSEXW
     * }
     */
    public static final AddressLayout NPWNDCLASSEXW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXW {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     *     HICON hIconSm;
     * } *LPWNDCLASSEXW
     * }
     */
    public static final AddressLayout LPWNDCLASSEXW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWNDCLASSEXA PWNDCLASSEX
     * }
     */
    public static final AddressLayout PWNDCLASSEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPWNDCLASSEXA NPWNDCLASSEX
     * }
     */
    public static final AddressLayout NPWNDCLASSEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWNDCLASSEXA LPWNDCLASSEX
     * }
     */
    public static final AddressLayout LPWNDCLASSEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSA {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     * } *PWNDCLASSA
     * }
     */
    public static final AddressLayout PWNDCLASSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSA {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     * } *NPWNDCLASSA
     * }
     */
    public static final AddressLayout NPWNDCLASSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSA {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     * } *LPWNDCLASSA
     * }
     */
    public static final AddressLayout LPWNDCLASSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSW {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     * } *PWNDCLASSW
     * }
     */
    public static final AddressLayout PWNDCLASSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSW {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     * } *NPWNDCLASSW
     * }
     */
    public static final AddressLayout NPWNDCLASSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSW {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     * } *LPWNDCLASSW
     * }
     */
    public static final AddressLayout LPWNDCLASSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWNDCLASSA PWNDCLASS
     * }
     */
    public static final AddressLayout PWNDCLASS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPWNDCLASSA NPWNDCLASS
     * }
     */
    public static final AddressLayout NPWNDCLASS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWNDCLASSA LPWNDCLASS
     * }
     */
    public static final AddressLayout LPWNDCLASS = freeglut_h.C_POINTER;

    private static class IsHungAppWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsHungAppWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsHungAppWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor IsHungAppWindow$descriptor() {
        return IsHungAppWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsHungAppWindow(HWND hwnd)
     * }
     */
    public static MethodHandle IsHungAppWindow$handle() {
        return IsHungAppWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsHungAppWindow(HWND hwnd)
     * }
     */
    public static MemorySegment IsHungAppWindow$address() {
        return IsHungAppWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsHungAppWindow(HWND hwnd)
     * }
     */
    public static int IsHungAppWindow(MemorySegment hwnd) {
        var mh$ = IsHungAppWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsHungAppWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisableProcessWindowsGhosting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DisableProcessWindowsGhosting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DisableProcessWindowsGhosting()
     * }
     */
    public static FunctionDescriptor DisableProcessWindowsGhosting$descriptor() {
        return DisableProcessWindowsGhosting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DisableProcessWindowsGhosting()
     * }
     */
    public static MethodHandle DisableProcessWindowsGhosting$handle() {
        return DisableProcessWindowsGhosting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DisableProcessWindowsGhosting()
     * }
     */
    public static MemorySegment DisableProcessWindowsGhosting$address() {
        return DisableProcessWindowsGhosting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DisableProcessWindowsGhosting()
     * }
     */
    public static void DisableProcessWindowsGhosting() {
        var mh$ = DisableProcessWindowsGhosting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableProcessWindowsGhosting");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMSG {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     *     DWORD time;
     *     POINT pt;
     * } *PMSG
     * }
     */
    public static final AddressLayout PMSG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSG {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     *     DWORD time;
     *     POINT pt;
     * } *NPMSG
     * }
     */
    public static final AddressLayout NPMSG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSG {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     *     DWORD time;
     *     POINT pt;
     * } *LPMSG
     * }
     */
    public static final AddressLayout LPMSG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMINMAXINFO {
     *     POINT ptReserved;
     *     POINT ptMaxSize;
     *     POINT ptMaxPosition;
     *     POINT ptMinTrackSize;
     *     POINT ptMaxTrackSize;
     * } *PMINMAXINFO
     * }
     */
    public static final AddressLayout PMINMAXINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMINMAXINFO {
     *     POINT ptReserved;
     *     POINT ptMaxSize;
     *     POINT ptMaxPosition;
     *     POINT ptMinTrackSize;
     *     POINT ptMaxTrackSize;
     * } *LPMINMAXINFO
     * }
     */
    public static final AddressLayout LPMINMAXINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOPYDATASTRUCT {
     *     ULONG_PTR dwData;
     *     DWORD cbData;
     *     PVOID lpData;
     * } *PCOPYDATASTRUCT
     * }
     */
    public static final AddressLayout PCOPYDATASTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMDINEXTMENU {
     *     HMENU hmenuIn;
     *     HMENU hmenuNext;
     *     HWND hwndNext;
     * } *PMDINEXTMENU
     * }
     */
    public static final AddressLayout PMDINEXTMENU = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMDINEXTMENU {
     *     HMENU hmenuIn;
     *     HMENU hmenuNext;
     *     HWND hwndNext;
     * } *LPMDINEXTMENU
     * }
     */
    public static final AddressLayout LPMDINEXTMENU = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     GUID PowerSetting;
     *     DWORD DataLength;
     *     UCHAR Data[1];
     * } *PPOWERBROADCAST_SETTING
     * }
     */
    public static final AddressLayout PPOWERBROADCAST_SETTING = freeglut_h.C_POINTER;

    private static class RegisterWindowMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterWindowMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor RegisterWindowMessageA$descriptor() {
        return RegisterWindowMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageA(LPCSTR lpString)
     * }
     */
    public static MethodHandle RegisterWindowMessageA$handle() {
        return RegisterWindowMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageA(LPCSTR lpString)
     * }
     */
    public static MemorySegment RegisterWindowMessageA$address() {
        return RegisterWindowMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RegisterWindowMessageA(LPCSTR lpString)
     * }
     */
    public static int RegisterWindowMessageA(MemorySegment lpString) {
        var mh$ = RegisterWindowMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterWindowMessageA", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterWindowMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterWindowMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor RegisterWindowMessageW$descriptor() {
        return RegisterWindowMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle RegisterWindowMessageW$handle() {
        return RegisterWindowMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment RegisterWindowMessageW$address() {
        return RegisterWindowMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RegisterWindowMessageW(LPCWSTR lpString)
     * }
     */
    public static int RegisterWindowMessageW(MemorySegment lpString) {
        var mh$ = RegisterWindowMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterWindowMessageW", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWINDOWPOS {
     *     HWND hwnd;
     *     HWND hwndInsertAfter;
     *     int x;
     *     int y;
     *     int cx;
     *     int cy;
     *     UINT flags;
     * } *LPWINDOWPOS
     * }
     */
    public static final AddressLayout LPWINDOWPOS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWINDOWPOS {
     *     HWND hwnd;
     *     HWND hwndInsertAfter;
     *     int x;
     *     int y;
     *     int cx;
     *     int cy;
     *     UINT flags;
     * } *PWINDOWPOS
     * }
     */
    public static final AddressLayout PWINDOWPOS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNCCALCSIZE_PARAMS {
     *     RECT rgrc[3];
     *     PWINDOWPOS lppos;
     * } *LPNCCALCSIZE_PARAMS
     * }
     */
    public static final AddressLayout LPNCCALCSIZE_PARAMS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTRACKMOUSEEVENT {
     *     DWORD cbSize;
     *     DWORD dwFlags;
     *     HWND hwndTrack;
     *     DWORD dwHoverTime;
     * } *LPTRACKMOUSEEVENT
     * }
     */
    public static final AddressLayout LPTRACKMOUSEEVENT = freeglut_h.C_POINTER;

    private static class TrackMouseEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TrackMouseEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
     * }
     */
    public static FunctionDescriptor TrackMouseEvent$descriptor() {
        return TrackMouseEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
     * }
     */
    public static MethodHandle TrackMouseEvent$handle() {
        return TrackMouseEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
     * }
     */
    public static MemorySegment TrackMouseEvent$address() {
        return TrackMouseEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
     * }
     */
    public static int TrackMouseEvent(MemorySegment lpEventTrack) {
        var mh$ = TrackMouseEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrackMouseEvent", lpEventTrack);
            }
            return (int)mh$.invokeExact(lpEventTrack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawEdge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawEdge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags)
     * }
     */
    public static FunctionDescriptor DrawEdge$descriptor() {
        return DrawEdge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags)
     * }
     */
    public static MethodHandle DrawEdge$handle() {
        return DrawEdge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags)
     * }
     */
    public static MemorySegment DrawEdge$address() {
        return DrawEdge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags)
     * }
     */
    public static int DrawEdge(MemorySegment hdc, MemorySegment qrc, int edge, int grfFlags) {
        var mh$ = DrawEdge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawEdge", hdc, qrc, edge, grfFlags);
            }
            return (int)mh$.invokeExact(hdc, qrc, edge, grfFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawFrameControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawFrameControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT)
     * }
     */
    public static FunctionDescriptor DrawFrameControl$descriptor() {
        return DrawFrameControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT)
     * }
     */
    public static MethodHandle DrawFrameControl$handle() {
        return DrawFrameControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT)
     * }
     */
    public static MemorySegment DrawFrameControl$address() {
        return DrawFrameControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT)
     * }
     */
    public static int DrawFrameControl(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = DrawFrameControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawFrameControl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCaption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawCaption");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawCaption(HWND hwnd, HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static FunctionDescriptor DrawCaption$descriptor() {
        return DrawCaption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawCaption(HWND hwnd, HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MethodHandle DrawCaption$handle() {
        return DrawCaption.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawCaption(HWND hwnd, HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MemorySegment DrawCaption$address() {
        return DrawCaption.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawCaption(HWND hwnd, HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static int DrawCaption(MemorySegment hwnd, MemorySegment hdc, MemorySegment lprect, int flags) {
        var mh$ = DrawCaption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCaption", hwnd, hdc, lprect, flags);
            }
            return (int)mh$.invokeExact(hwnd, hdc, lprect, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawAnimatedRects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawAnimatedRects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawAnimatedRects(HWND hwnd, int idAni, const RECT *lprcFrom, const RECT *lprcTo)
     * }
     */
    public static FunctionDescriptor DrawAnimatedRects$descriptor() {
        return DrawAnimatedRects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawAnimatedRects(HWND hwnd, int idAni, const RECT *lprcFrom, const RECT *lprcTo)
     * }
     */
    public static MethodHandle DrawAnimatedRects$handle() {
        return DrawAnimatedRects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawAnimatedRects(HWND hwnd, int idAni, const RECT *lprcFrom, const RECT *lprcTo)
     * }
     */
    public static MemorySegment DrawAnimatedRects$address() {
        return DrawAnimatedRects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawAnimatedRects(HWND hwnd, int idAni, const RECT *lprcFrom, const RECT *lprcTo)
     * }
     */
    public static int DrawAnimatedRects(MemorySegment hwnd, int idAni, MemorySegment lprcFrom, MemorySegment lprcTo) {
        var mh$ = DrawAnimatedRects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawAnimatedRects", hwnd, idAni, lprcFrom, lprcTo);
            }
            return (int)mh$.invokeExact(hwnd, idAni, lprcFrom, lprcTo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagACCEL {
     *     BYTE fVirt;
     *     WORD key;
     *     WORD cmd;
     * } *LPACCEL
     * }
     */
    public static final AddressLayout LPACCEL = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPAINTSTRUCT {
     *     HDC hdc;
     *     BOOL fErase;
     *     RECT rcPaint;
     *     BOOL fRestore;
     *     BOOL fIncUpdate;
     *     BYTE rgbReserved[32];
     * } *PPAINTSTRUCT
     * }
     */
    public static final AddressLayout PPAINTSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPAINTSTRUCT {
     *     HDC hdc;
     *     BOOL fErase;
     *     RECT rcPaint;
     *     BOOL fRestore;
     *     BOOL fIncUpdate;
     *     BYTE rgbReserved[32];
     * } *NPPAINTSTRUCT
     * }
     */
    public static final AddressLayout NPPAINTSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPAINTSTRUCT {
     *     HDC hdc;
     *     BOOL fErase;
     *     RECT rcPaint;
     *     BOOL fRestore;
     *     BOOL fIncUpdate;
     *     BYTE rgbReserved[32];
     * } *LPPAINTSTRUCT
     * }
     */
    public static final AddressLayout LPPAINTSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCREATESTRUCTA {
     *     LPVOID lpCreateParams;
     *     HINSTANCE hInstance;
     *     HMENU hMenu;
     *     HWND hwndParent;
     *     int cy;
     *     int cx;
     *     int y;
     *     int x;
     *     LONG style;
     *     LPCSTR lpszName;
     *     LPCSTR lpszClass;
     *     DWORD dwExStyle;
     * } *LPCREATESTRUCTA
     * }
     */
    public static final AddressLayout LPCREATESTRUCTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCREATESTRUCTW {
     *     LPVOID lpCreateParams;
     *     HINSTANCE hInstance;
     *     HMENU hMenu;
     *     HWND hwndParent;
     *     int cy;
     *     int cx;
     *     int y;
     *     int x;
     *     LONG style;
     *     LPCWSTR lpszName;
     *     LPCWSTR lpszClass;
     *     DWORD dwExStyle;
     * } *LPCREATESTRUCTW
     * }
     */
    public static final AddressLayout LPCREATESTRUCTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCREATESTRUCTA LPCREATESTRUCT
     * }
     */
    public static final AddressLayout LPCREATESTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WINDOWPLACEMENT *PWINDOWPLACEMENT
     * }
     */
    public static final AddressLayout PWINDOWPLACEMENT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WINDOWPLACEMENT *LPWINDOWPLACEMENT
     * }
     */
    public static final AddressLayout LPWINDOWPLACEMENT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NMHDR *LPNMHDR
     * }
     */
    public static final AddressLayout LPNMHDR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLESTRUCT {
     *     DWORD styleOld;
     *     DWORD styleNew;
     * } *LPSTYLESTRUCT
     * }
     */
    public static final AddressLayout LPSTYLESTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMEASUREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemWidth;
     *     UINT itemHeight;
     *     ULONG_PTR itemData;
     * } *PMEASUREITEMSTRUCT
     * }
     */
    public static final AddressLayout PMEASUREITEMSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMEASUREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemWidth;
     *     UINT itemHeight;
     *     ULONG_PTR itemData;
     * } *LPMEASUREITEMSTRUCT
     * }
     */
    public static final AddressLayout LPMEASUREITEMSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDRAWITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemAction;
     *     UINT itemState;
     *     HWND hwndItem;
     *     HDC hDC;
     *     RECT rcItem;
     *     ULONG_PTR itemData;
     * } *PDRAWITEMSTRUCT
     * }
     */
    public static final AddressLayout PDRAWITEMSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDRAWITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemAction;
     *     UINT itemState;
     *     HWND hwndItem;
     *     HDC hDC;
     *     RECT rcItem;
     *     ULONG_PTR itemData;
     * } *LPDRAWITEMSTRUCT
     * }
     */
    public static final AddressLayout LPDRAWITEMSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDELETEITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     HWND hwndItem;
     *     ULONG_PTR itemData;
     * } *PDELETEITEMSTRUCT
     * }
     */
    public static final AddressLayout PDELETEITEMSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDELETEITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     HWND hwndItem;
     *     ULONG_PTR itemData;
     * } *LPDELETEITEMSTRUCT
     * }
     */
    public static final AddressLayout LPDELETEITEMSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPAREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     HWND hwndItem;
     *     UINT itemID1;
     *     ULONG_PTR itemData1;
     *     UINT itemID2;
     *     ULONG_PTR itemData2;
     *     DWORD dwLocaleId;
     * } *PCOMPAREITEMSTRUCT
     * }
     */
    public static final AddressLayout PCOMPAREITEMSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPAREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     HWND hwndItem;
     *     UINT itemID1;
     *     ULONG_PTR itemData1;
     *     UINT itemID2;
     *     ULONG_PTR itemData2;
     *     DWORD dwLocaleId;
     * } *LPCOMPAREITEMSTRUCT
     * }
     */
    public static final AddressLayout LPCOMPAREITEMSTRUCT = freeglut_h.C_POINTER;

    private static class GetMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static FunctionDescriptor GetMessageA$descriptor() {
        return GetMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static MethodHandle GetMessageA$handle() {
        return GetMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static MemorySegment GetMessageA$address() {
        return GetMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static int GetMessageA(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax) {
        var mh$ = GetMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageA", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static FunctionDescriptor GetMessageW$descriptor() {
        return GetMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static MethodHandle GetMessageW$handle() {
        return GetMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static MemorySegment GetMessageW$address() {
        return GetMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static int GetMessageW(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax) {
        var mh$ = GetMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageW", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TranslateMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TranslateMessage(const MSG *lpMsg)
     * }
     */
    public static FunctionDescriptor TranslateMessage$descriptor() {
        return TranslateMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TranslateMessage(const MSG *lpMsg)
     * }
     */
    public static MethodHandle TranslateMessage$handle() {
        return TranslateMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TranslateMessage(const MSG *lpMsg)
     * }
     */
    public static MemorySegment TranslateMessage$address() {
        return TranslateMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TranslateMessage(const MSG *lpMsg)
     * }
     */
    public static int TranslateMessage(MemorySegment lpMsg) {
        var mh$ = TranslateMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateMessage", lpMsg);
            }
            return (int)mh$.invokeExact(lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DispatchMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DispatchMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageA(const MSG *lpMsg)
     * }
     */
    public static FunctionDescriptor DispatchMessageA$descriptor() {
        return DispatchMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageA(const MSG *lpMsg)
     * }
     */
    public static MethodHandle DispatchMessageA$handle() {
        return DispatchMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageA(const MSG *lpMsg)
     * }
     */
    public static MemorySegment DispatchMessageA$address() {
        return DispatchMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DispatchMessageA(const MSG *lpMsg)
     * }
     */
    public static long DispatchMessageA(MemorySegment lpMsg) {
        var mh$ = DispatchMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DispatchMessageA", lpMsg);
            }
            return (long)mh$.invokeExact(lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DispatchMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DispatchMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageW(const MSG *lpMsg)
     * }
     */
    public static FunctionDescriptor DispatchMessageW$descriptor() {
        return DispatchMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageW(const MSG *lpMsg)
     * }
     */
    public static MethodHandle DispatchMessageW$handle() {
        return DispatchMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageW(const MSG *lpMsg)
     * }
     */
    public static MemorySegment DispatchMessageW$address() {
        return DispatchMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DispatchMessageW(const MSG *lpMsg)
     * }
     */
    public static long DispatchMessageW(MemorySegment lpMsg) {
        var mh$ = DispatchMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DispatchMessageW", lpMsg);
            }
            return (long)mh$.invokeExact(lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMessageQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMessageQueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMessageQueue(int cMessagesMax)
     * }
     */
    public static FunctionDescriptor SetMessageQueue$descriptor() {
        return SetMessageQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMessageQueue(int cMessagesMax)
     * }
     */
    public static MethodHandle SetMessageQueue$handle() {
        return SetMessageQueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMessageQueue(int cMessagesMax)
     * }
     */
    public static MemorySegment SetMessageQueue$address() {
        return SetMessageQueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMessageQueue(int cMessagesMax)
     * }
     */
    public static int SetMessageQueue(int cMessagesMax) {
        var mh$ = SetMessageQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMessageQueue", cMessagesMax);
            }
            return (int)mh$.invokeExact(cMessagesMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PeekMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static FunctionDescriptor PeekMessageA$descriptor() {
        return PeekMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static MethodHandle PeekMessageA$handle() {
        return PeekMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static MemorySegment PeekMessageA$address() {
        return PeekMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static int PeekMessageA(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax, int wRemoveMsg) {
        var mh$ = PeekMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekMessageA", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PeekMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static FunctionDescriptor PeekMessageW$descriptor() {
        return PeekMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static MethodHandle PeekMessageW$handle() {
        return PeekMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static MemorySegment PeekMessageW$address() {
        return PeekMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static int PeekMessageW(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax, int wRemoveMsg) {
        var mh$ = PeekMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekMessageW", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterHotKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterHotKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk)
     * }
     */
    public static FunctionDescriptor RegisterHotKey$descriptor() {
        return RegisterHotKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk)
     * }
     */
    public static MethodHandle RegisterHotKey$handle() {
        return RegisterHotKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk)
     * }
     */
    public static MemorySegment RegisterHotKey$address() {
        return RegisterHotKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk)
     * }
     */
    public static int RegisterHotKey(MemorySegment hWnd, int id, int fsModifiers, int vk) {
        var mh$ = RegisterHotKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterHotKey", hWnd, id, fsModifiers, vk);
            }
            return (int)mh$.invokeExact(hWnd, id, fsModifiers, vk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterHotKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterHotKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterHotKey(HWND hWnd, int id)
     * }
     */
    public static FunctionDescriptor UnregisterHotKey$descriptor() {
        return UnregisterHotKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterHotKey(HWND hWnd, int id)
     * }
     */
    public static MethodHandle UnregisterHotKey$handle() {
        return UnregisterHotKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterHotKey(HWND hWnd, int id)
     * }
     */
    public static MemorySegment UnregisterHotKey$address() {
        return UnregisterHotKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterHotKey(HWND hWnd, int id)
     * }
     */
    public static int UnregisterHotKey(MemorySegment hWnd, int id) {
        var mh$ = UnregisterHotKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterHotKey", hWnd, id);
            }
            return (int)mh$.invokeExact(hWnd, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExitWindowsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExitWindowsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExitWindowsEx(UINT uFlags, DWORD dwReason)
     * }
     */
    public static FunctionDescriptor ExitWindowsEx$descriptor() {
        return ExitWindowsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExitWindowsEx(UINT uFlags, DWORD dwReason)
     * }
     */
    public static MethodHandle ExitWindowsEx$handle() {
        return ExitWindowsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExitWindowsEx(UINT uFlags, DWORD dwReason)
     * }
     */
    public static MemorySegment ExitWindowsEx$address() {
        return ExitWindowsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExitWindowsEx(UINT uFlags, DWORD dwReason)
     * }
     */
    public static int ExitWindowsEx(int uFlags, int dwReason) {
        var mh$ = ExitWindowsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExitWindowsEx", uFlags, dwReason);
            }
            return (int)mh$.invokeExact(uFlags, dwReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwapMouseButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SwapMouseButton");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwapMouseButton(BOOL fSwap)
     * }
     */
    public static FunctionDescriptor SwapMouseButton$descriptor() {
        return SwapMouseButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwapMouseButton(BOOL fSwap)
     * }
     */
    public static MethodHandle SwapMouseButton$handle() {
        return SwapMouseButton.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SwapMouseButton(BOOL fSwap)
     * }
     */
    public static MemorySegment SwapMouseButton$address() {
        return SwapMouseButton.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SwapMouseButton(BOOL fSwap)
     * }
     */
    public static int SwapMouseButton(int fSwap) {
        var mh$ = SwapMouseButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwapMouseButton", fSwap);
            }
            return (int)mh$.invokeExact(fSwap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessagePos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMessagePos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetMessagePos()
     * }
     */
    public static FunctionDescriptor GetMessagePos$descriptor() {
        return GetMessagePos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetMessagePos()
     * }
     */
    public static MethodHandle GetMessagePos$handle() {
        return GetMessagePos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetMessagePos()
     * }
     */
    public static MemorySegment GetMessagePos$address() {
        return GetMessagePos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetMessagePos()
     * }
     */
    public static int GetMessagePos() {
        var mh$ = GetMessagePos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessagePos");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessageTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMessageTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetMessageTime()
     * }
     */
    public static FunctionDescriptor GetMessageTime$descriptor() {
        return GetMessageTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetMessageTime()
     * }
     */
    public static MethodHandle GetMessageTime$handle() {
        return GetMessageTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG GetMessageTime()
     * }
     */
    public static MemorySegment GetMessageTime$address() {
        return GetMessageTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG GetMessageTime()
     * }
     */
    public static int GetMessageTime() {
        var mh$ = GetMessageTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageTime");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessageExtraInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMessageExtraInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPARAM GetMessageExtraInfo()
     * }
     */
    public static FunctionDescriptor GetMessageExtraInfo$descriptor() {
        return GetMessageExtraInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPARAM GetMessageExtraInfo()
     * }
     */
    public static MethodHandle GetMessageExtraInfo$handle() {
        return GetMessageExtraInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPARAM GetMessageExtraInfo()
     * }
     */
    public static MemorySegment GetMessageExtraInfo$address() {
        return GetMessageExtraInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPARAM GetMessageExtraInfo()
     * }
     */
    public static long GetMessageExtraInfo() {
        var mh$ = GetMessageExtraInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageExtraInfo");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUnpredictedMessagePos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUnpredictedMessagePos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetUnpredictedMessagePos()
     * }
     */
    public static FunctionDescriptor GetUnpredictedMessagePos$descriptor() {
        return GetUnpredictedMessagePos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetUnpredictedMessagePos()
     * }
     */
    public static MethodHandle GetUnpredictedMessagePos$handle() {
        return GetUnpredictedMessagePos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetUnpredictedMessagePos()
     * }
     */
    public static MemorySegment GetUnpredictedMessagePos$address() {
        return GetUnpredictedMessagePos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetUnpredictedMessagePos()
     * }
     */
    public static int GetUnpredictedMessagePos() {
        var mh$ = GetUnpredictedMessagePos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUnpredictedMessagePos");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64Message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsWow64Message");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWow64Message()
     * }
     */
    public static FunctionDescriptor IsWow64Message$descriptor() {
        return IsWow64Message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWow64Message()
     * }
     */
    public static MethodHandle IsWow64Message$handle() {
        return IsWow64Message.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWow64Message()
     * }
     */
    public static MemorySegment IsWow64Message$address() {
        return IsWow64Message.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWow64Message()
     * }
     */
    public static int IsWow64Message() {
        var mh$ = IsWow64Message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64Message");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMessageExtraInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMessageExtraInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPARAM SetMessageExtraInfo(LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SetMessageExtraInfo$descriptor() {
        return SetMessageExtraInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPARAM SetMessageExtraInfo(LPARAM lParam)
     * }
     */
    public static MethodHandle SetMessageExtraInfo$handle() {
        return SetMessageExtraInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPARAM SetMessageExtraInfo(LPARAM lParam)
     * }
     */
    public static MemorySegment SetMessageExtraInfo$address() {
        return SetMessageExtraInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPARAM SetMessageExtraInfo(LPARAM lParam)
     * }
     */
    public static long SetMessageExtraInfo(long lParam) {
        var mh$ = SetMessageExtraInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMessageExtraInfo", lParam);
            }
            return (long)mh$.invokeExact(lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SendMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendMessageA$descriptor() {
        return SendMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendMessageA$handle() {
        return SendMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendMessageA$address() {
        return SendMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendMessageA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageA", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SendMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendMessageW$descriptor() {
        return SendMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendMessageW$handle() {
        return SendMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendMessageW$address() {
        return SendMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendMessageW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageW", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageTimeoutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SendMessageTimeoutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static FunctionDescriptor SendMessageTimeoutA$descriptor() {
        return SendMessageTimeoutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static MethodHandle SendMessageTimeoutA$handle() {
        return SendMessageTimeoutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static MemorySegment SendMessageTimeoutA$address() {
        return SendMessageTimeoutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static long SendMessageTimeoutA(MemorySegment hWnd, int Msg, long wParam, long lParam, int fuFlags, int uTimeout, MemorySegment lpdwResult) {
        var mh$ = SendMessageTimeoutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageTimeoutA", hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageTimeoutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SendMessageTimeoutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static FunctionDescriptor SendMessageTimeoutW$descriptor() {
        return SendMessageTimeoutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static MethodHandle SendMessageTimeoutW$handle() {
        return SendMessageTimeoutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static MemorySegment SendMessageTimeoutW$address() {
        return SendMessageTimeoutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static long SendMessageTimeoutW(MemorySegment hWnd, int Msg, long wParam, long lParam, int fuFlags, int uTimeout, MemorySegment lpdwResult) {
        var mh$ = SendMessageTimeoutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageTimeoutW", hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendNotifyMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SendNotifyMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendNotifyMessageA$descriptor() {
        return SendNotifyMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendNotifyMessageA$handle() {
        return SendNotifyMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendNotifyMessageA$address() {
        return SendNotifyMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int SendNotifyMessageA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendNotifyMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendNotifyMessageA", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendNotifyMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SendNotifyMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendNotifyMessageW$descriptor() {
        return SendNotifyMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendNotifyMessageW$handle() {
        return SendNotifyMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendNotifyMessageW$address() {
        return SendNotifyMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int SendNotifyMessageW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendNotifyMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendNotifyMessageW", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageCallbackA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SendMessageCallbackA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor SendMessageCallbackA$descriptor() {
        return SendMessageCallbackA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle SendMessageCallbackA$handle() {
        return SendMessageCallbackA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static MemorySegment SendMessageCallbackA$address() {
        return SendMessageCallbackA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static int SendMessageCallbackA(MemorySegment hWnd, int Msg, long wParam, long lParam, MemorySegment lpResultCallBack, long dwData) {
        var mh$ = SendMessageCallbackA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageCallbackA", hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageCallbackW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SendMessageCallbackW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor SendMessageCallbackW$descriptor() {
        return SendMessageCallbackW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle SendMessageCallbackW$handle() {
        return SendMessageCallbackW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static MemorySegment SendMessageCallbackW$address() {
        return SendMessageCallbackW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static int SendMessageCallbackW(MemorySegment hWnd, int Msg, long wParam, long lParam, MemorySegment lpResultCallBack, long dwData) {
        var mh$ = SendMessageCallbackW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageCallbackW", hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     UINT cbSize;
     *     HDESK hdesk;
     *     HWND hwnd;
     *     LUID luid;
     * } *PBSMINFO
     * }
     */
    public static final AddressLayout PBSMINFO = freeglut_h.C_POINTER;

    private static class BroadcastSystemMessageExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BroadcastSystemMessageExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageExA$descriptor() {
        return BroadcastSystemMessageExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static MethodHandle BroadcastSystemMessageExA$handle() {
        return BroadcastSystemMessageExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static MemorySegment BroadcastSystemMessageExA$address() {
        return BroadcastSystemMessageExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static int BroadcastSystemMessageExA(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam, MemorySegment pbsmInfo) {
        var mh$ = BroadcastSystemMessageExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageExA", flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BroadcastSystemMessageExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BroadcastSystemMessageExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageExW$descriptor() {
        return BroadcastSystemMessageExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static MethodHandle BroadcastSystemMessageExW$handle() {
        return BroadcastSystemMessageExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static MemorySegment BroadcastSystemMessageExW$address() {
        return BroadcastSystemMessageExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static int BroadcastSystemMessageExW(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam, MemorySegment pbsmInfo) {
        var mh$ = BroadcastSystemMessageExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageExW", flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BroadcastSystemMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BroadcastSystemMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageA$descriptor() {
        return BroadcastSystemMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle BroadcastSystemMessageA$handle() {
        return BroadcastSystemMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment BroadcastSystemMessageA$address() {
        return BroadcastSystemMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int BroadcastSystemMessageA(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam) {
        var mh$ = BroadcastSystemMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageA", flags, lpInfo, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BroadcastSystemMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BroadcastSystemMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageW$descriptor() {
        return BroadcastSystemMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle BroadcastSystemMessageW$handle() {
        return BroadcastSystemMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment BroadcastSystemMessageW$address() {
        return BroadcastSystemMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int BroadcastSystemMessageW(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam) {
        var mh$ = BroadcastSystemMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageW", flags, lpInfo, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PVOID HDEVNOTIFY
     * }
     */
    public static final AddressLayout HDEVNOTIFY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HDEVNOTIFY *PHDEVNOTIFY
     * }
     */
    public static final AddressLayout PHDEVNOTIFY = freeglut_h.C_POINTER;

    private static class RegisterDeviceNotificationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterDeviceNotificationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterDeviceNotificationA$descriptor() {
        return RegisterDeviceNotificationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterDeviceNotificationA$handle() {
        return RegisterDeviceNotificationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterDeviceNotificationA$address() {
        return RegisterDeviceNotificationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterDeviceNotificationA(MemorySegment hRecipient, MemorySegment NotificationFilter, int Flags) {
        var mh$ = RegisterDeviceNotificationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterDeviceNotificationA", hRecipient, NotificationFilter, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, NotificationFilter, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterDeviceNotificationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterDeviceNotificationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterDeviceNotificationW$descriptor() {
        return RegisterDeviceNotificationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterDeviceNotificationW$handle() {
        return RegisterDeviceNotificationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterDeviceNotificationW$address() {
        return RegisterDeviceNotificationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterDeviceNotificationW(MemorySegment hRecipient, MemorySegment NotificationFilter, int Flags) {
        var mh$ = RegisterDeviceNotificationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterDeviceNotificationW", hRecipient, NotificationFilter, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, NotificationFilter, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterDeviceNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterDeviceNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterDeviceNotification(HDEVNOTIFY Handle)
     * }
     */
    public static FunctionDescriptor UnregisterDeviceNotification$descriptor() {
        return UnregisterDeviceNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterDeviceNotification(HDEVNOTIFY Handle)
     * }
     */
    public static MethodHandle UnregisterDeviceNotification$handle() {
        return UnregisterDeviceNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterDeviceNotification(HDEVNOTIFY Handle)
     * }
     */
    public static MemorySegment UnregisterDeviceNotification$address() {
        return UnregisterDeviceNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterDeviceNotification(HDEVNOTIFY Handle)
     * }
     */
    public static int UnregisterDeviceNotification(MemorySegment Handle) {
        var mh$ = UnregisterDeviceNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterDeviceNotification", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PVOID HPOWERNOTIFY
     * }
     */
    public static final AddressLayout HPOWERNOTIFY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HPOWERNOTIFY *PHPOWERNOTIFY
     * }
     */
    public static final AddressLayout PHPOWERNOTIFY = freeglut_h.C_POINTER;

    private static class RegisterPowerSettingNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterPowerSettingNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterPowerSettingNotification$descriptor() {
        return RegisterPowerSettingNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterPowerSettingNotification$handle() {
        return RegisterPowerSettingNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterPowerSettingNotification$address() {
        return RegisterPowerSettingNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterPowerSettingNotification(MemorySegment hRecipient, MemorySegment PowerSettingGuid, int Flags) {
        var mh$ = RegisterPowerSettingNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterPowerSettingNotification", hRecipient, PowerSettingGuid, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, PowerSettingGuid, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterPowerSettingNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterPowerSettingNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterPowerSettingNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static FunctionDescriptor UnregisterPowerSettingNotification$descriptor() {
        return UnregisterPowerSettingNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterPowerSettingNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static MethodHandle UnregisterPowerSettingNotification$handle() {
        return UnregisterPowerSettingNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterPowerSettingNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static MemorySegment UnregisterPowerSettingNotification$address() {
        return UnregisterPowerSettingNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterPowerSettingNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static int UnregisterPowerSettingNotification(MemorySegment Handle) {
        var mh$ = UnregisterPowerSettingNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterPowerSettingNotification", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterSuspendResumeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterSuspendResumeNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterSuspendResumeNotification$descriptor() {
        return RegisterSuspendResumeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterSuspendResumeNotification$handle() {
        return RegisterSuspendResumeNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterSuspendResumeNotification$address() {
        return RegisterSuspendResumeNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterSuspendResumeNotification(MemorySegment hRecipient, int Flags) {
        var mh$ = RegisterSuspendResumeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterSuspendResumeNotification", hRecipient, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterSuspendResumeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterSuspendResumeNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static FunctionDescriptor UnregisterSuspendResumeNotification$descriptor() {
        return UnregisterSuspendResumeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static MethodHandle UnregisterSuspendResumeNotification$handle() {
        return UnregisterSuspendResumeNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static MemorySegment UnregisterSuspendResumeNotification$address() {
        return UnregisterSuspendResumeNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static int UnregisterSuspendResumeNotification(MemorySegment Handle) {
        var mh$ = UnregisterSuspendResumeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterSuspendResumeNotification", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PostMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostMessageA$descriptor() {
        return PostMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostMessageA$handle() {
        return PostMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment PostMessageA$address() {
        return PostMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostMessageA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = PostMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostMessageA", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PostMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostMessageW$descriptor() {
        return PostMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostMessageW$handle() {
        return PostMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment PostMessageW$address() {
        return PostMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostMessageW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = PostMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostMessageW", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostThreadMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PostThreadMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostThreadMessageA$descriptor() {
        return PostThreadMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostThreadMessageA$handle() {
        return PostThreadMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment PostThreadMessageA$address() {
        return PostThreadMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostThreadMessageA(int idThread, int Msg, long wParam, long lParam) {
        var mh$ = PostThreadMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostThreadMessageA", idThread, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(idThread, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostThreadMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PostThreadMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostThreadMessageW$descriptor() {
        return PostThreadMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostThreadMessageW$handle() {
        return PostThreadMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment PostThreadMessageW$address() {
        return PostThreadMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostThreadMessageW(int idThread, int Msg, long wParam, long lParam) {
        var mh$ = PostThreadMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostThreadMessageW", idThread, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(idThread, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachThreadInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AttachThreadInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach)
     * }
     */
    public static FunctionDescriptor AttachThreadInput$descriptor() {
        return AttachThreadInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach)
     * }
     */
    public static MethodHandle AttachThreadInput$handle() {
        return AttachThreadInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach)
     * }
     */
    public static MemorySegment AttachThreadInput$address() {
        return AttachThreadInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach)
     * }
     */
    public static int AttachThreadInput(int idAttach, int idAttachTo, int fAttach) {
        var mh$ = AttachThreadInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachThreadInput", idAttach, idAttachTo, fAttach);
            }
            return (int)mh$.invokeExact(idAttach, idAttachTo, fAttach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplyMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReplyMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplyMessage(LRESULT lResult)
     * }
     */
    public static FunctionDescriptor ReplyMessage$descriptor() {
        return ReplyMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplyMessage(LRESULT lResult)
     * }
     */
    public static MethodHandle ReplyMessage$handle() {
        return ReplyMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplyMessage(LRESULT lResult)
     * }
     */
    public static MemorySegment ReplyMessage$address() {
        return ReplyMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplyMessage(LRESULT lResult)
     * }
     */
    public static int ReplyMessage(long lResult) {
        var mh$ = ReplyMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplyMessage", lResult);
            }
            return (int)mh$.invokeExact(lResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitMessage()
     * }
     */
    public static FunctionDescriptor WaitMessage$descriptor() {
        return WaitMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitMessage()
     * }
     */
    public static MethodHandle WaitMessage$handle() {
        return WaitMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitMessage()
     * }
     */
    public static MemorySegment WaitMessage$address() {
        return WaitMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitMessage()
     * }
     */
    public static int WaitMessage() {
        var mh$ = WaitMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitMessage");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForInputIdle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitForInputIdle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForInputIdle$descriptor() {
        return WaitForInputIdle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForInputIdle$handle() {
        return WaitForInputIdle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForInputIdle$address() {
        return WaitForInputIdle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForInputIdle(MemorySegment hProcess, int dwMilliseconds) {
        var mh$ = WaitForInputIdle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForInputIdle", hProcess, dwMilliseconds);
            }
            return (int)mh$.invokeExact(hProcess, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefWindowProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DefWindowProcA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefWindowProcA$descriptor() {
        return DefWindowProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefWindowProcA$handle() {
        return DefWindowProcA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefWindowProcA$address() {
        return DefWindowProcA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefWindowProcA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = DefWindowProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefWindowProcA", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefWindowProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DefWindowProcW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefWindowProcW$descriptor() {
        return DefWindowProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefWindowProcW$handle() {
        return DefWindowProcW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefWindowProcW$address() {
        return DefWindowProcW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefWindowProcW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = DefWindowProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefWindowProcW", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostQuitMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PostQuitMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PostQuitMessage(int nExitCode)
     * }
     */
    public static FunctionDescriptor PostQuitMessage$descriptor() {
        return PostQuitMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PostQuitMessage(int nExitCode)
     * }
     */
    public static MethodHandle PostQuitMessage$handle() {
        return PostQuitMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PostQuitMessage(int nExitCode)
     * }
     */
    public static MemorySegment PostQuitMessage$address() {
        return PostQuitMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PostQuitMessage(int nExitCode)
     * }
     */
    public static void PostQuitMessage(int nExitCode) {
        var mh$ = PostQuitMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostQuitMessage", nExitCode);
            }
            mh$.invokeExact(nExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallWindowProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CallWindowProcA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CallWindowProcA$descriptor() {
        return CallWindowProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle CallWindowProcA$handle() {
        return CallWindowProcA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment CallWindowProcA$address() {
        return CallWindowProcA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long CallWindowProcA(MemorySegment lpPrevWndFunc, MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = CallWindowProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallWindowProcA", lpPrevWndFunc, hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallWindowProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CallWindowProcW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CallWindowProcW$descriptor() {
        return CallWindowProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle CallWindowProcW$handle() {
        return CallWindowProcW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment CallWindowProcW$address() {
        return CallWindowProcW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long CallWindowProcW(MemorySegment lpPrevWndFunc, MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = CallWindowProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallWindowProcW", lpPrevWndFunc, hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InSendMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InSendMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InSendMessage()
     * }
     */
    public static FunctionDescriptor InSendMessage$descriptor() {
        return InSendMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InSendMessage()
     * }
     */
    public static MethodHandle InSendMessage$handle() {
        return InSendMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InSendMessage()
     * }
     */
    public static MemorySegment InSendMessage$address() {
        return InSendMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InSendMessage()
     * }
     */
    public static int InSendMessage() {
        var mh$ = InSendMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InSendMessage");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InSendMessageEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InSendMessageEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD InSendMessageEx(LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor InSendMessageEx$descriptor() {
        return InSendMessageEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD InSendMessageEx(LPVOID lpReserved)
     * }
     */
    public static MethodHandle InSendMessageEx$handle() {
        return InSendMessageEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD InSendMessageEx(LPVOID lpReserved)
     * }
     */
    public static MemorySegment InSendMessageEx$address() {
        return InSendMessageEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD InSendMessageEx(LPVOID lpReserved)
     * }
     */
    public static int InSendMessageEx(MemorySegment lpReserved) {
        var mh$ = InSendMessageEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InSendMessageEx", lpReserved);
            }
            return (int)mh$.invokeExact(lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDoubleClickTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDoubleClickTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDoubleClickTime()
     * }
     */
    public static FunctionDescriptor GetDoubleClickTime$descriptor() {
        return GetDoubleClickTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDoubleClickTime()
     * }
     */
    public static MethodHandle GetDoubleClickTime$handle() {
        return GetDoubleClickTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDoubleClickTime()
     * }
     */
    public static MemorySegment GetDoubleClickTime$address() {
        return GetDoubleClickTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDoubleClickTime()
     * }
     */
    public static int GetDoubleClickTime() {
        var mh$ = GetDoubleClickTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDoubleClickTime");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDoubleClickTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDoubleClickTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDoubleClickTime(UINT)
     * }
     */
    public static FunctionDescriptor SetDoubleClickTime$descriptor() {
        return SetDoubleClickTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDoubleClickTime(UINT)
     * }
     */
    public static MethodHandle SetDoubleClickTime$handle() {
        return SetDoubleClickTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDoubleClickTime(UINT)
     * }
     */
    public static MemorySegment SetDoubleClickTime$address() {
        return SetDoubleClickTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDoubleClickTime(UINT)
     * }
     */
    public static int SetDoubleClickTime(int x0) {
        var mh$ = SetDoubleClickTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDoubleClickTime", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterClassA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassA(const WNDCLASSA *lpWndClass)
     * }
     */
    public static FunctionDescriptor RegisterClassA$descriptor() {
        return RegisterClassA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassA(const WNDCLASSA *lpWndClass)
     * }
     */
    public static MethodHandle RegisterClassA$handle() {
        return RegisterClassA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM RegisterClassA(const WNDCLASSA *lpWndClass)
     * }
     */
    public static MemorySegment RegisterClassA$address() {
        return RegisterClassA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM RegisterClassA(const WNDCLASSA *lpWndClass)
     * }
     */
    public static short RegisterClassA(MemorySegment lpWndClass) {
        var mh$ = RegisterClassA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassA", lpWndClass);
            }
            return (short)mh$.invokeExact(lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterClassW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassW(const WNDCLASSW *lpWndClass)
     * }
     */
    public static FunctionDescriptor RegisterClassW$descriptor() {
        return RegisterClassW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassW(const WNDCLASSW *lpWndClass)
     * }
     */
    public static MethodHandle RegisterClassW$handle() {
        return RegisterClassW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM RegisterClassW(const WNDCLASSW *lpWndClass)
     * }
     */
    public static MemorySegment RegisterClassW$address() {
        return RegisterClassW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM RegisterClassW(const WNDCLASSW *lpWndClass)
     * }
     */
    public static short RegisterClassW(MemorySegment lpWndClass) {
        var mh$ = RegisterClassW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassW", lpWndClass);
            }
            return (short)mh$.invokeExact(lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterClassA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterClassA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static FunctionDescriptor UnregisterClassA$descriptor() {
        return UnregisterClassA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static MethodHandle UnregisterClassA$handle() {
        return UnregisterClassA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static MemorySegment UnregisterClassA$address() {
        return UnregisterClassA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static int UnregisterClassA(MemorySegment lpClassName, MemorySegment hInstance) {
        var mh$ = UnregisterClassA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterClassA", lpClassName, hInstance);
            }
            return (int)mh$.invokeExact(lpClassName, hInstance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterClassW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterClassW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static FunctionDescriptor UnregisterClassW$descriptor() {
        return UnregisterClassW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static MethodHandle UnregisterClassW$handle() {
        return UnregisterClassW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static MemorySegment UnregisterClassW$address() {
        return UnregisterClassW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static int UnregisterClassW(MemorySegment lpClassName, MemorySegment hInstance) {
        var mh$ = UnregisterClassW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterClassW", lpClassName, hInstance);
            }
            return (int)mh$.invokeExact(lpClassName, hInstance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClassInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass)
     * }
     */
    public static FunctionDescriptor GetClassInfoA$descriptor() {
        return GetClassInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass)
     * }
     */
    public static MethodHandle GetClassInfoA$handle() {
        return GetClassInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass)
     * }
     */
    public static MemorySegment GetClassInfoA$address() {
        return GetClassInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass)
     * }
     */
    public static int GetClassInfoA(MemorySegment hInstance, MemorySegment lpClassName, MemorySegment lpWndClass) {
        var mh$ = GetClassInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoA", hInstance, lpClassName, lpWndClass);
            }
            return (int)mh$.invokeExact(hInstance, lpClassName, lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClassInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass)
     * }
     */
    public static FunctionDescriptor GetClassInfoW$descriptor() {
        return GetClassInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass)
     * }
     */
    public static MethodHandle GetClassInfoW$handle() {
        return GetClassInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass)
     * }
     */
    public static MemorySegment GetClassInfoW$address() {
        return GetClassInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass)
     * }
     */
    public static int GetClassInfoW(MemorySegment hInstance, MemorySegment lpClassName, MemorySegment lpWndClass) {
        var mh$ = GetClassInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoW", hInstance, lpClassName, lpWndClass);
            }
            return (int)mh$.invokeExact(hInstance, lpClassName, lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterClassExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassExA(const WNDCLASSEXA *)
     * }
     */
    public static FunctionDescriptor RegisterClassExA$descriptor() {
        return RegisterClassExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassExA(const WNDCLASSEXA *)
     * }
     */
    public static MethodHandle RegisterClassExA$handle() {
        return RegisterClassExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM RegisterClassExA(const WNDCLASSEXA *)
     * }
     */
    public static MemorySegment RegisterClassExA$address() {
        return RegisterClassExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM RegisterClassExA(const WNDCLASSEXA *)
     * }
     */
    public static short RegisterClassExA(MemorySegment x0) {
        var mh$ = RegisterClassExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassExA", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterClassExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassExW(const WNDCLASSEXW *)
     * }
     */
    public static FunctionDescriptor RegisterClassExW$descriptor() {
        return RegisterClassExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassExW(const WNDCLASSEXW *)
     * }
     */
    public static MethodHandle RegisterClassExW$handle() {
        return RegisterClassExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM RegisterClassExW(const WNDCLASSEXW *)
     * }
     */
    public static MemorySegment RegisterClassExW$address() {
        return RegisterClassExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM RegisterClassExW(const WNDCLASSEXW *)
     * }
     */
    public static short RegisterClassExW(MemorySegment x0) {
        var mh$ = RegisterClassExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassExW", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClassInfoExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx)
     * }
     */
    public static FunctionDescriptor GetClassInfoExA$descriptor() {
        return GetClassInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx)
     * }
     */
    public static MethodHandle GetClassInfoExA$handle() {
        return GetClassInfoExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx)
     * }
     */
    public static MemorySegment GetClassInfoExA$address() {
        return GetClassInfoExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx)
     * }
     */
    public static int GetClassInfoExA(MemorySegment hInstance, MemorySegment lpszClass, MemorySegment lpwcx) {
        var mh$ = GetClassInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoExA", hInstance, lpszClass, lpwcx);
            }
            return (int)mh$.invokeExact(hInstance, lpszClass, lpwcx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClassInfoExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx)
     * }
     */
    public static FunctionDescriptor GetClassInfoExW$descriptor() {
        return GetClassInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx)
     * }
     */
    public static MethodHandle GetClassInfoExW$handle() {
        return GetClassInfoExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx)
     * }
     */
    public static MemorySegment GetClassInfoExW$address() {
        return GetClassInfoExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx)
     * }
     */
    public static int GetClassInfoExW(MemorySegment hInstance, MemorySegment lpszClass, MemorySegment lpwcx) {
        var mh$ = GetClassInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoExW", hInstance, lpszClass, lpwcx);
            }
            return (int)mh$.invokeExact(hInstance, lpszClass, lpwcx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateWindowExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static FunctionDescriptor CreateWindowExA$descriptor() {
        return CreateWindowExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MethodHandle CreateWindowExA$handle() {
        return CreateWindowExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MemorySegment CreateWindowExA$address() {
        return CreateWindowExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MemorySegment CreateWindowExA(int dwExStyle, MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hMenu, MemorySegment hInstance, MemorySegment lpParam) {
        var mh$ = CreateWindowExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowExA", dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
            }
            return (MemorySegment)mh$.invokeExact(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateWindowExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static FunctionDescriptor CreateWindowExW$descriptor() {
        return CreateWindowExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MethodHandle CreateWindowExW$handle() {
        return CreateWindowExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MemorySegment CreateWindowExW$address() {
        return CreateWindowExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MemorySegment CreateWindowExW(int dwExStyle, MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hMenu, MemorySegment hInstance, MemorySegment lpParam) {
        var mh$ = CreateWindowExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowExW", dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
            }
            return (MemorySegment)mh$.invokeExact(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindow$descriptor() {
        return IsWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindow(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindow$handle() {
        return IsWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWindow(HWND hWnd)
     * }
     */
    public static MemorySegment IsWindow$address() {
        return IsWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWindow(HWND hWnd)
     * }
     */
    public static int IsWindow(MemorySegment hWnd) {
        var mh$ = IsWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsMenu(HMENU hMenu)
     * }
     */
    public static FunctionDescriptor IsMenu$descriptor() {
        return IsMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsMenu(HMENU hMenu)
     * }
     */
    public static MethodHandle IsMenu$handle() {
        return IsMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsMenu(HMENU hMenu)
     * }
     */
    public static MemorySegment IsMenu$address() {
        return IsMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsMenu(HMENU hMenu)
     * }
     */
    public static int IsMenu(MemorySegment hMenu) {
        var mh$ = IsMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMenu", hMenu);
            }
            return (int)mh$.invokeExact(hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsChild {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsChild");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsChild(HWND hWndParent, HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsChild$descriptor() {
        return IsChild.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsChild(HWND hWndParent, HWND hWnd)
     * }
     */
    public static MethodHandle IsChild$handle() {
        return IsChild.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsChild(HWND hWndParent, HWND hWnd)
     * }
     */
    public static MemorySegment IsChild$address() {
        return IsChild.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsChild(HWND hWndParent, HWND hWnd)
     * }
     */
    public static int IsChild(MemorySegment hWndParent, MemorySegment hWnd) {
        var mh$ = IsChild.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsChild", hWndParent, hWnd);
            }
            return (int)mh$.invokeExact(hWndParent, hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DestroyWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor DestroyWindow$descriptor() {
        return DestroyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyWindow(HWND hWnd)
     * }
     */
    public static MethodHandle DestroyWindow$handle() {
        return DestroyWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DestroyWindow(HWND hWnd)
     * }
     */
    public static MemorySegment DestroyWindow$address() {
        return DestroyWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DestroyWindow(HWND hWnd)
     * }
     */
    public static int DestroyWindow(MemorySegment hWnd) {
        var mh$ = DestroyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ShowWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowWindow(HWND hWnd, int nCmdShow)
     * }
     */
    public static FunctionDescriptor ShowWindow$descriptor() {
        return ShowWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowWindow(HWND hWnd, int nCmdShow)
     * }
     */
    public static MethodHandle ShowWindow$handle() {
        return ShowWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ShowWindow(HWND hWnd, int nCmdShow)
     * }
     */
    public static MemorySegment ShowWindow$address() {
        return ShowWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ShowWindow(HWND hWnd, int nCmdShow)
     * }
     */
    public static int ShowWindow(MemorySegment hWnd, int nCmdShow) {
        var mh$ = ShowWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowWindow", hWnd, nCmdShow);
            }
            return (int)mh$.invokeExact(hWnd, nCmdShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AnimateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor AnimateWindow$descriptor() {
        return AnimateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags)
     * }
     */
    public static MethodHandle AnimateWindow$handle() {
        return AnimateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags)
     * }
     */
    public static MemorySegment AnimateWindow$address() {
        return AnimateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags)
     * }
     */
    public static int AnimateWindow(MemorySegment hWnd, int dwTime, int dwFlags) {
        var mh$ = AnimateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimateWindow", hWnd, dwTime, dwFlags);
            }
            return (int)mh$.invokeExact(hWnd, dwTime, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateLayeredWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UpdateLayeredWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor UpdateLayeredWindow$descriptor() {
        return UpdateLayeredWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
     * }
     */
    public static MethodHandle UpdateLayeredWindow$handle() {
        return UpdateLayeredWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
     * }
     */
    public static MemorySegment UpdateLayeredWindow$address() {
        return UpdateLayeredWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
     * }
     */
    public static int UpdateLayeredWindow(MemorySegment hWnd, MemorySegment hdcDst, MemorySegment pptDst, MemorySegment psize, MemorySegment hdcSrc, MemorySegment pptSrc, int crKey, MemorySegment pblend, int dwFlags) {
        var mh$ = UpdateLayeredWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateLayeredWindow", hWnd, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags);
            }
            return (int)mh$.invokeExact(hWnd, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagUPDATELAYEREDWINDOWINFO {
     *     DWORD cbSize;
     *     HDC hdcDst;
     *     const POINT *pptDst;
     *     const SIZE *psize;
     *     HDC hdcSrc;
     *     const POINT *pptSrc;
     *     COLORREF crKey;
     *     const BLENDFUNCTION *pblend;
     *     DWORD dwFlags;
     *     const RECT *prcDirty;
     * } *PUPDATELAYEREDWINDOWINFO
     * }
     */
    public static final AddressLayout PUPDATELAYEREDWINDOWINFO = freeglut_h.C_POINTER;

    private static class UpdateLayeredWindowIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UpdateLayeredWindowIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO *pULWInfo)
     * }
     */
    public static FunctionDescriptor UpdateLayeredWindowIndirect$descriptor() {
        return UpdateLayeredWindowIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO *pULWInfo)
     * }
     */
    public static MethodHandle UpdateLayeredWindowIndirect$handle() {
        return UpdateLayeredWindowIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO *pULWInfo)
     * }
     */
    public static MemorySegment UpdateLayeredWindowIndirect$address() {
        return UpdateLayeredWindowIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO *pULWInfo)
     * }
     */
    public static int UpdateLayeredWindowIndirect(MemorySegment hWnd, MemorySegment pULWInfo) {
        var mh$ = UpdateLayeredWindowIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateLayeredWindowIndirect", hWnd, pULWInfo);
            }
            return (int)mh$.invokeExact(hWnd, pULWInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLayeredWindowAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLayeredWindowAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLayeredWindowAttributes(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor GetLayeredWindowAttributes$descriptor() {
        return GetLayeredWindowAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLayeredWindowAttributes(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle GetLayeredWindowAttributes$handle() {
        return GetLayeredWindowAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLayeredWindowAttributes(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment GetLayeredWindowAttributes$address() {
        return GetLayeredWindowAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLayeredWindowAttributes(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
     * }
     */
    public static int GetLayeredWindowAttributes(MemorySegment hwnd, MemorySegment pcrKey, MemorySegment pbAlpha, MemorySegment pdwFlags) {
        var mh$ = GetLayeredWindowAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLayeredWindowAttributes", hwnd, pcrKey, pbAlpha, pdwFlags);
            }
            return (int)mh$.invokeExact(hwnd, pcrKey, pbAlpha, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrintWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PrintWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)
     * }
     */
    public static FunctionDescriptor PrintWindow$descriptor() {
        return PrintWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)
     * }
     */
    public static MethodHandle PrintWindow$handle() {
        return PrintWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)
     * }
     */
    public static MemorySegment PrintWindow$address() {
        return PrintWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)
     * }
     */
    public static int PrintWindow(MemorySegment hwnd, MemorySegment hdcBlt, int nFlags) {
        var mh$ = PrintWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrintWindow", hwnd, hdcBlt, nFlags);
            }
            return (int)mh$.invokeExact(hwnd, hdcBlt, nFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLayeredWindowAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_CHAR,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetLayeredWindowAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetLayeredWindowAttributes$descriptor() {
        return SetLayeredWindowAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetLayeredWindowAttributes$handle() {
        return SetLayeredWindowAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetLayeredWindowAttributes$address() {
        return SetLayeredWindowAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
     * }
     */
    public static int SetLayeredWindowAttributes(MemorySegment hwnd, int crKey, byte bAlpha, int dwFlags) {
        var mh$ = SetLayeredWindowAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLayeredWindowAttributes", hwnd, crKey, bAlpha, dwFlags);
            }
            return (int)mh$.invokeExact(hwnd, crKey, bAlpha, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowWindowAsync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ShowWindowAsync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowWindowAsync(HWND hWnd, int nCmdShow)
     * }
     */
    public static FunctionDescriptor ShowWindowAsync$descriptor() {
        return ShowWindowAsync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowWindowAsync(HWND hWnd, int nCmdShow)
     * }
     */
    public static MethodHandle ShowWindowAsync$handle() {
        return ShowWindowAsync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ShowWindowAsync(HWND hWnd, int nCmdShow)
     * }
     */
    public static MemorySegment ShowWindowAsync$address() {
        return ShowWindowAsync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ShowWindowAsync(HWND hWnd, int nCmdShow)
     * }
     */
    public static int ShowWindowAsync(MemorySegment hWnd, int nCmdShow) {
        var mh$ = ShowWindowAsync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowWindowAsync", hWnd, nCmdShow);
            }
            return (int)mh$.invokeExact(hWnd, nCmdShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlashWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FlashWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlashWindow(HWND hWnd, BOOL bInvert)
     * }
     */
    public static FunctionDescriptor FlashWindow$descriptor() {
        return FlashWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlashWindow(HWND hWnd, BOOL bInvert)
     * }
     */
    public static MethodHandle FlashWindow$handle() {
        return FlashWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlashWindow(HWND hWnd, BOOL bInvert)
     * }
     */
    public static MemorySegment FlashWindow$address() {
        return FlashWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlashWindow(HWND hWnd, BOOL bInvert)
     * }
     */
    public static int FlashWindow(MemorySegment hWnd, int bInvert) {
        var mh$ = FlashWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlashWindow", hWnd, bInvert);
            }
            return (int)mh$.invokeExact(hWnd, bInvert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     UINT cbSize;
     *     HWND hwnd;
     *     DWORD dwFlags;
     *     UINT uCount;
     *     DWORD dwTimeout;
     * } *PFLASHWINFO
     * }
     */
    public static final AddressLayout PFLASHWINFO = freeglut_h.C_POINTER;

    private static class FlashWindowEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FlashWindowEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlashWindowEx(PFLASHWINFO pfwi)
     * }
     */
    public static FunctionDescriptor FlashWindowEx$descriptor() {
        return FlashWindowEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlashWindowEx(PFLASHWINFO pfwi)
     * }
     */
    public static MethodHandle FlashWindowEx$handle() {
        return FlashWindowEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlashWindowEx(PFLASHWINFO pfwi)
     * }
     */
    public static MemorySegment FlashWindowEx$address() {
        return FlashWindowEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlashWindowEx(PFLASHWINFO pfwi)
     * }
     */
    public static int FlashWindowEx(MemorySegment pfwi) {
        var mh$ = FlashWindowEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlashWindowEx", pfwi);
            }
            return (int)mh$.invokeExact(pfwi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowOwnedPopups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ShowOwnedPopups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowOwnedPopups(HWND hWnd, BOOL fShow)
     * }
     */
    public static FunctionDescriptor ShowOwnedPopups$descriptor() {
        return ShowOwnedPopups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowOwnedPopups(HWND hWnd, BOOL fShow)
     * }
     */
    public static MethodHandle ShowOwnedPopups$handle() {
        return ShowOwnedPopups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ShowOwnedPopups(HWND hWnd, BOOL fShow)
     * }
     */
    public static MemorySegment ShowOwnedPopups$address() {
        return ShowOwnedPopups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ShowOwnedPopups(HWND hWnd, BOOL fShow)
     * }
     */
    public static int ShowOwnedPopups(MemorySegment hWnd, int fShow) {
        var mh$ = ShowOwnedPopups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowOwnedPopups", hWnd, fShow);
            }
            return (int)mh$.invokeExact(hWnd, fShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenIcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenIcon(HWND hWnd)
     * }
     */
    public static FunctionDescriptor OpenIcon$descriptor() {
        return OpenIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenIcon(HWND hWnd)
     * }
     */
    public static MethodHandle OpenIcon$handle() {
        return OpenIcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OpenIcon(HWND hWnd)
     * }
     */
    public static MemorySegment OpenIcon$address() {
        return OpenIcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OpenIcon(HWND hWnd)
     * }
     */
    public static int OpenIcon(MemorySegment hWnd) {
        var mh$ = OpenIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenIcon", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor CloseWindow$descriptor() {
        return CloseWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseWindow(HWND hWnd)
     * }
     */
    public static MethodHandle CloseWindow$handle() {
        return CloseWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseWindow(HWND hWnd)
     * }
     */
    public static MemorySegment CloseWindow$address() {
        return CloseWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseWindow(HWND hWnd)
     * }
     */
    public static int CloseWindow(MemorySegment hWnd) {
        var mh$ = CloseWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MoveWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
     * }
     */
    public static FunctionDescriptor MoveWindow$descriptor() {
        return MoveWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
     * }
     */
    public static MethodHandle MoveWindow$handle() {
        return MoveWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
     * }
     */
    public static MemorySegment MoveWindow$address() {
        return MoveWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
     * }
     */
    public static int MoveWindow(MemorySegment hWnd, int X, int Y, int nWidth, int nHeight, int bRepaint) {
        var mh$ = MoveWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveWindow", hWnd, X, Y, nWidth, nHeight, bRepaint);
            }
            return (int)mh$.invokeExact(hWnd, X, Y, nWidth, nHeight, bRepaint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor SetWindowPos$descriptor() {
        return SetWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle SetWindowPos$handle() {
        return SetWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MemorySegment SetWindowPos$address() {
        return SetWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
     * }
     */
    public static int SetWindowPos(MemorySegment hWnd, MemorySegment hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags) {
        var mh$ = SetWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowPos", hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
            }
            return (int)mh$.invokeExact(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowPlacement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowPlacement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static FunctionDescriptor GetWindowPlacement$descriptor() {
        return GetWindowPlacement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static MethodHandle GetWindowPlacement$handle() {
        return GetWindowPlacement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static MemorySegment GetWindowPlacement$address() {
        return GetWindowPlacement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static int GetWindowPlacement(MemorySegment hWnd, MemorySegment lpwndpl) {
        var mh$ = GetWindowPlacement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowPlacement", hWnd, lpwndpl);
            }
            return (int)mh$.invokeExact(hWnd, lpwndpl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowPlacement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowPlacement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static FunctionDescriptor SetWindowPlacement$descriptor() {
        return SetWindowPlacement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static MethodHandle SetWindowPlacement$handle() {
        return SetWindowPlacement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static MemorySegment SetWindowPlacement$address() {
        return SetWindowPlacement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static int SetWindowPlacement(MemorySegment hWnd, MemorySegment lpwndpl) {
        var mh$ = SetWindowPlacement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowPlacement", hWnd, lpwndpl);
            }
            return (int)mh$.invokeExact(hWnd, lpwndpl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowDisplayAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowDisplayAffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowDisplayAffinity(HWND hWnd, DWORD *pdwAffinity)
     * }
     */
    public static FunctionDescriptor GetWindowDisplayAffinity$descriptor() {
        return GetWindowDisplayAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowDisplayAffinity(HWND hWnd, DWORD *pdwAffinity)
     * }
     */
    public static MethodHandle GetWindowDisplayAffinity$handle() {
        return GetWindowDisplayAffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowDisplayAffinity(HWND hWnd, DWORD *pdwAffinity)
     * }
     */
    public static MemorySegment GetWindowDisplayAffinity$address() {
        return GetWindowDisplayAffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowDisplayAffinity(HWND hWnd, DWORD *pdwAffinity)
     * }
     */
    public static int GetWindowDisplayAffinity(MemorySegment hWnd, MemorySegment pdwAffinity) {
        var mh$ = GetWindowDisplayAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowDisplayAffinity", hWnd, pdwAffinity);
            }
            return (int)mh$.invokeExact(hWnd, pdwAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowDisplayAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowDisplayAffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity)
     * }
     */
    public static FunctionDescriptor SetWindowDisplayAffinity$descriptor() {
        return SetWindowDisplayAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity)
     * }
     */
    public static MethodHandle SetWindowDisplayAffinity$handle() {
        return SetWindowDisplayAffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity)
     * }
     */
    public static MemorySegment SetWindowDisplayAffinity$address() {
        return SetWindowDisplayAffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity)
     * }
     */
    public static int SetWindowDisplayAffinity(MemorySegment hWnd, int dwAffinity) {
        var mh$ = SetWindowDisplayAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowDisplayAffinity", hWnd, dwAffinity);
            }
            return (int)mh$.invokeExact(hWnd, dwAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginDeferWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BeginDeferWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDWP BeginDeferWindowPos(int nNumWindows)
     * }
     */
    public static FunctionDescriptor BeginDeferWindowPos$descriptor() {
        return BeginDeferWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDWP BeginDeferWindowPos(int nNumWindows)
     * }
     */
    public static MethodHandle BeginDeferWindowPos$handle() {
        return BeginDeferWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDWP BeginDeferWindowPos(int nNumWindows)
     * }
     */
    public static MemorySegment BeginDeferWindowPos$address() {
        return BeginDeferWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDWP BeginDeferWindowPos(int nNumWindows)
     * }
     */
    public static MemorySegment BeginDeferWindowPos(int nNumWindows) {
        var mh$ = BeginDeferWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginDeferWindowPos", nNumWindows);
            }
            return (MemorySegment)mh$.invokeExact(nNumWindows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeferWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeferWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DeferWindowPos$descriptor() {
        return DeferWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle DeferWindowPos$handle() {
        return DeferWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MemorySegment DeferWindowPos$address() {
        return DeferWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MemorySegment DeferWindowPos(MemorySegment hWinPosInfo, MemorySegment hWnd, MemorySegment hWndInsertAfter, int x, int y, int cx, int cy, int uFlags) {
        var mh$ = DeferWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeferWindowPos", hWinPosInfo, hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
            }
            return (MemorySegment)mh$.invokeExact(hWinPosInfo, hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDeferWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EndDeferWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndDeferWindowPos(HDWP hWinPosInfo)
     * }
     */
    public static FunctionDescriptor EndDeferWindowPos$descriptor() {
        return EndDeferWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndDeferWindowPos(HDWP hWinPosInfo)
     * }
     */
    public static MethodHandle EndDeferWindowPos$handle() {
        return EndDeferWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndDeferWindowPos(HDWP hWinPosInfo)
     * }
     */
    public static MemorySegment EndDeferWindowPos$address() {
        return EndDeferWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndDeferWindowPos(HDWP hWinPosInfo)
     * }
     */
    public static int EndDeferWindowPos(MemorySegment hWinPosInfo) {
        var mh$ = EndDeferWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDeferWindowPos", hWinPosInfo);
            }
            return (int)mh$.invokeExact(hWinPosInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsWindowVisible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindowVisible(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindowVisible$descriptor() {
        return IsWindowVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindowVisible(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindowVisible$handle() {
        return IsWindowVisible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWindowVisible(HWND hWnd)
     * }
     */
    public static MemorySegment IsWindowVisible$address() {
        return IsWindowVisible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWindowVisible(HWND hWnd)
     * }
     */
    public static int IsWindowVisible(MemorySegment hWnd) {
        var mh$ = IsWindowVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowVisible", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsIconic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsIconic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsIconic(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsIconic$descriptor() {
        return IsIconic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsIconic(HWND hWnd)
     * }
     */
    public static MethodHandle IsIconic$handle() {
        return IsIconic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsIconic(HWND hWnd)
     * }
     */
    public static MemorySegment IsIconic$address() {
        return IsIconic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsIconic(HWND hWnd)
     * }
     */
    public static int IsIconic(MemorySegment hWnd) {
        var mh$ = IsIconic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsIconic", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnyPopup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AnyPopup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AnyPopup()
     * }
     */
    public static FunctionDescriptor AnyPopup$descriptor() {
        return AnyPopup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AnyPopup()
     * }
     */
    public static MethodHandle AnyPopup$handle() {
        return AnyPopup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AnyPopup()
     * }
     */
    public static MemorySegment AnyPopup$address() {
        return AnyPopup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AnyPopup()
     * }
     */
    public static int AnyPopup() {
        var mh$ = AnyPopup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnyPopup");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BringWindowToTop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BringWindowToTop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BringWindowToTop(HWND hWnd)
     * }
     */
    public static FunctionDescriptor BringWindowToTop$descriptor() {
        return BringWindowToTop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BringWindowToTop(HWND hWnd)
     * }
     */
    public static MethodHandle BringWindowToTop$handle() {
        return BringWindowToTop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BringWindowToTop(HWND hWnd)
     * }
     */
    public static MemorySegment BringWindowToTop$address() {
        return BringWindowToTop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BringWindowToTop(HWND hWnd)
     * }
     */
    public static int BringWindowToTop(MemorySegment hWnd) {
        var mh$ = BringWindowToTop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BringWindowToTop", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsZoomed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsZoomed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsZoomed(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsZoomed$descriptor() {
        return IsZoomed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsZoomed(HWND hWnd)
     * }
     */
    public static MethodHandle IsZoomed$handle() {
        return IsZoomed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsZoomed(HWND hWnd)
     * }
     */
    public static MemorySegment IsZoomed$address() {
        return IsZoomed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsZoomed(HWND hWnd)
     * }
     */
    public static int IsZoomed(MemorySegment hWnd) {
        var mh$ = IsZoomed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsZoomed", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef DLGTEMPLATE *LPDLGTEMPLATEA
     * }
     */
    public static final AddressLayout LPDLGTEMPLATEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGTEMPLATE *LPDLGTEMPLATEW
     * }
     */
    public static final AddressLayout LPDLGTEMPLATEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDLGTEMPLATEA LPDLGTEMPLATE
     * }
     */
    public static final AddressLayout LPDLGTEMPLATE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const DLGTEMPLATE *LPCDLGTEMPLATEA
     * }
     */
    public static final AddressLayout LPCDLGTEMPLATEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const DLGTEMPLATE *LPCDLGTEMPLATEW
     * }
     */
    public static final AddressLayout LPCDLGTEMPLATEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE
     * }
     */
    public static final AddressLayout LPCDLGTEMPLATE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA
     * }
     */
    public static final AddressLayout PDLGITEMTEMPLATEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW
     * }
     */
    public static final AddressLayout PDLGITEMTEMPLATEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE
     * }
     */
    public static final AddressLayout PDLGITEMTEMPLATE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA
     * }
     */
    public static final AddressLayout LPDLGITEMTEMPLATEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW
     * }
     */
    public static final AddressLayout LPDLGITEMTEMPLATEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE
     * }
     */
    public static final AddressLayout LPDLGITEMTEMPLATE = freeglut_h.C_POINTER;

    private static class CreateDialogParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDialogParamA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogParamA$descriptor() {
        return CreateDialogParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogParamA$handle() {
        return CreateDialogParamA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogParamA$address() {
        return CreateDialogParamA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogParamA(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogParamA", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDialogParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDialogParamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogParamW$descriptor() {
        return CreateDialogParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogParamW$handle() {
        return CreateDialogParamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogParamW$address() {
        return CreateDialogParamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogParamW(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogParamW", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDialogIndirectParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDialogIndirectParamA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogIndirectParamA$descriptor() {
        return CreateDialogIndirectParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogIndirectParamA$handle() {
        return CreateDialogIndirectParamA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogIndirectParamA$address() {
        return CreateDialogIndirectParamA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogIndirectParamA(MemorySegment hInstance, MemorySegment lpTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogIndirectParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogIndirectParamA", hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDialogIndirectParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDialogIndirectParamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogIndirectParamW$descriptor() {
        return CreateDialogIndirectParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogIndirectParamW$handle() {
        return CreateDialogIndirectParamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogIndirectParamW$address() {
        return CreateDialogIndirectParamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogIndirectParamW(MemorySegment hInstance, MemorySegment lpTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogIndirectParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogIndirectParamW", hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DialogBoxParamA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxParamA$descriptor() {
        return DialogBoxParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxParamA$handle() {
        return DialogBoxParamA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment DialogBoxParamA$address() {
        return DialogBoxParamA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxParamA(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxParamA", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DialogBoxParamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxParamW$descriptor() {
        return DialogBoxParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxParamW$handle() {
        return DialogBoxParamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment DialogBoxParamW$address() {
        return DialogBoxParamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxParamW(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxParamW", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxIndirectParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DialogBoxIndirectParamA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxIndirectParamA$descriptor() {
        return DialogBoxIndirectParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxIndirectParamA$handle() {
        return DialogBoxIndirectParamA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment DialogBoxIndirectParamA$address() {
        return DialogBoxIndirectParamA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxIndirectParamA(MemorySegment hInstance, MemorySegment hDialogTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxIndirectParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxIndirectParamA", hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxIndirectParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DialogBoxIndirectParamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxIndirectParamW$descriptor() {
        return DialogBoxIndirectParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxIndirectParamW$handle() {
        return DialogBoxIndirectParamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment DialogBoxIndirectParamW$address() {
        return DialogBoxIndirectParamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxIndirectParamW(MemorySegment hInstance, MemorySegment hDialogTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxIndirectParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxIndirectParamW", hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EndDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndDialog(HWND hDlg, INT_PTR nResult)
     * }
     */
    public static FunctionDescriptor EndDialog$descriptor() {
        return EndDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndDialog(HWND hDlg, INT_PTR nResult)
     * }
     */
    public static MethodHandle EndDialog$handle() {
        return EndDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndDialog(HWND hDlg, INT_PTR nResult)
     * }
     */
    public static MemorySegment EndDialog$address() {
        return EndDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndDialog(HWND hDlg, INT_PTR nResult)
     * }
     */
    public static int EndDialog(MemorySegment hDlg, long nResult) {
        var mh$ = EndDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDialog", hDlg, nResult);
            }
            return (int)mh$.invokeExact(hDlg, nResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDlgItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetDlgItem(HWND hDlg, int nIDDlgItem)
     * }
     */
    public static FunctionDescriptor GetDlgItem$descriptor() {
        return GetDlgItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetDlgItem(HWND hDlg, int nIDDlgItem)
     * }
     */
    public static MethodHandle GetDlgItem$handle() {
        return GetDlgItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetDlgItem(HWND hDlg, int nIDDlgItem)
     * }
     */
    public static MemorySegment GetDlgItem$address() {
        return GetDlgItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetDlgItem(HWND hDlg, int nIDDlgItem)
     * }
     */
    public static MemorySegment GetDlgItem(MemorySegment hDlg, int nIDDlgItem) {
        var mh$ = GetDlgItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItem", hDlg, nIDDlgItem);
            }
            return (MemorySegment)mh$.invokeExact(hDlg, nIDDlgItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDlgItemInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDlgItemInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
     * }
     */
    public static FunctionDescriptor SetDlgItemInt$descriptor() {
        return SetDlgItemInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
     * }
     */
    public static MethodHandle SetDlgItemInt$handle() {
        return SetDlgItemInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
     * }
     */
    public static MemorySegment SetDlgItemInt$address() {
        return SetDlgItemInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
     * }
     */
    public static int SetDlgItemInt(MemorySegment hDlg, int nIDDlgItem, int uValue, int bSigned) {
        var mh$ = SetDlgItemInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDlgItemInt", hDlg, nIDDlgItem, uValue, bSigned);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, uValue, bSigned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItemInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDlgItemInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
     * }
     */
    public static FunctionDescriptor GetDlgItemInt$descriptor() {
        return GetDlgItemInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
     * }
     */
    public static MethodHandle GetDlgItemInt$handle() {
        return GetDlgItemInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
     * }
     */
    public static MemorySegment GetDlgItemInt$address() {
        return GetDlgItemInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
     * }
     */
    public static int GetDlgItemInt(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpTranslated, int bSigned) {
        var mh$ = GetDlgItemInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItemInt", hDlg, nIDDlgItem, lpTranslated, bSigned);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpTranslated, bSigned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDlgItemTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDlgItemTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor SetDlgItemTextA$descriptor() {
        return SetDlgItemTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString)
     * }
     */
    public static MethodHandle SetDlgItemTextA$handle() {
        return SetDlgItemTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString)
     * }
     */
    public static MemorySegment SetDlgItemTextA$address() {
        return SetDlgItemTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString)
     * }
     */
    public static int SetDlgItemTextA(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString) {
        var mh$ = SetDlgItemTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDlgItemTextA", hDlg, nIDDlgItem, lpString);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDlgItemTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDlgItemTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor SetDlgItemTextW$descriptor() {
        return SetDlgItemTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
     * }
     */
    public static MethodHandle SetDlgItemTextW$handle() {
        return SetDlgItemTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
     * }
     */
    public static MemorySegment SetDlgItemTextW$address() {
        return SetDlgItemTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
     * }
     */
    public static int SetDlgItemTextW(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString) {
        var mh$ = SetDlgItemTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDlgItemTextW", hDlg, nIDDlgItem, lpString);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItemTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDlgItemTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax)
     * }
     */
    public static FunctionDescriptor GetDlgItemTextA$descriptor() {
        return GetDlgItemTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax)
     * }
     */
    public static MethodHandle GetDlgItemTextA$handle() {
        return GetDlgItemTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax)
     * }
     */
    public static MemorySegment GetDlgItemTextA$address() {
        return GetDlgItemTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax)
     * }
     */
    public static int GetDlgItemTextA(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString, int cchMax) {
        var mh$ = GetDlgItemTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItemTextA", hDlg, nIDDlgItem, lpString, cchMax);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString, cchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItemTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDlgItemTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
     * }
     */
    public static FunctionDescriptor GetDlgItemTextW$descriptor() {
        return GetDlgItemTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
     * }
     */
    public static MethodHandle GetDlgItemTextW$handle() {
        return GetDlgItemTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
     * }
     */
    public static MemorySegment GetDlgItemTextW$address() {
        return GetDlgItemTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
     * }
     */
    public static int GetDlgItemTextW(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString, int cchMax) {
        var mh$ = GetDlgItemTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItemTextW", hDlg, nIDDlgItem, lpString, cchMax);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString, cchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckDlgButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckDlgButton");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck)
     * }
     */
    public static FunctionDescriptor CheckDlgButton$descriptor() {
        return CheckDlgButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck)
     * }
     */
    public static MethodHandle CheckDlgButton$handle() {
        return CheckDlgButton.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck)
     * }
     */
    public static MemorySegment CheckDlgButton$address() {
        return CheckDlgButton.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck)
     * }
     */
    public static int CheckDlgButton(MemorySegment hDlg, int nIDButton, int uCheck) {
        var mh$ = CheckDlgButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckDlgButton", hDlg, nIDButton, uCheck);
            }
            return (int)mh$.invokeExact(hDlg, nIDButton, uCheck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckRadioButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckRadioButton");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
     * }
     */
    public static FunctionDescriptor CheckRadioButton$descriptor() {
        return CheckRadioButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
     * }
     */
    public static MethodHandle CheckRadioButton$handle() {
        return CheckRadioButton.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
     * }
     */
    public static MemorySegment CheckRadioButton$address() {
        return CheckRadioButton.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
     * }
     */
    public static int CheckRadioButton(MemorySegment hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton) {
        var mh$ = CheckRadioButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckRadioButton", hDlg, nIDFirstButton, nIDLastButton, nIDCheckButton);
            }
            return (int)mh$.invokeExact(hDlg, nIDFirstButton, nIDLastButton, nIDCheckButton);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDlgButtonChecked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsDlgButtonChecked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT IsDlgButtonChecked(HWND hDlg, int nIDButton)
     * }
     */
    public static FunctionDescriptor IsDlgButtonChecked$descriptor() {
        return IsDlgButtonChecked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT IsDlgButtonChecked(HWND hDlg, int nIDButton)
     * }
     */
    public static MethodHandle IsDlgButtonChecked$handle() {
        return IsDlgButtonChecked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT IsDlgButtonChecked(HWND hDlg, int nIDButton)
     * }
     */
    public static MemorySegment IsDlgButtonChecked$address() {
        return IsDlgButtonChecked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT IsDlgButtonChecked(HWND hDlg, int nIDButton)
     * }
     */
    public static int IsDlgButtonChecked(MemorySegment hDlg, int nIDButton) {
        var mh$ = IsDlgButtonChecked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDlgButtonChecked", hDlg, nIDButton);
            }
            return (int)mh$.invokeExact(hDlg, nIDButton);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendDlgItemMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SendDlgItemMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendDlgItemMessageA$descriptor() {
        return SendDlgItemMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendDlgItemMessageA$handle() {
        return SendDlgItemMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendDlgItemMessageA$address() {
        return SendDlgItemMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendDlgItemMessageA(MemorySegment hDlg, int nIDDlgItem, int Msg, long wParam, long lParam) {
        var mh$ = SendDlgItemMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendDlgItemMessageA", hDlg, nIDDlgItem, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, nIDDlgItem, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendDlgItemMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SendDlgItemMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendDlgItemMessageW$descriptor() {
        return SendDlgItemMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendDlgItemMessageW$handle() {
        return SendDlgItemMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendDlgItemMessageW$address() {
        return SendDlgItemMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendDlgItemMessageW(MemorySegment hDlg, int nIDDlgItem, int Msg, long wParam, long lParam) {
        var mh$ = SendDlgItemMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendDlgItemMessageW", hDlg, nIDDlgItem, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, nIDDlgItem, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNextDlgGroupItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNextDlgGroupItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static FunctionDescriptor GetNextDlgGroupItem$descriptor() {
        return GetNextDlgGroupItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MethodHandle GetNextDlgGroupItem$handle() {
        return GetNextDlgGroupItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MemorySegment GetNextDlgGroupItem$address() {
        return GetNextDlgGroupItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MemorySegment GetNextDlgGroupItem(MemorySegment hDlg, MemorySegment hCtl, int bPrevious) {
        var mh$ = GetNextDlgGroupItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNextDlgGroupItem", hDlg, hCtl, bPrevious);
            }
            return (MemorySegment)mh$.invokeExact(hDlg, hCtl, bPrevious);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNextDlgTabItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNextDlgTabItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static FunctionDescriptor GetNextDlgTabItem$descriptor() {
        return GetNextDlgTabItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MethodHandle GetNextDlgTabItem$handle() {
        return GetNextDlgTabItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MemorySegment GetNextDlgTabItem$address() {
        return GetNextDlgTabItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MemorySegment GetNextDlgTabItem(MemorySegment hDlg, MemorySegment hCtl, int bPrevious) {
        var mh$ = GetNextDlgTabItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNextDlgTabItem", hDlg, hCtl, bPrevious);
            }
            return (MemorySegment)mh$.invokeExact(hDlg, hCtl, bPrevious);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgCtrlID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDlgCtrlID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDlgCtrlID(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetDlgCtrlID$descriptor() {
        return GetDlgCtrlID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDlgCtrlID(HWND hWnd)
     * }
     */
    public static MethodHandle GetDlgCtrlID$handle() {
        return GetDlgCtrlID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDlgCtrlID(HWND hWnd)
     * }
     */
    public static MemorySegment GetDlgCtrlID$address() {
        return GetDlgCtrlID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDlgCtrlID(HWND hWnd)
     * }
     */
    public static int GetDlgCtrlID(MemorySegment hWnd) {
        var mh$ = GetDlgCtrlID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgCtrlID", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDialogBaseUnits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDialogBaseUnits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long GetDialogBaseUnits()
     * }
     */
    public static FunctionDescriptor GetDialogBaseUnits$descriptor() {
        return GetDialogBaseUnits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long GetDialogBaseUnits()
     * }
     */
    public static MethodHandle GetDialogBaseUnits$handle() {
        return GetDialogBaseUnits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long GetDialogBaseUnits()
     * }
     */
    public static MemorySegment GetDialogBaseUnits$address() {
        return GetDialogBaseUnits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long GetDialogBaseUnits()
     * }
     */
    public static int GetDialogBaseUnits() {
        var mh$ = GetDialogBaseUnits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDialogBaseUnits");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefDlgProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DefDlgProcA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefDlgProcA$descriptor() {
        return DefDlgProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefDlgProcA$handle() {
        return DefDlgProcA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefDlgProcA$address() {
        return DefDlgProcA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefDlgProcA(MemorySegment hDlg, int Msg, long wParam, long lParam) {
        var mh$ = DefDlgProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefDlgProcA", hDlg, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefDlgProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DefDlgProcW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefDlgProcW$descriptor() {
        return DefDlgProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefDlgProcW$handle() {
        return DefDlgProcW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefDlgProcW$address() {
        return DefDlgProcW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefDlgProcW(MemorySegment hDlg, int Msg, long wParam, long lParam) {
        var mh$ = DefDlgProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefDlgProcW", hDlg, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int DCDC_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DEFAULT = 0
     * }
     */
    public static int DCDC_DEFAULT() {
        return DCDC_DEFAULT;
    }
    private static final int DCDC_DISABLE_FONT_UPDATE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_FONT_UPDATE = 1
     * }
     */
    public static int DCDC_DISABLE_FONT_UPDATE() {
        return DCDC_DISABLE_FONT_UPDATE;
    }
    private static final int DCDC_DISABLE_RELAYOUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_RELAYOUT = 2
     * }
     */
    public static int DCDC_DISABLE_RELAYOUT() {
        return DCDC_DISABLE_RELAYOUT;
    }

    private static class SetDialogControlDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDialogControlDpiChangeBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDialogControlDpiChangeBehavior(HWND hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static FunctionDescriptor SetDialogControlDpiChangeBehavior$descriptor() {
        return SetDialogControlDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDialogControlDpiChangeBehavior(HWND hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static MethodHandle SetDialogControlDpiChangeBehavior$handle() {
        return SetDialogControlDpiChangeBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDialogControlDpiChangeBehavior(HWND hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static MemorySegment SetDialogControlDpiChangeBehavior$address() {
        return SetDialogControlDpiChangeBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDialogControlDpiChangeBehavior(HWND hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static int SetDialogControlDpiChangeBehavior(MemorySegment hWnd, int mask, int values) {
        var mh$ = SetDialogControlDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDialogControlDpiChangeBehavior", hWnd, mask, values);
            }
            return (int)mh$.invokeExact(hWnd, mask, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDialogControlDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDialogControlDpiChangeBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetDialogControlDpiChangeBehavior$descriptor() {
        return GetDialogControlDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(HWND hWnd)
     * }
     */
    public static MethodHandle GetDialogControlDpiChangeBehavior$handle() {
        return GetDialogControlDpiChangeBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(HWND hWnd)
     * }
     */
    public static MemorySegment GetDialogControlDpiChangeBehavior$address() {
        return GetDialogControlDpiChangeBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(HWND hWnd)
     * }
     */
    public static int GetDialogControlDpiChangeBehavior(MemorySegment hWnd) {
        var mh$ = GetDialogControlDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDialogControlDpiChangeBehavior", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int DDC_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DEFAULT = 0
     * }
     */
    public static int DDC_DEFAULT() {
        return DDC_DEFAULT;
    }
    private static final int DDC_DISABLE_ALL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_ALL = 1
     * }
     */
    public static int DDC_DISABLE_ALL() {
        return DDC_DISABLE_ALL;
    }
    private static final int DDC_DISABLE_RESIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_RESIZE = 2
     * }
     */
    public static int DDC_DISABLE_RESIZE() {
        return DDC_DISABLE_RESIZE;
    }
    private static final int DDC_DISABLE_CONTROL_RELAYOUT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_CONTROL_RELAYOUT = 4
     * }
     */
    public static int DDC_DISABLE_CONTROL_RELAYOUT() {
        return DDC_DISABLE_CONTROL_RELAYOUT;
    }

    private static class SetDialogDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDialogDpiChangeBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static FunctionDescriptor SetDialogDpiChangeBehavior$descriptor() {
        return SetDialogDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static MethodHandle SetDialogDpiChangeBehavior$handle() {
        return SetDialogDpiChangeBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static MemorySegment SetDialogDpiChangeBehavior$address() {
        return SetDialogDpiChangeBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static int SetDialogDpiChangeBehavior(MemorySegment hDlg, int mask, int values) {
        var mh$ = SetDialogDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDialogDpiChangeBehavior", hDlg, mask, values);
            }
            return (int)mh$.invokeExact(hDlg, mask, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDialogDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDialogDpiChangeBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(HWND hDlg)
     * }
     */
    public static FunctionDescriptor GetDialogDpiChangeBehavior$descriptor() {
        return GetDialogDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(HWND hDlg)
     * }
     */
    public static MethodHandle GetDialogDpiChangeBehavior$handle() {
        return GetDialogDpiChangeBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(HWND hDlg)
     * }
     */
    public static MemorySegment GetDialogDpiChangeBehavior$address() {
        return GetDialogDpiChangeBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(HWND hDlg)
     * }
     */
    public static int GetDialogDpiChangeBehavior(MemorySegment hDlg) {
        var mh$ = GetDialogDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDialogDpiChangeBehavior", hDlg);
            }
            return (int)mh$.invokeExact(hDlg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallMsgFilterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CallMsgFilterA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterA(LPMSG lpMsg, int nCode)
     * }
     */
    public static FunctionDescriptor CallMsgFilterA$descriptor() {
        return CallMsgFilterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterA(LPMSG lpMsg, int nCode)
     * }
     */
    public static MethodHandle CallMsgFilterA$handle() {
        return CallMsgFilterA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterA(LPMSG lpMsg, int nCode)
     * }
     */
    public static MemorySegment CallMsgFilterA$address() {
        return CallMsgFilterA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallMsgFilterA(LPMSG lpMsg, int nCode)
     * }
     */
    public static int CallMsgFilterA(MemorySegment lpMsg, int nCode) {
        var mh$ = CallMsgFilterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallMsgFilterA", lpMsg, nCode);
            }
            return (int)mh$.invokeExact(lpMsg, nCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallMsgFilterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CallMsgFilterW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterW(LPMSG lpMsg, int nCode)
     * }
     */
    public static FunctionDescriptor CallMsgFilterW$descriptor() {
        return CallMsgFilterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterW(LPMSG lpMsg, int nCode)
     * }
     */
    public static MethodHandle CallMsgFilterW$handle() {
        return CallMsgFilterW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterW(LPMSG lpMsg, int nCode)
     * }
     */
    public static MemorySegment CallMsgFilterW$address() {
        return CallMsgFilterW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallMsgFilterW(LPMSG lpMsg, int nCode)
     * }
     */
    public static int CallMsgFilterW(MemorySegment lpMsg, int nCode) {
        var mh$ = CallMsgFilterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallMsgFilterW", lpMsg, nCode);
            }
            return (int)mh$.invokeExact(lpMsg, nCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenClipboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenClipboard(HWND hWndNewOwner)
     * }
     */
    public static FunctionDescriptor OpenClipboard$descriptor() {
        return OpenClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenClipboard(HWND hWndNewOwner)
     * }
     */
    public static MethodHandle OpenClipboard$handle() {
        return OpenClipboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OpenClipboard(HWND hWndNewOwner)
     * }
     */
    public static MemorySegment OpenClipboard$address() {
        return OpenClipboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OpenClipboard(HWND hWndNewOwner)
     * }
     */
    public static int OpenClipboard(MemorySegment hWndNewOwner) {
        var mh$ = OpenClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenClipboard", hWndNewOwner);
            }
            return (int)mh$.invokeExact(hWndNewOwner);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseClipboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseClipboard()
     * }
     */
    public static FunctionDescriptor CloseClipboard$descriptor() {
        return CloseClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseClipboard()
     * }
     */
    public static MethodHandle CloseClipboard$handle() {
        return CloseClipboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseClipboard()
     * }
     */
    public static MemorySegment CloseClipboard$address() {
        return CloseClipboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseClipboard()
     * }
     */
    public static int CloseClipboard() {
        var mh$ = CloseClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseClipboard");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardSequenceNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClipboardSequenceNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetClipboardSequenceNumber()
     * }
     */
    public static FunctionDescriptor GetClipboardSequenceNumber$descriptor() {
        return GetClipboardSequenceNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetClipboardSequenceNumber()
     * }
     */
    public static MethodHandle GetClipboardSequenceNumber$handle() {
        return GetClipboardSequenceNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetClipboardSequenceNumber()
     * }
     */
    public static MemorySegment GetClipboardSequenceNumber$address() {
        return GetClipboardSequenceNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetClipboardSequenceNumber()
     * }
     */
    public static int GetClipboardSequenceNumber() {
        var mh$ = GetClipboardSequenceNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardSequenceNumber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardOwner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClipboardOwner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetClipboardOwner()
     * }
     */
    public static FunctionDescriptor GetClipboardOwner$descriptor() {
        return GetClipboardOwner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetClipboardOwner()
     * }
     */
    public static MethodHandle GetClipboardOwner$handle() {
        return GetClipboardOwner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetClipboardOwner()
     * }
     */
    public static MemorySegment GetClipboardOwner$address() {
        return GetClipboardOwner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetClipboardOwner()
     * }
     */
    public static MemorySegment GetClipboardOwner() {
        var mh$ = GetClipboardOwner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardOwner");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClipboardViewer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetClipboardViewer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetClipboardViewer(HWND hWndNewViewer)
     * }
     */
    public static FunctionDescriptor SetClipboardViewer$descriptor() {
        return SetClipboardViewer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetClipboardViewer(HWND hWndNewViewer)
     * }
     */
    public static MethodHandle SetClipboardViewer$handle() {
        return SetClipboardViewer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND SetClipboardViewer(HWND hWndNewViewer)
     * }
     */
    public static MemorySegment SetClipboardViewer$address() {
        return SetClipboardViewer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND SetClipboardViewer(HWND hWndNewViewer)
     * }
     */
    public static MemorySegment SetClipboardViewer(MemorySegment hWndNewViewer) {
        var mh$ = SetClipboardViewer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClipboardViewer", hWndNewViewer);
            }
            return (MemorySegment)mh$.invokeExact(hWndNewViewer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardViewer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClipboardViewer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetClipboardViewer()
     * }
     */
    public static FunctionDescriptor GetClipboardViewer$descriptor() {
        return GetClipboardViewer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetClipboardViewer()
     * }
     */
    public static MethodHandle GetClipboardViewer$handle() {
        return GetClipboardViewer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetClipboardViewer()
     * }
     */
    public static MemorySegment GetClipboardViewer$address() {
        return GetClipboardViewer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetClipboardViewer()
     * }
     */
    public static MemorySegment GetClipboardViewer() {
        var mh$ = GetClipboardViewer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardViewer");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeClipboardChain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeClipboardChain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
     * }
     */
    public static FunctionDescriptor ChangeClipboardChain$descriptor() {
        return ChangeClipboardChain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
     * }
     */
    public static MethodHandle ChangeClipboardChain$handle() {
        return ChangeClipboardChain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
     * }
     */
    public static MemorySegment ChangeClipboardChain$address() {
        return ChangeClipboardChain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
     * }
     */
    public static int ChangeClipboardChain(MemorySegment hWndRemove, MemorySegment hWndNewNext) {
        var mh$ = ChangeClipboardChain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeClipboardChain", hWndRemove, hWndNewNext);
            }
            return (int)mh$.invokeExact(hWndRemove, hWndNewNext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClipboardData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetClipboardData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE SetClipboardData(UINT uFormat, HANDLE hMem)
     * }
     */
    public static FunctionDescriptor SetClipboardData$descriptor() {
        return SetClipboardData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE SetClipboardData(UINT uFormat, HANDLE hMem)
     * }
     */
    public static MethodHandle SetClipboardData$handle() {
        return SetClipboardData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE SetClipboardData(UINT uFormat, HANDLE hMem)
     * }
     */
    public static MemorySegment SetClipboardData$address() {
        return SetClipboardData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE SetClipboardData(UINT uFormat, HANDLE hMem)
     * }
     */
    public static MemorySegment SetClipboardData(int uFormat, MemorySegment hMem) {
        var mh$ = SetClipboardData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClipboardData", uFormat, hMem);
            }
            return (MemorySegment)mh$.invokeExact(uFormat, hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClipboardData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetClipboardData(UINT uFormat)
     * }
     */
    public static FunctionDescriptor GetClipboardData$descriptor() {
        return GetClipboardData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetClipboardData(UINT uFormat)
     * }
     */
    public static MethodHandle GetClipboardData$handle() {
        return GetClipboardData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetClipboardData(UINT uFormat)
     * }
     */
    public static MemorySegment GetClipboardData$address() {
        return GetClipboardData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetClipboardData(UINT uFormat)
     * }
     */
    public static MemorySegment GetClipboardData(int uFormat) {
        var mh$ = GetClipboardData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardData", uFormat);
            }
            return (MemorySegment)mh$.invokeExact(uFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClipboardFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterClipboardFormatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatA(LPCSTR lpszFormat)
     * }
     */
    public static FunctionDescriptor RegisterClipboardFormatA$descriptor() {
        return RegisterClipboardFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatA(LPCSTR lpszFormat)
     * }
     */
    public static MethodHandle RegisterClipboardFormatA$handle() {
        return RegisterClipboardFormatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatA(LPCSTR lpszFormat)
     * }
     */
    public static MemorySegment RegisterClipboardFormatA$address() {
        return RegisterClipboardFormatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatA(LPCSTR lpszFormat)
     * }
     */
    public static int RegisterClipboardFormatA(MemorySegment lpszFormat) {
        var mh$ = RegisterClipboardFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClipboardFormatA", lpszFormat);
            }
            return (int)mh$.invokeExact(lpszFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClipboardFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterClipboardFormatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatW(LPCWSTR lpszFormat)
     * }
     */
    public static FunctionDescriptor RegisterClipboardFormatW$descriptor() {
        return RegisterClipboardFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatW(LPCWSTR lpszFormat)
     * }
     */
    public static MethodHandle RegisterClipboardFormatW$handle() {
        return RegisterClipboardFormatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatW(LPCWSTR lpszFormat)
     * }
     */
    public static MemorySegment RegisterClipboardFormatW$address() {
        return RegisterClipboardFormatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatW(LPCWSTR lpszFormat)
     * }
     */
    public static int RegisterClipboardFormatW(MemorySegment lpszFormat) {
        var mh$ = RegisterClipboardFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClipboardFormatW", lpszFormat);
            }
            return (int)mh$.invokeExact(lpszFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CountClipboardFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CountClipboardFormats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CountClipboardFormats()
     * }
     */
    public static FunctionDescriptor CountClipboardFormats$descriptor() {
        return CountClipboardFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CountClipboardFormats()
     * }
     */
    public static MethodHandle CountClipboardFormats$handle() {
        return CountClipboardFormats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CountClipboardFormats()
     * }
     */
    public static MemorySegment CountClipboardFormats$address() {
        return CountClipboardFormats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CountClipboardFormats()
     * }
     */
    public static int CountClipboardFormats() {
        var mh$ = CountClipboardFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CountClipboardFormats");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumClipboardFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumClipboardFormats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT EnumClipboardFormats(UINT format)
     * }
     */
    public static FunctionDescriptor EnumClipboardFormats$descriptor() {
        return EnumClipboardFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT EnumClipboardFormats(UINT format)
     * }
     */
    public static MethodHandle EnumClipboardFormats$handle() {
        return EnumClipboardFormats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT EnumClipboardFormats(UINT format)
     * }
     */
    public static MemorySegment EnumClipboardFormats$address() {
        return EnumClipboardFormats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT EnumClipboardFormats(UINT format)
     * }
     */
    public static int EnumClipboardFormats(int format) {
        var mh$ = EnumClipboardFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumClipboardFormats", format);
            }
            return (int)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardFormatNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClipboardFormatNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static FunctionDescriptor GetClipboardFormatNameA$descriptor() {
        return GetClipboardFormatNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static MethodHandle GetClipboardFormatNameA$handle() {
        return GetClipboardFormatNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static MemorySegment GetClipboardFormatNameA$address() {
        return GetClipboardFormatNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static int GetClipboardFormatNameA(int format, MemorySegment lpszFormatName, int cchMaxCount) {
        var mh$ = GetClipboardFormatNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardFormatNameA", format, lpszFormatName, cchMaxCount);
            }
            return (int)mh$.invokeExact(format, lpszFormatName, cchMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardFormatNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClipboardFormatNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static FunctionDescriptor GetClipboardFormatNameW$descriptor() {
        return GetClipboardFormatNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static MethodHandle GetClipboardFormatNameW$handle() {
        return GetClipboardFormatNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static MemorySegment GetClipboardFormatNameW$address() {
        return GetClipboardFormatNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static int GetClipboardFormatNameW(int format, MemorySegment lpszFormatName, int cchMaxCount) {
        var mh$ = GetClipboardFormatNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardFormatNameW", format, lpszFormatName, cchMaxCount);
            }
            return (int)mh$.invokeExact(format, lpszFormatName, cchMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EmptyClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EmptyClipboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EmptyClipboard()
     * }
     */
    public static FunctionDescriptor EmptyClipboard$descriptor() {
        return EmptyClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EmptyClipboard()
     * }
     */
    public static MethodHandle EmptyClipboard$handle() {
        return EmptyClipboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EmptyClipboard()
     * }
     */
    public static MemorySegment EmptyClipboard$address() {
        return EmptyClipboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EmptyClipboard()
     * }
     */
    public static int EmptyClipboard() {
        var mh$ = EmptyClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EmptyClipboard");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsClipboardFormatAvailable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsClipboardFormatAvailable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsClipboardFormatAvailable(UINT format)
     * }
     */
    public static FunctionDescriptor IsClipboardFormatAvailable$descriptor() {
        return IsClipboardFormatAvailable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsClipboardFormatAvailable(UINT format)
     * }
     */
    public static MethodHandle IsClipboardFormatAvailable$handle() {
        return IsClipboardFormatAvailable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsClipboardFormatAvailable(UINT format)
     * }
     */
    public static MemorySegment IsClipboardFormatAvailable$address() {
        return IsClipboardFormatAvailable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsClipboardFormatAvailable(UINT format)
     * }
     */
    public static int IsClipboardFormatAvailable(int format) {
        var mh$ = IsClipboardFormatAvailable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsClipboardFormatAvailable", format);
            }
            return (int)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPriorityClipboardFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPriorityClipboardFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats)
     * }
     */
    public static FunctionDescriptor GetPriorityClipboardFormat$descriptor() {
        return GetPriorityClipboardFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats)
     * }
     */
    public static MethodHandle GetPriorityClipboardFormat$handle() {
        return GetPriorityClipboardFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats)
     * }
     */
    public static MemorySegment GetPriorityClipboardFormat$address() {
        return GetPriorityClipboardFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats)
     * }
     */
    public static int GetPriorityClipboardFormat(MemorySegment paFormatPriorityList, int cFormats) {
        var mh$ = GetPriorityClipboardFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPriorityClipboardFormat", paFormatPriorityList, cFormats);
            }
            return (int)mh$.invokeExact(paFormatPriorityList, cFormats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOpenClipboardWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetOpenClipboardWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetOpenClipboardWindow()
     * }
     */
    public static FunctionDescriptor GetOpenClipboardWindow$descriptor() {
        return GetOpenClipboardWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetOpenClipboardWindow()
     * }
     */
    public static MethodHandle GetOpenClipboardWindow$handle() {
        return GetOpenClipboardWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetOpenClipboardWindow()
     * }
     */
    public static MemorySegment GetOpenClipboardWindow$address() {
        return GetOpenClipboardWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetOpenClipboardWindow()
     * }
     */
    public static MemorySegment GetOpenClipboardWindow() {
        var mh$ = GetOpenClipboardWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOpenClipboardWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddClipboardFormatListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddClipboardFormatListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddClipboardFormatListener(HWND hwnd)
     * }
     */
    public static FunctionDescriptor AddClipboardFormatListener$descriptor() {
        return AddClipboardFormatListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddClipboardFormatListener(HWND hwnd)
     * }
     */
    public static MethodHandle AddClipboardFormatListener$handle() {
        return AddClipboardFormatListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddClipboardFormatListener(HWND hwnd)
     * }
     */
    public static MemorySegment AddClipboardFormatListener$address() {
        return AddClipboardFormatListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddClipboardFormatListener(HWND hwnd)
     * }
     */
    public static int AddClipboardFormatListener(MemorySegment hwnd) {
        var mh$ = AddClipboardFormatListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddClipboardFormatListener", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveClipboardFormatListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveClipboardFormatListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveClipboardFormatListener(HWND hwnd)
     * }
     */
    public static FunctionDescriptor RemoveClipboardFormatListener$descriptor() {
        return RemoveClipboardFormatListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveClipboardFormatListener(HWND hwnd)
     * }
     */
    public static MethodHandle RemoveClipboardFormatListener$handle() {
        return RemoveClipboardFormatListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveClipboardFormatListener(HWND hwnd)
     * }
     */
    public static MemorySegment RemoveClipboardFormatListener$address() {
        return RemoveClipboardFormatListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveClipboardFormatListener(HWND hwnd)
     * }
     */
    public static int RemoveClipboardFormatListener(MemorySegment hwnd) {
        var mh$ = RemoveClipboardFormatListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveClipboardFormatListener", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUpdatedClipboardFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUpdatedClipboardFormats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut)
     * }
     */
    public static FunctionDescriptor GetUpdatedClipboardFormats$descriptor() {
        return GetUpdatedClipboardFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut)
     * }
     */
    public static MethodHandle GetUpdatedClipboardFormats$handle() {
        return GetUpdatedClipboardFormats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut)
     * }
     */
    public static MemorySegment GetUpdatedClipboardFormats$address() {
        return GetUpdatedClipboardFormats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut)
     * }
     */
    public static int GetUpdatedClipboardFormats(MemorySegment lpuiFormats, int cFormats, MemorySegment pcFormatsOut) {
        var mh$ = GetUpdatedClipboardFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUpdatedClipboardFormats", lpuiFormats, cFormats, pcFormatsOut);
            }
            return (int)mh$.invokeExact(lpuiFormats, cFormats, pcFormatsOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharToOemA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static FunctionDescriptor CharToOemA$descriptor() {
        return CharToOemA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static MethodHandle CharToOemA$handle() {
        return CharToOemA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CharToOemA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static MemorySegment CharToOemA$address() {
        return CharToOemA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CharToOemA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static int CharToOemA(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = CharToOemA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemA", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharToOemW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemW(LPCWSTR pSrc, LPSTR pDst)
     * }
     */
    public static FunctionDescriptor CharToOemW$descriptor() {
        return CharToOemW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemW(LPCWSTR pSrc, LPSTR pDst)
     * }
     */
    public static MethodHandle CharToOemW$handle() {
        return CharToOemW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CharToOemW(LPCWSTR pSrc, LPSTR pDst)
     * }
     */
    public static MemorySegment CharToOemW$address() {
        return CharToOemW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CharToOemW(LPCWSTR pSrc, LPSTR pDst)
     * }
     */
    public static int CharToOemW(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = CharToOemW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemW", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OemToCharA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static FunctionDescriptor OemToCharA$descriptor() {
        return OemToCharA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static MethodHandle OemToCharA$handle() {
        return OemToCharA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OemToCharA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static MemorySegment OemToCharA$address() {
        return OemToCharA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OemToCharA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static int OemToCharA(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = OemToCharA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharA", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OemToCharW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharW(LPCSTR pSrc, LPWSTR pDst)
     * }
     */
    public static FunctionDescriptor OemToCharW$descriptor() {
        return OemToCharW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharW(LPCSTR pSrc, LPWSTR pDst)
     * }
     */
    public static MethodHandle OemToCharW$handle() {
        return OemToCharW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OemToCharW(LPCSTR pSrc, LPWSTR pDst)
     * }
     */
    public static MemorySegment OemToCharW$address() {
        return OemToCharW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OemToCharW(LPCSTR pSrc, LPWSTR pDst)
     * }
     */
    public static int OemToCharW(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = OemToCharW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharW", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharToOemBuffA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor CharToOemBuffA$descriptor() {
        return CharToOemBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle CharToOemBuffA$handle() {
        return CharToOemBuffA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MemorySegment CharToOemBuffA$address() {
        return CharToOemBuffA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int CharToOemBuffA(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = CharToOemBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemBuffA", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharToOemBuffW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor CharToOemBuffW$descriptor() {
        return CharToOemBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle CharToOemBuffW$handle() {
        return CharToOemBuffW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MemorySegment CharToOemBuffW$address() {
        return CharToOemBuffW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int CharToOemBuffW(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = CharToOemBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemBuffW", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OemToCharBuffA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor OemToCharBuffA$descriptor() {
        return OemToCharBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle OemToCharBuffA$handle() {
        return OemToCharBuffA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MemorySegment OemToCharBuffA$address() {
        return OemToCharBuffA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int OemToCharBuffA(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = OemToCharBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharBuffA", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OemToCharBuffW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor OemToCharBuffW$descriptor() {
        return OemToCharBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle OemToCharBuffW$handle() {
        return OemToCharBuffW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MemorySegment OemToCharBuffW$address() {
        return OemToCharBuffW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int OemToCharBuffW(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = OemToCharBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharBuffW", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharUpperA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharUpperA(LPSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharUpperA$descriptor() {
        return CharUpperA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharUpperA(LPSTR lpsz)
     * }
     */
    public static MethodHandle CharUpperA$handle() {
        return CharUpperA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharUpperA(LPSTR lpsz)
     * }
     */
    public static MemorySegment CharUpperA$address() {
        return CharUpperA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharUpperA(LPSTR lpsz)
     * }
     */
    public static MemorySegment CharUpperA(MemorySegment lpsz) {
        var mh$ = CharUpperA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperA", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharUpperW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharUpperW(LPWSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharUpperW$descriptor() {
        return CharUpperW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharUpperW(LPWSTR lpsz)
     * }
     */
    public static MethodHandle CharUpperW$handle() {
        return CharUpperW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR CharUpperW(LPWSTR lpsz)
     * }
     */
    public static MemorySegment CharUpperW$address() {
        return CharUpperW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR CharUpperW(LPWSTR lpsz)
     * }
     */
    public static MemorySegment CharUpperW(MemorySegment lpsz) {
        var mh$ = CharUpperW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperW", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharUpperBuffA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharUpperBuffA$descriptor() {
        return CharUpperBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharUpperBuffA$handle() {
        return CharUpperBuffA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static MemorySegment CharUpperBuffA$address() {
        return CharUpperBuffA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CharUpperBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharUpperBuffA(MemorySegment lpsz, int cchLength) {
        var mh$ = CharUpperBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperBuffA", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharUpperBuffW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharUpperBuffW$descriptor() {
        return CharUpperBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharUpperBuffW$handle() {
        return CharUpperBuffW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static MemorySegment CharUpperBuffW$address() {
        return CharUpperBuffW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CharUpperBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharUpperBuffW(MemorySegment lpsz, int cchLength) {
        var mh$ = CharUpperBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperBuffW", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharLowerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharLowerA(LPSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharLowerA$descriptor() {
        return CharLowerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharLowerA(LPSTR lpsz)
     * }
     */
    public static MethodHandle CharLowerA$handle() {
        return CharLowerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharLowerA(LPSTR lpsz)
     * }
     */
    public static MemorySegment CharLowerA$address() {
        return CharLowerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharLowerA(LPSTR lpsz)
     * }
     */
    public static MemorySegment CharLowerA(MemorySegment lpsz) {
        var mh$ = CharLowerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerA", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharLowerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharLowerW(LPWSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharLowerW$descriptor() {
        return CharLowerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharLowerW(LPWSTR lpsz)
     * }
     */
    public static MethodHandle CharLowerW$handle() {
        return CharLowerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR CharLowerW(LPWSTR lpsz)
     * }
     */
    public static MemorySegment CharLowerW$address() {
        return CharLowerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR CharLowerW(LPWSTR lpsz)
     * }
     */
    public static MemorySegment CharLowerW(MemorySegment lpsz) {
        var mh$ = CharLowerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerW", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharLowerBuffA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharLowerBuffA$descriptor() {
        return CharLowerBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharLowerBuffA$handle() {
        return CharLowerBuffA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static MemorySegment CharLowerBuffA$address() {
        return CharLowerBuffA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CharLowerBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharLowerBuffA(MemorySegment lpsz, int cchLength) {
        var mh$ = CharLowerBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerBuffA", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharLowerBuffW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharLowerBuffW$descriptor() {
        return CharLowerBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharLowerBuffW$handle() {
        return CharLowerBuffW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static MemorySegment CharLowerBuffW$address() {
        return CharLowerBuffW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CharLowerBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharLowerBuffW(MemorySegment lpsz, int cchLength) {
        var mh$ = CharLowerBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerBuffW", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharNextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharNextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharNextA(LPCSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharNextA$descriptor() {
        return CharNextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharNextA(LPCSTR lpsz)
     * }
     */
    public static MethodHandle CharNextA$handle() {
        return CharNextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharNextA(LPCSTR lpsz)
     * }
     */
    public static MemorySegment CharNextA$address() {
        return CharNextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharNextA(LPCSTR lpsz)
     * }
     */
    public static MemorySegment CharNextA(MemorySegment lpsz) {
        var mh$ = CharNextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharNextA", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharNextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharNextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharNextW(LPCWSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharNextW$descriptor() {
        return CharNextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharNextW(LPCWSTR lpsz)
     * }
     */
    public static MethodHandle CharNextW$handle() {
        return CharNextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR CharNextW(LPCWSTR lpsz)
     * }
     */
    public static MemorySegment CharNextW$address() {
        return CharNextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR CharNextW(LPCWSTR lpsz)
     * }
     */
    public static MemorySegment CharNextW(MemorySegment lpsz) {
        var mh$ = CharNextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharNextW", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharPrevA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharPrevA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent)
     * }
     */
    public static FunctionDescriptor CharPrevA$descriptor() {
        return CharPrevA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent)
     * }
     */
    public static MethodHandle CharPrevA$handle() {
        return CharPrevA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent)
     * }
     */
    public static MemorySegment CharPrevA$address() {
        return CharPrevA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent)
     * }
     */
    public static MemorySegment CharPrevA(MemorySegment lpszStart, MemorySegment lpszCurrent) {
        var mh$ = CharPrevA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharPrevA", lpszStart, lpszCurrent);
            }
            return (MemorySegment)mh$.invokeExact(lpszStart, lpszCurrent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharPrevW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharPrevW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
     * }
     */
    public static FunctionDescriptor CharPrevW$descriptor() {
        return CharPrevW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
     * }
     */
    public static MethodHandle CharPrevW$handle() {
        return CharPrevW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
     * }
     */
    public static MemorySegment CharPrevW$address() {
        return CharPrevW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
     * }
     */
    public static MemorySegment CharPrevW(MemorySegment lpszStart, MemorySegment lpszCurrent) {
        var mh$ = CharPrevW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharPrevW", lpszStart, lpszCurrent);
            }
            return (MemorySegment)mh$.invokeExact(lpszStart, lpszCurrent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharNextExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharNextExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CharNextExA$descriptor() {
        return CharNextExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MethodHandle CharNextExA$handle() {
        return CharNextExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MemorySegment CharNextExA$address() {
        return CharNextExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MemorySegment CharNextExA(short CodePage, MemorySegment lpCurrentChar, int dwFlags) {
        var mh$ = CharNextExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharNextExA", CodePage, lpCurrentChar, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(CodePage, lpCurrentChar, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharPrevExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CharPrevExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CharPrevExA$descriptor() {
        return CharPrevExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MethodHandle CharPrevExA$handle() {
        return CharPrevExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MemorySegment CharPrevExA$address() {
        return CharPrevExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MemorySegment CharPrevExA(short CodePage, MemorySegment lpStart, MemorySegment lpCurrentChar, int dwFlags) {
        var mh$ = CharPrevExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharPrevExA", CodePage, lpStart, lpCurrentChar, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(CodePage, lpStart, lpCurrentChar, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsCharAlphaA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaA$descriptor() {
        return IsCharAlphaA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaA$handle() {
        return IsCharAlphaA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaA(CHAR ch)
     * }
     */
    public static MemorySegment IsCharAlphaA$address() {
        return IsCharAlphaA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaA(CHAR ch)
     * }
     */
    public static int IsCharAlphaA(byte ch) {
        var mh$ = IsCharAlphaA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsCharAlphaW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaW$descriptor() {
        return IsCharAlphaW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaW$handle() {
        return IsCharAlphaW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaW(WCHAR ch)
     * }
     */
    public static MemorySegment IsCharAlphaW$address() {
        return IsCharAlphaW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaW(WCHAR ch)
     * }
     */
    public static int IsCharAlphaW(short ch) {
        var mh$ = IsCharAlphaW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaNumericA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsCharAlphaNumericA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaNumericA$descriptor() {
        return IsCharAlphaNumericA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaNumericA$handle() {
        return IsCharAlphaNumericA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericA(CHAR ch)
     * }
     */
    public static MemorySegment IsCharAlphaNumericA$address() {
        return IsCharAlphaNumericA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericA(CHAR ch)
     * }
     */
    public static int IsCharAlphaNumericA(byte ch) {
        var mh$ = IsCharAlphaNumericA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaNumericA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaNumericW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsCharAlphaNumericW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaNumericW$descriptor() {
        return IsCharAlphaNumericW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaNumericW$handle() {
        return IsCharAlphaNumericW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericW(WCHAR ch)
     * }
     */
    public static MemorySegment IsCharAlphaNumericW$address() {
        return IsCharAlphaNumericW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericW(WCHAR ch)
     * }
     */
    public static int IsCharAlphaNumericW(short ch) {
        var mh$ = IsCharAlphaNumericW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaNumericW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharUpperA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsCharUpperA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharUpperA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharUpperA$descriptor() {
        return IsCharUpperA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharUpperA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharUpperA$handle() {
        return IsCharUpperA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharUpperA(CHAR ch)
     * }
     */
    public static MemorySegment IsCharUpperA$address() {
        return IsCharUpperA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharUpperA(CHAR ch)
     * }
     */
    public static int IsCharUpperA(byte ch) {
        var mh$ = IsCharUpperA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharUpperA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharUpperW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsCharUpperW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharUpperW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharUpperW$descriptor() {
        return IsCharUpperW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharUpperW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharUpperW$handle() {
        return IsCharUpperW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharUpperW(WCHAR ch)
     * }
     */
    public static MemorySegment IsCharUpperW$address() {
        return IsCharUpperW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharUpperW(WCHAR ch)
     * }
     */
    public static int IsCharUpperW(short ch) {
        var mh$ = IsCharUpperW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharUpperW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharLowerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsCharLowerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharLowerA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharLowerA$descriptor() {
        return IsCharLowerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharLowerA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharLowerA$handle() {
        return IsCharLowerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharLowerA(CHAR ch)
     * }
     */
    public static MemorySegment IsCharLowerA$address() {
        return IsCharLowerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharLowerA(CHAR ch)
     * }
     */
    public static int IsCharLowerA(byte ch) {
        var mh$ = IsCharLowerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharLowerA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharLowerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsCharLowerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharLowerW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharLowerW$descriptor() {
        return IsCharLowerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharLowerW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharLowerW$handle() {
        return IsCharLowerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharLowerW(WCHAR ch)
     * }
     */
    public static MemorySegment IsCharLowerW$address() {
        return IsCharLowerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharLowerW(WCHAR ch)
     * }
     */
    public static int IsCharLowerW(short ch) {
        var mh$ = IsCharLowerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharLowerW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFocus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFocus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetFocus(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetFocus$descriptor() {
        return SetFocus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetFocus(HWND hWnd)
     * }
     */
    public static MethodHandle SetFocus$handle() {
        return SetFocus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND SetFocus(HWND hWnd)
     * }
     */
    public static MemorySegment SetFocus$address() {
        return SetFocus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND SetFocus(HWND hWnd)
     * }
     */
    public static MemorySegment SetFocus(MemorySegment hWnd) {
        var mh$ = SetFocus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFocus", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetActiveWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetActiveWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetActiveWindow()
     * }
     */
    public static FunctionDescriptor GetActiveWindow$descriptor() {
        return GetActiveWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetActiveWindow()
     * }
     */
    public static MethodHandle GetActiveWindow$handle() {
        return GetActiveWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetActiveWindow()
     * }
     */
    public static MemorySegment GetActiveWindow$address() {
        return GetActiveWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetActiveWindow()
     * }
     */
    public static MemorySegment GetActiveWindow() {
        var mh$ = GetActiveWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetActiveWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFocus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFocus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetFocus()
     * }
     */
    public static FunctionDescriptor GetFocus$descriptor() {
        return GetFocus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetFocus()
     * }
     */
    public static MethodHandle GetFocus$handle() {
        return GetFocus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetFocus()
     * }
     */
    public static MemorySegment GetFocus$address() {
        return GetFocus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetFocus()
     * }
     */
    public static MemorySegment GetFocus() {
        var mh$ = GetFocus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFocus");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKBCodePage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKBCodePage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetKBCodePage()
     * }
     */
    public static FunctionDescriptor GetKBCodePage$descriptor() {
        return GetKBCodePage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetKBCodePage()
     * }
     */
    public static MethodHandle GetKBCodePage$handle() {
        return GetKBCodePage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetKBCodePage()
     * }
     */
    public static MemorySegment GetKBCodePage$address() {
        return GetKBCodePage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetKBCodePage()
     * }
     */
    public static int GetKBCodePage() {
        var mh$ = GetKBCodePage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKBCodePage");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKeyState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT GetKeyState(int nVirtKey)
     * }
     */
    public static FunctionDescriptor GetKeyState$descriptor() {
        return GetKeyState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT GetKeyState(int nVirtKey)
     * }
     */
    public static MethodHandle GetKeyState$handle() {
        return GetKeyState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT GetKeyState(int nVirtKey)
     * }
     */
    public static MemorySegment GetKeyState$address() {
        return GetKeyState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT GetKeyState(int nVirtKey)
     * }
     */
    public static short GetKeyState(int nVirtKey) {
        var mh$ = GetKeyState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyState", nVirtKey);
            }
            return (short)mh$.invokeExact(nVirtKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAsyncKeyState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAsyncKeyState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT GetAsyncKeyState(int vKey)
     * }
     */
    public static FunctionDescriptor GetAsyncKeyState$descriptor() {
        return GetAsyncKeyState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT GetAsyncKeyState(int vKey)
     * }
     */
    public static MethodHandle GetAsyncKeyState$handle() {
        return GetAsyncKeyState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT GetAsyncKeyState(int vKey)
     * }
     */
    public static MemorySegment GetAsyncKeyState$address() {
        return GetAsyncKeyState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT GetAsyncKeyState(int vKey)
     * }
     */
    public static short GetAsyncKeyState(int vKey) {
        var mh$ = GetAsyncKeyState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAsyncKeyState", vKey);
            }
            return (short)mh$.invokeExact(vKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKeyboardState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKeyboardState(PBYTE lpKeyState)
     * }
     */
    public static FunctionDescriptor GetKeyboardState$descriptor() {
        return GetKeyboardState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKeyboardState(PBYTE lpKeyState)
     * }
     */
    public static MethodHandle GetKeyboardState$handle() {
        return GetKeyboardState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetKeyboardState(PBYTE lpKeyState)
     * }
     */
    public static MemorySegment GetKeyboardState$address() {
        return GetKeyboardState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetKeyboardState(PBYTE lpKeyState)
     * }
     */
    public static int GetKeyboardState(MemorySegment lpKeyState) {
        var mh$ = GetKeyboardState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardState", lpKeyState);
            }
            return (int)mh$.invokeExact(lpKeyState);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetKeyboardState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetKeyboardState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetKeyboardState(LPBYTE lpKeyState)
     * }
     */
    public static FunctionDescriptor SetKeyboardState$descriptor() {
        return SetKeyboardState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetKeyboardState(LPBYTE lpKeyState)
     * }
     */
    public static MethodHandle SetKeyboardState$handle() {
        return SetKeyboardState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetKeyboardState(LPBYTE lpKeyState)
     * }
     */
    public static MemorySegment SetKeyboardState$address() {
        return SetKeyboardState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetKeyboardState(LPBYTE lpKeyState)
     * }
     */
    public static int SetKeyboardState(MemorySegment lpKeyState) {
        var mh$ = SetKeyboardState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetKeyboardState", lpKeyState);
            }
            return (int)mh$.invokeExact(lpKeyState);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyNameTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKeyNameTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize)
     * }
     */
    public static FunctionDescriptor GetKeyNameTextA$descriptor() {
        return GetKeyNameTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize)
     * }
     */
    public static MethodHandle GetKeyNameTextA$handle() {
        return GetKeyNameTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize)
     * }
     */
    public static MemorySegment GetKeyNameTextA$address() {
        return GetKeyNameTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize)
     * }
     */
    public static int GetKeyNameTextA(int lParam, MemorySegment lpString, int cchSize) {
        var mh$ = GetKeyNameTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyNameTextA", lParam, lpString, cchSize);
            }
            return (int)mh$.invokeExact(lParam, lpString, cchSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyNameTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKeyNameTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize)
     * }
     */
    public static FunctionDescriptor GetKeyNameTextW$descriptor() {
        return GetKeyNameTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize)
     * }
     */
    public static MethodHandle GetKeyNameTextW$handle() {
        return GetKeyNameTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize)
     * }
     */
    public static MemorySegment GetKeyNameTextW$address() {
        return GetKeyNameTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize)
     * }
     */
    public static int GetKeyNameTextW(int lParam, MemorySegment lpString, int cchSize) {
        var mh$ = GetKeyNameTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyNameTextW", lParam, lpString, cchSize);
            }
            return (int)mh$.invokeExact(lParam, lpString, cchSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKeyboardType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyboardType(int nTypeFlag)
     * }
     */
    public static FunctionDescriptor GetKeyboardType$descriptor() {
        return GetKeyboardType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyboardType(int nTypeFlag)
     * }
     */
    public static MethodHandle GetKeyboardType$handle() {
        return GetKeyboardType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetKeyboardType(int nTypeFlag)
     * }
     */
    public static MemorySegment GetKeyboardType$address() {
        return GetKeyboardType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetKeyboardType(int nTypeFlag)
     * }
     */
    public static int GetKeyboardType(int nTypeFlag) {
        var mh$ = GetKeyboardType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardType", nTypeFlag);
            }
            return (int)mh$.invokeExact(nTypeFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToAscii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ToAscii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags)
     * }
     */
    public static FunctionDescriptor ToAscii$descriptor() {
        return ToAscii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags)
     * }
     */
    public static MethodHandle ToAscii$handle() {
        return ToAscii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags)
     * }
     */
    public static MemorySegment ToAscii$address() {
        return ToAscii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags)
     * }
     */
    public static int ToAscii(int uVirtKey, int uScanCode, MemorySegment lpKeyState, MemorySegment lpChar, int uFlags) {
        var mh$ = ToAscii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToAscii", uVirtKey, uScanCode, lpKeyState, lpChar, uFlags);
            }
            return (int)mh$.invokeExact(uVirtKey, uScanCode, lpKeyState, lpChar, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToAsciiEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ToAsciiEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor ToAsciiEx$descriptor() {
        return ToAsciiEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl)
     * }
     */
    public static MethodHandle ToAsciiEx$handle() {
        return ToAsciiEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl)
     * }
     */
    public static MemorySegment ToAsciiEx$address() {
        return ToAsciiEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl)
     * }
     */
    public static int ToAsciiEx(int uVirtKey, int uScanCode, MemorySegment lpKeyState, MemorySegment lpChar, int uFlags, MemorySegment dwhkl) {
        var mh$ = ToAsciiEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToAsciiEx", uVirtKey, uScanCode, lpKeyState, lpChar, uFlags, dwhkl);
            }
            return (int)mh$.invokeExact(uVirtKey, uScanCode, lpKeyState, lpChar, uFlags, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ToUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags)
     * }
     */
    public static FunctionDescriptor ToUnicode$descriptor() {
        return ToUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags)
     * }
     */
    public static MethodHandle ToUnicode$handle() {
        return ToUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags)
     * }
     */
    public static MemorySegment ToUnicode$address() {
        return ToUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags)
     * }
     */
    public static int ToUnicode(int wVirtKey, int wScanCode, MemorySegment lpKeyState, MemorySegment pwszBuff, int cchBuff, int wFlags) {
        var mh$ = ToUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToUnicode", wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags);
            }
            return (int)mh$.invokeExact(wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemKeyScan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OemKeyScan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OemKeyScan(WORD wOemChar)
     * }
     */
    public static FunctionDescriptor OemKeyScan$descriptor() {
        return OemKeyScan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OemKeyScan(WORD wOemChar)
     * }
     */
    public static MethodHandle OemKeyScan$handle() {
        return OemKeyScan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD OemKeyScan(WORD wOemChar)
     * }
     */
    public static MemorySegment OemKeyScan$address() {
        return OemKeyScan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD OemKeyScan(WORD wOemChar)
     * }
     */
    public static int OemKeyScan(short wOemChar) {
        var mh$ = OemKeyScan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemKeyScan", wOemChar);
            }
            return (int)mh$.invokeExact(wOemChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VkKeyScanA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanA(CHAR ch)
     * }
     */
    public static FunctionDescriptor VkKeyScanA$descriptor() {
        return VkKeyScanA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanA(CHAR ch)
     * }
     */
    public static MethodHandle VkKeyScanA$handle() {
        return VkKeyScanA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT VkKeyScanA(CHAR ch)
     * }
     */
    public static MemorySegment VkKeyScanA$address() {
        return VkKeyScanA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanA(CHAR ch)
     * }
     */
    public static short VkKeyScanA(byte ch) {
        var mh$ = VkKeyScanA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanA", ch);
            }
            return (short)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VkKeyScanW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor VkKeyScanW$descriptor() {
        return VkKeyScanW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanW(WCHAR ch)
     * }
     */
    public static MethodHandle VkKeyScanW$handle() {
        return VkKeyScanW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT VkKeyScanW(WCHAR ch)
     * }
     */
    public static MemorySegment VkKeyScanW$address() {
        return VkKeyScanW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanW(WCHAR ch)
     * }
     */
    public static short VkKeyScanW(short ch) {
        var mh$ = VkKeyScanW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanW", ch);
            }
            return (short)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VkKeyScanExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExA(CHAR ch, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor VkKeyScanExA$descriptor() {
        return VkKeyScanExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExA(CHAR ch, HKL dwhkl)
     * }
     */
    public static MethodHandle VkKeyScanExA$handle() {
        return VkKeyScanExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExA(CHAR ch, HKL dwhkl)
     * }
     */
    public static MemorySegment VkKeyScanExA$address() {
        return VkKeyScanExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanExA(CHAR ch, HKL dwhkl)
     * }
     */
    public static short VkKeyScanExA(byte ch, MemorySegment dwhkl) {
        var mh$ = VkKeyScanExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanExA", ch, dwhkl);
            }
            return (short)mh$.invokeExact(ch, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VkKeyScanExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExW(WCHAR ch, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor VkKeyScanExW$descriptor() {
        return VkKeyScanExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExW(WCHAR ch, HKL dwhkl)
     * }
     */
    public static MethodHandle VkKeyScanExW$handle() {
        return VkKeyScanExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExW(WCHAR ch, HKL dwhkl)
     * }
     */
    public static MemorySegment VkKeyScanExW$address() {
        return VkKeyScanExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanExW(WCHAR ch, HKL dwhkl)
     * }
     */
    public static short VkKeyScanExW(short ch, MemorySegment dwhkl) {
        var mh$ = VkKeyScanExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanExW", ch, dwhkl);
            }
            return (short)mh$.invokeExact(ch, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class keybd_event {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("keybd_event");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
     * }
     */
    public static FunctionDescriptor keybd_event$descriptor() {
        return keybd_event.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
     * }
     */
    public static MethodHandle keybd_event$handle() {
        return keybd_event.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
     * }
     */
    public static MemorySegment keybd_event$address() {
        return keybd_event.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
     * }
     */
    public static void keybd_event(byte bVk, byte bScan, int dwFlags, long dwExtraInfo) {
        var mh$ = keybd_event.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("keybd_event", bVk, bScan, dwFlags, dwExtraInfo);
            }
            mh$.invokeExact(bVk, bScan, dwFlags, dwExtraInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mouse_event {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mouse_event");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
     * }
     */
    public static FunctionDescriptor mouse_event$descriptor() {
        return mouse_event.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
     * }
     */
    public static MethodHandle mouse_event$handle() {
        return mouse_event.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
     * }
     */
    public static MemorySegment mouse_event$address() {
        return mouse_event.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
     * }
     */
    public static void mouse_event(int dwFlags, int dx, int dy, int dwData, long dwExtraInfo) {
        var mh$ = mouse_event.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mouse_event", dwFlags, dx, dy, dwData, dwExtraInfo);
            }
            mh$.invokeExact(dwFlags, dx, dy, dwData, dwExtraInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEINPUT {
     *     LONG dx;
     *     LONG dy;
     *     DWORD mouseData;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PMOUSEINPUT
     * }
     */
    public static final AddressLayout PMOUSEINPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEINPUT {
     *     LONG dx;
     *     LONG dy;
     *     DWORD mouseData;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMOUSEINPUT
     * }
     */
    public static final AddressLayout LPMOUSEINPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKEYBDINPUT {
     *     WORD wVk;
     *     WORD wScan;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PKEYBDINPUT
     * }
     */
    public static final AddressLayout PKEYBDINPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKEYBDINPUT {
     *     WORD wVk;
     *     WORD wScan;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPKEYBDINPUT
     * }
     */
    public static final AddressLayout LPKEYBDINPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREINPUT {
     *     DWORD uMsg;
     *     WORD wParamL;
     *     WORD wParamH;
     * } *PHARDWAREINPUT
     * }
     */
    public static final AddressLayout PHARDWAREINPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREINPUT {
     *     DWORD uMsg;
     *     WORD wParamL;
     *     WORD wParamH;
     * } *LPHARDWAREINPUT
     * }
     */
    public static final AddressLayout LPHARDWAREINPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagINPUT {
     *     DWORD type;
     *     union {
     *         MOUSEINPUT mi;
     *         KEYBDINPUT ki;
     *         HARDWAREINPUT hi;
     *     };
     * } *PINPUT
     * }
     */
    public static final AddressLayout PINPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagINPUT {
     *     DWORD type;
     *     union {
     *         MOUSEINPUT mi;
     *         KEYBDINPUT ki;
     *         HARDWAREINPUT hi;
     *     };
     * } *LPINPUT
     * }
     */
    public static final AddressLayout LPINPUT = freeglut_h.C_POINTER;

    private static class SendInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SendInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SendInput(UINT cInputs, LPINPUT pInputs, int cbSize)
     * }
     */
    public static FunctionDescriptor SendInput$descriptor() {
        return SendInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SendInput(UINT cInputs, LPINPUT pInputs, int cbSize)
     * }
     */
    public static MethodHandle SendInput$handle() {
        return SendInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SendInput(UINT cInputs, LPINPUT pInputs, int cbSize)
     * }
     */
    public static MemorySegment SendInput$address() {
        return SendInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SendInput(UINT cInputs, LPINPUT pInputs, int cbSize)
     * }
     */
    public static int SendInput(int cInputs, MemorySegment pInputs, int cbSize) {
        var mh$ = SendInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendInput", cInputs, pInputs, cbSize);
            }
            return (int)mh$.invokeExact(cInputs, pInputs, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HTOUCHINPUT__ {
     *     int unused;
     * } *HTOUCHINPUT
     * }
     */
    public static final AddressLayout HTOUCHINPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTOUCHINPUT {
     *     LONG x;
     *     LONG y;
     *     HANDLE hSource;
     *     DWORD dwID;
     *     DWORD dwFlags;
     *     DWORD dwMask;
     *     DWORD dwTime;
     *     ULONG_PTR dwExtraInfo;
     *     DWORD cxContact;
     *     DWORD cyContact;
     * } *PTOUCHINPUT
     * }
     */
    public static final AddressLayout PTOUCHINPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const TOUCHINPUT *PCTOUCHINPUT
     * }
     */
    public static final AddressLayout PCTOUCHINPUT = freeglut_h.C_POINTER;

    private static class GetTouchInputInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTouchInputInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
     * }
     */
    public static FunctionDescriptor GetTouchInputInfo$descriptor() {
        return GetTouchInputInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
     * }
     */
    public static MethodHandle GetTouchInputInfo$handle() {
        return GetTouchInputInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
     * }
     */
    public static MemorySegment GetTouchInputInfo$address() {
        return GetTouchInputInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
     * }
     */
    public static int GetTouchInputInfo(MemorySegment hTouchInput, int cInputs, MemorySegment pInputs, int cbSize) {
        var mh$ = GetTouchInputInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTouchInputInfo", hTouchInput, cInputs, pInputs, cbSize);
            }
            return (int)mh$.invokeExact(hTouchInput, cInputs, pInputs, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseTouchInputHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseTouchInputHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
     * }
     */
    public static FunctionDescriptor CloseTouchInputHandle$descriptor() {
        return CloseTouchInputHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
     * }
     */
    public static MethodHandle CloseTouchInputHandle$handle() {
        return CloseTouchInputHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
     * }
     */
    public static MemorySegment CloseTouchInputHandle$address() {
        return CloseTouchInputHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
     * }
     */
    public static int CloseTouchInputHandle(MemorySegment hTouchInput) {
        var mh$ = CloseTouchInputHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseTouchInputHandle", hTouchInput);
            }
            return (int)mh$.invokeExact(hTouchInput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterTouchWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterTouchWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterTouchWindow(HWND hwnd, ULONG ulFlags)
     * }
     */
    public static FunctionDescriptor RegisterTouchWindow$descriptor() {
        return RegisterTouchWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterTouchWindow(HWND hwnd, ULONG ulFlags)
     * }
     */
    public static MethodHandle RegisterTouchWindow$handle() {
        return RegisterTouchWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterTouchWindow(HWND hwnd, ULONG ulFlags)
     * }
     */
    public static MemorySegment RegisterTouchWindow$address() {
        return RegisterTouchWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterTouchWindow(HWND hwnd, ULONG ulFlags)
     * }
     */
    public static int RegisterTouchWindow(MemorySegment hwnd, int ulFlags) {
        var mh$ = RegisterTouchWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterTouchWindow", hwnd, ulFlags);
            }
            return (int)mh$.invokeExact(hwnd, ulFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterTouchWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterTouchWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterTouchWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor UnregisterTouchWindow$descriptor() {
        return UnregisterTouchWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterTouchWindow(HWND hwnd)
     * }
     */
    public static MethodHandle UnregisterTouchWindow$handle() {
        return UnregisterTouchWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterTouchWindow(HWND hwnd)
     * }
     */
    public static MemorySegment UnregisterTouchWindow$address() {
        return UnregisterTouchWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterTouchWindow(HWND hwnd)
     * }
     */
    public static int UnregisterTouchWindow(MemorySegment hwnd) {
        var mh$ = UnregisterTouchWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterTouchWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTouchWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsTouchWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTouchWindow(HWND hwnd, PULONG pulFlags)
     * }
     */
    public static FunctionDescriptor IsTouchWindow$descriptor() {
        return IsTouchWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTouchWindow(HWND hwnd, PULONG pulFlags)
     * }
     */
    public static MethodHandle IsTouchWindow$handle() {
        return IsTouchWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsTouchWindow(HWND hwnd, PULONG pulFlags)
     * }
     */
    public static MemorySegment IsTouchWindow$address() {
        return IsTouchWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsTouchWindow(HWND hwnd, PULONG pulFlags)
     * }
     */
    public static int IsTouchWindow(MemorySegment hwnd, MemorySegment pulFlags) {
        var mh$ = IsTouchWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTouchWindow", hwnd, pulFlags);
            }
            return (int)mh$.invokeExact(hwnd, pulFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PT_POINTER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_POINTER = 1
     * }
     */
    public static int PT_POINTER() {
        return PT_POINTER;
    }
    private static final int PT_TOUCH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_TOUCH = 2
     * }
     */
    public static int PT_TOUCH() {
        return PT_TOUCH;
    }
    private static final int PT_PEN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_PEN = 3
     * }
     */
    public static int PT_PEN() {
        return PT_PEN;
    }
    private static final int PT_MOUSE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_MOUSE = 4
     * }
     */
    public static int PT_MOUSE() {
        return PT_MOUSE;
    }
    private static final int PT_TOUCHPAD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_TOUCHPAD = 5
     * }
     */
    public static int PT_TOUCHPAD() {
        return PT_TOUCHPAD;
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD POINTER_INPUT_TYPE
     * }
     */
    public static final OfInt POINTER_INPUT_TYPE = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef UINT32 POINTER_FLAGS
     * }
     */
    public static final OfInt POINTER_FLAGS = freeglut_h.C_INT;
    private static final int POINTER_CHANGE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_NONE = 0
     * }
     */
    public static int POINTER_CHANGE_NONE() {
        return POINTER_CHANGE_NONE;
    }
    private static final int POINTER_CHANGE_FIRSTBUTTON_DOWN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIRSTBUTTON_DOWN = 1
     * }
     */
    public static int POINTER_CHANGE_FIRSTBUTTON_DOWN() {
        return POINTER_CHANGE_FIRSTBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_FIRSTBUTTON_UP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIRSTBUTTON_UP = 2
     * }
     */
    public static int POINTER_CHANGE_FIRSTBUTTON_UP() {
        return POINTER_CHANGE_FIRSTBUTTON_UP;
    }
    private static final int POINTER_CHANGE_SECONDBUTTON_DOWN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_SECONDBUTTON_DOWN = 3
     * }
     */
    public static int POINTER_CHANGE_SECONDBUTTON_DOWN() {
        return POINTER_CHANGE_SECONDBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_SECONDBUTTON_UP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_SECONDBUTTON_UP = 4
     * }
     */
    public static int POINTER_CHANGE_SECONDBUTTON_UP() {
        return POINTER_CHANGE_SECONDBUTTON_UP;
    }
    private static final int POINTER_CHANGE_THIRDBUTTON_DOWN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_THIRDBUTTON_DOWN = 5
     * }
     */
    public static int POINTER_CHANGE_THIRDBUTTON_DOWN() {
        return POINTER_CHANGE_THIRDBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_THIRDBUTTON_UP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_THIRDBUTTON_UP = 6
     * }
     */
    public static int POINTER_CHANGE_THIRDBUTTON_UP() {
        return POINTER_CHANGE_THIRDBUTTON_UP;
    }
    private static final int POINTER_CHANGE_FOURTHBUTTON_DOWN = (int)7L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FOURTHBUTTON_DOWN = 7
     * }
     */
    public static int POINTER_CHANGE_FOURTHBUTTON_DOWN() {
        return POINTER_CHANGE_FOURTHBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_FOURTHBUTTON_UP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FOURTHBUTTON_UP = 8
     * }
     */
    public static int POINTER_CHANGE_FOURTHBUTTON_UP() {
        return POINTER_CHANGE_FOURTHBUTTON_UP;
    }
    private static final int POINTER_CHANGE_FIFTHBUTTON_DOWN = (int)9L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIFTHBUTTON_DOWN = 9
     * }
     */
    public static int POINTER_CHANGE_FIFTHBUTTON_DOWN() {
        return POINTER_CHANGE_FIFTHBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_FIFTHBUTTON_UP = (int)10L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIFTHBUTTON_UP = 10
     * }
     */
    public static int POINTER_CHANGE_FIFTHBUTTON_UP() {
        return POINTER_CHANGE_FIFTHBUTTON_UP;
    }
    /**
     * {@snippet lang=c :
     * typedef UINT32 TOUCH_FLAGS
     * }
     */
    public static final OfInt TOUCH_FLAGS = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef UINT32 TOUCH_MASK
     * }
     */
    public static final OfInt TOUCH_MASK = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef UINT32 PEN_FLAGS
     * }
     */
    public static final OfInt PEN_FLAGS = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef UINT32 PEN_MASK
     * }
     */
    public static final OfInt PEN_MASK = freeglut_h.C_INT;
    private static final int POINTER_FEEDBACK_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POINTER_FEEDBACK_DEFAULT = 1
     * }
     */
    public static int POINTER_FEEDBACK_DEFAULT() {
        return POINTER_FEEDBACK_DEFAULT;
    }
    private static final int POINTER_FEEDBACK_INDIRECT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POINTER_FEEDBACK_INDIRECT = 2
     * }
     */
    public static int POINTER_FEEDBACK_INDIRECT() {
        return POINTER_FEEDBACK_INDIRECT;
    }
    private static final int POINTER_FEEDBACK_NONE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POINTER_FEEDBACK_NONE = 3
     * }
     */
    public static int POINTER_FEEDBACK_NONE() {
        return POINTER_FEEDBACK_NONE;
    }

    private static class InitializeTouchInjection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeTouchInjection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeTouchInjection(UINT32 maxCount, DWORD dwMode)
     * }
     */
    public static FunctionDescriptor InitializeTouchInjection$descriptor() {
        return InitializeTouchInjection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeTouchInjection(UINT32 maxCount, DWORD dwMode)
     * }
     */
    public static MethodHandle InitializeTouchInjection$handle() {
        return InitializeTouchInjection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeTouchInjection(UINT32 maxCount, DWORD dwMode)
     * }
     */
    public static MemorySegment InitializeTouchInjection$address() {
        return InitializeTouchInjection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeTouchInjection(UINT32 maxCount, DWORD dwMode)
     * }
     */
    public static int InitializeTouchInjection(int maxCount, int dwMode) {
        var mh$ = InitializeTouchInjection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeTouchInjection", maxCount, dwMode);
            }
            return (int)mh$.invokeExact(maxCount, dwMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InjectTouchInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InjectTouchInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO *contacts)
     * }
     */
    public static FunctionDescriptor InjectTouchInput$descriptor() {
        return InjectTouchInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO *contacts)
     * }
     */
    public static MethodHandle InjectTouchInput$handle() {
        return InjectTouchInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO *contacts)
     * }
     */
    public static MemorySegment InjectTouchInput$address() {
        return InjectTouchInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO *contacts)
     * }
     */
    public static int InjectTouchInput(int count, MemorySegment contacts) {
        var mh$ = InjectTouchInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InjectTouchInput", count, contacts);
            }
            return (int)mh$.invokeExact(count, contacts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagUSAGE_PROPERTIES {
     *     USHORT level;
     *     USHORT page;
     *     USHORT usage;
     *     INT32 logicalMinimum;
     *     INT32 logicalMaximum;
     *     USHORT unit;
     *     USHORT exponent;
     *     BYTE count;
     *     INT32 physicalMinimum;
     *     INT32 physicalMaximum;
     * } *PUSAGE_PROPERTIES
     * }
     */
    public static final AddressLayout PUSAGE_PROPERTIES = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTER_TYPE_INFO {
     *     POINTER_INPUT_TYPE type;
     *     union {
     *         POINTER_TOUCH_INFO touchInfo;
     *         POINTER_PEN_INFO penInfo;
     *     };
     * } *PPOINTER_TYPE_INFO
     * }
     */
    public static final AddressLayout PPOINTER_TYPE_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagINPUT_INJECTION_VALUE {
     *     USHORT page;
     *     USHORT usage;
     *     INT32 value;
     *     USHORT index;
     * } *PINPUT_INJECTION_VALUE
     * }
     */
    public static final AddressLayout PINPUT_INJECTION_VALUE = freeglut_h.C_POINTER;

    private static class GetPointerType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType)
     * }
     */
    public static FunctionDescriptor GetPointerType$descriptor() {
        return GetPointerType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType)
     * }
     */
    public static MethodHandle GetPointerType$handle() {
        return GetPointerType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType)
     * }
     */
    public static MemorySegment GetPointerType$address() {
        return GetPointerType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType)
     * }
     */
    public static int GetPointerType(int pointerId, MemorySegment pointerType) {
        var mh$ = GetPointerType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerType", pointerId, pointerType);
            }
            return (int)mh$.invokeExact(pointerId, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerCursorId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerCursorId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId)
     * }
     */
    public static FunctionDescriptor GetPointerCursorId$descriptor() {
        return GetPointerCursorId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId)
     * }
     */
    public static MethodHandle GetPointerCursorId$handle() {
        return GetPointerCursorId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId)
     * }
     */
    public static MemorySegment GetPointerCursorId$address() {
        return GetPointerCursorId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId)
     * }
     */
    public static int GetPointerCursorId(int pointerId, MemorySegment cursorId) {
        var mh$ = GetPointerCursorId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerCursorId", pointerId, cursorId);
            }
            return (int)mh$.invokeExact(pointerId, cursorId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerInfo$descriptor() {
        return GetPointerInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerInfo$handle() {
        return GetPointerInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo)
     * }
     */
    public static MemorySegment GetPointerInfo$address() {
        return GetPointerInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerInfo(int pointerId, MemorySegment pointerInfo) {
        var mh$ = GetPointerInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerInfo", pointerId, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerInfoHistory$descriptor() {
        return GetPointerInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerInfoHistory$handle() {
        return GetPointerInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MemorySegment GetPointerInfoHistory$address() {
        return GetPointerInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerInfo) {
        var mh$ = GetPointerInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerInfoHistory", pointerId, entriesCount, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerFrameInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameInfo$descriptor() {
        return GetPointerFrameInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerFrameInfo$handle() {
        return GetPointerFrameInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MemorySegment GetPointerFrameInfo$address() {
        return GetPointerFrameInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerFrameInfo(int pointerId, MemorySegment pointerCount, MemorySegment pointerInfo) {
        var mh$ = GetPointerFrameInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameInfo", pointerId, pointerCount, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerCount, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerFrameInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameInfoHistory$descriptor() {
        return GetPointerFrameInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerFrameInfoHistory$handle() {
        return GetPointerFrameInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MemorySegment GetPointerFrameInfoHistory$address() {
        return GetPointerFrameInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerFrameInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerCount, MemorySegment pointerInfo) {
        var mh$ = GetPointerFrameInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameInfoHistory", pointerId, entriesCount, pointerCount, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerCount, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerTouchInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerTouchInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerTouchInfo$descriptor() {
        return GetPointerTouchInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerTouchInfo$handle() {
        return GetPointerTouchInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MemorySegment GetPointerTouchInfo$address() {
        return GetPointerTouchInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerTouchInfo(int pointerId, MemorySegment touchInfo) {
        var mh$ = GetPointerTouchInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerTouchInfo", pointerId, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerTouchInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerTouchInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerTouchInfoHistory$descriptor() {
        return GetPointerTouchInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerTouchInfoHistory$handle() {
        return GetPointerTouchInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MemorySegment GetPointerTouchInfoHistory$address() {
        return GetPointerTouchInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerTouchInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment touchInfo) {
        var mh$ = GetPointerTouchInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerTouchInfoHistory", pointerId, entriesCount, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameTouchInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerFrameTouchInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameTouchInfo$descriptor() {
        return GetPointerFrameTouchInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerFrameTouchInfo$handle() {
        return GetPointerFrameTouchInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MemorySegment GetPointerFrameTouchInfo$address() {
        return GetPointerFrameTouchInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerFrameTouchInfo(int pointerId, MemorySegment pointerCount, MemorySegment touchInfo) {
        var mh$ = GetPointerFrameTouchInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameTouchInfo", pointerId, pointerCount, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerCount, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameTouchInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerFrameTouchInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameTouchInfoHistory$descriptor() {
        return GetPointerFrameTouchInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerFrameTouchInfoHistory$handle() {
        return GetPointerFrameTouchInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MemorySegment GetPointerFrameTouchInfoHistory$address() {
        return GetPointerFrameTouchInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerFrameTouchInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerCount, MemorySegment touchInfo) {
        var mh$ = GetPointerFrameTouchInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameTouchInfoHistory", pointerId, entriesCount, pointerCount, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerCount, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerPenInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerPenInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerPenInfo$descriptor() {
        return GetPointerPenInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerPenInfo$handle() {
        return GetPointerPenInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MemorySegment GetPointerPenInfo$address() {
        return GetPointerPenInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerPenInfo(int pointerId, MemorySegment penInfo) {
        var mh$ = GetPointerPenInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerPenInfo", pointerId, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerPenInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerPenInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerPenInfoHistory$descriptor() {
        return GetPointerPenInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerPenInfoHistory$handle() {
        return GetPointerPenInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MemorySegment GetPointerPenInfoHistory$address() {
        return GetPointerPenInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerPenInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment penInfo) {
        var mh$ = GetPointerPenInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerPenInfoHistory", pointerId, entriesCount, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFramePenInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerFramePenInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFramePenInfo$descriptor() {
        return GetPointerFramePenInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerFramePenInfo$handle() {
        return GetPointerFramePenInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MemorySegment GetPointerFramePenInfo$address() {
        return GetPointerFramePenInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerFramePenInfo(int pointerId, MemorySegment pointerCount, MemorySegment penInfo) {
        var mh$ = GetPointerFramePenInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFramePenInfo", pointerId, pointerCount, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerCount, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFramePenInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerFramePenInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFramePenInfoHistory$descriptor() {
        return GetPointerFramePenInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerFramePenInfoHistory$handle() {
        return GetPointerFramePenInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MemorySegment GetPointerFramePenInfoHistory$address() {
        return GetPointerFramePenInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerFramePenInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerCount, MemorySegment penInfo) {
        var mh$ = GetPointerFramePenInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFramePenInfoHistory", pointerId, entriesCount, pointerCount, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerCount, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SkipPointerFrameMessages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SkipPointerFrameMessages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SkipPointerFrameMessages(UINT32 pointerId)
     * }
     */
    public static FunctionDescriptor SkipPointerFrameMessages$descriptor() {
        return SkipPointerFrameMessages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SkipPointerFrameMessages(UINT32 pointerId)
     * }
     */
    public static MethodHandle SkipPointerFrameMessages$handle() {
        return SkipPointerFrameMessages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SkipPointerFrameMessages(UINT32 pointerId)
     * }
     */
    public static MemorySegment SkipPointerFrameMessages$address() {
        return SkipPointerFrameMessages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SkipPointerFrameMessages(UINT32 pointerId)
     * }
     */
    public static int SkipPointerFrameMessages(int pointerId) {
        var mh$ = SkipPointerFrameMessages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SkipPointerFrameMessages", pointerId);
            }
            return (int)mh$.invokeExact(pointerId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterPointerInputTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterPointerInputTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static FunctionDescriptor RegisterPointerInputTarget$descriptor() {
        return RegisterPointerInputTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MethodHandle RegisterPointerInputTarget$handle() {
        return RegisterPointerInputTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MemorySegment RegisterPointerInputTarget$address() {
        return RegisterPointerInputTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static int RegisterPointerInputTarget(MemorySegment hwnd, int pointerType) {
        var mh$ = RegisterPointerInputTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterPointerInputTarget", hwnd, pointerType);
            }
            return (int)mh$.invokeExact(hwnd, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterPointerInputTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterPointerInputTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static FunctionDescriptor UnregisterPointerInputTarget$descriptor() {
        return UnregisterPointerInputTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MethodHandle UnregisterPointerInputTarget$handle() {
        return UnregisterPointerInputTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MemorySegment UnregisterPointerInputTarget$address() {
        return UnregisterPointerInputTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static int UnregisterPointerInputTarget(MemorySegment hwnd, int pointerType) {
        var mh$ = UnregisterPointerInputTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterPointerInputTarget", hwnd, pointerType);
            }
            return (int)mh$.invokeExact(hwnd, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterPointerInputTargetEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterPointerInputTargetEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve)
     * }
     */
    public static FunctionDescriptor RegisterPointerInputTargetEx$descriptor() {
        return RegisterPointerInputTargetEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve)
     * }
     */
    public static MethodHandle RegisterPointerInputTargetEx$handle() {
        return RegisterPointerInputTargetEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve)
     * }
     */
    public static MemorySegment RegisterPointerInputTargetEx$address() {
        return RegisterPointerInputTargetEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve)
     * }
     */
    public static int RegisterPointerInputTargetEx(MemorySegment hwnd, int pointerType, int fObserve) {
        var mh$ = RegisterPointerInputTargetEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterPointerInputTargetEx", hwnd, pointerType, fObserve);
            }
            return (int)mh$.invokeExact(hwnd, pointerType, fObserve);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterPointerInputTargetEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterPointerInputTargetEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static FunctionDescriptor UnregisterPointerInputTargetEx$descriptor() {
        return UnregisterPointerInputTargetEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MethodHandle UnregisterPointerInputTargetEx$handle() {
        return UnregisterPointerInputTargetEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MemorySegment UnregisterPointerInputTargetEx$address() {
        return UnregisterPointerInputTargetEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static int UnregisterPointerInputTargetEx(MemorySegment hwnd, int pointerType) {
        var mh$ = UnregisterPointerInputTargetEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterPointerInputTargetEx", hwnd, pointerType);
            }
            return (int)mh$.invokeExact(hwnd, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HSYNTHETICPOINTERDEVICE__ {
     *     int unused;
     * } *HSYNTHETICPOINTERDEVICE
     * }
     */
    public static final AddressLayout HSYNTHETICPOINTERDEVICE = freeglut_h.C_POINTER;

    private static class CreateSyntheticPointerDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateSyntheticPointerDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode)
     * }
     */
    public static FunctionDescriptor CreateSyntheticPointerDevice$descriptor() {
        return CreateSyntheticPointerDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode)
     * }
     */
    public static MethodHandle CreateSyntheticPointerDevice$handle() {
        return CreateSyntheticPointerDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode)
     * }
     */
    public static MemorySegment CreateSyntheticPointerDevice$address() {
        return CreateSyntheticPointerDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode)
     * }
     */
    public static MemorySegment CreateSyntheticPointerDevice(int pointerType, int maxCount, int mode) {
        var mh$ = CreateSyntheticPointerDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSyntheticPointerDevice", pointerType, maxCount, mode);
            }
            return (MemorySegment)mh$.invokeExact(pointerType, maxCount, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InjectSyntheticPointerInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InjectSyntheticPointerInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO *pointerInfo, UINT32 count)
     * }
     */
    public static FunctionDescriptor InjectSyntheticPointerInput$descriptor() {
        return InjectSyntheticPointerInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO *pointerInfo, UINT32 count)
     * }
     */
    public static MethodHandle InjectSyntheticPointerInput$handle() {
        return InjectSyntheticPointerInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO *pointerInfo, UINT32 count)
     * }
     */
    public static MemorySegment InjectSyntheticPointerInput$address() {
        return InjectSyntheticPointerInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO *pointerInfo, UINT32 count)
     * }
     */
    public static int InjectSyntheticPointerInput(MemorySegment device, MemorySegment pointerInfo, int count) {
        var mh$ = InjectSyntheticPointerInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InjectSyntheticPointerInput", device, pointerInfo, count);
            }
            return (int)mh$.invokeExact(device, pointerInfo, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroySyntheticPointerDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DestroySyntheticPointerDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device)
     * }
     */
    public static FunctionDescriptor DestroySyntheticPointerDevice$descriptor() {
        return DestroySyntheticPointerDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device)
     * }
     */
    public static MethodHandle DestroySyntheticPointerDevice$handle() {
        return DestroySyntheticPointerDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device)
     * }
     */
    public static MemorySegment DestroySyntheticPointerDevice$address() {
        return DestroySyntheticPointerDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device)
     * }
     */
    public static void DestroySyntheticPointerDevice(MemorySegment device) {
        var mh$ = DestroySyntheticPointerDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroySyntheticPointerDevice", device);
            }
            mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableMouseInPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnableMouseInPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointer(BOOL fEnable)
     * }
     */
    public static FunctionDescriptor EnableMouseInPointer$descriptor() {
        return EnableMouseInPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointer(BOOL fEnable)
     * }
     */
    public static MethodHandle EnableMouseInPointer$handle() {
        return EnableMouseInPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointer(BOOL fEnable)
     * }
     */
    public static MemorySegment EnableMouseInPointer$address() {
        return EnableMouseInPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnableMouseInPointer(BOOL fEnable)
     * }
     */
    public static int EnableMouseInPointer(int fEnable) {
        var mh$ = EnableMouseInPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableMouseInPointer", fEnable);
            }
            return (int)mh$.invokeExact(fEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMouseInPointerEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsMouseInPointerEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsMouseInPointerEnabled()
     * }
     */
    public static FunctionDescriptor IsMouseInPointerEnabled$descriptor() {
        return IsMouseInPointerEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsMouseInPointerEnabled()
     * }
     */
    public static MethodHandle IsMouseInPointerEnabled$handle() {
        return IsMouseInPointerEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsMouseInPointerEnabled()
     * }
     */
    public static MemorySegment IsMouseInPointerEnabled$address() {
        return IsMouseInPointerEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsMouseInPointerEnabled()
     * }
     */
    public static int IsMouseInPointerEnabled() {
        var mh$ = IsMouseInPointerEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMouseInPointerEnabled");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableMouseInPointerForThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnableMouseInPointerForThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointerForThread()
     * }
     */
    public static FunctionDescriptor EnableMouseInPointerForThread$descriptor() {
        return EnableMouseInPointerForThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointerForThread()
     * }
     */
    public static MethodHandle EnableMouseInPointerForThread$handle() {
        return EnableMouseInPointerForThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointerForThread()
     * }
     */
    public static MemorySegment EnableMouseInPointerForThread$address() {
        return EnableMouseInPointerForThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnableMouseInPointerForThread()
     * }
     */
    public static int EnableMouseInPointerForThread() {
        var mh$ = EnableMouseInPointerForThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableMouseInPointerForThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterTouchHitTestingWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterTouchHitTestingWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterTouchHitTestingWindow(HWND hwnd, ULONG value)
     * }
     */
    public static FunctionDescriptor RegisterTouchHitTestingWindow$descriptor() {
        return RegisterTouchHitTestingWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterTouchHitTestingWindow(HWND hwnd, ULONG value)
     * }
     */
    public static MethodHandle RegisterTouchHitTestingWindow$handle() {
        return RegisterTouchHitTestingWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterTouchHitTestingWindow(HWND hwnd, ULONG value)
     * }
     */
    public static MemorySegment RegisterTouchHitTestingWindow$address() {
        return RegisterTouchHitTestingWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterTouchHitTestingWindow(HWND hwnd, ULONG value)
     * }
     */
    public static int RegisterTouchHitTestingWindow(MemorySegment hwnd, int value) {
        var mh$ = RegisterTouchHitTestingWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterTouchHitTestingWindow", hwnd, value);
            }
            return (int)mh$.invokeExact(hwnd, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION {
     *     UINT16 score;
     *     POINT adjustedPoint;
     * } *PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION
     * }
     */
    public static final AddressLayout PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTOUCH_HIT_TESTING_INPUT {
     *     UINT32 pointerId;
     *     POINT point;
     *     RECT boundingBox;
     *     RECT nonOccludedBoundingBox;
     *     UINT32 orientation;
     * } *PTOUCH_HIT_TESTING_INPUT
     * }
     */
    public static final AddressLayout PTOUCH_HIT_TESTING_INPUT = freeglut_h.C_POINTER;

    private static class EvaluateProximityToRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EvaluateProximityToRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToRect(const RECT *controlBoundingBox, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static FunctionDescriptor EvaluateProximityToRect$descriptor() {
        return EvaluateProximityToRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToRect(const RECT *controlBoundingBox, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MethodHandle EvaluateProximityToRect$handle() {
        return EvaluateProximityToRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToRect(const RECT *controlBoundingBox, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MemorySegment EvaluateProximityToRect$address() {
        return EvaluateProximityToRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EvaluateProximityToRect(const RECT *controlBoundingBox, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static int EvaluateProximityToRect(MemorySegment controlBoundingBox, MemorySegment pHitTestingInput, MemorySegment pProximityEval) {
        var mh$ = EvaluateProximityToRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EvaluateProximityToRect", controlBoundingBox, pHitTestingInput, pProximityEval);
            }
            return (int)mh$.invokeExact(controlBoundingBox, pHitTestingInput, pProximityEval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EvaluateProximityToPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EvaluateProximityToPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToPolygon(UINT32 numVertices, const POINT *controlPolygon, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static FunctionDescriptor EvaluateProximityToPolygon$descriptor() {
        return EvaluateProximityToPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToPolygon(UINT32 numVertices, const POINT *controlPolygon, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MethodHandle EvaluateProximityToPolygon$handle() {
        return EvaluateProximityToPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToPolygon(UINT32 numVertices, const POINT *controlPolygon, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MemorySegment EvaluateProximityToPolygon$address() {
        return EvaluateProximityToPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EvaluateProximityToPolygon(UINT32 numVertices, const POINT *controlPolygon, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static int EvaluateProximityToPolygon(int numVertices, MemorySegment controlPolygon, MemorySegment pHitTestingInput, MemorySegment pProximityEval) {
        var mh$ = EvaluateProximityToPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EvaluateProximityToPolygon", numVertices, controlPolygon, pHitTestingInput, pProximityEval);
            }
            return (int)mh$.invokeExact(numVertices, controlPolygon, pHitTestingInput, pProximityEval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PackTouchHitTestingProximityEvaluation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PackTouchHitTestingProximityEvaluation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static FunctionDescriptor PackTouchHitTestingProximityEvaluation$descriptor() {
        return PackTouchHitTestingProximityEvaluation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MethodHandle PackTouchHitTestingProximityEvaluation$handle() {
        return PackTouchHitTestingProximityEvaluation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MemorySegment PackTouchHitTestingProximityEvaluation$address() {
        return PackTouchHitTestingProximityEvaluation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static long PackTouchHitTestingProximityEvaluation(MemorySegment pHitTestingInput, MemorySegment pProximityEval) {
        var mh$ = PackTouchHitTestingProximityEvaluation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PackTouchHitTestingProximityEvaluation", pHitTestingInput, pProximityEval);
            }
            return (long)mh$.invokeExact(pHitTestingInput, pProximityEval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FEEDBACK_TOUCH_CONTACTVISUALIZATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1
     * }
     */
    public static int FEEDBACK_TOUCH_CONTACTVISUALIZATION() {
        return FEEDBACK_TOUCH_CONTACTVISUALIZATION;
    }
    private static final int FEEDBACK_PEN_BARRELVISUALIZATION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_BARRELVISUALIZATION = 2
     * }
     */
    public static int FEEDBACK_PEN_BARRELVISUALIZATION() {
        return FEEDBACK_PEN_BARRELVISUALIZATION;
    }
    private static final int FEEDBACK_PEN_TAP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_TAP = 3
     * }
     */
    public static int FEEDBACK_PEN_TAP() {
        return FEEDBACK_PEN_TAP;
    }
    private static final int FEEDBACK_PEN_DOUBLETAP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_DOUBLETAP = 4
     * }
     */
    public static int FEEDBACK_PEN_DOUBLETAP() {
        return FEEDBACK_PEN_DOUBLETAP;
    }
    private static final int FEEDBACK_PEN_PRESSANDHOLD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_PRESSANDHOLD = 5
     * }
     */
    public static int FEEDBACK_PEN_PRESSANDHOLD() {
        return FEEDBACK_PEN_PRESSANDHOLD;
    }
    private static final int FEEDBACK_PEN_RIGHTTAP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_RIGHTTAP = 6
     * }
     */
    public static int FEEDBACK_PEN_RIGHTTAP() {
        return FEEDBACK_PEN_RIGHTTAP;
    }
    private static final int FEEDBACK_TOUCH_TAP = (int)7L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_TAP = 7
     * }
     */
    public static int FEEDBACK_TOUCH_TAP() {
        return FEEDBACK_TOUCH_TAP;
    }
    private static final int FEEDBACK_TOUCH_DOUBLETAP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_DOUBLETAP = 8
     * }
     */
    public static int FEEDBACK_TOUCH_DOUBLETAP() {
        return FEEDBACK_TOUCH_DOUBLETAP;
    }
    private static final int FEEDBACK_TOUCH_PRESSANDHOLD = (int)9L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_PRESSANDHOLD = 9
     * }
     */
    public static int FEEDBACK_TOUCH_PRESSANDHOLD() {
        return FEEDBACK_TOUCH_PRESSANDHOLD;
    }
    private static final int FEEDBACK_TOUCH_RIGHTTAP = (int)10L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_RIGHTTAP = 10
     * }
     */
    public static int FEEDBACK_TOUCH_RIGHTTAP() {
        return FEEDBACK_TOUCH_RIGHTTAP;
    }
    private static final int FEEDBACK_GESTURE_PRESSANDTAP = (int)11L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_GESTURE_PRESSANDTAP = 11
     * }
     */
    public static int FEEDBACK_GESTURE_PRESSANDTAP() {
        return FEEDBACK_GESTURE_PRESSANDTAP;
    }
    private static final int FEEDBACK_MAX = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_MAX = -1
     * }
     */
    public static int FEEDBACK_MAX() {
        return FEEDBACK_MAX;
    }

    private static class GetWindowFeedbackSetting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowFeedbackSetting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 *pSize, void *config)
     * }
     */
    public static FunctionDescriptor GetWindowFeedbackSetting$descriptor() {
        return GetWindowFeedbackSetting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 *pSize, void *config)
     * }
     */
    public static MethodHandle GetWindowFeedbackSetting$handle() {
        return GetWindowFeedbackSetting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 *pSize, void *config)
     * }
     */
    public static MemorySegment GetWindowFeedbackSetting$address() {
        return GetWindowFeedbackSetting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 *pSize, void *config)
     * }
     */
    public static int GetWindowFeedbackSetting(MemorySegment hwnd, int feedback, int dwFlags, MemorySegment pSize, MemorySegment config) {
        var mh$ = GetWindowFeedbackSetting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowFeedbackSetting", hwnd, feedback, dwFlags, pSize, config);
            }
            return (int)mh$.invokeExact(hwnd, feedback, dwFlags, pSize, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowFeedbackSetting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowFeedbackSetting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void *configuration)
     * }
     */
    public static FunctionDescriptor SetWindowFeedbackSetting$descriptor() {
        return SetWindowFeedbackSetting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void *configuration)
     * }
     */
    public static MethodHandle SetWindowFeedbackSetting$handle() {
        return SetWindowFeedbackSetting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void *configuration)
     * }
     */
    public static MemorySegment SetWindowFeedbackSetting$address() {
        return SetWindowFeedbackSetting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void *configuration)
     * }
     */
    public static int SetWindowFeedbackSetting(MemorySegment hwnd, int feedback, int dwFlags, int size, MemorySegment configuration) {
        var mh$ = SetWindowFeedbackSetting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowFeedbackSetting", hwnd, feedback, dwFlags, size, configuration);
            }
            return (int)mh$.invokeExact(hwnd, feedback, dwFlags, size, configuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerInputTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerInputTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform)
     * }
     */
    public static FunctionDescriptor GetPointerInputTransform$descriptor() {
        return GetPointerInputTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform)
     * }
     */
    public static MethodHandle GetPointerInputTransform$handle() {
        return GetPointerInputTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform)
     * }
     */
    public static MemorySegment GetPointerInputTransform$address() {
        return GetPointerInputTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform)
     * }
     */
    public static int GetPointerInputTransform(int pointerId, int historyCount, MemorySegment inputTransform) {
        var mh$ = GetPointerInputTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerInputTransform", pointerId, historyCount, inputTransform);
            }
            return (int)mh$.invokeExact(pointerId, historyCount, inputTransform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagLASTINPUTINFO {
     *     UINT cbSize;
     *     DWORD dwTime;
     * } *PLASTINPUTINFO
     * }
     */
    public static final AddressLayout PLASTINPUTINFO = freeglut_h.C_POINTER;

    private static class GetLastInputInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLastInputInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLastInputInfo(PLASTINPUTINFO plii)
     * }
     */
    public static FunctionDescriptor GetLastInputInfo$descriptor() {
        return GetLastInputInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLastInputInfo(PLASTINPUTINFO plii)
     * }
     */
    public static MethodHandle GetLastInputInfo$handle() {
        return GetLastInputInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLastInputInfo(PLASTINPUTINFO plii)
     * }
     */
    public static MemorySegment GetLastInputInfo$address() {
        return GetLastInputInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLastInputInfo(PLASTINPUTINFO plii)
     * }
     */
    public static int GetLastInputInfo(MemorySegment plii) {
        var mh$ = GetLastInputInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastInputInfo", plii);
            }
            return (int)mh$.invokeExact(plii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapVirtualKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyA(UINT uCode, UINT uMapType)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyA$descriptor() {
        return MapVirtualKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyA(UINT uCode, UINT uMapType)
     * }
     */
    public static MethodHandle MapVirtualKeyA$handle() {
        return MapVirtualKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyA(UINT uCode, UINT uMapType)
     * }
     */
    public static MemorySegment MapVirtualKeyA$address() {
        return MapVirtualKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyA(UINT uCode, UINT uMapType)
     * }
     */
    public static int MapVirtualKeyA(int uCode, int uMapType) {
        var mh$ = MapVirtualKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyA", uCode, uMapType);
            }
            return (int)mh$.invokeExact(uCode, uMapType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapVirtualKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyW(UINT uCode, UINT uMapType)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyW$descriptor() {
        return MapVirtualKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyW(UINT uCode, UINT uMapType)
     * }
     */
    public static MethodHandle MapVirtualKeyW$handle() {
        return MapVirtualKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyW(UINT uCode, UINT uMapType)
     * }
     */
    public static MemorySegment MapVirtualKeyW$address() {
        return MapVirtualKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyW(UINT uCode, UINT uMapType)
     * }
     */
    public static int MapVirtualKeyW(int uCode, int uMapType) {
        var mh$ = MapVirtualKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyW", uCode, uMapType);
            }
            return (int)mh$.invokeExact(uCode, uMapType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapVirtualKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyExA$descriptor() {
        return MapVirtualKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static MethodHandle MapVirtualKeyExA$handle() {
        return MapVirtualKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static MemorySegment MapVirtualKeyExA$address() {
        return MapVirtualKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static int MapVirtualKeyExA(int uCode, int uMapType, MemorySegment dwhkl) {
        var mh$ = MapVirtualKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyExA", uCode, uMapType, dwhkl);
            }
            return (int)mh$.invokeExact(uCode, uMapType, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapVirtualKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyExW$descriptor() {
        return MapVirtualKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static MethodHandle MapVirtualKeyExW$handle() {
        return MapVirtualKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static MemorySegment MapVirtualKeyExW$address() {
        return MapVirtualKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static int MapVirtualKeyExW(int uCode, int uMapType, MemorySegment dwhkl) {
        var mh$ = MapVirtualKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyExW", uCode, uMapType, dwhkl);
            }
            return (int)mh$.invokeExact(uCode, uMapType, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetInputState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetInputState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetInputState()
     * }
     */
    public static FunctionDescriptor GetInputState$descriptor() {
        return GetInputState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetInputState()
     * }
     */
    public static MethodHandle GetInputState$handle() {
        return GetInputState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetInputState()
     * }
     */
    public static MemorySegment GetInputState$address() {
        return GetInputState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetInputState()
     * }
     */
    public static int GetInputState() {
        var mh$ = GetInputState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetInputState");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueueStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetQueueStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetQueueStatus(UINT flags)
     * }
     */
    public static FunctionDescriptor GetQueueStatus$descriptor() {
        return GetQueueStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetQueueStatus(UINT flags)
     * }
     */
    public static MethodHandle GetQueueStatus$handle() {
        return GetQueueStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetQueueStatus(UINT flags)
     * }
     */
    public static MemorySegment GetQueueStatus$address() {
        return GetQueueStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetQueueStatus(UINT flags)
     * }
     */
    public static int GetQueueStatus(int flags) {
        var mh$ = GetQueueStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueueStatus", flags);
            }
            return (int)mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCapture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCapture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetCapture()
     * }
     */
    public static FunctionDescriptor GetCapture$descriptor() {
        return GetCapture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetCapture()
     * }
     */
    public static MethodHandle GetCapture$handle() {
        return GetCapture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetCapture()
     * }
     */
    public static MemorySegment GetCapture$address() {
        return GetCapture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetCapture()
     * }
     */
    public static MemorySegment GetCapture() {
        var mh$ = GetCapture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCapture");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCapture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCapture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetCapture(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetCapture$descriptor() {
        return SetCapture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetCapture(HWND hWnd)
     * }
     */
    public static MethodHandle SetCapture$handle() {
        return SetCapture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND SetCapture(HWND hWnd)
     * }
     */
    public static MemorySegment SetCapture$address() {
        return SetCapture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND SetCapture(HWND hWnd)
     * }
     */
    public static MemorySegment SetCapture(MemorySegment hWnd) {
        var mh$ = SetCapture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCapture", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseCapture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReleaseCapture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReleaseCapture()
     * }
     */
    public static FunctionDescriptor ReleaseCapture$descriptor() {
        return ReleaseCapture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReleaseCapture()
     * }
     */
    public static MethodHandle ReleaseCapture$handle() {
        return ReleaseCapture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReleaseCapture()
     * }
     */
    public static MemorySegment ReleaseCapture$address() {
        return ReleaseCapture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReleaseCapture()
     * }
     */
    public static int ReleaseCapture() {
        var mh$ = ReleaseCapture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseCapture");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MsgWaitForMultipleObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MsgWaitForMultipleObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
     * }
     */
    public static FunctionDescriptor MsgWaitForMultipleObjects$descriptor() {
        return MsgWaitForMultipleObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
     * }
     */
    public static MethodHandle MsgWaitForMultipleObjects$handle() {
        return MsgWaitForMultipleObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
     * }
     */
    public static MemorySegment MsgWaitForMultipleObjects$address() {
        return MsgWaitForMultipleObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
     * }
     */
    public static int MsgWaitForMultipleObjects(int nCount, MemorySegment pHandles, int fWaitAll, int dwMilliseconds, int dwWakeMask) {
        var mh$ = MsgWaitForMultipleObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MsgWaitForMultipleObjects", nCount, pHandles, fWaitAll, dwMilliseconds, dwWakeMask);
            }
            return (int)mh$.invokeExact(nCount, pHandles, fWaitAll, dwMilliseconds, dwWakeMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MsgWaitForMultipleObjectsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MsgWaitForMultipleObjectsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MsgWaitForMultipleObjectsEx$descriptor() {
        return MsgWaitForMultipleObjectsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags)
     * }
     */
    public static MethodHandle MsgWaitForMultipleObjectsEx$handle() {
        return MsgWaitForMultipleObjectsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags)
     * }
     */
    public static MemorySegment MsgWaitForMultipleObjectsEx$address() {
        return MsgWaitForMultipleObjectsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags)
     * }
     */
    public static int MsgWaitForMultipleObjectsEx(int nCount, MemorySegment pHandles, int dwMilliseconds, int dwWakeMask, int dwFlags) {
        var mh$ = MsgWaitForMultipleObjectsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MsgWaitForMultipleObjectsEx", nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags);
            }
            return (int)mh$.invokeExact(nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
     * }
     */
    public static FunctionDescriptor SetTimer$descriptor() {
        return SetTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
     * }
     */
    public static MethodHandle SetTimer$handle() {
        return SetTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
     * }
     */
    public static MemorySegment SetTimer$address() {
        return SetTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
     * }
     */
    public static long SetTimer(MemorySegment hWnd, long nIDEvent, int uElapse, MemorySegment lpTimerFunc) {
        var mh$ = SetTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTimer", hWnd, nIDEvent, uElapse, lpTimerFunc);
            }
            return (long)mh$.invokeExact(hWnd, nIDEvent, uElapse, lpTimerFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCoalescableTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCoalescableTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT_PTR SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay)
     * }
     */
    public static FunctionDescriptor SetCoalescableTimer$descriptor() {
        return SetCoalescableTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT_PTR SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay)
     * }
     */
    public static MethodHandle SetCoalescableTimer$handle() {
        return SetCoalescableTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT_PTR SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay)
     * }
     */
    public static MemorySegment SetCoalescableTimer$address() {
        return SetCoalescableTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT_PTR SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay)
     * }
     */
    public static long SetCoalescableTimer(MemorySegment hWnd, long nIDEvent, int uElapse, MemorySegment lpTimerFunc, int uToleranceDelay) {
        var mh$ = SetCoalescableTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCoalescableTimer", hWnd, nIDEvent, uElapse, lpTimerFunc, uToleranceDelay);
            }
            return (long)mh$.invokeExact(hWnd, nIDEvent, uElapse, lpTimerFunc, uToleranceDelay);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class KillTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("KillTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL KillTimer(HWND hWnd, UINT_PTR uIDEvent)
     * }
     */
    public static FunctionDescriptor KillTimer$descriptor() {
        return KillTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL KillTimer(HWND hWnd, UINT_PTR uIDEvent)
     * }
     */
    public static MethodHandle KillTimer$handle() {
        return KillTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL KillTimer(HWND hWnd, UINT_PTR uIDEvent)
     * }
     */
    public static MemorySegment KillTimer$address() {
        return KillTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL KillTimer(HWND hWnd, UINT_PTR uIDEvent)
     * }
     */
    public static int KillTimer(MemorySegment hWnd, long uIDEvent) {
        var mh$ = KillTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("KillTimer", hWnd, uIDEvent);
            }
            return (int)mh$.invokeExact(hWnd, uIDEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsWindowUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindowUnicode(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindowUnicode$descriptor() {
        return IsWindowUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindowUnicode(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindowUnicode$handle() {
        return IsWindowUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWindowUnicode(HWND hWnd)
     * }
     */
    public static MemorySegment IsWindowUnicode$address() {
        return IsWindowUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWindowUnicode(HWND hWnd)
     * }
     */
    public static int IsWindowUnicode(MemorySegment hWnd) {
        var mh$ = IsWindowUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowUnicode", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnableWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableWindow(HWND hWnd, BOOL bEnable)
     * }
     */
    public static FunctionDescriptor EnableWindow$descriptor() {
        return EnableWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableWindow(HWND hWnd, BOOL bEnable)
     * }
     */
    public static MethodHandle EnableWindow$handle() {
        return EnableWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnableWindow(HWND hWnd, BOOL bEnable)
     * }
     */
    public static MemorySegment EnableWindow$address() {
        return EnableWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnableWindow(HWND hWnd, BOOL bEnable)
     * }
     */
    public static int EnableWindow(MemorySegment hWnd, int bEnable) {
        var mh$ = EnableWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableWindow", hWnd, bEnable);
            }
            return (int)mh$.invokeExact(hWnd, bEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsWindowEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindowEnabled(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindowEnabled$descriptor() {
        return IsWindowEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindowEnabled(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindowEnabled$handle() {
        return IsWindowEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWindowEnabled(HWND hWnd)
     * }
     */
    public static MemorySegment IsWindowEnabled$address() {
        return IsWindowEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWindowEnabled(HWND hWnd)
     * }
     */
    public static int IsWindowEnabled(MemorySegment hWnd) {
        var mh$ = IsWindowEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowEnabled", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadAcceleratorsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadAcceleratorsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName)
     * }
     */
    public static FunctionDescriptor LoadAcceleratorsA$descriptor() {
        return LoadAcceleratorsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName)
     * }
     */
    public static MethodHandle LoadAcceleratorsA$handle() {
        return LoadAcceleratorsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName)
     * }
     */
    public static MemorySegment LoadAcceleratorsA$address() {
        return LoadAcceleratorsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName)
     * }
     */
    public static MemorySegment LoadAcceleratorsA(MemorySegment hInstance, MemorySegment lpTableName) {
        var mh$ = LoadAcceleratorsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadAcceleratorsA", hInstance, lpTableName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTableName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadAcceleratorsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadAcceleratorsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
     * }
     */
    public static FunctionDescriptor LoadAcceleratorsW$descriptor() {
        return LoadAcceleratorsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
     * }
     */
    public static MethodHandle LoadAcceleratorsW$handle() {
        return LoadAcceleratorsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
     * }
     */
    public static MemorySegment LoadAcceleratorsW$address() {
        return LoadAcceleratorsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
     * }
     */
    public static MemorySegment LoadAcceleratorsW(MemorySegment hInstance, MemorySegment lpTableName) {
        var mh$ = LoadAcceleratorsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadAcceleratorsW", hInstance, lpTableName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTableName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateAcceleratorTableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateAcceleratorTableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableA(LPACCEL paccel, int cAccel)
     * }
     */
    public static FunctionDescriptor CreateAcceleratorTableA$descriptor() {
        return CreateAcceleratorTableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableA(LPACCEL paccel, int cAccel)
     * }
     */
    public static MethodHandle CreateAcceleratorTableA$handle() {
        return CreateAcceleratorTableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableA(LPACCEL paccel, int cAccel)
     * }
     */
    public static MemorySegment CreateAcceleratorTableA$address() {
        return CreateAcceleratorTableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableA(LPACCEL paccel, int cAccel)
     * }
     */
    public static MemorySegment CreateAcceleratorTableA(MemorySegment paccel, int cAccel) {
        var mh$ = CreateAcceleratorTableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateAcceleratorTableA", paccel, cAccel);
            }
            return (MemorySegment)mh$.invokeExact(paccel, cAccel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateAcceleratorTableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateAcceleratorTableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableW(LPACCEL paccel, int cAccel)
     * }
     */
    public static FunctionDescriptor CreateAcceleratorTableW$descriptor() {
        return CreateAcceleratorTableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableW(LPACCEL paccel, int cAccel)
     * }
     */
    public static MethodHandle CreateAcceleratorTableW$handle() {
        return CreateAcceleratorTableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableW(LPACCEL paccel, int cAccel)
     * }
     */
    public static MemorySegment CreateAcceleratorTableW$address() {
        return CreateAcceleratorTableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableW(LPACCEL paccel, int cAccel)
     * }
     */
    public static MemorySegment CreateAcceleratorTableW(MemorySegment paccel, int cAccel) {
        var mh$ = CreateAcceleratorTableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateAcceleratorTableW", paccel, cAccel);
            }
            return (MemorySegment)mh$.invokeExact(paccel, cAccel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyAcceleratorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DestroyAcceleratorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyAcceleratorTable(HACCEL hAccel)
     * }
     */
    public static FunctionDescriptor DestroyAcceleratorTable$descriptor() {
        return DestroyAcceleratorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyAcceleratorTable(HACCEL hAccel)
     * }
     */
    public static MethodHandle DestroyAcceleratorTable$handle() {
        return DestroyAcceleratorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DestroyAcceleratorTable(HACCEL hAccel)
     * }
     */
    public static MemorySegment DestroyAcceleratorTable$address() {
        return DestroyAcceleratorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DestroyAcceleratorTable(HACCEL hAccel)
     * }
     */
    public static int DestroyAcceleratorTable(MemorySegment hAccel) {
        var mh$ = DestroyAcceleratorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyAcceleratorTable", hAccel);
            }
            return (int)mh$.invokeExact(hAccel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyAcceleratorTableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyAcceleratorTableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static FunctionDescriptor CopyAcceleratorTableA$descriptor() {
        return CopyAcceleratorTableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static MethodHandle CopyAcceleratorTableA$handle() {
        return CopyAcceleratorTableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static MemorySegment CopyAcceleratorTableA$address() {
        return CopyAcceleratorTableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static int CopyAcceleratorTableA(MemorySegment hAccelSrc, MemorySegment lpAccelDst, int cAccelEntries) {
        var mh$ = CopyAcceleratorTableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyAcceleratorTableA", hAccelSrc, lpAccelDst, cAccelEntries);
            }
            return (int)mh$.invokeExact(hAccelSrc, lpAccelDst, cAccelEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyAcceleratorTableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyAcceleratorTableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static FunctionDescriptor CopyAcceleratorTableW$descriptor() {
        return CopyAcceleratorTableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static MethodHandle CopyAcceleratorTableW$handle() {
        return CopyAcceleratorTableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static MemorySegment CopyAcceleratorTableW$address() {
        return CopyAcceleratorTableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static int CopyAcceleratorTableW(MemorySegment hAccelSrc, MemorySegment lpAccelDst, int cAccelEntries) {
        var mh$ = CopyAcceleratorTableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyAcceleratorTableW", hAccelSrc, lpAccelDst, cAccelEntries);
            }
            return (int)mh$.invokeExact(hAccelSrc, lpAccelDst, cAccelEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateAcceleratorA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TranslateAcceleratorA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor TranslateAcceleratorA$descriptor() {
        return TranslateAcceleratorA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static MethodHandle TranslateAcceleratorA$handle() {
        return TranslateAcceleratorA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static MemorySegment TranslateAcceleratorA$address() {
        return TranslateAcceleratorA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static int TranslateAcceleratorA(MemorySegment hWnd, MemorySegment hAccTable, MemorySegment lpMsg) {
        var mh$ = TranslateAcceleratorA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateAcceleratorA", hWnd, hAccTable, lpMsg);
            }
            return (int)mh$.invokeExact(hWnd, hAccTable, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateAcceleratorW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TranslateAcceleratorW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor TranslateAcceleratorW$descriptor() {
        return TranslateAcceleratorW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static MethodHandle TranslateAcceleratorW$handle() {
        return TranslateAcceleratorW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static MemorySegment TranslateAcceleratorW$address() {
        return TranslateAcceleratorW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static int TranslateAcceleratorW(MemorySegment hWnd, MemorySegment hAccTable, MemorySegment lpMsg) {
        var mh$ = TranslateAcceleratorW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateAcceleratorW", hWnd, hAccTable, lpMsg);
            }
            return (int)mh$.invokeExact(hWnd, hAccTable, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemMetrics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemMetrics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetSystemMetrics(int nIndex)
     * }
     */
    public static FunctionDescriptor GetSystemMetrics$descriptor() {
        return GetSystemMetrics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetSystemMetrics(int nIndex)
     * }
     */
    public static MethodHandle GetSystemMetrics$handle() {
        return GetSystemMetrics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetSystemMetrics(int nIndex)
     * }
     */
    public static MemorySegment GetSystemMetrics$address() {
        return GetSystemMetrics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetSystemMetrics(int nIndex)
     * }
     */
    public static int GetSystemMetrics(int nIndex) {
        var mh$ = GetSystemMetrics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemMetrics", nIndex);
            }
            return (int)mh$.invokeExact(nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemMetricsForDpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemMetricsForDpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetSystemMetricsForDpi(int nIndex, UINT dpi)
     * }
     */
    public static FunctionDescriptor GetSystemMetricsForDpi$descriptor() {
        return GetSystemMetricsForDpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetSystemMetricsForDpi(int nIndex, UINT dpi)
     * }
     */
    public static MethodHandle GetSystemMetricsForDpi$handle() {
        return GetSystemMetricsForDpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetSystemMetricsForDpi(int nIndex, UINT dpi)
     * }
     */
    public static MemorySegment GetSystemMetricsForDpi$address() {
        return GetSystemMetricsForDpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetSystemMetricsForDpi(int nIndex, UINT dpi)
     * }
     */
    public static int GetSystemMetricsForDpi(int nIndex, int dpi) {
        var mh$ = GetSystemMetricsForDpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemMetricsForDpi", nIndex, dpi);
            }
            return (int)mh$.invokeExact(nIndex, dpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadMenuA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName)
     * }
     */
    public static FunctionDescriptor LoadMenuA$descriptor() {
        return LoadMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName)
     * }
     */
    public static MethodHandle LoadMenuA$handle() {
        return LoadMenuA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName)
     * }
     */
    public static MemorySegment LoadMenuA$address() {
        return LoadMenuA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName)
     * }
     */
    public static MemorySegment LoadMenuA(MemorySegment hInstance, MemorySegment lpMenuName) {
        var mh$ = LoadMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuA", hInstance, lpMenuName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpMenuName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadMenuW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
     * }
     */
    public static FunctionDescriptor LoadMenuW$descriptor() {
        return LoadMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
     * }
     */
    public static MethodHandle LoadMenuW$handle() {
        return LoadMenuW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
     * }
     */
    public static MemorySegment LoadMenuW$address() {
        return LoadMenuW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
     * }
     */
    public static MemorySegment LoadMenuW(MemorySegment hInstance, MemorySegment lpMenuName) {
        var mh$ = LoadMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuW", hInstance, lpMenuName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpMenuName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuIndirectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadMenuIndirectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectA(const MENUTEMPLATEA *lpMenuTemplate)
     * }
     */
    public static FunctionDescriptor LoadMenuIndirectA$descriptor() {
        return LoadMenuIndirectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectA(const MENUTEMPLATEA *lpMenuTemplate)
     * }
     */
    public static MethodHandle LoadMenuIndirectA$handle() {
        return LoadMenuIndirectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectA(const MENUTEMPLATEA *lpMenuTemplate)
     * }
     */
    public static MemorySegment LoadMenuIndirectA$address() {
        return LoadMenuIndirectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectA(const MENUTEMPLATEA *lpMenuTemplate)
     * }
     */
    public static MemorySegment LoadMenuIndirectA(MemorySegment lpMenuTemplate) {
        var mh$ = LoadMenuIndirectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuIndirectA", lpMenuTemplate);
            }
            return (MemorySegment)mh$.invokeExact(lpMenuTemplate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuIndirectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadMenuIndirectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectW(const MENUTEMPLATEW *lpMenuTemplate)
     * }
     */
    public static FunctionDescriptor LoadMenuIndirectW$descriptor() {
        return LoadMenuIndirectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectW(const MENUTEMPLATEW *lpMenuTemplate)
     * }
     */
    public static MethodHandle LoadMenuIndirectW$handle() {
        return LoadMenuIndirectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectW(const MENUTEMPLATEW *lpMenuTemplate)
     * }
     */
    public static MemorySegment LoadMenuIndirectW$address() {
        return LoadMenuIndirectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectW(const MENUTEMPLATEW *lpMenuTemplate)
     * }
     */
    public static MemorySegment LoadMenuIndirectW(MemorySegment lpMenuTemplate) {
        var mh$ = LoadMenuIndirectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuIndirectW", lpMenuTemplate);
            }
            return (MemorySegment)mh$.invokeExact(lpMenuTemplate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU GetMenu(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetMenu$descriptor() {
        return GetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU GetMenu(HWND hWnd)
     * }
     */
    public static MethodHandle GetMenu$handle() {
        return GetMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU GetMenu(HWND hWnd)
     * }
     */
    public static MemorySegment GetMenu$address() {
        return GetMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU GetMenu(HWND hWnd)
     * }
     */
    public static MemorySegment GetMenu(MemorySegment hWnd) {
        var mh$ = GetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenu", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenu(HWND hWnd, HMENU hMenu)
     * }
     */
    public static FunctionDescriptor SetMenu$descriptor() {
        return SetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenu(HWND hWnd, HMENU hMenu)
     * }
     */
    public static MethodHandle SetMenu$handle() {
        return SetMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenu(HWND hWnd, HMENU hMenu)
     * }
     */
    public static MemorySegment SetMenu$address() {
        return SetMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenu(HWND hWnd, HMENU hMenu)
     * }
     */
    public static int SetMenu(MemorySegment hWnd, MemorySegment hMenu) {
        var mh$ = SetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenu", hWnd, hMenu);
            }
            return (int)mh$.invokeExact(hWnd, hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeMenuA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static FunctionDescriptor ChangeMenuA$descriptor() {
        return ChangeMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static MethodHandle ChangeMenuA$handle() {
        return ChangeMenuA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static MemorySegment ChangeMenuA$address() {
        return ChangeMenuA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static int ChangeMenuA(MemorySegment hMenu, int cmd, MemorySegment lpszNewItem, int cmdInsert, int flags) {
        var mh$ = ChangeMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeMenuA", hMenu, cmd, lpszNewItem, cmdInsert, flags);
            }
            return (int)mh$.invokeExact(hMenu, cmd, lpszNewItem, cmdInsert, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeMenuW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static FunctionDescriptor ChangeMenuW$descriptor() {
        return ChangeMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static MethodHandle ChangeMenuW$handle() {
        return ChangeMenuW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static MemorySegment ChangeMenuW$address() {
        return ChangeMenuW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static int ChangeMenuW(MemorySegment hMenu, int cmd, MemorySegment lpszNewItem, int cmdInsert, int flags) {
        var mh$ = ChangeMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeMenuW", hMenu, cmd, lpszNewItem, cmdInsert, flags);
            }
            return (int)mh$.invokeExact(hMenu, cmd, lpszNewItem, cmdInsert, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HiliteMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HiliteMenuItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite)
     * }
     */
    public static FunctionDescriptor HiliteMenuItem$descriptor() {
        return HiliteMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite)
     * }
     */
    public static MethodHandle HiliteMenuItem$handle() {
        return HiliteMenuItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite)
     * }
     */
    public static MemorySegment HiliteMenuItem$address() {
        return HiliteMenuItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite)
     * }
     */
    public static int HiliteMenuItem(MemorySegment hWnd, MemorySegment hMenu, int uIDHiliteItem, int uHilite) {
        var mh$ = HiliteMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HiliteMenuItem", hWnd, hMenu, uIDHiliteItem, uHilite);
            }
            return (int)mh$.invokeExact(hWnd, hMenu, uIDHiliteItem, uHilite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static FunctionDescriptor GetMenuStringA$descriptor() {
        return GetMenuStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static MethodHandle GetMenuStringA$handle() {
        return GetMenuStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static MemorySegment GetMenuStringA$address() {
        return GetMenuStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static int GetMenuStringA(MemorySegment hMenu, int uIDItem, MemorySegment lpString, int cchMax, int flags) {
        var mh$ = GetMenuStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuStringA", hMenu, uIDItem, lpString, cchMax, flags);
            }
            return (int)mh$.invokeExact(hMenu, uIDItem, lpString, cchMax, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static FunctionDescriptor GetMenuStringW$descriptor() {
        return GetMenuStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static MethodHandle GetMenuStringW$handle() {
        return GetMenuStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static MemorySegment GetMenuStringW$address() {
        return GetMenuStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static int GetMenuStringW(MemorySegment hMenu, int uIDItem, MemorySegment lpString, int cchMax, int flags) {
        var mh$ = GetMenuStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuStringW", hMenu, uIDItem, lpString, cchMax, flags);
            }
            return (int)mh$.invokeExact(hMenu, uIDItem, lpString, cchMax, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
     * }
     */
    public static FunctionDescriptor GetMenuState$descriptor() {
        return GetMenuState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
     * }
     */
    public static MethodHandle GetMenuState$handle() {
        return GetMenuState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
     * }
     */
    public static MemorySegment GetMenuState$address() {
        return GetMenuState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
     * }
     */
    public static int GetMenuState(MemorySegment hMenu, int uId, int uFlags) {
        var mh$ = GetMenuState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuState", hMenu, uId, uFlags);
            }
            return (int)mh$.invokeExact(hMenu, uId, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawMenuBar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawMenuBar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawMenuBar(HWND hWnd)
     * }
     */
    public static FunctionDescriptor DrawMenuBar$descriptor() {
        return DrawMenuBar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawMenuBar(HWND hWnd)
     * }
     */
    public static MethodHandle DrawMenuBar$handle() {
        return DrawMenuBar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawMenuBar(HWND hWnd)
     * }
     */
    public static MemorySegment DrawMenuBar$address() {
        return DrawMenuBar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawMenuBar(HWND hWnd)
     * }
     */
    public static int DrawMenuBar(MemorySegment hWnd) {
        var mh$ = DrawMenuBar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawMenuBar", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU GetSystemMenu(HWND hWnd, BOOL bRevert)
     * }
     */
    public static FunctionDescriptor GetSystemMenu$descriptor() {
        return GetSystemMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU GetSystemMenu(HWND hWnd, BOOL bRevert)
     * }
     */
    public static MethodHandle GetSystemMenu$handle() {
        return GetSystemMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU GetSystemMenu(HWND hWnd, BOOL bRevert)
     * }
     */
    public static MemorySegment GetSystemMenu$address() {
        return GetSystemMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU GetSystemMenu(HWND hWnd, BOOL bRevert)
     * }
     */
    public static MemorySegment GetSystemMenu(MemorySegment hWnd, int bRevert) {
        var mh$ = GetSystemMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemMenu", hWnd, bRevert);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, bRevert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU CreateMenu()
     * }
     */
    public static FunctionDescriptor CreateMenu$descriptor() {
        return CreateMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU CreateMenu()
     * }
     */
    public static MethodHandle CreateMenu$handle() {
        return CreateMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU CreateMenu()
     * }
     */
    public static MemorySegment CreateMenu$address() {
        return CreateMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU CreateMenu()
     * }
     */
    public static MemorySegment CreateMenu() {
        var mh$ = CreateMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMenu");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePopupMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePopupMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU CreatePopupMenu()
     * }
     */
    public static FunctionDescriptor CreatePopupMenu$descriptor() {
        return CreatePopupMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU CreatePopupMenu()
     * }
     */
    public static MethodHandle CreatePopupMenu$handle() {
        return CreatePopupMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU CreatePopupMenu()
     * }
     */
    public static MemorySegment CreatePopupMenu$address() {
        return CreatePopupMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU CreatePopupMenu()
     * }
     */
    public static MemorySegment CreatePopupMenu() {
        var mh$ = CreatePopupMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePopupMenu");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DestroyMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyMenu(HMENU hMenu)
     * }
     */
    public static FunctionDescriptor DestroyMenu$descriptor() {
        return DestroyMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyMenu(HMENU hMenu)
     * }
     */
    public static MethodHandle DestroyMenu$handle() {
        return DestroyMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DestroyMenu(HMENU hMenu)
     * }
     */
    public static MemorySegment DestroyMenu$address() {
        return DestroyMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DestroyMenu(HMENU hMenu)
     * }
     */
    public static int DestroyMenu(MemorySegment hMenu) {
        var mh$ = DestroyMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyMenu", hMenu);
            }
            return (int)mh$.invokeExact(hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckMenuItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
     * }
     */
    public static FunctionDescriptor CheckMenuItem$descriptor() {
        return CheckMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
     * }
     */
    public static MethodHandle CheckMenuItem$handle() {
        return CheckMenuItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
     * }
     */
    public static MemorySegment CheckMenuItem$address() {
        return CheckMenuItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
     * }
     */
    public static int CheckMenuItem(MemorySegment hMenu, int uIDCheckItem, int uCheck) {
        var mh$ = CheckMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckMenuItem", hMenu, uIDCheckItem, uCheck);
            }
            return (int)mh$.invokeExact(hMenu, uIDCheckItem, uCheck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnableMenuItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
     * }
     */
    public static FunctionDescriptor EnableMenuItem$descriptor() {
        return EnableMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
     * }
     */
    public static MethodHandle EnableMenuItem$handle() {
        return EnableMenuItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
     * }
     */
    public static MemorySegment EnableMenuItem$address() {
        return EnableMenuItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
     * }
     */
    public static int EnableMenuItem(MemorySegment hMenu, int uIDEnableItem, int uEnable) {
        var mh$ = EnableMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableMenuItem", hMenu, uIDEnableItem, uEnable);
            }
            return (int)mh$.invokeExact(hMenu, uIDEnableItem, uEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSubMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSubMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU GetSubMenu(HMENU hMenu, int nPos)
     * }
     */
    public static FunctionDescriptor GetSubMenu$descriptor() {
        return GetSubMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU GetSubMenu(HMENU hMenu, int nPos)
     * }
     */
    public static MethodHandle GetSubMenu$handle() {
        return GetSubMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU GetSubMenu(HMENU hMenu, int nPos)
     * }
     */
    public static MemorySegment GetSubMenu$address() {
        return GetSubMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU GetSubMenu(HMENU hMenu, int nPos)
     * }
     */
    public static MemorySegment GetSubMenu(MemorySegment hMenu, int nPos) {
        var mh$ = GetSubMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSubMenu", hMenu, nPos);
            }
            return (MemorySegment)mh$.invokeExact(hMenu, nPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuItemID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMenuItemID(HMENU hMenu, int nPos)
     * }
     */
    public static FunctionDescriptor GetMenuItemID$descriptor() {
        return GetMenuItemID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMenuItemID(HMENU hMenu, int nPos)
     * }
     */
    public static MethodHandle GetMenuItemID$handle() {
        return GetMenuItemID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetMenuItemID(HMENU hMenu, int nPos)
     * }
     */
    public static MemorySegment GetMenuItemID$address() {
        return GetMenuItemID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetMenuItemID(HMENU hMenu, int nPos)
     * }
     */
    public static int GetMenuItemID(MemorySegment hMenu, int nPos) {
        var mh$ = GetMenuItemID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemID", hMenu, nPos);
            }
            return (int)mh$.invokeExact(hMenu, nPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuItemCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMenuItemCount(HMENU hMenu)
     * }
     */
    public static FunctionDescriptor GetMenuItemCount$descriptor() {
        return GetMenuItemCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMenuItemCount(HMENU hMenu)
     * }
     */
    public static MethodHandle GetMenuItemCount$handle() {
        return GetMenuItemCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMenuItemCount(HMENU hMenu)
     * }
     */
    public static MemorySegment GetMenuItemCount$address() {
        return GetMenuItemCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMenuItemCount(HMENU hMenu)
     * }
     */
    public static int GetMenuItemCount(MemorySegment hMenu) {
        var mh$ = GetMenuItemCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemCount", hMenu);
            }
            return (int)mh$.invokeExact(hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InsertMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InsertMenuA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor InsertMenuA$descriptor() {
        return InsertMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MethodHandle InsertMenuA$handle() {
        return InsertMenuA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MemorySegment InsertMenuA$address() {
        return InsertMenuA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static int InsertMenuA(MemorySegment hMenu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = InsertMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuA", hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InsertMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InsertMenuW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor InsertMenuW$descriptor() {
        return InsertMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MethodHandle InsertMenuW$handle() {
        return InsertMenuW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MemorySegment InsertMenuW$address() {
        return InsertMenuW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static int InsertMenuW(MemorySegment hMenu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = InsertMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuW", hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AppendMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AppendMenuA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor AppendMenuA$descriptor() {
        return AppendMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MethodHandle AppendMenuA$handle() {
        return AppendMenuA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MemorySegment AppendMenuA$address() {
        return AppendMenuA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static int AppendMenuA(MemorySegment hMenu, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = AppendMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AppendMenuA", hMenu, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AppendMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AppendMenuW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor AppendMenuW$descriptor() {
        return AppendMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MethodHandle AppendMenuW$handle() {
        return AppendMenuW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MemorySegment AppendMenuW$address() {
        return AppendMenuW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static int AppendMenuW(MemorySegment hMenu, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = AppendMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AppendMenuW", hMenu, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModifyMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ModifyMenuA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor ModifyMenuA$descriptor() {
        return ModifyMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MethodHandle ModifyMenuA$handle() {
        return ModifyMenuA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MemorySegment ModifyMenuA$address() {
        return ModifyMenuA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static int ModifyMenuA(MemorySegment hMnu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = ModifyMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModifyMenuA", hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModifyMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ModifyMenuW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor ModifyMenuW$descriptor() {
        return ModifyMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MethodHandle ModifyMenuW$handle() {
        return ModifyMenuW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MemorySegment ModifyMenuW$address() {
        return ModifyMenuW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static int ModifyMenuW(MemorySegment hMnu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = ModifyMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModifyMenuW", hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static FunctionDescriptor RemoveMenu$descriptor() {
        return RemoveMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static MethodHandle RemoveMenu$handle() {
        return RemoveMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static MemorySegment RemoveMenu$address() {
        return RemoveMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static int RemoveMenu(MemorySegment hMenu, int uPosition, int uFlags) {
        var mh$ = RemoveMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveMenu", hMenu, uPosition, uFlags);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DeleteMenu$descriptor() {
        return DeleteMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static MethodHandle DeleteMenu$handle() {
        return DeleteMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static MemorySegment DeleteMenu$address() {
        return DeleteMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static int DeleteMenu(MemorySegment hMenu, int uPosition, int uFlags) {
        var mh$ = DeleteMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteMenu", hMenu, uPosition, uFlags);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuItemBitmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMenuItemBitmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked)
     * }
     */
    public static FunctionDescriptor SetMenuItemBitmaps$descriptor() {
        return SetMenuItemBitmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked)
     * }
     */
    public static MethodHandle SetMenuItemBitmaps$handle() {
        return SetMenuItemBitmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked)
     * }
     */
    public static MemorySegment SetMenuItemBitmaps$address() {
        return SetMenuItemBitmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked)
     * }
     */
    public static int SetMenuItemBitmaps(MemorySegment hMenu, int uPosition, int uFlags, MemorySegment hBitmapUnchecked, MemorySegment hBitmapChecked) {
        var mh$ = SetMenuItemBitmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuItemBitmaps", hMenu, uPosition, uFlags, hBitmapUnchecked, hBitmapChecked);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags, hBitmapUnchecked, hBitmapChecked);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuCheckMarkDimensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuCheckMarkDimensions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetMenuCheckMarkDimensions()
     * }
     */
    public static FunctionDescriptor GetMenuCheckMarkDimensions$descriptor() {
        return GetMenuCheckMarkDimensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetMenuCheckMarkDimensions()
     * }
     */
    public static MethodHandle GetMenuCheckMarkDimensions$handle() {
        return GetMenuCheckMarkDimensions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG GetMenuCheckMarkDimensions()
     * }
     */
    public static MemorySegment GetMenuCheckMarkDimensions$address() {
        return GetMenuCheckMarkDimensions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG GetMenuCheckMarkDimensions()
     * }
     */
    public static int GetMenuCheckMarkDimensions() {
        var mh$ = GetMenuCheckMarkDimensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuCheckMarkDimensions");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TrackPopupMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TrackPopupMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
     * }
     */
    public static FunctionDescriptor TrackPopupMenu$descriptor() {
        return TrackPopupMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
     * }
     */
    public static MethodHandle TrackPopupMenu$handle() {
        return TrackPopupMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
     * }
     */
    public static MemorySegment TrackPopupMenu$address() {
        return TrackPopupMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
     * }
     */
    public static int TrackPopupMenu(MemorySegment hMenu, int uFlags, int x, int y, int nReserved, MemorySegment hWnd, MemorySegment prcRect) {
        var mh$ = TrackPopupMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrackPopupMenu", hMenu, uFlags, x, y, nReserved, hWnd, prcRect);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, x, y, nReserved, hWnd, prcRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef TPMPARAMS *LPTPMPARAMS
     * }
     */
    public static final AddressLayout LPTPMPARAMS = freeglut_h.C_POINTER;

    private static class TrackPopupMenuEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TrackPopupMenuEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm)
     * }
     */
    public static FunctionDescriptor TrackPopupMenuEx$descriptor() {
        return TrackPopupMenuEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm)
     * }
     */
    public static MethodHandle TrackPopupMenuEx$handle() {
        return TrackPopupMenuEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm)
     * }
     */
    public static MemorySegment TrackPopupMenuEx$address() {
        return TrackPopupMenuEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm)
     * }
     */
    public static int TrackPopupMenuEx(MemorySegment hMenu, int uFlags, int x, int y, MemorySegment hwnd, MemorySegment lptpm) {
        var mh$ = TrackPopupMenuEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrackPopupMenuEx", hMenu, uFlags, x, y, hwnd, lptpm);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, x, y, hwnd, lptpm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CalculatePopupWindowPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CalculatePopupWindowPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CalculatePopupWindowPosition(const POINT *anchorPoint, const SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition)
     * }
     */
    public static FunctionDescriptor CalculatePopupWindowPosition$descriptor() {
        return CalculatePopupWindowPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CalculatePopupWindowPosition(const POINT *anchorPoint, const SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition)
     * }
     */
    public static MethodHandle CalculatePopupWindowPosition$handle() {
        return CalculatePopupWindowPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CalculatePopupWindowPosition(const POINT *anchorPoint, const SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition)
     * }
     */
    public static MemorySegment CalculatePopupWindowPosition$address() {
        return CalculatePopupWindowPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CalculatePopupWindowPosition(const POINT *anchorPoint, const SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition)
     * }
     */
    public static int CalculatePopupWindowPosition(MemorySegment anchorPoint, MemorySegment windowSize, int flags, MemorySegment excludeRect, MemorySegment popupWindowPosition) {
        var mh$ = CalculatePopupWindowPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CalculatePopupWindowPosition", anchorPoint, windowSize, flags, excludeRect, popupWindowPosition);
            }
            return (int)mh$.invokeExact(anchorPoint, windowSize, flags, excludeRect, popupWindowPosition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUINFO {
     *     DWORD cbSize;
     *     DWORD fMask;
     *     DWORD dwStyle;
     *     UINT cyMax;
     *     HBRUSH hbrBack;
     *     DWORD dwContextHelpID;
     *     ULONG_PTR dwMenuData;
     * } *LPMENUINFO
     * }
     */
    public static final AddressLayout LPMENUINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const MENUINFO *LPCMENUINFO
     * }
     */
    public static final AddressLayout LPCMENUINFO = freeglut_h.C_POINTER;

    private static class GetMenuInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuInfo(HMENU, LPMENUINFO)
     * }
     */
    public static FunctionDescriptor GetMenuInfo$descriptor() {
        return GetMenuInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuInfo(HMENU, LPMENUINFO)
     * }
     */
    public static MethodHandle GetMenuInfo$handle() {
        return GetMenuInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMenuInfo(HMENU, LPMENUINFO)
     * }
     */
    public static MemorySegment GetMenuInfo$address() {
        return GetMenuInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMenuInfo(HMENU, LPMENUINFO)
     * }
     */
    public static int GetMenuInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetMenuInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuInfo", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMenuInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuInfo(HMENU, LPCMENUINFO)
     * }
     */
    public static FunctionDescriptor SetMenuInfo$descriptor() {
        return SetMenuInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuInfo(HMENU, LPCMENUINFO)
     * }
     */
    public static MethodHandle SetMenuInfo$handle() {
        return SetMenuInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenuInfo(HMENU, LPCMENUINFO)
     * }
     */
    public static MemorySegment SetMenuInfo$address() {
        return SetMenuInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenuInfo(HMENU, LPCMENUINFO)
     * }
     */
    public static int SetMenuInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = SetMenuInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuInfo", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EndMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndMenu()
     * }
     */
    public static FunctionDescriptor EndMenu$descriptor() {
        return EndMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndMenu()
     * }
     */
    public static MethodHandle EndMenu$handle() {
        return EndMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndMenu()
     * }
     */
    public static MemorySegment EndMenu$address() {
        return EndMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndMenu()
     * }
     */
    public static int EndMenu() {
        var mh$ = EndMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndMenu");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUGETOBJECTINFO {
     *     DWORD dwFlags;
     *     UINT uPos;
     *     HMENU hmenu;
     *     PVOID riid;
     *     PVOID pvObj;
     * } *PMENUGETOBJECTINFO
     * }
     */
    public static final AddressLayout PMENUGETOBJECTINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUITEMINFOA {
     *     UINT cbSize;
     *     UINT fMask;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HMENU hSubMenu;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     ULONG_PTR dwItemData;
     *     LPSTR dwTypeData;
     *     UINT cch;
     *     HBITMAP hbmpItem;
     * } *LPMENUITEMINFOA
     * }
     */
    public static final AddressLayout LPMENUITEMINFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUITEMINFOW {
     *     UINT cbSize;
     *     UINT fMask;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HMENU hSubMenu;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     ULONG_PTR dwItemData;
     *     LPWSTR dwTypeData;
     *     UINT cch;
     *     HBITMAP hbmpItem;
     * } *LPMENUITEMINFOW
     * }
     */
    public static final AddressLayout LPMENUITEMINFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMENUITEMINFOA LPMENUITEMINFO
     * }
     */
    public static final AddressLayout LPMENUITEMINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const MENUITEMINFOA *LPCMENUITEMINFOA
     * }
     */
    public static final AddressLayout LPCMENUITEMINFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const MENUITEMINFOW *LPCMENUITEMINFOW
     * }
     */
    public static final AddressLayout LPCMENUITEMINFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCMENUITEMINFOA LPCMENUITEMINFO
     * }
     */
    public static final AddressLayout LPCMENUITEMINFO = freeglut_h.C_POINTER;

    private static class InsertMenuItemA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InsertMenuItemA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi)
     * }
     */
    public static FunctionDescriptor InsertMenuItemA$descriptor() {
        return InsertMenuItemA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi)
     * }
     */
    public static MethodHandle InsertMenuItemA$handle() {
        return InsertMenuItemA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi)
     * }
     */
    public static MemorySegment InsertMenuItemA$address() {
        return InsertMenuItemA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi)
     * }
     */
    public static int InsertMenuItemA(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmi) {
        var mh$ = InsertMenuItemA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuItemA", hmenu, item, fByPosition, lpmi);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InsertMenuItemW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InsertMenuItemW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
     * }
     */
    public static FunctionDescriptor InsertMenuItemW$descriptor() {
        return InsertMenuItemW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
     * }
     */
    public static MethodHandle InsertMenuItemW$handle() {
        return InsertMenuItemW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
     * }
     */
    public static MemorySegment InsertMenuItemW$address() {
        return InsertMenuItemW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
     * }
     */
    public static int InsertMenuItemW(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmi) {
        var mh$ = InsertMenuItemW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuItemW", hmenu, item, fByPosition, lpmi);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuItemInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii)
     * }
     */
    public static FunctionDescriptor GetMenuItemInfoA$descriptor() {
        return GetMenuItemInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii)
     * }
     */
    public static MethodHandle GetMenuItemInfoA$handle() {
        return GetMenuItemInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii)
     * }
     */
    public static MemorySegment GetMenuItemInfoA$address() {
        return GetMenuItemInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii)
     * }
     */
    public static int GetMenuItemInfoA(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmii) {
        var mh$ = GetMenuItemInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemInfoA", hmenu, item, fByPosition, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuItemInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii)
     * }
     */
    public static FunctionDescriptor GetMenuItemInfoW$descriptor() {
        return GetMenuItemInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii)
     * }
     */
    public static MethodHandle GetMenuItemInfoW$handle() {
        return GetMenuItemInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii)
     * }
     */
    public static MemorySegment GetMenuItemInfoW$address() {
        return GetMenuItemInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii)
     * }
     */
    public static int GetMenuItemInfoW(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmii) {
        var mh$ = GetMenuItemInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemInfoW", hmenu, item, fByPosition, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuItemInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMenuItemInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii)
     * }
     */
    public static FunctionDescriptor SetMenuItemInfoA$descriptor() {
        return SetMenuItemInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii)
     * }
     */
    public static MethodHandle SetMenuItemInfoA$handle() {
        return SetMenuItemInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii)
     * }
     */
    public static MemorySegment SetMenuItemInfoA$address() {
        return SetMenuItemInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii)
     * }
     */
    public static int SetMenuItemInfoA(MemorySegment hmenu, int item, int fByPositon, MemorySegment lpmii) {
        var mh$ = SetMenuItemInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuItemInfoA", hmenu, item, fByPositon, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPositon, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuItemInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMenuItemInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
     * }
     */
    public static FunctionDescriptor SetMenuItemInfoW$descriptor() {
        return SetMenuItemInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
     * }
     */
    public static MethodHandle SetMenuItemInfoW$handle() {
        return SetMenuItemInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
     * }
     */
    public static MemorySegment SetMenuItemInfoW$address() {
        return SetMenuItemInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
     * }
     */
    public static int SetMenuItemInfoW(MemorySegment hmenu, int item, int fByPositon, MemorySegment lpmii) {
        var mh$ = SetMenuItemInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuItemInfoW", hmenu, item, fByPositon, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPositon, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuDefaultItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuDefaultItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags)
     * }
     */
    public static FunctionDescriptor GetMenuDefaultItem$descriptor() {
        return GetMenuDefaultItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags)
     * }
     */
    public static MethodHandle GetMenuDefaultItem$handle() {
        return GetMenuDefaultItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags)
     * }
     */
    public static MemorySegment GetMenuDefaultItem$address() {
        return GetMenuDefaultItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags)
     * }
     */
    public static int GetMenuDefaultItem(MemorySegment hMenu, int fByPos, int gmdiFlags) {
        var mh$ = GetMenuDefaultItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuDefaultItem", hMenu, fByPos, gmdiFlags);
            }
            return (int)mh$.invokeExact(hMenu, fByPos, gmdiFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuDefaultItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMenuDefaultItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos)
     * }
     */
    public static FunctionDescriptor SetMenuDefaultItem$descriptor() {
        return SetMenuDefaultItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos)
     * }
     */
    public static MethodHandle SetMenuDefaultItem$handle() {
        return SetMenuDefaultItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos)
     * }
     */
    public static MemorySegment SetMenuDefaultItem$address() {
        return SetMenuDefaultItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos)
     * }
     */
    public static int SetMenuDefaultItem(MemorySegment hMenu, int uItem, int fByPos) {
        var mh$ = SetMenuDefaultItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuDefaultItem", hMenu, uItem, fByPos);
            }
            return (int)mh$.invokeExact(hMenu, uItem, fByPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuItemRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem)
     * }
     */
    public static FunctionDescriptor GetMenuItemRect$descriptor() {
        return GetMenuItemRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem)
     * }
     */
    public static MethodHandle GetMenuItemRect$handle() {
        return GetMenuItemRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem)
     * }
     */
    public static MemorySegment GetMenuItemRect$address() {
        return GetMenuItemRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem)
     * }
     */
    public static int GetMenuItemRect(MemorySegment hWnd, MemorySegment hMenu, int uItem, MemorySegment lprcItem) {
        var mh$ = GetMenuItemRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemRect", hWnd, hMenu, uItem, lprcItem);
            }
            return (int)mh$.invokeExact(hWnd, hMenu, uItem, lprcItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MenuItemFromPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            tagPOINT.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MenuItemFromPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen)
     * }
     */
    public static FunctionDescriptor MenuItemFromPoint$descriptor() {
        return MenuItemFromPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen)
     * }
     */
    public static MethodHandle MenuItemFromPoint$handle() {
        return MenuItemFromPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen)
     * }
     */
    public static MemorySegment MenuItemFromPoint$address() {
        return MenuItemFromPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen)
     * }
     */
    public static int MenuItemFromPoint(MemorySegment hWnd, MemorySegment hMenu, MemorySegment ptScreen) {
        var mh$ = MenuItemFromPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MenuItemFromPoint", hWnd, hMenu, ptScreen);
            }
            return (int)mh$.invokeExact(hWnd, hMenu, ptScreen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDROPSTRUCT {
     *     HWND hwndSource;
     *     HWND hwndSink;
     *     DWORD wFmt;
     *     ULONG_PTR dwData;
     *     POINT ptDrop;
     *     DWORD dwControlData;
     * } *PDROPSTRUCT
     * }
     */
    public static final AddressLayout PDROPSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDROPSTRUCT {
     *     HWND hwndSource;
     *     HWND hwndSink;
     *     DWORD wFmt;
     *     ULONG_PTR dwData;
     *     POINT ptDrop;
     *     DWORD dwControlData;
     * } *LPDROPSTRUCT
     * }
     */
    public static final AddressLayout LPDROPSTRUCT = freeglut_h.C_POINTER;

    private static class DragObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DragObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur)
     * }
     */
    public static FunctionDescriptor DragObject$descriptor() {
        return DragObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur)
     * }
     */
    public static MethodHandle DragObject$handle() {
        return DragObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur)
     * }
     */
    public static MemorySegment DragObject$address() {
        return DragObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur)
     * }
     */
    public static int DragObject(MemorySegment hwndParent, MemorySegment hwndFrom, int fmt, long data, MemorySegment hcur) {
        var mh$ = DragObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DragObject", hwndParent, hwndFrom, fmt, data, hcur);
            }
            return (int)mh$.invokeExact(hwndParent, hwndFrom, fmt, data, hcur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DragDetect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            tagPOINT.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DragDetect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DragDetect(HWND hwnd, POINT pt)
     * }
     */
    public static FunctionDescriptor DragDetect$descriptor() {
        return DragDetect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DragDetect(HWND hwnd, POINT pt)
     * }
     */
    public static MethodHandle DragDetect$handle() {
        return DragDetect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DragDetect(HWND hwnd, POINT pt)
     * }
     */
    public static MemorySegment DragDetect$address() {
        return DragDetect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DragDetect(HWND hwnd, POINT pt)
     * }
     */
    public static int DragDetect(MemorySegment hwnd, MemorySegment pt) {
        var mh$ = DragDetect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DragDetect", hwnd, pt);
            }
            return (int)mh$.invokeExact(hwnd, pt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawIcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
     * }
     */
    public static FunctionDescriptor DrawIcon$descriptor() {
        return DrawIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
     * }
     */
    public static MethodHandle DrawIcon$handle() {
        return DrawIcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
     * }
     */
    public static MemorySegment DrawIcon$address() {
        return DrawIcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
     * }
     */
    public static int DrawIcon(MemorySegment hDC, int X, int Y, MemorySegment hIcon) {
        var mh$ = DrawIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawIcon", hDC, X, Y, hIcon);
            }
            return (int)mh$.invokeExact(hDC, X, Y, hIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDRAWTEXTPARAMS {
     *     UINT cbSize;
     *     int iTabLength;
     *     int iLeftMargin;
     *     int iRightMargin;
     *     UINT uiLengthDrawn;
     * } *LPDRAWTEXTPARAMS
     * }
     */
    public static final AddressLayout LPDRAWTEXTPARAMS = freeglut_h.C_POINTER;

    private static class DrawTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static FunctionDescriptor DrawTextA$descriptor() {
        return DrawTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static MethodHandle DrawTextA$handle() {
        return DrawTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static MemorySegment DrawTextA$address() {
        return DrawTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static int DrawTextA(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format) {
        var mh$ = DrawTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextA", hdc, lpchText, cchText, lprc, format);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static FunctionDescriptor DrawTextW$descriptor() {
        return DrawTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static MethodHandle DrawTextW$handle() {
        return DrawTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static MemorySegment DrawTextW$address() {
        return DrawTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static int DrawTextW(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format) {
        var mh$ = DrawTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextW", hdc, lpchText, cchText, lprc, format);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawTextExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static FunctionDescriptor DrawTextExA$descriptor() {
        return DrawTextExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static MethodHandle DrawTextExA$handle() {
        return DrawTextExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static MemorySegment DrawTextExA$address() {
        return DrawTextExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static int DrawTextExA(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format, MemorySegment lpdtp) {
        var mh$ = DrawTextExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextExA", hdc, lpchText, cchText, lprc, format, lpdtp);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format, lpdtp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawTextExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static FunctionDescriptor DrawTextExW$descriptor() {
        return DrawTextExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static MethodHandle DrawTextExW$handle() {
        return DrawTextExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static MemorySegment DrawTextExW$address() {
        return DrawTextExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static int DrawTextExW(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format, MemorySegment lpdtp) {
        var mh$ = DrawTextExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextExW", hdc, lpchText, cchText, lprc, format, lpdtp);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format, lpdtp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrayStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GrayStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static FunctionDescriptor GrayStringA$descriptor() {
        return GrayStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static MethodHandle GrayStringA$handle() {
        return GrayStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static MemorySegment GrayStringA$address() {
        return GrayStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static int GrayStringA(MemorySegment hDC, MemorySegment hBrush, MemorySegment lpOutputFunc, long lpData, int nCount, int X, int Y, int nWidth, int nHeight) {
        var mh$ = GrayStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrayStringA", hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
            }
            return (int)mh$.invokeExact(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrayStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GrayStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static FunctionDescriptor GrayStringW$descriptor() {
        return GrayStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static MethodHandle GrayStringW$handle() {
        return GrayStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static MemorySegment GrayStringW$address() {
        return GrayStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static int GrayStringW(MemorySegment hDC, MemorySegment hBrush, MemorySegment lpOutputFunc, long lpData, int nCount, int X, int Y, int nWidth, int nHeight) {
        var mh$ = GrayStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrayStringW", hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
            }
            return (int)mh$.invokeExact(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawStateA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawStateA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DrawStateA$descriptor() {
        return DrawStateA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle DrawStateA$handle() {
        return DrawStateA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MemorySegment DrawStateA$address() {
        return DrawStateA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static int DrawStateA(MemorySegment hdc, MemorySegment hbrFore, MemorySegment qfnCallBack, long lData, long wData, int x, int y, int cx, int cy, int uFlags) {
        var mh$ = DrawStateA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawStateA", hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
            }
            return (int)mh$.invokeExact(hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawStateW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawStateW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DrawStateW$descriptor() {
        return DrawStateW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle DrawStateW$handle() {
        return DrawStateW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MemorySegment DrawStateW$address() {
        return DrawStateW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static int DrawStateW(MemorySegment hdc, MemorySegment hbrFore, MemorySegment qfnCallBack, long lData, long wData, int x, int y, int cx, int cy, int uFlags) {
        var mh$ = DrawStateW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawStateW", hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
            }
            return (int)mh$.invokeExact(hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TabbedTextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TabbedTextOutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static FunctionDescriptor TabbedTextOutA$descriptor() {
        return TabbedTextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static MethodHandle TabbedTextOutA$handle() {
        return TabbedTextOutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static MemorySegment TabbedTextOutA$address() {
        return TabbedTextOutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static int TabbedTextOutA(MemorySegment hdc, int x, int y, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions, int nTabOrigin) {
        var mh$ = TabbedTextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TabbedTextOutA", hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TabbedTextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TabbedTextOutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static FunctionDescriptor TabbedTextOutW$descriptor() {
        return TabbedTextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static MethodHandle TabbedTextOutW$handle() {
        return TabbedTextOutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static MemorySegment TabbedTextOutW$address() {
        return TabbedTextOutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static int TabbedTextOutW(MemorySegment hdc, int x, int y, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions, int nTabOrigin) {
        var mh$ = TabbedTextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TabbedTextOutW", hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTabbedTextExtentA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTabbedTextExtentA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static FunctionDescriptor GetTabbedTextExtentA$descriptor() {
        return GetTabbedTextExtentA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static MethodHandle GetTabbedTextExtentA$handle() {
        return GetTabbedTextExtentA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static MemorySegment GetTabbedTextExtentA$address() {
        return GetTabbedTextExtentA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static int GetTabbedTextExtentA(MemorySegment hdc, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions) {
        var mh$ = GetTabbedTextExtentA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTabbedTextExtentA", hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
            }
            return (int)mh$.invokeExact(hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTabbedTextExtentW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTabbedTextExtentW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static FunctionDescriptor GetTabbedTextExtentW$descriptor() {
        return GetTabbedTextExtentW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static MethodHandle GetTabbedTextExtentW$handle() {
        return GetTabbedTextExtentW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static MemorySegment GetTabbedTextExtentW$address() {
        return GetTabbedTextExtentW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static int GetTabbedTextExtentW(MemorySegment hdc, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions) {
        var mh$ = GetTabbedTextExtentW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTabbedTextExtentW", hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
            }
            return (int)mh$.invokeExact(hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UpdateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor UpdateWindow$descriptor() {
        return UpdateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateWindow(HWND hWnd)
     * }
     */
    public static MethodHandle UpdateWindow$handle() {
        return UpdateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateWindow(HWND hWnd)
     * }
     */
    public static MemorySegment UpdateWindow$address() {
        return UpdateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateWindow(HWND hWnd)
     * }
     */
    public static int UpdateWindow(MemorySegment hWnd) {
        var mh$ = UpdateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetActiveWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetActiveWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetActiveWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetActiveWindow$descriptor() {
        return SetActiveWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetActiveWindow(HWND hWnd)
     * }
     */
    public static MethodHandle SetActiveWindow$handle() {
        return SetActiveWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND SetActiveWindow(HWND hWnd)
     * }
     */
    public static MemorySegment SetActiveWindow$address() {
        return SetActiveWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND SetActiveWindow(HWND hWnd)
     * }
     */
    public static MemorySegment SetActiveWindow(MemorySegment hWnd) {
        var mh$ = SetActiveWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetActiveWindow", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetForegroundWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetForegroundWindow()
     * }
     */
    public static FunctionDescriptor GetForegroundWindow$descriptor() {
        return GetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetForegroundWindow()
     * }
     */
    public static MethodHandle GetForegroundWindow$handle() {
        return GetForegroundWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetForegroundWindow()
     * }
     */
    public static MemorySegment GetForegroundWindow$address() {
        return GetForegroundWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetForegroundWindow()
     * }
     */
    public static MemorySegment GetForegroundWindow() {
        var mh$ = GetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetForegroundWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PaintDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PaintDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PaintDesktop(HDC hdc)
     * }
     */
    public static FunctionDescriptor PaintDesktop$descriptor() {
        return PaintDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PaintDesktop(HDC hdc)
     * }
     */
    public static MethodHandle PaintDesktop$handle() {
        return PaintDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PaintDesktop(HDC hdc)
     * }
     */
    public static MemorySegment PaintDesktop$address() {
        return PaintDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PaintDesktop(HDC hdc)
     * }
     */
    public static int PaintDesktop(MemorySegment hdc) {
        var mh$ = PaintDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PaintDesktop", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchToThisWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SwitchToThisWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SwitchToThisWindow(HWND hwnd, BOOL fUnknown)
     * }
     */
    public static FunctionDescriptor SwitchToThisWindow$descriptor() {
        return SwitchToThisWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SwitchToThisWindow(HWND hwnd, BOOL fUnknown)
     * }
     */
    public static MethodHandle SwitchToThisWindow$handle() {
        return SwitchToThisWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SwitchToThisWindow(HWND hwnd, BOOL fUnknown)
     * }
     */
    public static MemorySegment SwitchToThisWindow$address() {
        return SwitchToThisWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SwitchToThisWindow(HWND hwnd, BOOL fUnknown)
     * }
     */
    public static void SwitchToThisWindow(MemorySegment hwnd, int fUnknown) {
        var mh$ = SwitchToThisWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchToThisWindow", hwnd, fUnknown);
            }
            mh$.invokeExact(hwnd, fUnknown);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetForegroundWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetForegroundWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetForegroundWindow$descriptor() {
        return SetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetForegroundWindow(HWND hWnd)
     * }
     */
    public static MethodHandle SetForegroundWindow$handle() {
        return SetForegroundWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetForegroundWindow(HWND hWnd)
     * }
     */
    public static MemorySegment SetForegroundWindow$address() {
        return SetForegroundWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetForegroundWindow(HWND hWnd)
     * }
     */
    public static int SetForegroundWindow(MemorySegment hWnd) {
        var mh$ = SetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetForegroundWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllowSetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AllowSetForegroundWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllowSetForegroundWindow(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor AllowSetForegroundWindow$descriptor() {
        return AllowSetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllowSetForegroundWindow(DWORD dwProcessId)
     * }
     */
    public static MethodHandle AllowSetForegroundWindow$handle() {
        return AllowSetForegroundWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllowSetForegroundWindow(DWORD dwProcessId)
     * }
     */
    public static MemorySegment AllowSetForegroundWindow$address() {
        return AllowSetForegroundWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllowSetForegroundWindow(DWORD dwProcessId)
     * }
     */
    public static int AllowSetForegroundWindow(int dwProcessId) {
        var mh$ = AllowSetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllowSetForegroundWindow", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockSetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LockSetForegroundWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockSetForegroundWindow(UINT uLockCode)
     * }
     */
    public static FunctionDescriptor LockSetForegroundWindow$descriptor() {
        return LockSetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockSetForegroundWindow(UINT uLockCode)
     * }
     */
    public static MethodHandle LockSetForegroundWindow$handle() {
        return LockSetForegroundWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LockSetForegroundWindow(UINT uLockCode)
     * }
     */
    public static MemorySegment LockSetForegroundWindow$address() {
        return LockSetForegroundWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LockSetForegroundWindow(UINT uLockCode)
     * }
     */
    public static int LockSetForegroundWindow(int uLockCode) {
        var mh$ = LockSetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockSetForegroundWindow", uLockCode);
            }
            return (int)mh$.invokeExact(uLockCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WindowFromDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WindowFromDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND WindowFromDC(HDC hDC)
     * }
     */
    public static FunctionDescriptor WindowFromDC$descriptor() {
        return WindowFromDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND WindowFromDC(HDC hDC)
     * }
     */
    public static MethodHandle WindowFromDC$handle() {
        return WindowFromDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND WindowFromDC(HDC hDC)
     * }
     */
    public static MemorySegment WindowFromDC$address() {
        return WindowFromDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND WindowFromDC(HDC hDC)
     * }
     */
    public static MemorySegment WindowFromDC(MemorySegment hDC) {
        var mh$ = WindowFromDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WindowFromDC", hDC);
            }
            return (MemorySegment)mh$.invokeExact(hDC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC GetDC(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetDC$descriptor() {
        return GetDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC GetDC(HWND hWnd)
     * }
     */
    public static MethodHandle GetDC$handle() {
        return GetDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC GetDC(HWND hWnd)
     * }
     */
    public static MemorySegment GetDC$address() {
        return GetDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC GetDC(HWND hWnd)
     * }
     */
    public static MemorySegment GetDC(MemorySegment hWnd) {
        var mh$ = GetDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDC", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDCEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
     * }
     */
    public static FunctionDescriptor GetDCEx$descriptor() {
        return GetDCEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
     * }
     */
    public static MethodHandle GetDCEx$handle() {
        return GetDCEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
     * }
     */
    public static MemorySegment GetDCEx$address() {
        return GetDCEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
     * }
     */
    public static MemorySegment GetDCEx(MemorySegment hWnd, MemorySegment hrgnClip, int flags) {
        var mh$ = GetDCEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCEx", hWnd, hrgnClip, flags);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, hrgnClip, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC GetWindowDC(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetWindowDC$descriptor() {
        return GetWindowDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC GetWindowDC(HWND hWnd)
     * }
     */
    public static MethodHandle GetWindowDC$handle() {
        return GetWindowDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC GetWindowDC(HWND hWnd)
     * }
     */
    public static MemorySegment GetWindowDC$address() {
        return GetWindowDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC GetWindowDC(HWND hWnd)
     * }
     */
    public static MemorySegment GetWindowDC(MemorySegment hWnd) {
        var mh$ = GetWindowDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowDC", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReleaseDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ReleaseDC(HWND hWnd, HDC hDC)
     * }
     */
    public static FunctionDescriptor ReleaseDC$descriptor() {
        return ReleaseDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ReleaseDC(HWND hWnd, HDC hDC)
     * }
     */
    public static MethodHandle ReleaseDC$handle() {
        return ReleaseDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ReleaseDC(HWND hWnd, HDC hDC)
     * }
     */
    public static MemorySegment ReleaseDC$address() {
        return ReleaseDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ReleaseDC(HWND hWnd, HDC hDC)
     * }
     */
    public static int ReleaseDC(MemorySegment hWnd, MemorySegment hDC) {
        var mh$ = ReleaseDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseDC", hWnd, hDC);
            }
            return (int)mh$.invokeExact(hWnd, hDC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginPaint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BeginPaint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
     * }
     */
    public static FunctionDescriptor BeginPaint$descriptor() {
        return BeginPaint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
     * }
     */
    public static MethodHandle BeginPaint$handle() {
        return BeginPaint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
     * }
     */
    public static MemorySegment BeginPaint$address() {
        return BeginPaint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
     * }
     */
    public static MemorySegment BeginPaint(MemorySegment hWnd, MemorySegment lpPaint) {
        var mh$ = BeginPaint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginPaint", hWnd, lpPaint);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, lpPaint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndPaint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EndPaint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
     * }
     */
    public static FunctionDescriptor EndPaint$descriptor() {
        return EndPaint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
     * }
     */
    public static MethodHandle EndPaint$handle() {
        return EndPaint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
     * }
     */
    public static MemorySegment EndPaint$address() {
        return EndPaint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
     * }
     */
    public static int EndPaint(MemorySegment hWnd, MemorySegment lpPaint) {
        var mh$ = EndPaint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndPaint", hWnd, lpPaint);
            }
            return (int)mh$.invokeExact(hWnd, lpPaint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUpdateRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUpdateRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase)
     * }
     */
    public static FunctionDescriptor GetUpdateRect$descriptor() {
        return GetUpdateRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase)
     * }
     */
    public static MethodHandle GetUpdateRect$handle() {
        return GetUpdateRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase)
     * }
     */
    public static MemorySegment GetUpdateRect$address() {
        return GetUpdateRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase)
     * }
     */
    public static int GetUpdateRect(MemorySegment hWnd, MemorySegment lpRect, int bErase) {
        var mh$ = GetUpdateRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUpdateRect", hWnd, lpRect, bErase);
            }
            return (int)mh$.invokeExact(hWnd, lpRect, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUpdateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUpdateRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static FunctionDescriptor GetUpdateRgn$descriptor() {
        return GetUpdateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static MethodHandle GetUpdateRgn$handle() {
        return GetUpdateRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static MemorySegment GetUpdateRgn$address() {
        return GetUpdateRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static int GetUpdateRgn(MemorySegment hWnd, MemorySegment hRgn, int bErase) {
        var mh$ = GetUpdateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUpdateRgn", hWnd, hRgn, bErase);
            }
            return (int)mh$.invokeExact(hWnd, hRgn, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw)
     * }
     */
    public static FunctionDescriptor SetWindowRgn$descriptor() {
        return SetWindowRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw)
     * }
     */
    public static MethodHandle SetWindowRgn$handle() {
        return SetWindowRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw)
     * }
     */
    public static MemorySegment SetWindowRgn$address() {
        return SetWindowRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw)
     * }
     */
    public static int SetWindowRgn(MemorySegment hWnd, MemorySegment hRgn, int bRedraw) {
        var mh$ = SetWindowRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowRgn", hWnd, hRgn, bRedraw);
            }
            return (int)mh$.invokeExact(hWnd, hRgn, bRedraw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static FunctionDescriptor GetWindowRgn$descriptor() {
        return GetWindowRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static MethodHandle GetWindowRgn$handle() {
        return GetWindowRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetWindowRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static MemorySegment GetWindowRgn$address() {
        return GetWindowRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetWindowRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static int GetWindowRgn(MemorySegment hWnd, MemorySegment hRgn) {
        var mh$ = GetWindowRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowRgn", hWnd, hRgn);
            }
            return (int)mh$.invokeExact(hWnd, hRgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowRgnBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowRgnBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowRgnBox(HWND hWnd, LPRECT lprc)
     * }
     */
    public static FunctionDescriptor GetWindowRgnBox$descriptor() {
        return GetWindowRgnBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowRgnBox(HWND hWnd, LPRECT lprc)
     * }
     */
    public static MethodHandle GetWindowRgnBox$handle() {
        return GetWindowRgnBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetWindowRgnBox(HWND hWnd, LPRECT lprc)
     * }
     */
    public static MemorySegment GetWindowRgnBox$address() {
        return GetWindowRgnBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetWindowRgnBox(HWND hWnd, LPRECT lprc)
     * }
     */
    public static int GetWindowRgnBox(MemorySegment hWnd, MemorySegment lprc) {
        var mh$ = GetWindowRgnBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowRgnBox", hWnd, lprc);
            }
            return (int)mh$.invokeExact(hWnd, lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExcludeUpdateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExcludeUpdateRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExcludeUpdateRgn(HDC hDC, HWND hWnd)
     * }
     */
    public static FunctionDescriptor ExcludeUpdateRgn$descriptor() {
        return ExcludeUpdateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExcludeUpdateRgn(HDC hDC, HWND hWnd)
     * }
     */
    public static MethodHandle ExcludeUpdateRgn$handle() {
        return ExcludeUpdateRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExcludeUpdateRgn(HDC hDC, HWND hWnd)
     * }
     */
    public static MemorySegment ExcludeUpdateRgn$address() {
        return ExcludeUpdateRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExcludeUpdateRgn(HDC hDC, HWND hWnd)
     * }
     */
    public static int ExcludeUpdateRgn(MemorySegment hDC, MemorySegment hWnd) {
        var mh$ = ExcludeUpdateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExcludeUpdateRgn", hDC, hWnd);
            }
            return (int)mh$.invokeExact(hDC, hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvalidateRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InvalidateRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
     * }
     */
    public static FunctionDescriptor InvalidateRect$descriptor() {
        return InvalidateRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
     * }
     */
    public static MethodHandle InvalidateRect$handle() {
        return InvalidateRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
     * }
     */
    public static MemorySegment InvalidateRect$address() {
        return InvalidateRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
     * }
     */
    public static int InvalidateRect(MemorySegment hWnd, MemorySegment lpRect, int bErase) {
        var mh$ = InvalidateRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvalidateRect", hWnd, lpRect, bErase);
            }
            return (int)mh$.invokeExact(hWnd, lpRect, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ValidateRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ValidateRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ValidateRect(HWND hWnd, const RECT *lpRect)
     * }
     */
    public static FunctionDescriptor ValidateRect$descriptor() {
        return ValidateRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ValidateRect(HWND hWnd, const RECT *lpRect)
     * }
     */
    public static MethodHandle ValidateRect$handle() {
        return ValidateRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ValidateRect(HWND hWnd, const RECT *lpRect)
     * }
     */
    public static MemorySegment ValidateRect$address() {
        return ValidateRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ValidateRect(HWND hWnd, const RECT *lpRect)
     * }
     */
    public static int ValidateRect(MemorySegment hWnd, MemorySegment lpRect) {
        var mh$ = ValidateRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ValidateRect", hWnd, lpRect);
            }
            return (int)mh$.invokeExact(hWnd, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvalidateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InvalidateRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static FunctionDescriptor InvalidateRgn$descriptor() {
        return InvalidateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static MethodHandle InvalidateRgn$handle() {
        return InvalidateRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static MemorySegment InvalidateRgn$address() {
        return InvalidateRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static int InvalidateRgn(MemorySegment hWnd, MemorySegment hRgn, int bErase) {
        var mh$ = InvalidateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvalidateRgn", hWnd, hRgn, bErase);
            }
            return (int)mh$.invokeExact(hWnd, hRgn, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ValidateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ValidateRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ValidateRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static FunctionDescriptor ValidateRgn$descriptor() {
        return ValidateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ValidateRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static MethodHandle ValidateRgn$handle() {
        return ValidateRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ValidateRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static MemorySegment ValidateRgn$address() {
        return ValidateRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ValidateRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static int ValidateRgn(MemorySegment hWnd, MemorySegment hRgn) {
        var mh$ = ValidateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ValidateRgn", hWnd, hRgn);
            }
            return (int)mh$.invokeExact(hWnd, hRgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RedrawWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RedrawWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags)
     * }
     */
    public static FunctionDescriptor RedrawWindow$descriptor() {
        return RedrawWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags)
     * }
     */
    public static MethodHandle RedrawWindow$handle() {
        return RedrawWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags)
     * }
     */
    public static MemorySegment RedrawWindow$address() {
        return RedrawWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags)
     * }
     */
    public static int RedrawWindow(MemorySegment hWnd, MemorySegment lprcUpdate, MemorySegment hrgnUpdate, int flags) {
        var mh$ = RedrawWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RedrawWindow", hWnd, lprcUpdate, hrgnUpdate, flags);
            }
            return (int)mh$.invokeExact(hWnd, lprcUpdate, hrgnUpdate, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockWindowUpdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LockWindowUpdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockWindowUpdate(HWND hWndLock)
     * }
     */
    public static FunctionDescriptor LockWindowUpdate$descriptor() {
        return LockWindowUpdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockWindowUpdate(HWND hWndLock)
     * }
     */
    public static MethodHandle LockWindowUpdate$handle() {
        return LockWindowUpdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LockWindowUpdate(HWND hWndLock)
     * }
     */
    public static MemorySegment LockWindowUpdate$address() {
        return LockWindowUpdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LockWindowUpdate(HWND hWndLock)
     * }
     */
    public static int LockWindowUpdate(MemorySegment hWndLock) {
        var mh$ = LockWindowUpdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockWindowUpdate", hWndLock);
            }
            return (int)mh$.invokeExact(hWndLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ScrollWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, const RECT *lpRect, const RECT *lpClipRect)
     * }
     */
    public static FunctionDescriptor ScrollWindow$descriptor() {
        return ScrollWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, const RECT *lpRect, const RECT *lpClipRect)
     * }
     */
    public static MethodHandle ScrollWindow$handle() {
        return ScrollWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, const RECT *lpRect, const RECT *lpClipRect)
     * }
     */
    public static MemorySegment ScrollWindow$address() {
        return ScrollWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, const RECT *lpRect, const RECT *lpClipRect)
     * }
     */
    public static int ScrollWindow(MemorySegment hWnd, int XAmount, int YAmount, MemorySegment lpRect, MemorySegment lpClipRect) {
        var mh$ = ScrollWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollWindow", hWnd, XAmount, YAmount, lpRect, lpClipRect);
            }
            return (int)mh$.invokeExact(hWnd, XAmount, YAmount, lpRect, lpClipRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ScrollDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScrollDC(HDC hDC, int dx, int dy, const RECT *lprcScroll, const RECT *lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate)
     * }
     */
    public static FunctionDescriptor ScrollDC$descriptor() {
        return ScrollDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScrollDC(HDC hDC, int dx, int dy, const RECT *lprcScroll, const RECT *lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate)
     * }
     */
    public static MethodHandle ScrollDC$handle() {
        return ScrollDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScrollDC(HDC hDC, int dx, int dy, const RECT *lprcScroll, const RECT *lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate)
     * }
     */
    public static MemorySegment ScrollDC$address() {
        return ScrollDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScrollDC(HDC hDC, int dx, int dy, const RECT *lprcScroll, const RECT *lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate)
     * }
     */
    public static int ScrollDC(MemorySegment hDC, int dx, int dy, MemorySegment lprcScroll, MemorySegment lprcClip, MemorySegment hrgnUpdate, MemorySegment lprcUpdate) {
        var mh$ = ScrollDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollDC", hDC, dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate);
            }
            return (int)mh$.invokeExact(hDC, dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollWindowEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ScrollWindowEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ScrollWindowEx(HWND hWnd, int dx, int dy, const RECT *prcScroll, const RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags)
     * }
     */
    public static FunctionDescriptor ScrollWindowEx$descriptor() {
        return ScrollWindowEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ScrollWindowEx(HWND hWnd, int dx, int dy, const RECT *prcScroll, const RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags)
     * }
     */
    public static MethodHandle ScrollWindowEx$handle() {
        return ScrollWindowEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ScrollWindowEx(HWND hWnd, int dx, int dy, const RECT *prcScroll, const RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags)
     * }
     */
    public static MemorySegment ScrollWindowEx$address() {
        return ScrollWindowEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ScrollWindowEx(HWND hWnd, int dx, int dy, const RECT *prcScroll, const RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags)
     * }
     */
    public static int ScrollWindowEx(MemorySegment hWnd, int dx, int dy, MemorySegment prcScroll, MemorySegment prcClip, MemorySegment hrgnUpdate, MemorySegment prcUpdate, int flags) {
        var mh$ = ScrollWindowEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollWindowEx", hWnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
            }
            return (int)mh$.invokeExact(hWnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetScrollPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetScrollPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw)
     * }
     */
    public static FunctionDescriptor SetScrollPos$descriptor() {
        return SetScrollPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw)
     * }
     */
    public static MethodHandle SetScrollPos$handle() {
        return SetScrollPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw)
     * }
     */
    public static MemorySegment SetScrollPos$address() {
        return SetScrollPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw)
     * }
     */
    public static int SetScrollPos(MemorySegment hWnd, int nBar, int nPos, int bRedraw) {
        var mh$ = SetScrollPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetScrollPos", hWnd, nBar, nPos, bRedraw);
            }
            return (int)mh$.invokeExact(hWnd, nBar, nPos, bRedraw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScrollPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetScrollPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetScrollPos(HWND hWnd, int nBar)
     * }
     */
    public static FunctionDescriptor GetScrollPos$descriptor() {
        return GetScrollPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetScrollPos(HWND hWnd, int nBar)
     * }
     */
    public static MethodHandle GetScrollPos$handle() {
        return GetScrollPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetScrollPos(HWND hWnd, int nBar)
     * }
     */
    public static MemorySegment GetScrollPos$address() {
        return GetScrollPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetScrollPos(HWND hWnd, int nBar)
     * }
     */
    public static int GetScrollPos(MemorySegment hWnd, int nBar) {
        var mh$ = GetScrollPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScrollPos", hWnd, nBar);
            }
            return (int)mh$.invokeExact(hWnd, nBar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetScrollRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetScrollRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw)
     * }
     */
    public static FunctionDescriptor SetScrollRange$descriptor() {
        return SetScrollRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw)
     * }
     */
    public static MethodHandle SetScrollRange$handle() {
        return SetScrollRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw)
     * }
     */
    public static MemorySegment SetScrollRange$address() {
        return SetScrollRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw)
     * }
     */
    public static int SetScrollRange(MemorySegment hWnd, int nBar, int nMinPos, int nMaxPos, int bRedraw) {
        var mh$ = SetScrollRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetScrollRange", hWnd, nBar, nMinPos, nMaxPos, bRedraw);
            }
            return (int)mh$.invokeExact(hWnd, nBar, nMinPos, nMaxPos, bRedraw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScrollRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetScrollRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetScrollRange(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos)
     * }
     */
    public static FunctionDescriptor GetScrollRange$descriptor() {
        return GetScrollRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetScrollRange(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos)
     * }
     */
    public static MethodHandle GetScrollRange$handle() {
        return GetScrollRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetScrollRange(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos)
     * }
     */
    public static MemorySegment GetScrollRange$address() {
        return GetScrollRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetScrollRange(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos)
     * }
     */
    public static int GetScrollRange(MemorySegment hWnd, int nBar, MemorySegment lpMinPos, MemorySegment lpMaxPos) {
        var mh$ = GetScrollRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScrollRange", hWnd, nBar, lpMinPos, lpMaxPos);
            }
            return (int)mh$.invokeExact(hWnd, nBar, lpMinPos, lpMaxPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowScrollBar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ShowScrollBar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowScrollBar(HWND hWnd, int wBar, BOOL bShow)
     * }
     */
    public static FunctionDescriptor ShowScrollBar$descriptor() {
        return ShowScrollBar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowScrollBar(HWND hWnd, int wBar, BOOL bShow)
     * }
     */
    public static MethodHandle ShowScrollBar$handle() {
        return ShowScrollBar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ShowScrollBar(HWND hWnd, int wBar, BOOL bShow)
     * }
     */
    public static MemorySegment ShowScrollBar$address() {
        return ShowScrollBar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ShowScrollBar(HWND hWnd, int wBar, BOOL bShow)
     * }
     */
    public static int ShowScrollBar(MemorySegment hWnd, int wBar, int bShow) {
        var mh$ = ShowScrollBar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowScrollBar", hWnd, wBar, bShow);
            }
            return (int)mh$.invokeExact(hWnd, wBar, bShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableScrollBar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnableScrollBar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows)
     * }
     */
    public static FunctionDescriptor EnableScrollBar$descriptor() {
        return EnableScrollBar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows)
     * }
     */
    public static MethodHandle EnableScrollBar$handle() {
        return EnableScrollBar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows)
     * }
     */
    public static MemorySegment EnableScrollBar$address() {
        return EnableScrollBar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows)
     * }
     */
    public static int EnableScrollBar(MemorySegment hWnd, int wSBflags, int wArrows) {
        var mh$ = EnableScrollBar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableScrollBar", hWnd, wSBflags, wArrows);
            }
            return (int)mh$.invokeExact(hWnd, wSBflags, wArrows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPropA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetPropA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPropA(HWND hWnd, LPCSTR lpString, HANDLE hData)
     * }
     */
    public static FunctionDescriptor SetPropA$descriptor() {
        return SetPropA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPropA(HWND hWnd, LPCSTR lpString, HANDLE hData)
     * }
     */
    public static MethodHandle SetPropA$handle() {
        return SetPropA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPropA(HWND hWnd, LPCSTR lpString, HANDLE hData)
     * }
     */
    public static MemorySegment SetPropA$address() {
        return SetPropA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPropA(HWND hWnd, LPCSTR lpString, HANDLE hData)
     * }
     */
    public static int SetPropA(MemorySegment hWnd, MemorySegment lpString, MemorySegment hData) {
        var mh$ = SetPropA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPropA", hWnd, lpString, hData);
            }
            return (int)mh$.invokeExact(hWnd, lpString, hData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPropW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetPropW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData)
     * }
     */
    public static FunctionDescriptor SetPropW$descriptor() {
        return SetPropW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData)
     * }
     */
    public static MethodHandle SetPropW$handle() {
        return SetPropW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData)
     * }
     */
    public static MemorySegment SetPropW$address() {
        return SetPropW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData)
     * }
     */
    public static int SetPropW(MemorySegment hWnd, MemorySegment lpString, MemorySegment hData) {
        var mh$ = SetPropW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPropW", hWnd, lpString, hData);
            }
            return (int)mh$.invokeExact(hWnd, lpString, hData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPropA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPropA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetPropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor GetPropA$descriptor() {
        return GetPropA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetPropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MethodHandle GetPropA$handle() {
        return GetPropA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetPropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MemorySegment GetPropA$address() {
        return GetPropA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetPropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MemorySegment GetPropA(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = GetPropA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPropA", hWnd, lpString);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPropW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPropW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetPropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor GetPropW$descriptor() {
        return GetPropW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetPropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MethodHandle GetPropW$handle() {
        return GetPropW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetPropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MemorySegment GetPropW$address() {
        return GetPropW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetPropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MemorySegment GetPropW(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = GetPropW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPropW", hWnd, lpString);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemovePropA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemovePropA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE RemovePropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor RemovePropA$descriptor() {
        return RemovePropA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE RemovePropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MethodHandle RemovePropA$handle() {
        return RemovePropA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE RemovePropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MemorySegment RemovePropA$address() {
        return RemovePropA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE RemovePropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MemorySegment RemovePropA(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = RemovePropA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemovePropA", hWnd, lpString);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemovePropW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemovePropW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE RemovePropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor RemovePropW$descriptor() {
        return RemovePropW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE RemovePropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MethodHandle RemovePropW$handle() {
        return RemovePropW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE RemovePropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MemorySegment RemovePropW$address() {
        return RemovePropW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE RemovePropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MemorySegment RemovePropW(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = RemovePropW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemovePropW", hWnd, lpString);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumPropsExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumPropsExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumPropsExA(HWND hWnd, PROPENUMPROCEXA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumPropsExA$descriptor() {
        return EnumPropsExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumPropsExA(HWND hWnd, PROPENUMPROCEXA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumPropsExA$handle() {
        return EnumPropsExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumPropsExA(HWND hWnd, PROPENUMPROCEXA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumPropsExA$address() {
        return EnumPropsExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumPropsExA(HWND hWnd, PROPENUMPROCEXA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumPropsExA(MemorySegment hWnd, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumPropsExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumPropsExA", hWnd, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hWnd, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumPropsExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumPropsExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumPropsExW(HWND hWnd, PROPENUMPROCEXW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumPropsExW$descriptor() {
        return EnumPropsExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumPropsExW(HWND hWnd, PROPENUMPROCEXW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumPropsExW$handle() {
        return EnumPropsExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumPropsExW(HWND hWnd, PROPENUMPROCEXW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumPropsExW$address() {
        return EnumPropsExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumPropsExW(HWND hWnd, PROPENUMPROCEXW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumPropsExW(MemorySegment hWnd, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumPropsExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumPropsExW", hWnd, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hWnd, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumPropsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumPropsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumPropsA(HWND hWnd, PROPENUMPROCA lpEnumFunc)
     * }
     */
    public static FunctionDescriptor EnumPropsA$descriptor() {
        return EnumPropsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumPropsA(HWND hWnd, PROPENUMPROCA lpEnumFunc)
     * }
     */
    public static MethodHandle EnumPropsA$handle() {
        return EnumPropsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumPropsA(HWND hWnd, PROPENUMPROCA lpEnumFunc)
     * }
     */
    public static MemorySegment EnumPropsA$address() {
        return EnumPropsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumPropsA(HWND hWnd, PROPENUMPROCA lpEnumFunc)
     * }
     */
    public static int EnumPropsA(MemorySegment hWnd, MemorySegment lpEnumFunc) {
        var mh$ = EnumPropsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumPropsA", hWnd, lpEnumFunc);
            }
            return (int)mh$.invokeExact(hWnd, lpEnumFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumPropsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumPropsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumPropsW(HWND hWnd, PROPENUMPROCW lpEnumFunc)
     * }
     */
    public static FunctionDescriptor EnumPropsW$descriptor() {
        return EnumPropsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumPropsW(HWND hWnd, PROPENUMPROCW lpEnumFunc)
     * }
     */
    public static MethodHandle EnumPropsW$handle() {
        return EnumPropsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumPropsW(HWND hWnd, PROPENUMPROCW lpEnumFunc)
     * }
     */
    public static MemorySegment EnumPropsW$address() {
        return EnumPropsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumPropsW(HWND hWnd, PROPENUMPROCW lpEnumFunc)
     * }
     */
    public static int EnumPropsW(MemorySegment hWnd, MemorySegment lpEnumFunc) {
        var mh$ = EnumPropsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumPropsW", hWnd, lpEnumFunc);
            }
            return (int)mh$.invokeExact(hWnd, lpEnumFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowTextA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor SetWindowTextA$descriptor() {
        return SetWindowTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowTextA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MethodHandle SetWindowTextA$handle() {
        return SetWindowTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowTextA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MemorySegment SetWindowTextA$address() {
        return SetWindowTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowTextA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static int SetWindowTextA(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = SetWindowTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowTextA", hWnd, lpString);
            }
            return (int)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor SetWindowTextW$descriptor() {
        return SetWindowTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MethodHandle SetWindowTextW$handle() {
        return SetWindowTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MemorySegment SetWindowTextW$address() {
        return SetWindowTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static int SetWindowTextW(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = SetWindowTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowTextW", hWnd, lpString);
            }
            return (int)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount)
     * }
     */
    public static FunctionDescriptor GetWindowTextA$descriptor() {
        return GetWindowTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount)
     * }
     */
    public static MethodHandle GetWindowTextA$handle() {
        return GetWindowTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount)
     * }
     */
    public static MemorySegment GetWindowTextA$address() {
        return GetWindowTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount)
     * }
     */
    public static int GetWindowTextA(MemorySegment hWnd, MemorySegment lpString, int nMaxCount) {
        var mh$ = GetWindowTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowTextA", hWnd, lpString, nMaxCount);
            }
            return (int)mh$.invokeExact(hWnd, lpString, nMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount)
     * }
     */
    public static FunctionDescriptor GetWindowTextW$descriptor() {
        return GetWindowTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount)
     * }
     */
    public static MethodHandle GetWindowTextW$handle() {
        return GetWindowTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount)
     * }
     */
    public static MemorySegment GetWindowTextW$address() {
        return GetWindowTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount)
     * }
     */
    public static int GetWindowTextW(MemorySegment hWnd, MemorySegment lpString, int nMaxCount) {
        var mh$ = GetWindowTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowTextW", hWnd, lpString, nMaxCount);
            }
            return (int)mh$.invokeExact(hWnd, lpString, nMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowTextLengthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowTextLengthA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowTextLengthA(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetWindowTextLengthA$descriptor() {
        return GetWindowTextLengthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowTextLengthA(HWND hWnd)
     * }
     */
    public static MethodHandle GetWindowTextLengthA$handle() {
        return GetWindowTextLengthA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetWindowTextLengthA(HWND hWnd)
     * }
     */
    public static MemorySegment GetWindowTextLengthA$address() {
        return GetWindowTextLengthA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetWindowTextLengthA(HWND hWnd)
     * }
     */
    public static int GetWindowTextLengthA(MemorySegment hWnd) {
        var mh$ = GetWindowTextLengthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowTextLengthA", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowTextLengthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowTextLengthW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowTextLengthW(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetWindowTextLengthW$descriptor() {
        return GetWindowTextLengthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowTextLengthW(HWND hWnd)
     * }
     */
    public static MethodHandle GetWindowTextLengthW$handle() {
        return GetWindowTextLengthW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetWindowTextLengthW(HWND hWnd)
     * }
     */
    public static MemorySegment GetWindowTextLengthW$address() {
        return GetWindowTextLengthW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetWindowTextLengthW(HWND hWnd)
     * }
     */
    public static int GetWindowTextLengthW(MemorySegment hWnd) {
        var mh$ = GetWindowTextLengthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowTextLengthW", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClientRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClientRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static FunctionDescriptor GetClientRect$descriptor() {
        return GetClientRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static MethodHandle GetClientRect$handle() {
        return GetClientRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static MemorySegment GetClientRect$address() {
        return GetClientRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static int GetClientRect(MemorySegment hWnd, MemorySegment lpRect) {
        var mh$ = GetClientRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClientRect", hWnd, lpRect);
            }
            return (int)mh$.invokeExact(hWnd, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static FunctionDescriptor GetWindowRect$descriptor() {
        return GetWindowRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static MethodHandle GetWindowRect$handle() {
        return GetWindowRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static MemorySegment GetWindowRect$address() {
        return GetWindowRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static int GetWindowRect(MemorySegment hWnd, MemorySegment lpRect) {
        var mh$ = GetWindowRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowRect", hWnd, lpRect);
            }
            return (int)mh$.invokeExact(hWnd, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustWindowRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AdjustWindowRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
     * }
     */
    public static FunctionDescriptor AdjustWindowRect$descriptor() {
        return AdjustWindowRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
     * }
     */
    public static MethodHandle AdjustWindowRect$handle() {
        return AdjustWindowRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
     * }
     */
    public static MemorySegment AdjustWindowRect$address() {
        return AdjustWindowRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
     * }
     */
    public static int AdjustWindowRect(MemorySegment lpRect, int dwStyle, int bMenu) {
        var mh$ = AdjustWindowRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustWindowRect", lpRect, dwStyle, bMenu);
            }
            return (int)mh$.invokeExact(lpRect, dwStyle, bMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustWindowRectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AdjustWindowRectEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle)
     * }
     */
    public static FunctionDescriptor AdjustWindowRectEx$descriptor() {
        return AdjustWindowRectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle)
     * }
     */
    public static MethodHandle AdjustWindowRectEx$handle() {
        return AdjustWindowRectEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle)
     * }
     */
    public static MemorySegment AdjustWindowRectEx$address() {
        return AdjustWindowRectEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle)
     * }
     */
    public static int AdjustWindowRectEx(MemorySegment lpRect, int dwStyle, int bMenu, int dwExStyle) {
        var mh$ = AdjustWindowRectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustWindowRectEx", lpRect, dwStyle, bMenu, dwExStyle);
            }
            return (int)mh$.invokeExact(lpRect, dwStyle, bMenu, dwExStyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustWindowRectExForDpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AdjustWindowRectExForDpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRectExForDpi(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle, UINT dpi)
     * }
     */
    public static FunctionDescriptor AdjustWindowRectExForDpi$descriptor() {
        return AdjustWindowRectExForDpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRectExForDpi(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle, UINT dpi)
     * }
     */
    public static MethodHandle AdjustWindowRectExForDpi$handle() {
        return AdjustWindowRectExForDpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRectExForDpi(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle, UINT dpi)
     * }
     */
    public static MemorySegment AdjustWindowRectExForDpi$address() {
        return AdjustWindowRectExForDpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AdjustWindowRectExForDpi(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle, UINT dpi)
     * }
     */
    public static int AdjustWindowRectExForDpi(MemorySegment lpRect, int dwStyle, int bMenu, int dwExStyle, int dpi) {
        var mh$ = AdjustWindowRectExForDpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustWindowRectExForDpi", lpRect, dwStyle, bMenu, dwExStyle, dpi);
            }
            return (int)mh$.invokeExact(lpRect, dwStyle, bMenu, dwExStyle, dpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagHELPINFO {
     *     UINT cbSize;
     *     int iContextType;
     *     int iCtrlId;
     *     HANDLE hItemHandle;
     *     DWORD_PTR dwContextId;
     *     POINT MousePos;
     * } *LPHELPINFO
     * }
     */
    public static final AddressLayout LPHELPINFO = freeglut_h.C_POINTER;

    private static class SetWindowContextHelpId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowContextHelpId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowContextHelpId(HWND, DWORD)
     * }
     */
    public static FunctionDescriptor SetWindowContextHelpId$descriptor() {
        return SetWindowContextHelpId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowContextHelpId(HWND, DWORD)
     * }
     */
    public static MethodHandle SetWindowContextHelpId$handle() {
        return SetWindowContextHelpId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowContextHelpId(HWND, DWORD)
     * }
     */
    public static MemorySegment SetWindowContextHelpId$address() {
        return SetWindowContextHelpId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowContextHelpId(HWND, DWORD)
     * }
     */
    public static int SetWindowContextHelpId(MemorySegment x0, int x1) {
        var mh$ = SetWindowContextHelpId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowContextHelpId", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowContextHelpId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowContextHelpId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetWindowContextHelpId(HWND)
     * }
     */
    public static FunctionDescriptor GetWindowContextHelpId$descriptor() {
        return GetWindowContextHelpId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetWindowContextHelpId(HWND)
     * }
     */
    public static MethodHandle GetWindowContextHelpId$handle() {
        return GetWindowContextHelpId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetWindowContextHelpId(HWND)
     * }
     */
    public static MemorySegment GetWindowContextHelpId$address() {
        return GetWindowContextHelpId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetWindowContextHelpId(HWND)
     * }
     */
    public static int GetWindowContextHelpId(MemorySegment x0) {
        var mh$ = GetWindowContextHelpId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowContextHelpId", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuContextHelpId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMenuContextHelpId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuContextHelpId(HMENU, DWORD)
     * }
     */
    public static FunctionDescriptor SetMenuContextHelpId$descriptor() {
        return SetMenuContextHelpId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuContextHelpId(HMENU, DWORD)
     * }
     */
    public static MethodHandle SetMenuContextHelpId$handle() {
        return SetMenuContextHelpId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenuContextHelpId(HMENU, DWORD)
     * }
     */
    public static MemorySegment SetMenuContextHelpId$address() {
        return SetMenuContextHelpId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenuContextHelpId(HMENU, DWORD)
     * }
     */
    public static int SetMenuContextHelpId(MemorySegment x0, int x1) {
        var mh$ = SetMenuContextHelpId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuContextHelpId", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuContextHelpId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuContextHelpId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetMenuContextHelpId(HMENU)
     * }
     */
    public static FunctionDescriptor GetMenuContextHelpId$descriptor() {
        return GetMenuContextHelpId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetMenuContextHelpId(HMENU)
     * }
     */
    public static MethodHandle GetMenuContextHelpId$handle() {
        return GetMenuContextHelpId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetMenuContextHelpId(HMENU)
     * }
     */
    public static MemorySegment GetMenuContextHelpId$address() {
        return GetMenuContextHelpId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetMenuContextHelpId(HMENU)
     * }
     */
    public static int GetMenuContextHelpId(MemorySegment x0) {
        var mh$ = GetMenuContextHelpId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuContextHelpId", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBoxA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MessageBoxA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
     * }
     */
    public static FunctionDescriptor MessageBoxA$descriptor() {
        return MessageBoxA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
     * }
     */
    public static MethodHandle MessageBoxA$handle() {
        return MessageBoxA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
     * }
     */
    public static MemorySegment MessageBoxA$address() {
        return MessageBoxA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
     * }
     */
    public static int MessageBoxA(MemorySegment hWnd, MemorySegment lpText, MemorySegment lpCaption, int uType) {
        var mh$ = MessageBoxA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxA", hWnd, lpText, lpCaption, uType);
            }
            return (int)mh$.invokeExact(hWnd, lpText, lpCaption, uType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBoxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MessageBoxW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
     * }
     */
    public static FunctionDescriptor MessageBoxW$descriptor() {
        return MessageBoxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
     * }
     */
    public static MethodHandle MessageBoxW$handle() {
        return MessageBoxW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
     * }
     */
    public static MemorySegment MessageBoxW$address() {
        return MessageBoxW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
     * }
     */
    public static int MessageBoxW(MemorySegment hWnd, MemorySegment lpText, MemorySegment lpCaption, int uType) {
        var mh$ = MessageBoxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxW", hWnd, lpText, lpCaption, uType);
            }
            return (int)mh$.invokeExact(hWnd, lpText, lpCaption, uType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBoxExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MessageBoxExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxExA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static FunctionDescriptor MessageBoxExA$descriptor() {
        return MessageBoxExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxExA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static MethodHandle MessageBoxExA$handle() {
        return MessageBoxExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MessageBoxExA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static MemorySegment MessageBoxExA$address() {
        return MessageBoxExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MessageBoxExA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static int MessageBoxExA(MemorySegment hWnd, MemorySegment lpText, MemorySegment lpCaption, int uType, short wLanguageId) {
        var mh$ = MessageBoxExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxExA", hWnd, lpText, lpCaption, uType, wLanguageId);
            }
            return (int)mh$.invokeExact(hWnd, lpText, lpCaption, uType, wLanguageId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBoxExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MessageBoxExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxExW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static FunctionDescriptor MessageBoxExW$descriptor() {
        return MessageBoxExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxExW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static MethodHandle MessageBoxExW$handle() {
        return MessageBoxExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MessageBoxExW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static MemorySegment MessageBoxExW$address() {
        return MessageBoxExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MessageBoxExW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static int MessageBoxExW(MemorySegment hWnd, MemorySegment lpText, MemorySegment lpCaption, int uType, short wLanguageId) {
        var mh$ = MessageBoxExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxExW", hWnd, lpText, lpCaption, uType, wLanguageId);
            }
            return (int)mh$.invokeExact(hWnd, lpText, lpCaption, uType, wLanguageId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMSGBOXPARAMSA {
     *     UINT cbSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCSTR lpszText;
     *     LPCSTR lpszCaption;
     *     DWORD dwStyle;
     *     LPCSTR lpszIcon;
     *     DWORD_PTR dwContextHelpId;
     *     MSGBOXCALLBACK lpfnMsgBoxCallback;
     *     DWORD dwLanguageId;
     * } *PMSGBOXPARAMSA
     * }
     */
    public static final AddressLayout PMSGBOXPARAMSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSGBOXPARAMSA {
     *     UINT cbSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCSTR lpszText;
     *     LPCSTR lpszCaption;
     *     DWORD dwStyle;
     *     LPCSTR lpszIcon;
     *     DWORD_PTR dwContextHelpId;
     *     MSGBOXCALLBACK lpfnMsgBoxCallback;
     *     DWORD dwLanguageId;
     * } *LPMSGBOXPARAMSA
     * }
     */
    public static final AddressLayout LPMSGBOXPARAMSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSGBOXPARAMSW {
     *     UINT cbSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCWSTR lpszText;
     *     LPCWSTR lpszCaption;
     *     DWORD dwStyle;
     *     LPCWSTR lpszIcon;
     *     DWORD_PTR dwContextHelpId;
     *     MSGBOXCALLBACK lpfnMsgBoxCallback;
     *     DWORD dwLanguageId;
     * } *PMSGBOXPARAMSW
     * }
     */
    public static final AddressLayout PMSGBOXPARAMSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSGBOXPARAMSW {
     *     UINT cbSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCWSTR lpszText;
     *     LPCWSTR lpszCaption;
     *     DWORD dwStyle;
     *     LPCWSTR lpszIcon;
     *     DWORD_PTR dwContextHelpId;
     *     MSGBOXCALLBACK lpfnMsgBoxCallback;
     *     DWORD dwLanguageId;
     * } *LPMSGBOXPARAMSW
     * }
     */
    public static final AddressLayout LPMSGBOXPARAMSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMSGBOXPARAMSA PMSGBOXPARAMS
     * }
     */
    public static final AddressLayout PMSGBOXPARAMS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMSGBOXPARAMSA LPMSGBOXPARAMS
     * }
     */
    public static final AddressLayout LPMSGBOXPARAMS = freeglut_h.C_POINTER;

    private static class MessageBoxIndirectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MessageBoxIndirectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxIndirectA(const MSGBOXPARAMSA *lpmbp)
     * }
     */
    public static FunctionDescriptor MessageBoxIndirectA$descriptor() {
        return MessageBoxIndirectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxIndirectA(const MSGBOXPARAMSA *lpmbp)
     * }
     */
    public static MethodHandle MessageBoxIndirectA$handle() {
        return MessageBoxIndirectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MessageBoxIndirectA(const MSGBOXPARAMSA *lpmbp)
     * }
     */
    public static MemorySegment MessageBoxIndirectA$address() {
        return MessageBoxIndirectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MessageBoxIndirectA(const MSGBOXPARAMSA *lpmbp)
     * }
     */
    public static int MessageBoxIndirectA(MemorySegment lpmbp) {
        var mh$ = MessageBoxIndirectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxIndirectA", lpmbp);
            }
            return (int)mh$.invokeExact(lpmbp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBoxIndirectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MessageBoxIndirectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxIndirectW(const MSGBOXPARAMSW *lpmbp)
     * }
     */
    public static FunctionDescriptor MessageBoxIndirectW$descriptor() {
        return MessageBoxIndirectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxIndirectW(const MSGBOXPARAMSW *lpmbp)
     * }
     */
    public static MethodHandle MessageBoxIndirectW$handle() {
        return MessageBoxIndirectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MessageBoxIndirectW(const MSGBOXPARAMSW *lpmbp)
     * }
     */
    public static MemorySegment MessageBoxIndirectW$address() {
        return MessageBoxIndirectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MessageBoxIndirectW(const MSGBOXPARAMSW *lpmbp)
     * }
     */
    public static int MessageBoxIndirectW(MemorySegment lpmbp) {
        var mh$ = MessageBoxIndirectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxIndirectW", lpmbp);
            }
            return (int)mh$.invokeExact(lpmbp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBeep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MessageBeep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MessageBeep(UINT uType)
     * }
     */
    public static FunctionDescriptor MessageBeep$descriptor() {
        return MessageBeep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MessageBeep(UINT uType)
     * }
     */
    public static MethodHandle MessageBeep$handle() {
        return MessageBeep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MessageBeep(UINT uType)
     * }
     */
    public static MemorySegment MessageBeep$address() {
        return MessageBeep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MessageBeep(UINT uType)
     * }
     */
    public static int MessageBeep(int uType) {
        var mh$ = MessageBeep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBeep", uType);
            }
            return (int)mh$.invokeExact(uType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ShowCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ShowCursor(BOOL bShow)
     * }
     */
    public static FunctionDescriptor ShowCursor$descriptor() {
        return ShowCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ShowCursor(BOOL bShow)
     * }
     */
    public static MethodHandle ShowCursor$handle() {
        return ShowCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ShowCursor(BOOL bShow)
     * }
     */
    public static MemorySegment ShowCursor$address() {
        return ShowCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ShowCursor(BOOL bShow)
     * }
     */
    public static int ShowCursor(int bShow) {
        var mh$ = ShowCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowCursor", bShow);
            }
            return (int)mh$.invokeExact(bShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCursorPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCursorPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCursorPos(int X, int Y)
     * }
     */
    public static FunctionDescriptor SetCursorPos$descriptor() {
        return SetCursorPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCursorPos(int X, int Y)
     * }
     */
    public static MethodHandle SetCursorPos$handle() {
        return SetCursorPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCursorPos(int X, int Y)
     * }
     */
    public static MemorySegment SetCursorPos$address() {
        return SetCursorPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCursorPos(int X, int Y)
     * }
     */
    public static int SetCursorPos(int X, int Y) {
        var mh$ = SetCursorPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCursorPos", X, Y);
            }
            return (int)mh$.invokeExact(X, Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPhysicalCursorPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetPhysicalCursorPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPhysicalCursorPos(int X, int Y)
     * }
     */
    public static FunctionDescriptor SetPhysicalCursorPos$descriptor() {
        return SetPhysicalCursorPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPhysicalCursorPos(int X, int Y)
     * }
     */
    public static MethodHandle SetPhysicalCursorPos$handle() {
        return SetPhysicalCursorPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPhysicalCursorPos(int X, int Y)
     * }
     */
    public static MemorySegment SetPhysicalCursorPos$address() {
        return SetPhysicalCursorPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPhysicalCursorPos(int X, int Y)
     * }
     */
    public static int SetPhysicalCursorPos(int X, int Y) {
        var mh$ = SetPhysicalCursorPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPhysicalCursorPos", X, Y);
            }
            return (int)mh$.invokeExact(X, Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR SetCursor(HCURSOR hCursor)
     * }
     */
    public static FunctionDescriptor SetCursor$descriptor() {
        return SetCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR SetCursor(HCURSOR hCursor)
     * }
     */
    public static MethodHandle SetCursor$handle() {
        return SetCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCURSOR SetCursor(HCURSOR hCursor)
     * }
     */
    public static MemorySegment SetCursor$address() {
        return SetCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCURSOR SetCursor(HCURSOR hCursor)
     * }
     */
    public static MemorySegment SetCursor(MemorySegment hCursor) {
        var mh$ = SetCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCursor", hCursor);
            }
            return (MemorySegment)mh$.invokeExact(hCursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCursorPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCursorPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCursorPos(LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor GetCursorPos$descriptor() {
        return GetCursorPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCursorPos(LPPOINT lpPoint)
     * }
     */
    public static MethodHandle GetCursorPos$handle() {
        return GetCursorPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCursorPos(LPPOINT lpPoint)
     * }
     */
    public static MemorySegment GetCursorPos$address() {
        return GetCursorPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCursorPos(LPPOINT lpPoint)
     * }
     */
    public static int GetCursorPos(MemorySegment lpPoint) {
        var mh$ = GetCursorPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCursorPos", lpPoint);
            }
            return (int)mh$.invokeExact(lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPhysicalCursorPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPhysicalCursorPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPhysicalCursorPos(LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor GetPhysicalCursorPos$descriptor() {
        return GetPhysicalCursorPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPhysicalCursorPos(LPPOINT lpPoint)
     * }
     */
    public static MethodHandle GetPhysicalCursorPos$handle() {
        return GetPhysicalCursorPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPhysicalCursorPos(LPPOINT lpPoint)
     * }
     */
    public static MemorySegment GetPhysicalCursorPos$address() {
        return GetPhysicalCursorPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPhysicalCursorPos(LPPOINT lpPoint)
     * }
     */
    public static int GetPhysicalCursorPos(MemorySegment lpPoint) {
        var mh$ = GetPhysicalCursorPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPhysicalCursorPos", lpPoint);
            }
            return (int)mh$.invokeExact(lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClipCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClipCursor(LPRECT lpRect)
     * }
     */
    public static FunctionDescriptor GetClipCursor$descriptor() {
        return GetClipCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClipCursor(LPRECT lpRect)
     * }
     */
    public static MethodHandle GetClipCursor$handle() {
        return GetClipCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetClipCursor(LPRECT lpRect)
     * }
     */
    public static MemorySegment GetClipCursor$address() {
        return GetClipCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetClipCursor(LPRECT lpRect)
     * }
     */
    public static int GetClipCursor(MemorySegment lpRect) {
        var mh$ = GetClipCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipCursor", lpRect);
            }
            return (int)mh$.invokeExact(lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR GetCursor()
     * }
     */
    public static FunctionDescriptor GetCursor$descriptor() {
        return GetCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR GetCursor()
     * }
     */
    public static MethodHandle GetCursor$handle() {
        return GetCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCURSOR GetCursor()
     * }
     */
    public static MemorySegment GetCursor$address() {
        return GetCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCURSOR GetCursor()
     * }
     */
    public static MemorySegment GetCursor() {
        var mh$ = GetCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCursor");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCaret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateCaret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateCaret(HWND hWnd, HBITMAP hBitmap, int nWidth, int nHeight)
     * }
     */
    public static FunctionDescriptor CreateCaret$descriptor() {
        return CreateCaret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateCaret(HWND hWnd, HBITMAP hBitmap, int nWidth, int nHeight)
     * }
     */
    public static MethodHandle CreateCaret$handle() {
        return CreateCaret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateCaret(HWND hWnd, HBITMAP hBitmap, int nWidth, int nHeight)
     * }
     */
    public static MemorySegment CreateCaret$address() {
        return CreateCaret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateCaret(HWND hWnd, HBITMAP hBitmap, int nWidth, int nHeight)
     * }
     */
    public static int CreateCaret(MemorySegment hWnd, MemorySegment hBitmap, int nWidth, int nHeight) {
        var mh$ = CreateCaret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCaret", hWnd, hBitmap, nWidth, nHeight);
            }
            return (int)mh$.invokeExact(hWnd, hBitmap, nWidth, nHeight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCaretBlinkTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCaretBlinkTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetCaretBlinkTime()
     * }
     */
    public static FunctionDescriptor GetCaretBlinkTime$descriptor() {
        return GetCaretBlinkTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetCaretBlinkTime()
     * }
     */
    public static MethodHandle GetCaretBlinkTime$handle() {
        return GetCaretBlinkTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetCaretBlinkTime()
     * }
     */
    public static MemorySegment GetCaretBlinkTime$address() {
        return GetCaretBlinkTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetCaretBlinkTime()
     * }
     */
    public static int GetCaretBlinkTime() {
        var mh$ = GetCaretBlinkTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCaretBlinkTime");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCaretBlinkTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCaretBlinkTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCaretBlinkTime(UINT uMSeconds)
     * }
     */
    public static FunctionDescriptor SetCaretBlinkTime$descriptor() {
        return SetCaretBlinkTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCaretBlinkTime(UINT uMSeconds)
     * }
     */
    public static MethodHandle SetCaretBlinkTime$handle() {
        return SetCaretBlinkTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCaretBlinkTime(UINT uMSeconds)
     * }
     */
    public static MemorySegment SetCaretBlinkTime$address() {
        return SetCaretBlinkTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCaretBlinkTime(UINT uMSeconds)
     * }
     */
    public static int SetCaretBlinkTime(int uMSeconds) {
        var mh$ = SetCaretBlinkTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCaretBlinkTime", uMSeconds);
            }
            return (int)mh$.invokeExact(uMSeconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyCaret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DestroyCaret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyCaret()
     * }
     */
    public static FunctionDescriptor DestroyCaret$descriptor() {
        return DestroyCaret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyCaret()
     * }
     */
    public static MethodHandle DestroyCaret$handle() {
        return DestroyCaret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DestroyCaret()
     * }
     */
    public static MemorySegment DestroyCaret$address() {
        return DestroyCaret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DestroyCaret()
     * }
     */
    public static int DestroyCaret() {
        var mh$ = DestroyCaret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyCaret");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HideCaret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HideCaret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HideCaret(HWND hWnd)
     * }
     */
    public static FunctionDescriptor HideCaret$descriptor() {
        return HideCaret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HideCaret(HWND hWnd)
     * }
     */
    public static MethodHandle HideCaret$handle() {
        return HideCaret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HideCaret(HWND hWnd)
     * }
     */
    public static MemorySegment HideCaret$address() {
        return HideCaret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HideCaret(HWND hWnd)
     * }
     */
    public static int HideCaret(MemorySegment hWnd) {
        var mh$ = HideCaret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HideCaret", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowCaret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ShowCaret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowCaret(HWND hWnd)
     * }
     */
    public static FunctionDescriptor ShowCaret$descriptor() {
        return ShowCaret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowCaret(HWND hWnd)
     * }
     */
    public static MethodHandle ShowCaret$handle() {
        return ShowCaret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ShowCaret(HWND hWnd)
     * }
     */
    public static MemorySegment ShowCaret$address() {
        return ShowCaret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ShowCaret(HWND hWnd)
     * }
     */
    public static int ShowCaret(MemorySegment hWnd) {
        var mh$ = ShowCaret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowCaret", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCaretPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCaretPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCaretPos(int X, int Y)
     * }
     */
    public static FunctionDescriptor SetCaretPos$descriptor() {
        return SetCaretPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCaretPos(int X, int Y)
     * }
     */
    public static MethodHandle SetCaretPos$handle() {
        return SetCaretPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCaretPos(int X, int Y)
     * }
     */
    public static MemorySegment SetCaretPos$address() {
        return SetCaretPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCaretPos(int X, int Y)
     * }
     */
    public static int SetCaretPos(int X, int Y) {
        var mh$ = SetCaretPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCaretPos", X, Y);
            }
            return (int)mh$.invokeExact(X, Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCaretPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCaretPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCaretPos(LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor GetCaretPos$descriptor() {
        return GetCaretPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCaretPos(LPPOINT lpPoint)
     * }
     */
    public static MethodHandle GetCaretPos$handle() {
        return GetCaretPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCaretPos(LPPOINT lpPoint)
     * }
     */
    public static MemorySegment GetCaretPos$address() {
        return GetCaretPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCaretPos(LPPOINT lpPoint)
     * }
     */
    public static int GetCaretPos(MemorySegment lpPoint) {
        var mh$ = GetCaretPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCaretPos", lpPoint);
            }
            return (int)mh$.invokeExact(lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClientToScreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ClientToScreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClientToScreen(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor ClientToScreen$descriptor() {
        return ClientToScreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClientToScreen(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle ClientToScreen$handle() {
        return ClientToScreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ClientToScreen(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MemorySegment ClientToScreen$address() {
        return ClientToScreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClientToScreen(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int ClientToScreen(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = ClientToScreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClientToScreen", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScreenToClient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ScreenToClient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScreenToClient(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor ScreenToClient$descriptor() {
        return ScreenToClient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScreenToClient(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle ScreenToClient$handle() {
        return ScreenToClient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScreenToClient(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MemorySegment ScreenToClient$address() {
        return ScreenToClient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScreenToClient(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int ScreenToClient(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = ScreenToClient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScreenToClient", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogicalToPhysicalPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LogicalToPhysicalPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor LogicalToPhysicalPoint$descriptor() {
        return LogicalToPhysicalPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle LogicalToPhysicalPoint$handle() {
        return LogicalToPhysicalPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MemorySegment LogicalToPhysicalPoint$address() {
        return LogicalToPhysicalPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int LogicalToPhysicalPoint(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = LogicalToPhysicalPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogicalToPhysicalPoint", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PhysicalToLogicalPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PhysicalToLogicalPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor PhysicalToLogicalPoint$descriptor() {
        return PhysicalToLogicalPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle PhysicalToLogicalPoint$handle() {
        return PhysicalToLogicalPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MemorySegment PhysicalToLogicalPoint$address() {
        return PhysicalToLogicalPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int PhysicalToLogicalPoint(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = PhysicalToLogicalPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PhysicalToLogicalPoint", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogicalToPhysicalPointForPerMonitorDPI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LogicalToPhysicalPointForPerMonitorDPI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor LogicalToPhysicalPointForPerMonitorDPI$descriptor() {
        return LogicalToPhysicalPointForPerMonitorDPI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle LogicalToPhysicalPointForPerMonitorDPI$handle() {
        return LogicalToPhysicalPointForPerMonitorDPI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MemorySegment LogicalToPhysicalPointForPerMonitorDPI$address() {
        return LogicalToPhysicalPointForPerMonitorDPI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int LogicalToPhysicalPointForPerMonitorDPI(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = LogicalToPhysicalPointForPerMonitorDPI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogicalToPhysicalPointForPerMonitorDPI", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PhysicalToLogicalPointForPerMonitorDPI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PhysicalToLogicalPointForPerMonitorDPI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor PhysicalToLogicalPointForPerMonitorDPI$descriptor() {
        return PhysicalToLogicalPointForPerMonitorDPI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle PhysicalToLogicalPointForPerMonitorDPI$handle() {
        return PhysicalToLogicalPointForPerMonitorDPI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MemorySegment PhysicalToLogicalPointForPerMonitorDPI$address() {
        return PhysicalToLogicalPointForPerMonitorDPI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int PhysicalToLogicalPointForPerMonitorDPI(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = PhysicalToLogicalPointForPerMonitorDPI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PhysicalToLogicalPointForPerMonitorDPI", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapWindowPoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapWindowPoints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints)
     * }
     */
    public static FunctionDescriptor MapWindowPoints$descriptor() {
        return MapWindowPoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints)
     * }
     */
    public static MethodHandle MapWindowPoints$handle() {
        return MapWindowPoints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints)
     * }
     */
    public static MemorySegment MapWindowPoints$address() {
        return MapWindowPoints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints)
     * }
     */
    public static int MapWindowPoints(MemorySegment hWndFrom, MemorySegment hWndTo, MemorySegment lpPoints, int cPoints) {
        var mh$ = MapWindowPoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapWindowPoints", hWndFrom, hWndTo, lpPoints, cPoints);
            }
            return (int)mh$.invokeExact(hWndFrom, hWndTo, lpPoints, cPoints);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WindowFromPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            tagPOINT.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WindowFromPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND WindowFromPoint(POINT Point)
     * }
     */
    public static FunctionDescriptor WindowFromPoint$descriptor() {
        return WindowFromPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND WindowFromPoint(POINT Point)
     * }
     */
    public static MethodHandle WindowFromPoint$handle() {
        return WindowFromPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND WindowFromPoint(POINT Point)
     * }
     */
    public static MemorySegment WindowFromPoint$address() {
        return WindowFromPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND WindowFromPoint(POINT Point)
     * }
     */
    public static MemorySegment WindowFromPoint(MemorySegment Point) {
        var mh$ = WindowFromPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WindowFromPoint", Point);
            }
            return (MemorySegment)mh$.invokeExact(Point);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WindowFromPhysicalPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            tagPOINT.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WindowFromPhysicalPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND WindowFromPhysicalPoint(POINT Point)
     * }
     */
    public static FunctionDescriptor WindowFromPhysicalPoint$descriptor() {
        return WindowFromPhysicalPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND WindowFromPhysicalPoint(POINT Point)
     * }
     */
    public static MethodHandle WindowFromPhysicalPoint$handle() {
        return WindowFromPhysicalPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND WindowFromPhysicalPoint(POINT Point)
     * }
     */
    public static MemorySegment WindowFromPhysicalPoint$address() {
        return WindowFromPhysicalPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND WindowFromPhysicalPoint(POINT Point)
     * }
     */
    public static MemorySegment WindowFromPhysicalPoint(MemorySegment Point) {
        var mh$ = WindowFromPhysicalPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WindowFromPhysicalPoint", Point);
            }
            return (MemorySegment)mh$.invokeExact(Point);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChildWindowFromPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            tagPOINT.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChildWindowFromPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND ChildWindowFromPoint(HWND hWndParent, POINT Point)
     * }
     */
    public static FunctionDescriptor ChildWindowFromPoint$descriptor() {
        return ChildWindowFromPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND ChildWindowFromPoint(HWND hWndParent, POINT Point)
     * }
     */
    public static MethodHandle ChildWindowFromPoint$handle() {
        return ChildWindowFromPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND ChildWindowFromPoint(HWND hWndParent, POINT Point)
     * }
     */
    public static MemorySegment ChildWindowFromPoint$address() {
        return ChildWindowFromPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND ChildWindowFromPoint(HWND hWndParent, POINT Point)
     * }
     */
    public static MemorySegment ChildWindowFromPoint(MemorySegment hWndParent, MemorySegment Point) {
        var mh$ = ChildWindowFromPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChildWindowFromPoint", hWndParent, Point);
            }
            return (MemorySegment)mh$.invokeExact(hWndParent, Point);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClipCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ClipCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClipCursor(const RECT *lpRect)
     * }
     */
    public static FunctionDescriptor ClipCursor$descriptor() {
        return ClipCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClipCursor(const RECT *lpRect)
     * }
     */
    public static MethodHandle ClipCursor$handle() {
        return ClipCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ClipCursor(const RECT *lpRect)
     * }
     */
    public static MemorySegment ClipCursor$address() {
        return ClipCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClipCursor(const RECT *lpRect)
     * }
     */
    public static int ClipCursor(MemorySegment lpRect) {
        var mh$ = ClipCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClipCursor", lpRect);
            }
            return (int)mh$.invokeExact(lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChildWindowFromPointEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            tagPOINT.layout(),
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChildWindowFromPointEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND ChildWindowFromPointEx(HWND hwnd, POINT pt, UINT flags)
     * }
     */
    public static FunctionDescriptor ChildWindowFromPointEx$descriptor() {
        return ChildWindowFromPointEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND ChildWindowFromPointEx(HWND hwnd, POINT pt, UINT flags)
     * }
     */
    public static MethodHandle ChildWindowFromPointEx$handle() {
        return ChildWindowFromPointEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND ChildWindowFromPointEx(HWND hwnd, POINT pt, UINT flags)
     * }
     */
    public static MemorySegment ChildWindowFromPointEx$address() {
        return ChildWindowFromPointEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND ChildWindowFromPointEx(HWND hwnd, POINT pt, UINT flags)
     * }
     */
    public static MemorySegment ChildWindowFromPointEx(MemorySegment hwnd, MemorySegment pt, int flags) {
        var mh$ = ChildWindowFromPointEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChildWindowFromPointEx", hwnd, pt, flags);
            }
            return (MemorySegment)mh$.invokeExact(hwnd, pt, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSysColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSysColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetSysColor(int nIndex)
     * }
     */
    public static FunctionDescriptor GetSysColor$descriptor() {
        return GetSysColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetSysColor(int nIndex)
     * }
     */
    public static MethodHandle GetSysColor$handle() {
        return GetSysColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetSysColor(int nIndex)
     * }
     */
    public static MemorySegment GetSysColor$address() {
        return GetSysColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetSysColor(int nIndex)
     * }
     */
    public static int GetSysColor(int nIndex) {
        var mh$ = GetSysColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSysColor", nIndex);
            }
            return (int)mh$.invokeExact(nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSysColorBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSysColorBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH GetSysColorBrush(int nIndex)
     * }
     */
    public static FunctionDescriptor GetSysColorBrush$descriptor() {
        return GetSysColorBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH GetSysColorBrush(int nIndex)
     * }
     */
    public static MethodHandle GetSysColorBrush$handle() {
        return GetSysColorBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH GetSysColorBrush(int nIndex)
     * }
     */
    public static MemorySegment GetSysColorBrush$address() {
        return GetSysColorBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH GetSysColorBrush(int nIndex)
     * }
     */
    public static MemorySegment GetSysColorBrush(int nIndex) {
        var mh$ = GetSysColorBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSysColorBrush", nIndex);
            }
            return (MemorySegment)mh$.invokeExact(nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSysColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSysColors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSysColors(int cElements, const INT *lpaElements, const COLORREF *lpaRgbValues)
     * }
     */
    public static FunctionDescriptor SetSysColors$descriptor() {
        return SetSysColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSysColors(int cElements, const INT *lpaElements, const COLORREF *lpaRgbValues)
     * }
     */
    public static MethodHandle SetSysColors$handle() {
        return SetSysColors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSysColors(int cElements, const INT *lpaElements, const COLORREF *lpaRgbValues)
     * }
     */
    public static MemorySegment SetSysColors$address() {
        return SetSysColors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSysColors(int cElements, const INT *lpaElements, const COLORREF *lpaRgbValues)
     * }
     */
    public static int SetSysColors(int cElements, MemorySegment lpaElements, MemorySegment lpaRgbValues) {
        var mh$ = SetSysColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSysColors", cElements, lpaElements, lpaRgbValues);
            }
            return (int)mh$.invokeExact(cElements, lpaElements, lpaRgbValues);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawFocusRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawFocusRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawFocusRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static FunctionDescriptor DrawFocusRect$descriptor() {
        return DrawFocusRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawFocusRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static MethodHandle DrawFocusRect$handle() {
        return DrawFocusRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawFocusRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static MemorySegment DrawFocusRect$address() {
        return DrawFocusRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawFocusRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static int DrawFocusRect(MemorySegment hDC, MemorySegment lprc) {
        var mh$ = DrawFocusRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawFocusRect", hDC, lprc);
            }
            return (int)mh$.invokeExact(hDC, lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FillRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static FunctionDescriptor FillRect$descriptor() {
        return FillRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static MethodHandle FillRect$handle() {
        return FillRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static MemorySegment FillRect$address() {
        return FillRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static int FillRect(MemorySegment hDC, MemorySegment lprc, MemorySegment hbr) {
        var mh$ = FillRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillRect", hDC, lprc, hbr);
            }
            return (int)mh$.invokeExact(hDC, lprc, hbr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FrameRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FrameRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FrameRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static FunctionDescriptor FrameRect$descriptor() {
        return FrameRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FrameRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static MethodHandle FrameRect$handle() {
        return FrameRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FrameRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static MemorySegment FrameRect$address() {
        return FrameRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FrameRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static int FrameRect(MemorySegment hDC, MemorySegment lprc, MemorySegment hbr) {
        var mh$ = FrameRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FrameRect", hDC, lprc, hbr);
            }
            return (int)mh$.invokeExact(hDC, lprc, hbr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvertRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InvertRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvertRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static FunctionDescriptor InvertRect$descriptor() {
        return InvertRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvertRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static MethodHandle InvertRect$handle() {
        return InvertRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InvertRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static MemorySegment InvertRect$address() {
        return InvertRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InvertRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static int InvertRect(MemorySegment hDC, MemorySegment lprc) {
        var mh$ = InvertRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvertRect", hDC, lprc);
            }
            return (int)mh$.invokeExact(hDC, lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetRect(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom)
     * }
     */
    public static FunctionDescriptor SetRect$descriptor() {
        return SetRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetRect(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom)
     * }
     */
    public static MethodHandle SetRect$handle() {
        return SetRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetRect(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom)
     * }
     */
    public static MemorySegment SetRect$address() {
        return SetRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetRect(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom)
     * }
     */
    public static int SetRect(MemorySegment lprc, int xLeft, int yTop, int xRight, int yBottom) {
        var mh$ = SetRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetRect", lprc, xLeft, yTop, xRight, yBottom);
            }
            return (int)mh$.invokeExact(lprc, xLeft, yTop, xRight, yBottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetRectEmpty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetRectEmpty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetRectEmpty(LPRECT lprc)
     * }
     */
    public static FunctionDescriptor SetRectEmpty$descriptor() {
        return SetRectEmpty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetRectEmpty(LPRECT lprc)
     * }
     */
    public static MethodHandle SetRectEmpty$handle() {
        return SetRectEmpty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetRectEmpty(LPRECT lprc)
     * }
     */
    public static MemorySegment SetRectEmpty$address() {
        return SetRectEmpty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetRectEmpty(LPRECT lprc)
     * }
     */
    public static int SetRectEmpty(MemorySegment lprc) {
        var mh$ = SetRectEmpty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetRectEmpty", lprc);
            }
            return (int)mh$.invokeExact(lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyRect(LPRECT lprcDst, const RECT *lprcSrc)
     * }
     */
    public static FunctionDescriptor CopyRect$descriptor() {
        return CopyRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyRect(LPRECT lprcDst, const RECT *lprcSrc)
     * }
     */
    public static MethodHandle CopyRect$handle() {
        return CopyRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyRect(LPRECT lprcDst, const RECT *lprcSrc)
     * }
     */
    public static MemorySegment CopyRect$address() {
        return CopyRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyRect(LPRECT lprcDst, const RECT *lprcSrc)
     * }
     */
    public static int CopyRect(MemorySegment lprcDst, MemorySegment lprcSrc) {
        var mh$ = CopyRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyRect", lprcDst, lprcSrc);
            }
            return (int)mh$.invokeExact(lprcDst, lprcSrc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InflateRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InflateRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InflateRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static FunctionDescriptor InflateRect$descriptor() {
        return InflateRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InflateRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static MethodHandle InflateRect$handle() {
        return InflateRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InflateRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static MemorySegment InflateRect$address() {
        return InflateRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InflateRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static int InflateRect(MemorySegment lprc, int dx, int dy) {
        var mh$ = InflateRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InflateRect", lprc, dx, dy);
            }
            return (int)mh$.invokeExact(lprc, dx, dy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IntersectRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IntersectRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static FunctionDescriptor IntersectRect$descriptor() {
        return IntersectRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IntersectRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static MethodHandle IntersectRect$handle() {
        return IntersectRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IntersectRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static MemorySegment IntersectRect$address() {
        return IntersectRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IntersectRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static int IntersectRect(MemorySegment lprcDst, MemorySegment lprcSrc1, MemorySegment lprcSrc2) {
        var mh$ = IntersectRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectRect", lprcDst, lprcSrc1, lprcSrc2);
            }
            return (int)mh$.invokeExact(lprcDst, lprcSrc1, lprcSrc2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnionRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnionRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnionRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static FunctionDescriptor UnionRect$descriptor() {
        return UnionRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnionRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static MethodHandle UnionRect$handle() {
        return UnionRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnionRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static MemorySegment UnionRect$address() {
        return UnionRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnionRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static int UnionRect(MemorySegment lprcDst, MemorySegment lprcSrc1, MemorySegment lprcSrc2) {
        var mh$ = UnionRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnionRect", lprcDst, lprcSrc1, lprcSrc2);
            }
            return (int)mh$.invokeExact(lprcDst, lprcSrc1, lprcSrc2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SubtractRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SubtractRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SubtractRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static FunctionDescriptor SubtractRect$descriptor() {
        return SubtractRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SubtractRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static MethodHandle SubtractRect$handle() {
        return SubtractRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SubtractRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static MemorySegment SubtractRect$address() {
        return SubtractRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SubtractRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static int SubtractRect(MemorySegment lprcDst, MemorySegment lprcSrc1, MemorySegment lprcSrc2) {
        var mh$ = SubtractRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SubtractRect", lprcDst, lprcSrc1, lprcSrc2);
            }
            return (int)mh$.invokeExact(lprcDst, lprcSrc1, lprcSrc2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OffsetRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OffsetRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static FunctionDescriptor OffsetRect$descriptor() {
        return OffsetRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OffsetRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static MethodHandle OffsetRect$handle() {
        return OffsetRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OffsetRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static MemorySegment OffsetRect$address() {
        return OffsetRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OffsetRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static int OffsetRect(MemorySegment lprc, int dx, int dy) {
        var mh$ = OffsetRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetRect", lprc, dx, dy);
            }
            return (int)mh$.invokeExact(lprc, dx, dy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsRectEmpty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsRectEmpty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsRectEmpty(const RECT *lprc)
     * }
     */
    public static FunctionDescriptor IsRectEmpty$descriptor() {
        return IsRectEmpty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsRectEmpty(const RECT *lprc)
     * }
     */
    public static MethodHandle IsRectEmpty$handle() {
        return IsRectEmpty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsRectEmpty(const RECT *lprc)
     * }
     */
    public static MemorySegment IsRectEmpty$address() {
        return IsRectEmpty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsRectEmpty(const RECT *lprc)
     * }
     */
    public static int IsRectEmpty(MemorySegment lprc) {
        var mh$ = IsRectEmpty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsRectEmpty", lprc);
            }
            return (int)mh$.invokeExact(lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EqualRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualRect(const RECT *lprc1, const RECT *lprc2)
     * }
     */
    public static FunctionDescriptor EqualRect$descriptor() {
        return EqualRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualRect(const RECT *lprc1, const RECT *lprc2)
     * }
     */
    public static MethodHandle EqualRect$handle() {
        return EqualRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EqualRect(const RECT *lprc1, const RECT *lprc2)
     * }
     */
    public static MemorySegment EqualRect$address() {
        return EqualRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EqualRect(const RECT *lprc1, const RECT *lprc2)
     * }
     */
    public static int EqualRect(MemorySegment lprc1, MemorySegment lprc2) {
        var mh$ = EqualRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualRect", lprc1, lprc2);
            }
            return (int)mh$.invokeExact(lprc1, lprc2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PtInRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            tagPOINT.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PtInRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PtInRect(const RECT *lprc, POINT pt)
     * }
     */
    public static FunctionDescriptor PtInRect$descriptor() {
        return PtInRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PtInRect(const RECT *lprc, POINT pt)
     * }
     */
    public static MethodHandle PtInRect$handle() {
        return PtInRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PtInRect(const RECT *lprc, POINT pt)
     * }
     */
    public static MemorySegment PtInRect$address() {
        return PtInRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PtInRect(const RECT *lprc, POINT pt)
     * }
     */
    public static int PtInRect(MemorySegment lprc, MemorySegment pt) {
        var mh$ = PtInRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PtInRect", lprc, pt);
            }
            return (int)mh$.invokeExact(lprc, pt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowWord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowWord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetWindowWord(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetWindowWord$descriptor() {
        return GetWindowWord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetWindowWord(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetWindowWord$handle() {
        return GetWindowWord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD GetWindowWord(HWND hWnd, int nIndex)
     * }
     */
    public static MemorySegment GetWindowWord$address() {
        return GetWindowWord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD GetWindowWord(HWND hWnd, int nIndex)
     * }
     */
    public static short GetWindowWord(MemorySegment hWnd, int nIndex) {
        var mh$ = GetWindowWord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowWord", hWnd, nIndex);
            }
            return (short)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowWord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowWord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD SetWindowWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static FunctionDescriptor SetWindowWord$descriptor() {
        return SetWindowWord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD SetWindowWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static MethodHandle SetWindowWord$handle() {
        return SetWindowWord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD SetWindowWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static MemorySegment SetWindowWord$address() {
        return SetWindowWord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD SetWindowWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static short SetWindowWord(MemorySegment hWnd, int nIndex, short wNewWord) {
        var mh$ = SetWindowWord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowWord", hWnd, nIndex, wNewWord);
            }
            return (short)mh$.invokeExact(hWnd, nIndex, wNewWord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowLongA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowLongA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetWindowLongA(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetWindowLongA$descriptor() {
        return GetWindowLongA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetWindowLongA(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetWindowLongA$handle() {
        return GetWindowLongA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG GetWindowLongA(HWND hWnd, int nIndex)
     * }
     */
    public static MemorySegment GetWindowLongA$address() {
        return GetWindowLongA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG GetWindowLongA(HWND hWnd, int nIndex)
     * }
     */
    public static int GetWindowLongA(MemorySegment hWnd, int nIndex) {
        var mh$ = GetWindowLongA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowLongA", hWnd, nIndex);
            }
            return (int)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowLongW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowLongW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetWindowLongW(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetWindowLongW$descriptor() {
        return GetWindowLongW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetWindowLongW(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetWindowLongW$handle() {
        return GetWindowLongW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG GetWindowLongW(HWND hWnd, int nIndex)
     * }
     */
    public static MemorySegment GetWindowLongW$address() {
        return GetWindowLongW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG GetWindowLongW(HWND hWnd, int nIndex)
     * }
     */
    public static int GetWindowLongW(MemorySegment hWnd, int nIndex) {
        var mh$ = GetWindowLongW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowLongW", hWnd, nIndex);
            }
            return (int)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowLongA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowLongA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static FunctionDescriptor SetWindowLongA$descriptor() {
        return SetWindowLongA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MethodHandle SetWindowLongA$handle() {
        return SetWindowLongA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MemorySegment SetWindowLongA$address() {
        return SetWindowLongA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static int SetWindowLongA(MemorySegment hWnd, int nIndex, int dwNewLong) {
        var mh$ = SetWindowLongA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowLongA", hWnd, nIndex, dwNewLong);
            }
            return (int)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowLongW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowLongW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static FunctionDescriptor SetWindowLongW$descriptor() {
        return SetWindowLongW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MethodHandle SetWindowLongW$handle() {
        return SetWindowLongW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MemorySegment SetWindowLongW$address() {
        return SetWindowLongW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static int SetWindowLongW(MemorySegment hWnd, int nIndex, int dwNewLong) {
        var mh$ = SetWindowLongW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowLongW", hWnd, nIndex, dwNewLong);
            }
            return (int)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowLongPtrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowLongPtrA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetWindowLongPtrA$descriptor() {
        return GetWindowLongPtrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetWindowLongPtrA$handle() {
        return GetWindowLongPtrA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static MemorySegment GetWindowLongPtrA$address() {
        return GetWindowLongPtrA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static long GetWindowLongPtrA(MemorySegment hWnd, int nIndex) {
        var mh$ = GetWindowLongPtrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowLongPtrA", hWnd, nIndex);
            }
            return (long)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowLongPtrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowLongPtrW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetWindowLongPtrW$descriptor() {
        return GetWindowLongPtrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetWindowLongPtrW$handle() {
        return GetWindowLongPtrW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static MemorySegment GetWindowLongPtrW$address() {
        return GetWindowLongPtrW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static long GetWindowLongPtrW(MemorySegment hWnd, int nIndex) {
        var mh$ = GetWindowLongPtrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowLongPtrW", hWnd, nIndex);
            }
            return (long)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowLongPtrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowLongPtrA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static FunctionDescriptor SetWindowLongPtrA$descriptor() {
        return SetWindowLongPtrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MethodHandle SetWindowLongPtrA$handle() {
        return SetWindowLongPtrA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MemorySegment SetWindowLongPtrA$address() {
        return SetWindowLongPtrA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static long SetWindowLongPtrA(MemorySegment hWnd, int nIndex, long dwNewLong) {
        var mh$ = SetWindowLongPtrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowLongPtrA", hWnd, nIndex, dwNewLong);
            }
            return (long)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowLongPtrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowLongPtrW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static FunctionDescriptor SetWindowLongPtrW$descriptor() {
        return SetWindowLongPtrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MethodHandle SetWindowLongPtrW$handle() {
        return SetWindowLongPtrW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MemorySegment SetWindowLongPtrW$address() {
        return SetWindowLongPtrW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static long SetWindowLongPtrW(MemorySegment hWnd, int nIndex, long dwNewLong) {
        var mh$ = SetWindowLongPtrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowLongPtrW", hWnd, nIndex, dwNewLong);
            }
            return (long)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassWord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClassWord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetClassWord(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetClassWord$descriptor() {
        return GetClassWord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetClassWord(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetClassWord$handle() {
        return GetClassWord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD GetClassWord(HWND hWnd, int nIndex)
     * }
     */
    public static MemorySegment GetClassWord$address() {
        return GetClassWord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD GetClassWord(HWND hWnd, int nIndex)
     * }
     */
    public static short GetClassWord(MemorySegment hWnd, int nIndex) {
        var mh$ = GetClassWord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassWord", hWnd, nIndex);
            }
            return (short)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClassWord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetClassWord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD SetClassWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static FunctionDescriptor SetClassWord$descriptor() {
        return SetClassWord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD SetClassWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static MethodHandle SetClassWord$handle() {
        return SetClassWord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD SetClassWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static MemorySegment SetClassWord$address() {
        return SetClassWord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD SetClassWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static short SetClassWord(MemorySegment hWnd, int nIndex, short wNewWord) {
        var mh$ = SetClassWord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClassWord", hWnd, nIndex, wNewWord);
            }
            return (short)mh$.invokeExact(hWnd, nIndex, wNewWord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassLongA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClassLongA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetClassLongA(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetClassLongA$descriptor() {
        return GetClassLongA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetClassLongA(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetClassLongA$handle() {
        return GetClassLongA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetClassLongA(HWND hWnd, int nIndex)
     * }
     */
    public static MemorySegment GetClassLongA$address() {
        return GetClassLongA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetClassLongA(HWND hWnd, int nIndex)
     * }
     */
    public static int GetClassLongA(MemorySegment hWnd, int nIndex) {
        var mh$ = GetClassLongA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassLongA", hWnd, nIndex);
            }
            return (int)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassLongW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClassLongW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetClassLongW(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetClassLongW$descriptor() {
        return GetClassLongW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetClassLongW(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetClassLongW$handle() {
        return GetClassLongW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetClassLongW(HWND hWnd, int nIndex)
     * }
     */
    public static MemorySegment GetClassLongW$address() {
        return GetClassLongW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetClassLongW(HWND hWnd, int nIndex)
     * }
     */
    public static int GetClassLongW(MemorySegment hWnd, int nIndex) {
        var mh$ = GetClassLongW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassLongW", hWnd, nIndex);
            }
            return (int)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClassLongA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetClassLongA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetClassLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static FunctionDescriptor SetClassLongA$descriptor() {
        return SetClassLongA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetClassLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MethodHandle SetClassLongA$handle() {
        return SetClassLongA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetClassLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MemorySegment SetClassLongA$address() {
        return SetClassLongA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetClassLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static int SetClassLongA(MemorySegment hWnd, int nIndex, int dwNewLong) {
        var mh$ = SetClassLongA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClassLongA", hWnd, nIndex, dwNewLong);
            }
            return (int)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClassLongW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetClassLongW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static FunctionDescriptor SetClassLongW$descriptor() {
        return SetClassLongW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MethodHandle SetClassLongW$handle() {
        return SetClassLongW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MemorySegment SetClassLongW$address() {
        return SetClassLongW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static int SetClassLongW(MemorySegment hWnd, int nIndex, int dwNewLong) {
        var mh$ = SetClassLongW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClassLongW", hWnd, nIndex, dwNewLong);
            }
            return (int)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassLongPtrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClassLongPtrA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetClassLongPtrA$descriptor() {
        return GetClassLongPtrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetClassLongPtrA$handle() {
        return GetClassLongPtrA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static MemorySegment GetClassLongPtrA$address() {
        return GetClassLongPtrA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static long GetClassLongPtrA(MemorySegment hWnd, int nIndex) {
        var mh$ = GetClassLongPtrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassLongPtrA", hWnd, nIndex);
            }
            return (long)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassLongPtrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClassLongPtrW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetClassLongPtrW$descriptor() {
        return GetClassLongPtrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetClassLongPtrW$handle() {
        return GetClassLongPtrW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static MemorySegment GetClassLongPtrW$address() {
        return GetClassLongPtrW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static long GetClassLongPtrW(MemorySegment hWnd, int nIndex) {
        var mh$ = GetClassLongPtrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassLongPtrW", hWnd, nIndex);
            }
            return (long)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClassLongPtrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetClassLongPtrA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static FunctionDescriptor SetClassLongPtrA$descriptor() {
        return SetClassLongPtrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MethodHandle SetClassLongPtrA$handle() {
        return SetClassLongPtrA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MemorySegment SetClassLongPtrA$address() {
        return SetClassLongPtrA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static long SetClassLongPtrA(MemorySegment hWnd, int nIndex, long dwNewLong) {
        var mh$ = SetClassLongPtrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClassLongPtrA", hWnd, nIndex, dwNewLong);
            }
            return (long)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClassLongPtrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetClassLongPtrW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static FunctionDescriptor SetClassLongPtrW$descriptor() {
        return SetClassLongPtrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MethodHandle SetClassLongPtrW$handle() {
        return SetClassLongPtrW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MemorySegment SetClassLongPtrW$address() {
        return SetClassLongPtrW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static long SetClassLongPtrW(MemorySegment hWnd, int nIndex, long dwNewLong) {
        var mh$ = SetClassLongPtrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClassLongPtrW", hWnd, nIndex, dwNewLong);
            }
            return (long)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessDefaultLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessDefaultLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultLayout(DWORD *pdwDefaultLayout)
     * }
     */
    public static FunctionDescriptor GetProcessDefaultLayout$descriptor() {
        return GetProcessDefaultLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultLayout(DWORD *pdwDefaultLayout)
     * }
     */
    public static MethodHandle GetProcessDefaultLayout$handle() {
        return GetProcessDefaultLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultLayout(DWORD *pdwDefaultLayout)
     * }
     */
    public static MemorySegment GetProcessDefaultLayout$address() {
        return GetProcessDefaultLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessDefaultLayout(DWORD *pdwDefaultLayout)
     * }
     */
    public static int GetProcessDefaultLayout(MemorySegment pdwDefaultLayout) {
        var mh$ = GetProcessDefaultLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessDefaultLayout", pdwDefaultLayout);
            }
            return (int)mh$.invokeExact(pdwDefaultLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDefaultLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessDefaultLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultLayout(DWORD dwDefaultLayout)
     * }
     */
    public static FunctionDescriptor SetProcessDefaultLayout$descriptor() {
        return SetProcessDefaultLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultLayout(DWORD dwDefaultLayout)
     * }
     */
    public static MethodHandle SetProcessDefaultLayout$handle() {
        return SetProcessDefaultLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultLayout(DWORD dwDefaultLayout)
     * }
     */
    public static MemorySegment SetProcessDefaultLayout$address() {
        return SetProcessDefaultLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessDefaultLayout(DWORD dwDefaultLayout)
     * }
     */
    public static int SetProcessDefaultLayout(int dwDefaultLayout) {
        var mh$ = SetProcessDefaultLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDefaultLayout", dwDefaultLayout);
            }
            return (int)mh$.invokeExact(dwDefaultLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDesktopWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDesktopWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetDesktopWindow()
     * }
     */
    public static FunctionDescriptor GetDesktopWindow$descriptor() {
        return GetDesktopWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetDesktopWindow()
     * }
     */
    public static MethodHandle GetDesktopWindow$handle() {
        return GetDesktopWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetDesktopWindow()
     * }
     */
    public static MemorySegment GetDesktopWindow$address() {
        return GetDesktopWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetDesktopWindow()
     * }
     */
    public static MemorySegment GetDesktopWindow() {
        var mh$ = GetDesktopWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDesktopWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetParent(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetParent$descriptor() {
        return GetParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetParent(HWND hWnd)
     * }
     */
    public static MethodHandle GetParent$handle() {
        return GetParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetParent(HWND hWnd)
     * }
     */
    public static MemorySegment GetParent$address() {
        return GetParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetParent(HWND hWnd)
     * }
     */
    public static MemorySegment GetParent(MemorySegment hWnd) {
        var mh$ = GetParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetParent", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetParent(HWND hWndChild, HWND hWndNewParent)
     * }
     */
    public static FunctionDescriptor SetParent$descriptor() {
        return SetParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetParent(HWND hWndChild, HWND hWndNewParent)
     * }
     */
    public static MethodHandle SetParent$handle() {
        return SetParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND SetParent(HWND hWndChild, HWND hWndNewParent)
     * }
     */
    public static MemorySegment SetParent$address() {
        return SetParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND SetParent(HWND hWndChild, HWND hWndNewParent)
     * }
     */
    public static MemorySegment SetParent(MemorySegment hWndChild, MemorySegment hWndNewParent) {
        var mh$ = SetParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetParent", hWndChild, hWndNewParent);
            }
            return (MemorySegment)mh$.invokeExact(hWndChild, hWndNewParent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumChildWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumChildWindows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumChildWindows$descriptor() {
        return EnumChildWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumChildWindows$handle() {
        return EnumChildWindows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumChildWindows$address() {
        return EnumChildWindows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumChildWindows(MemorySegment hWndParent, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumChildWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumChildWindows", hWndParent, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hWndParent, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindWindowA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindWindowA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName)
     * }
     */
    public static FunctionDescriptor FindWindowA$descriptor() {
        return FindWindowA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName)
     * }
     */
    public static MethodHandle FindWindowA$handle() {
        return FindWindowA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName)
     * }
     */
    public static MemorySegment FindWindowA$address() {
        return FindWindowA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName)
     * }
     */
    public static MemorySegment FindWindowA(MemorySegment lpClassName, MemorySegment lpWindowName) {
        var mh$ = FindWindowA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindWindowA", lpClassName, lpWindowName);
            }
            return (MemorySegment)mh$.invokeExact(lpClassName, lpWindowName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindWindowW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindWindowW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
     * }
     */
    public static FunctionDescriptor FindWindowW$descriptor() {
        return FindWindowW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
     * }
     */
    public static MethodHandle FindWindowW$handle() {
        return FindWindowW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
     * }
     */
    public static MemorySegment FindWindowW$address() {
        return FindWindowW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
     * }
     */
    public static MemorySegment FindWindowW(MemorySegment lpClassName, MemorySegment lpWindowName) {
        var mh$ = FindWindowW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindWindowW", lpClassName, lpWindowName);
            }
            return (MemorySegment)mh$.invokeExact(lpClassName, lpWindowName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindWindowExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindWindowExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND FindWindowExA(HWND hWndParent, HWND hWndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow)
     * }
     */
    public static FunctionDescriptor FindWindowExA$descriptor() {
        return FindWindowExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND FindWindowExA(HWND hWndParent, HWND hWndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow)
     * }
     */
    public static MethodHandle FindWindowExA$handle() {
        return FindWindowExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND FindWindowExA(HWND hWndParent, HWND hWndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow)
     * }
     */
    public static MemorySegment FindWindowExA$address() {
        return FindWindowExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND FindWindowExA(HWND hWndParent, HWND hWndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow)
     * }
     */
    public static MemorySegment FindWindowExA(MemorySegment hWndParent, MemorySegment hWndChildAfter, MemorySegment lpszClass, MemorySegment lpszWindow) {
        var mh$ = FindWindowExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindWindowExA", hWndParent, hWndChildAfter, lpszClass, lpszWindow);
            }
            return (MemorySegment)mh$.invokeExact(hWndParent, hWndChildAfter, lpszClass, lpszWindow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindWindowExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindWindowExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND FindWindowExW(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow)
     * }
     */
    public static FunctionDescriptor FindWindowExW$descriptor() {
        return FindWindowExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND FindWindowExW(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow)
     * }
     */
    public static MethodHandle FindWindowExW$handle() {
        return FindWindowExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND FindWindowExW(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow)
     * }
     */
    public static MemorySegment FindWindowExW$address() {
        return FindWindowExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND FindWindowExW(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow)
     * }
     */
    public static MemorySegment FindWindowExW(MemorySegment hWndParent, MemorySegment hWndChildAfter, MemorySegment lpszClass, MemorySegment lpszWindow) {
        var mh$ = FindWindowExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindWindowExW", hWndParent, hWndChildAfter, lpszClass, lpszWindow);
            }
            return (MemorySegment)mh$.invokeExact(hWndParent, hWndChildAfter, lpszClass, lpszWindow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShellWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetShellWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetShellWindow()
     * }
     */
    public static FunctionDescriptor GetShellWindow$descriptor() {
        return GetShellWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetShellWindow()
     * }
     */
    public static MethodHandle GetShellWindow$handle() {
        return GetShellWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetShellWindow()
     * }
     */
    public static MemorySegment GetShellWindow$address() {
        return GetShellWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetShellWindow()
     * }
     */
    public static MemorySegment GetShellWindow() {
        var mh$ = GetShellWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShellWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterShellHookWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterShellHookWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterShellHookWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor RegisterShellHookWindow$descriptor() {
        return RegisterShellHookWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterShellHookWindow(HWND hwnd)
     * }
     */
    public static MethodHandle RegisterShellHookWindow$handle() {
        return RegisterShellHookWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterShellHookWindow(HWND hwnd)
     * }
     */
    public static MemorySegment RegisterShellHookWindow$address() {
        return RegisterShellHookWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterShellHookWindow(HWND hwnd)
     * }
     */
    public static int RegisterShellHookWindow(MemorySegment hwnd) {
        var mh$ = RegisterShellHookWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterShellHookWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeregisterShellHookWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeregisterShellHookWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeregisterShellHookWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor DeregisterShellHookWindow$descriptor() {
        return DeregisterShellHookWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeregisterShellHookWindow(HWND hwnd)
     * }
     */
    public static MethodHandle DeregisterShellHookWindow$handle() {
        return DeregisterShellHookWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeregisterShellHookWindow(HWND hwnd)
     * }
     */
    public static MemorySegment DeregisterShellHookWindow$address() {
        return DeregisterShellHookWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeregisterShellHookWindow(HWND hwnd)
     * }
     */
    public static int DeregisterShellHookWindow(MemorySegment hwnd) {
        var mh$ = DeregisterShellHookWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeregisterShellHookWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumWindows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumWindows$descriptor() {
        return EnumWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumWindows$handle() {
        return EnumWindows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumWindows$address() {
        return EnumWindows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumWindows(MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumWindows", lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumThreadWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumThreadWindows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumThreadWindows(DWORD dwThreadId, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumThreadWindows$descriptor() {
        return EnumThreadWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumThreadWindows(DWORD dwThreadId, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumThreadWindows$handle() {
        return EnumThreadWindows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumThreadWindows(DWORD dwThreadId, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumThreadWindows$address() {
        return EnumThreadWindows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumThreadWindows(DWORD dwThreadId, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static int EnumThreadWindows(int dwThreadId, MemorySegment lpfn, long lParam) {
        var mh$ = EnumThreadWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumThreadWindows", dwThreadId, lpfn, lParam);
            }
            return (int)mh$.invokeExact(dwThreadId, lpfn, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClassNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClassNameA(HWND hWnd, LPSTR lpClassName, int nMaxCount)
     * }
     */
    public static FunctionDescriptor GetClassNameA$descriptor() {
        return GetClassNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClassNameA(HWND hWnd, LPSTR lpClassName, int nMaxCount)
     * }
     */
    public static MethodHandle GetClassNameA$handle() {
        return GetClassNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClassNameA(HWND hWnd, LPSTR lpClassName, int nMaxCount)
     * }
     */
    public static MemorySegment GetClassNameA$address() {
        return GetClassNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClassNameA(HWND hWnd, LPSTR lpClassName, int nMaxCount)
     * }
     */
    public static int GetClassNameA(MemorySegment hWnd, MemorySegment lpClassName, int nMaxCount) {
        var mh$ = GetClassNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassNameA", hWnd, lpClassName, nMaxCount);
            }
            return (int)mh$.invokeExact(hWnd, lpClassName, nMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClassNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
     * }
     */
    public static FunctionDescriptor GetClassNameW$descriptor() {
        return GetClassNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
     * }
     */
    public static MethodHandle GetClassNameW$handle() {
        return GetClassNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
     * }
     */
    public static MemorySegment GetClassNameW$address() {
        return GetClassNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
     * }
     */
    public static int GetClassNameW(MemorySegment hWnd, MemorySegment lpClassName, int nMaxCount) {
        var mh$ = GetClassNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassNameW", hWnd, lpClassName, nMaxCount);
            }
            return (int)mh$.invokeExact(hWnd, lpClassName, nMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTopWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTopWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetTopWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetTopWindow$descriptor() {
        return GetTopWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetTopWindow(HWND hWnd)
     * }
     */
    public static MethodHandle GetTopWindow$handle() {
        return GetTopWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetTopWindow(HWND hWnd)
     * }
     */
    public static MemorySegment GetTopWindow$address() {
        return GetTopWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetTopWindow(HWND hWnd)
     * }
     */
    public static MemorySegment GetTopWindow(MemorySegment hWnd) {
        var mh$ = GetTopWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTopWindow", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowThreadProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowThreadProcessId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId)
     * }
     */
    public static FunctionDescriptor GetWindowThreadProcessId$descriptor() {
        return GetWindowThreadProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId)
     * }
     */
    public static MethodHandle GetWindowThreadProcessId$handle() {
        return GetWindowThreadProcessId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId)
     * }
     */
    public static MemorySegment GetWindowThreadProcessId$address() {
        return GetWindowThreadProcessId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId)
     * }
     */
    public static int GetWindowThreadProcessId(MemorySegment hWnd, MemorySegment lpdwProcessId) {
        var mh$ = GetWindowThreadProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowThreadProcessId", hWnd, lpdwProcessId);
            }
            return (int)mh$.invokeExact(hWnd, lpdwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsGUIThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsGUIThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsGUIThread(BOOL bConvert)
     * }
     */
    public static FunctionDescriptor IsGUIThread$descriptor() {
        return IsGUIThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsGUIThread(BOOL bConvert)
     * }
     */
    public static MethodHandle IsGUIThread$handle() {
        return IsGUIThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsGUIThread(BOOL bConvert)
     * }
     */
    public static MemorySegment IsGUIThread$address() {
        return IsGUIThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsGUIThread(BOOL bConvert)
     * }
     */
    public static int IsGUIThread(int bConvert) {
        var mh$ = IsGUIThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsGUIThread", bConvert);
            }
            return (int)mh$.invokeExact(bConvert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLastActivePopup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLastActivePopup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetLastActivePopup(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetLastActivePopup$descriptor() {
        return GetLastActivePopup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetLastActivePopup(HWND hWnd)
     * }
     */
    public static MethodHandle GetLastActivePopup$handle() {
        return GetLastActivePopup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetLastActivePopup(HWND hWnd)
     * }
     */
    public static MemorySegment GetLastActivePopup$address() {
        return GetLastActivePopup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetLastActivePopup(HWND hWnd)
     * }
     */
    public static MemorySegment GetLastActivePopup(MemorySegment hWnd) {
        var mh$ = GetLastActivePopup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastActivePopup", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetWindow(HWND hWnd, UINT uCmd)
     * }
     */
    public static FunctionDescriptor GetWindow$descriptor() {
        return GetWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetWindow(HWND hWnd, UINT uCmd)
     * }
     */
    public static MethodHandle GetWindow$handle() {
        return GetWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetWindow(HWND hWnd, UINT uCmd)
     * }
     */
    public static MemorySegment GetWindow$address() {
        return GetWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetWindow(HWND hWnd, UINT uCmd)
     * }
     */
    public static MemorySegment GetWindow(MemorySegment hWnd, int uCmd) {
        var mh$ = GetWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindow", hWnd, uCmd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, uCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowsHookA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowsHookA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookA(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static FunctionDescriptor SetWindowsHookA$descriptor() {
        return SetWindowsHookA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookA(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static MethodHandle SetWindowsHookA$handle() {
        return SetWindowsHookA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookA(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static MemorySegment SetWindowsHookA$address() {
        return SetWindowsHookA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HHOOK SetWindowsHookA(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static MemorySegment SetWindowsHookA(int nFilterType, MemorySegment pfnFilterProc) {
        var mh$ = SetWindowsHookA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowsHookA", nFilterType, pfnFilterProc);
            }
            return (MemorySegment)mh$.invokeExact(nFilterType, pfnFilterProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowsHookW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowsHookW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookW(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static FunctionDescriptor SetWindowsHookW$descriptor() {
        return SetWindowsHookW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookW(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static MethodHandle SetWindowsHookW$handle() {
        return SetWindowsHookW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookW(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static MemorySegment SetWindowsHookW$address() {
        return SetWindowsHookW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HHOOK SetWindowsHookW(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static MemorySegment SetWindowsHookW(int nFilterType, MemorySegment pfnFilterProc) {
        var mh$ = SetWindowsHookW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowsHookW", nFilterType, pfnFilterProc);
            }
            return (MemorySegment)mh$.invokeExact(nFilterType, pfnFilterProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnhookWindowsHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnhookWindowsHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnhookWindowsHook(int nCode, HOOKPROC pfnFilterProc)
     * }
     */
    public static FunctionDescriptor UnhookWindowsHook$descriptor() {
        return UnhookWindowsHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnhookWindowsHook(int nCode, HOOKPROC pfnFilterProc)
     * }
     */
    public static MethodHandle UnhookWindowsHook$handle() {
        return UnhookWindowsHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnhookWindowsHook(int nCode, HOOKPROC pfnFilterProc)
     * }
     */
    public static MemorySegment UnhookWindowsHook$address() {
        return UnhookWindowsHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnhookWindowsHook(int nCode, HOOKPROC pfnFilterProc)
     * }
     */
    public static int UnhookWindowsHook(int nCode, MemorySegment pfnFilterProc) {
        var mh$ = UnhookWindowsHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnhookWindowsHook", nCode, pfnFilterProc);
            }
            return (int)mh$.invokeExact(nCode, pfnFilterProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowsHookExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowsHookExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExA(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static FunctionDescriptor SetWindowsHookExA$descriptor() {
        return SetWindowsHookExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExA(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static MethodHandle SetWindowsHookExA$handle() {
        return SetWindowsHookExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExA(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static MemorySegment SetWindowsHookExA$address() {
        return SetWindowsHookExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExA(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static MemorySegment SetWindowsHookExA(int idHook, MemorySegment lpfn, MemorySegment hmod, int dwThreadId) {
        var mh$ = SetWindowsHookExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowsHookExA", idHook, lpfn, hmod, dwThreadId);
            }
            return (MemorySegment)mh$.invokeExact(idHook, lpfn, hmod, dwThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowsHookExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowsHookExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static FunctionDescriptor SetWindowsHookExW$descriptor() {
        return SetWindowsHookExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static MethodHandle SetWindowsHookExW$handle() {
        return SetWindowsHookExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static MemorySegment SetWindowsHookExW$address() {
        return SetWindowsHookExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static MemorySegment SetWindowsHookExW(int idHook, MemorySegment lpfn, MemorySegment hmod, int dwThreadId) {
        var mh$ = SetWindowsHookExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowsHookExW", idHook, lpfn, hmod, dwThreadId);
            }
            return (MemorySegment)mh$.invokeExact(idHook, lpfn, hmod, dwThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnhookWindowsHookEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnhookWindowsHookEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnhookWindowsHookEx(HHOOK hhk)
     * }
     */
    public static FunctionDescriptor UnhookWindowsHookEx$descriptor() {
        return UnhookWindowsHookEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnhookWindowsHookEx(HHOOK hhk)
     * }
     */
    public static MethodHandle UnhookWindowsHookEx$handle() {
        return UnhookWindowsHookEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnhookWindowsHookEx(HHOOK hhk)
     * }
     */
    public static MemorySegment UnhookWindowsHookEx$address() {
        return UnhookWindowsHookEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnhookWindowsHookEx(HHOOK hhk)
     * }
     */
    public static int UnhookWindowsHookEx(MemorySegment hhk) {
        var mh$ = UnhookWindowsHookEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnhookWindowsHookEx", hhk);
            }
            return (int)mh$.invokeExact(hhk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallNextHookEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CallNextHookEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CallNextHookEx$descriptor() {
        return CallNextHookEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle CallNextHookEx$handle() {
        return CallNextHookEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment CallNextHookEx$address() {
        return CallNextHookEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long CallNextHookEx(MemorySegment hhk, int nCode, long wParam, long lParam) {
        var mh$ = CallNextHookEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallNextHookEx", hhk, nCode, wParam, lParam);
            }
            return (long)mh$.invokeExact(hhk, nCode, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckMenuRadioItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckMenuRadioItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckMenuRadioItem(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags)
     * }
     */
    public static FunctionDescriptor CheckMenuRadioItem$descriptor() {
        return CheckMenuRadioItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckMenuRadioItem(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags)
     * }
     */
    public static MethodHandle CheckMenuRadioItem$handle() {
        return CheckMenuRadioItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckMenuRadioItem(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags)
     * }
     */
    public static MemorySegment CheckMenuRadioItem$address() {
        return CheckMenuRadioItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckMenuRadioItem(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags)
     * }
     */
    public static int CheckMenuRadioItem(MemorySegment hmenu, int first, int last, int check, int flags) {
        var mh$ = CheckMenuRadioItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckMenuRadioItem", hmenu, first, last, check, flags);
            }
            return (int)mh$.invokeExact(hmenu, first, last, check, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     WORD versionNumber;
     *     WORD offset;
     * } *PMENUITEMTEMPLATEHEADER
     * }
     */
    public static final AddressLayout PMENUITEMTEMPLATEHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     WORD mtOption;
     *     WORD mtID;
     *     WCHAR mtString[1];
     * } *PMENUITEMTEMPLATE
     * }
     */
    public static final AddressLayout PMENUITEMTEMPLATE = freeglut_h.C_POINTER;

    private static class LoadBitmapA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadBitmapA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP LoadBitmapA(HINSTANCE hInstance, LPCSTR lpBitmapName)
     * }
     */
    public static FunctionDescriptor LoadBitmapA$descriptor() {
        return LoadBitmapA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP LoadBitmapA(HINSTANCE hInstance, LPCSTR lpBitmapName)
     * }
     */
    public static MethodHandle LoadBitmapA$handle() {
        return LoadBitmapA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP LoadBitmapA(HINSTANCE hInstance, LPCSTR lpBitmapName)
     * }
     */
    public static MemorySegment LoadBitmapA$address() {
        return LoadBitmapA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP LoadBitmapA(HINSTANCE hInstance, LPCSTR lpBitmapName)
     * }
     */
    public static MemorySegment LoadBitmapA(MemorySegment hInstance, MemorySegment lpBitmapName) {
        var mh$ = LoadBitmapA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadBitmapA", hInstance, lpBitmapName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpBitmapName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadBitmapW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadBitmapW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
     * }
     */
    public static FunctionDescriptor LoadBitmapW$descriptor() {
        return LoadBitmapW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
     * }
     */
    public static MethodHandle LoadBitmapW$handle() {
        return LoadBitmapW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
     * }
     */
    public static MemorySegment LoadBitmapW$address() {
        return LoadBitmapW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
     * }
     */
    public static MemorySegment LoadBitmapW(MemorySegment hInstance, MemorySegment lpBitmapName) {
        var mh$ = LoadBitmapW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadBitmapW", hInstance, lpBitmapName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpBitmapName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadCursorA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadCursorA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName)
     * }
     */
    public static FunctionDescriptor LoadCursorA$descriptor() {
        return LoadCursorA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName)
     * }
     */
    public static MethodHandle LoadCursorA$handle() {
        return LoadCursorA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName)
     * }
     */
    public static MemorySegment LoadCursorA$address() {
        return LoadCursorA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCURSOR LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName)
     * }
     */
    public static MemorySegment LoadCursorA(MemorySegment hInstance, MemorySegment lpCursorName) {
        var mh$ = LoadCursorA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadCursorA", hInstance, lpCursorName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpCursorName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadCursorW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadCursorW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
     * }
     */
    public static FunctionDescriptor LoadCursorW$descriptor() {
        return LoadCursorW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
     * }
     */
    public static MethodHandle LoadCursorW$handle() {
        return LoadCursorW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
     * }
     */
    public static MemorySegment LoadCursorW$address() {
        return LoadCursorW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCURSOR LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
     * }
     */
    public static MemorySegment LoadCursorW(MemorySegment hInstance, MemorySegment lpCursorName) {
        var mh$ = LoadCursorW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadCursorW", hInstance, lpCursorName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpCursorName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadCursorFromFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadCursorFromFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor LoadCursorFromFileA$descriptor() {
        return LoadCursorFromFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle LoadCursorFromFileA$handle() {
        return LoadCursorFromFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment LoadCursorFromFileA$address() {
        return LoadCursorFromFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment LoadCursorFromFileA(MemorySegment lpFileName) {
        var mh$ = LoadCursorFromFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadCursorFromFileA", lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadCursorFromFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadCursorFromFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor LoadCursorFromFileW$descriptor() {
        return LoadCursorFromFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle LoadCursorFromFileW$handle() {
        return LoadCursorFromFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment LoadCursorFromFileW$address() {
        return LoadCursorFromFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment LoadCursorFromFileW(MemorySegment lpFileName) {
        var mh$ = LoadCursorFromFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadCursorFromFileW", lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR CreateCursor(HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, const void *pvANDPlane, const void *pvXORPlane)
     * }
     */
    public static FunctionDescriptor CreateCursor$descriptor() {
        return CreateCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR CreateCursor(HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, const void *pvANDPlane, const void *pvXORPlane)
     * }
     */
    public static MethodHandle CreateCursor$handle() {
        return CreateCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCURSOR CreateCursor(HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, const void *pvANDPlane, const void *pvXORPlane)
     * }
     */
    public static MemorySegment CreateCursor$address() {
        return CreateCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCURSOR CreateCursor(HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, const void *pvANDPlane, const void *pvXORPlane)
     * }
     */
    public static MemorySegment CreateCursor(MemorySegment hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, MemorySegment pvANDPlane, MemorySegment pvXORPlane) {
        var mh$ = CreateCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCursor", hInst, xHotSpot, yHotSpot, nWidth, nHeight, pvANDPlane, pvXORPlane);
            }
            return (MemorySegment)mh$.invokeExact(hInst, xHotSpot, yHotSpot, nWidth, nHeight, pvANDPlane, pvXORPlane);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DestroyCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyCursor(HCURSOR hCursor)
     * }
     */
    public static FunctionDescriptor DestroyCursor$descriptor() {
        return DestroyCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyCursor(HCURSOR hCursor)
     * }
     */
    public static MethodHandle DestroyCursor$handle() {
        return DestroyCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DestroyCursor(HCURSOR hCursor)
     * }
     */
    public static MemorySegment DestroyCursor$address() {
        return DestroyCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DestroyCursor(HCURSOR hCursor)
     * }
     */
    public static int DestroyCursor(MemorySegment hCursor) {
        var mh$ = DestroyCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyCursor", hCursor);
            }
            return (int)mh$.invokeExact(hCursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSystemCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemCursor(HCURSOR hcur, DWORD id)
     * }
     */
    public static FunctionDescriptor SetSystemCursor$descriptor() {
        return SetSystemCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemCursor(HCURSOR hcur, DWORD id)
     * }
     */
    public static MethodHandle SetSystemCursor$handle() {
        return SetSystemCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemCursor(HCURSOR hcur, DWORD id)
     * }
     */
    public static MemorySegment SetSystemCursor$address() {
        return SetSystemCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemCursor(HCURSOR hcur, DWORD id)
     * }
     */
    public static int SetSystemCursor(MemorySegment hcur, int id) {
        var mh$ = SetSystemCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemCursor", hcur, id);
            }
            return (int)mh$.invokeExact(hcur, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef ICONINFO *PICONINFO
     * }
     */
    public static final AddressLayout PICONINFO = freeglut_h.C_POINTER;

    private static class LoadIconA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadIconA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName)
     * }
     */
    public static FunctionDescriptor LoadIconA$descriptor() {
        return LoadIconA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName)
     * }
     */
    public static MethodHandle LoadIconA$handle() {
        return LoadIconA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HICON LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName)
     * }
     */
    public static MemorySegment LoadIconA$address() {
        return LoadIconA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HICON LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName)
     * }
     */
    public static MemorySegment LoadIconA(MemorySegment hInstance, MemorySegment lpIconName) {
        var mh$ = LoadIconA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadIconA", hInstance, lpIconName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpIconName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadIconW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadIconW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName)
     * }
     */
    public static FunctionDescriptor LoadIconW$descriptor() {
        return LoadIconW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName)
     * }
     */
    public static MethodHandle LoadIconW$handle() {
        return LoadIconW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HICON LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName)
     * }
     */
    public static MemorySegment LoadIconW$address() {
        return LoadIconW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HICON LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName)
     * }
     */
    public static MemorySegment LoadIconW(MemorySegment hInstance, MemorySegment lpIconName) {
        var mh$ = LoadIconW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadIconW", hInstance, lpIconName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpIconName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivateExtractIconsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PrivateExtractIconsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT PrivateExtractIconsA(LPCSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static FunctionDescriptor PrivateExtractIconsA$descriptor() {
        return PrivateExtractIconsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT PrivateExtractIconsA(LPCSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static MethodHandle PrivateExtractIconsA$handle() {
        return PrivateExtractIconsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT PrivateExtractIconsA(LPCSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static MemorySegment PrivateExtractIconsA$address() {
        return PrivateExtractIconsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT PrivateExtractIconsA(LPCSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static int PrivateExtractIconsA(MemorySegment szFileName, int nIconIndex, int cxIcon, int cyIcon, MemorySegment phicon, MemorySegment piconid, int nIcons, int flags) {
        var mh$ = PrivateExtractIconsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivateExtractIconsA", szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
            }
            return (int)mh$.invokeExact(szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivateExtractIconsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PrivateExtractIconsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT PrivateExtractIconsW(LPCWSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static FunctionDescriptor PrivateExtractIconsW$descriptor() {
        return PrivateExtractIconsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT PrivateExtractIconsW(LPCWSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static MethodHandle PrivateExtractIconsW$handle() {
        return PrivateExtractIconsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT PrivateExtractIconsW(LPCWSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static MemorySegment PrivateExtractIconsW$address() {
        return PrivateExtractIconsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT PrivateExtractIconsW(LPCWSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static int PrivateExtractIconsW(MemorySegment szFileName, int nIconIndex, int cxIcon, int cyIcon, MemorySegment phicon, MemorySegment piconid, int nIcons, int flags) {
        var mh$ = PrivateExtractIconsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivateExtractIconsW", szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
            }
            return (int)mh$.invokeExact(szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateIcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE *lpbANDbits, const BYTE *lpbXORbits)
     * }
     */
    public static FunctionDescriptor CreateIcon$descriptor() {
        return CreateIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE *lpbANDbits, const BYTE *lpbXORbits)
     * }
     */
    public static MethodHandle CreateIcon$handle() {
        return CreateIcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HICON CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE *lpbANDbits, const BYTE *lpbXORbits)
     * }
     */
    public static MemorySegment CreateIcon$address() {
        return CreateIcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HICON CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE *lpbANDbits, const BYTE *lpbXORbits)
     * }
     */
    public static MemorySegment CreateIcon(MemorySegment hInstance, int nWidth, int nHeight, byte cPlanes, byte cBitsPixel, MemorySegment lpbANDbits, MemorySegment lpbXORbits) {
        var mh$ = CreateIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIcon", hInstance, nWidth, nHeight, cPlanes, cBitsPixel, lpbANDbits, lpbXORbits);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, nWidth, nHeight, cPlanes, cBitsPixel, lpbANDbits, lpbXORbits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DestroyIcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyIcon(HICON hIcon)
     * }
     */
    public static FunctionDescriptor DestroyIcon$descriptor() {
        return DestroyIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyIcon(HICON hIcon)
     * }
     */
    public static MethodHandle DestroyIcon$handle() {
        return DestroyIcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DestroyIcon(HICON hIcon)
     * }
     */
    public static MemorySegment DestroyIcon$address() {
        return DestroyIcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DestroyIcon(HICON hIcon)
     * }
     */
    public static int DestroyIcon(MemorySegment hIcon) {
        var mh$ = DestroyIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyIcon", hIcon);
            }
            return (int)mh$.invokeExact(hIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupIconIdFromDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupIconIdFromDirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LookupIconIdFromDirectory(PBYTE presbits, BOOL fIcon)
     * }
     */
    public static FunctionDescriptor LookupIconIdFromDirectory$descriptor() {
        return LookupIconIdFromDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LookupIconIdFromDirectory(PBYTE presbits, BOOL fIcon)
     * }
     */
    public static MethodHandle LookupIconIdFromDirectory$handle() {
        return LookupIconIdFromDirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LookupIconIdFromDirectory(PBYTE presbits, BOOL fIcon)
     * }
     */
    public static MemorySegment LookupIconIdFromDirectory$address() {
        return LookupIconIdFromDirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LookupIconIdFromDirectory(PBYTE presbits, BOOL fIcon)
     * }
     */
    public static int LookupIconIdFromDirectory(MemorySegment presbits, int fIcon) {
        var mh$ = LookupIconIdFromDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupIconIdFromDirectory", presbits, fIcon);
            }
            return (int)mh$.invokeExact(presbits, fIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupIconIdFromDirectoryEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupIconIdFromDirectoryEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LookupIconIdFromDirectoryEx(PBYTE presbits, BOOL fIcon, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static FunctionDescriptor LookupIconIdFromDirectoryEx$descriptor() {
        return LookupIconIdFromDirectoryEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LookupIconIdFromDirectoryEx(PBYTE presbits, BOOL fIcon, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static MethodHandle LookupIconIdFromDirectoryEx$handle() {
        return LookupIconIdFromDirectoryEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LookupIconIdFromDirectoryEx(PBYTE presbits, BOOL fIcon, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static MemorySegment LookupIconIdFromDirectoryEx$address() {
        return LookupIconIdFromDirectoryEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LookupIconIdFromDirectoryEx(PBYTE presbits, BOOL fIcon, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static int LookupIconIdFromDirectoryEx(MemorySegment presbits, int fIcon, int cxDesired, int cyDesired, int Flags) {
        var mh$ = LookupIconIdFromDirectoryEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupIconIdFromDirectoryEx", presbits, fIcon, cxDesired, cyDesired, Flags);
            }
            return (int)mh$.invokeExact(presbits, fIcon, cxDesired, cyDesired, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIconFromResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateIconFromResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON CreateIconFromResource(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer)
     * }
     */
    public static FunctionDescriptor CreateIconFromResource$descriptor() {
        return CreateIconFromResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON CreateIconFromResource(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer)
     * }
     */
    public static MethodHandle CreateIconFromResource$handle() {
        return CreateIconFromResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HICON CreateIconFromResource(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer)
     * }
     */
    public static MemorySegment CreateIconFromResource$address() {
        return CreateIconFromResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HICON CreateIconFromResource(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer)
     * }
     */
    public static MemorySegment CreateIconFromResource(MemorySegment presbits, int dwResSize, int fIcon, int dwVer) {
        var mh$ = CreateIconFromResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIconFromResource", presbits, dwResSize, fIcon, dwVer);
            }
            return (MemorySegment)mh$.invokeExact(presbits, dwResSize, fIcon, dwVer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIconFromResourceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateIconFromResourceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static FunctionDescriptor CreateIconFromResourceEx$descriptor() {
        return CreateIconFromResourceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static MethodHandle CreateIconFromResourceEx$handle() {
        return CreateIconFromResourceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HICON CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static MemorySegment CreateIconFromResourceEx$address() {
        return CreateIconFromResourceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HICON CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static MemorySegment CreateIconFromResourceEx(MemorySegment presbits, int dwResSize, int fIcon, int dwVer, int cxDesired, int cyDesired, int Flags) {
        var mh$ = CreateIconFromResourceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIconFromResourceEx", presbits, dwResSize, fIcon, dwVer, cxDesired, cyDesired, Flags);
            }
            return (MemorySegment)mh$.invokeExact(presbits, dwResSize, fIcon, dwVer, cxDesired, cyDesired, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCURSORSHAPE {
     *     int xHotSpot;
     *     int yHotSpot;
     *     int cx;
     *     int cy;
     *     int cbWidth;
     *     BYTE Planes;
     *     BYTE BitsPixel;
     * } *LPCURSORSHAPE
     * }
     */
    public static final AddressLayout LPCURSORSHAPE = freeglut_h.C_POINTER;

    private static class LoadImageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadImageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static FunctionDescriptor LoadImageA$descriptor() {
        return LoadImageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static MethodHandle LoadImageA$handle() {
        return LoadImageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static MemorySegment LoadImageA$address() {
        return LoadImageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static MemorySegment LoadImageA(MemorySegment hInst, MemorySegment name, int type, int cx, int cy, int fuLoad) {
        var mh$ = LoadImageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageA", hInst, name, type, cx, cy, fuLoad);
            }
            return (MemorySegment)mh$.invokeExact(hInst, name, type, cx, cy, fuLoad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadImageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static FunctionDescriptor LoadImageW$descriptor() {
        return LoadImageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static MethodHandle LoadImageW$handle() {
        return LoadImageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static MemorySegment LoadImageW$address() {
        return LoadImageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static MemorySegment LoadImageW(MemorySegment hInst, MemorySegment name, int type, int cx, int cy, int fuLoad) {
        var mh$ = LoadImageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageW", hInst, name, type, cx, cy, fuLoad);
            }
            return (MemorySegment)mh$.invokeExact(hInst, name, type, cx, cy, fuLoad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CopyImage(HANDLE h, UINT type, int cx, int cy, UINT flags)
     * }
     */
    public static FunctionDescriptor CopyImage$descriptor() {
        return CopyImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CopyImage(HANDLE h, UINT type, int cx, int cy, UINT flags)
     * }
     */
    public static MethodHandle CopyImage$handle() {
        return CopyImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CopyImage(HANDLE h, UINT type, int cx, int cy, UINT flags)
     * }
     */
    public static MemorySegment CopyImage$address() {
        return CopyImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CopyImage(HANDLE h, UINT type, int cx, int cy, UINT flags)
     * }
     */
    public static MemorySegment CopyImage(MemorySegment h, int type, int cx, int cy, int flags) {
        var mh$ = CopyImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyImage", h, type, cx, cy, flags);
            }
            return (MemorySegment)mh$.invokeExact(h, type, cx, cy, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawIconEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawIconEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags)
     * }
     */
    public static FunctionDescriptor DrawIconEx$descriptor() {
        return DrawIconEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags)
     * }
     */
    public static MethodHandle DrawIconEx$handle() {
        return DrawIconEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags)
     * }
     */
    public static MemorySegment DrawIconEx$address() {
        return DrawIconEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags)
     * }
     */
    public static int DrawIconEx(MemorySegment hdc, int xLeft, int yTop, MemorySegment hIcon, int cxWidth, int cyWidth, int istepIfAniCur, MemorySegment hbrFlickerFreeDraw, int diFlags) {
        var mh$ = DrawIconEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawIconEx", hdc, xLeft, yTop, hIcon, cxWidth, cyWidth, istepIfAniCur, hbrFlickerFreeDraw, diFlags);
            }
            return (int)mh$.invokeExact(hdc, xLeft, yTop, hIcon, cxWidth, cyWidth, istepIfAniCur, hbrFlickerFreeDraw, diFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIconIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateIconIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON CreateIconIndirect(PICONINFO piconinfo)
     * }
     */
    public static FunctionDescriptor CreateIconIndirect$descriptor() {
        return CreateIconIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON CreateIconIndirect(PICONINFO piconinfo)
     * }
     */
    public static MethodHandle CreateIconIndirect$handle() {
        return CreateIconIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HICON CreateIconIndirect(PICONINFO piconinfo)
     * }
     */
    public static MemorySegment CreateIconIndirect$address() {
        return CreateIconIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HICON CreateIconIndirect(PICONINFO piconinfo)
     * }
     */
    public static MemorySegment CreateIconIndirect(MemorySegment piconinfo) {
        var mh$ = CreateIconIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIconIndirect", piconinfo);
            }
            return (MemorySegment)mh$.invokeExact(piconinfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyIcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON CopyIcon(HICON hIcon)
     * }
     */
    public static FunctionDescriptor CopyIcon$descriptor() {
        return CopyIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON CopyIcon(HICON hIcon)
     * }
     */
    public static MethodHandle CopyIcon$handle() {
        return CopyIcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HICON CopyIcon(HICON hIcon)
     * }
     */
    public static MemorySegment CopyIcon$address() {
        return CopyIcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HICON CopyIcon(HICON hIcon)
     * }
     */
    public static MemorySegment CopyIcon(MemorySegment hIcon) {
        var mh$ = CopyIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyIcon", hIcon);
            }
            return (MemorySegment)mh$.invokeExact(hIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetIconInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetIconInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetIconInfo(HICON hIcon, PICONINFO piconinfo)
     * }
     */
    public static FunctionDescriptor GetIconInfo$descriptor() {
        return GetIconInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetIconInfo(HICON hIcon, PICONINFO piconinfo)
     * }
     */
    public static MethodHandle GetIconInfo$handle() {
        return GetIconInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetIconInfo(HICON hIcon, PICONINFO piconinfo)
     * }
     */
    public static MemorySegment GetIconInfo$address() {
        return GetIconInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetIconInfo(HICON hIcon, PICONINFO piconinfo)
     * }
     */
    public static int GetIconInfo(MemorySegment hIcon, MemorySegment piconinfo) {
        var mh$ = GetIconInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetIconInfo", hIcon, piconinfo);
            }
            return (int)mh$.invokeExact(hIcon, piconinfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ICONINFOEXA {
     *     DWORD cbSize;
     *     BOOL fIcon;
     *     DWORD xHotspot;
     *     DWORD yHotspot;
     *     HBITMAP hbmMask;
     *     HBITMAP hbmColor;
     *     WORD wResID;
     *     CHAR szModName[260];
     *     CHAR szResName[260];
     * } *PICONINFOEXA
     * }
     */
    public static final AddressLayout PICONINFOEXA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ICONINFOEXW {
     *     DWORD cbSize;
     *     BOOL fIcon;
     *     DWORD xHotspot;
     *     DWORD yHotspot;
     *     HBITMAP hbmMask;
     *     HBITMAP hbmColor;
     *     WORD wResID;
     *     WCHAR szModName[260];
     *     WCHAR szResName[260];
     * } *PICONINFOEXW
     * }
     */
    public static final AddressLayout PICONINFOEXW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PICONINFOEXA PICONINFOEX
     * }
     */
    public static final AddressLayout PICONINFOEX = freeglut_h.C_POINTER;

    private static class GetIconInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetIconInfoExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetIconInfoExA(HICON hicon, PICONINFOEXA piconinfo)
     * }
     */
    public static FunctionDescriptor GetIconInfoExA$descriptor() {
        return GetIconInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetIconInfoExA(HICON hicon, PICONINFOEXA piconinfo)
     * }
     */
    public static MethodHandle GetIconInfoExA$handle() {
        return GetIconInfoExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetIconInfoExA(HICON hicon, PICONINFOEXA piconinfo)
     * }
     */
    public static MemorySegment GetIconInfoExA$address() {
        return GetIconInfoExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetIconInfoExA(HICON hicon, PICONINFOEXA piconinfo)
     * }
     */
    public static int GetIconInfoExA(MemorySegment hicon, MemorySegment piconinfo) {
        var mh$ = GetIconInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetIconInfoExA", hicon, piconinfo);
            }
            return (int)mh$.invokeExact(hicon, piconinfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetIconInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetIconInfoExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetIconInfoExW(HICON hicon, PICONINFOEXW piconinfo)
     * }
     */
    public static FunctionDescriptor GetIconInfoExW$descriptor() {
        return GetIconInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetIconInfoExW(HICON hicon, PICONINFOEXW piconinfo)
     * }
     */
    public static MethodHandle GetIconInfoExW$handle() {
        return GetIconInfoExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetIconInfoExW(HICON hicon, PICONINFOEXW piconinfo)
     * }
     */
    public static MemorySegment GetIconInfoExW$address() {
        return GetIconInfoExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetIconInfoExW(HICON hicon, PICONINFOEXW piconinfo)
     * }
     */
    public static int GetIconInfoExW(MemorySegment hicon, MemorySegment piconinfo) {
        var mh$ = GetIconInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetIconInfoExW", hicon, piconinfo);
            }
            return (int)mh$.invokeExact(hicon, piconinfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT = 0
     * }
     */
    public static int EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT() {
        return EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT;
    }
    private static final int EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS = 1
     * }
     */
    public static int EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS() {
        return EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS;
    }

    private static class IsDialogMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsDialogMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDialogMessageA(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor IsDialogMessageA$descriptor() {
        return IsDialogMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDialogMessageA(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static MethodHandle IsDialogMessageA$handle() {
        return IsDialogMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsDialogMessageA(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static MemorySegment IsDialogMessageA$address() {
        return IsDialogMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsDialogMessageA(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static int IsDialogMessageA(MemorySegment hDlg, MemorySegment lpMsg) {
        var mh$ = IsDialogMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDialogMessageA", hDlg, lpMsg);
            }
            return (int)mh$.invokeExact(hDlg, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDialogMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsDialogMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDialogMessageW(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor IsDialogMessageW$descriptor() {
        return IsDialogMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDialogMessageW(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static MethodHandle IsDialogMessageW$handle() {
        return IsDialogMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsDialogMessageW(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static MemorySegment IsDialogMessageW$address() {
        return IsDialogMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsDialogMessageW(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static int IsDialogMessageW(MemorySegment hDlg, MemorySegment lpMsg) {
        var mh$ = IsDialogMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDialogMessageW", hDlg, lpMsg);
            }
            return (int)mh$.invokeExact(hDlg, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapDialogRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapDialogRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MapDialogRect(HWND hDlg, LPRECT lpRect)
     * }
     */
    public static FunctionDescriptor MapDialogRect$descriptor() {
        return MapDialogRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MapDialogRect(HWND hDlg, LPRECT lpRect)
     * }
     */
    public static MethodHandle MapDialogRect$handle() {
        return MapDialogRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MapDialogRect(HWND hDlg, LPRECT lpRect)
     * }
     */
    public static MemorySegment MapDialogRect$address() {
        return MapDialogRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MapDialogRect(HWND hDlg, LPRECT lpRect)
     * }
     */
    public static int MapDialogRect(MemorySegment hDlg, MemorySegment lpRect) {
        var mh$ = MapDialogRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapDialogRect", hDlg, lpRect);
            }
            return (int)mh$.invokeExact(hDlg, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirListA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DlgDirListA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DlgDirListA(HWND hDlg, LPSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static FunctionDescriptor DlgDirListA$descriptor() {
        return DlgDirListA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DlgDirListA(HWND hDlg, LPSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static MethodHandle DlgDirListA$handle() {
        return DlgDirListA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DlgDirListA(HWND hDlg, LPSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static MemorySegment DlgDirListA$address() {
        return DlgDirListA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DlgDirListA(HWND hDlg, LPSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static int DlgDirListA(MemorySegment hDlg, MemorySegment lpPathSpec, int nIDListBox, int nIDStaticPath, int uFileType) {
        var mh$ = DlgDirListA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirListA", hDlg, lpPathSpec, nIDListBox, nIDStaticPath, uFileType);
            }
            return (int)mh$.invokeExact(hDlg, lpPathSpec, nIDListBox, nIDStaticPath, uFileType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirListW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DlgDirListW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static FunctionDescriptor DlgDirListW$descriptor() {
        return DlgDirListW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static MethodHandle DlgDirListW$handle() {
        return DlgDirListW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static MemorySegment DlgDirListW$address() {
        return DlgDirListW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static int DlgDirListW(MemorySegment hDlg, MemorySegment lpPathSpec, int nIDListBox, int nIDStaticPath, int uFileType) {
        var mh$ = DlgDirListW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirListW", hDlg, lpPathSpec, nIDListBox, nIDStaticPath, uFileType);
            }
            return (int)mh$.invokeExact(hDlg, lpPathSpec, nIDListBox, nIDStaticPath, uFileType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirSelectExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DlgDirSelectExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectExA(HWND hwndDlg, LPSTR lpString, int chCount, int idListBox)
     * }
     */
    public static FunctionDescriptor DlgDirSelectExA$descriptor() {
        return DlgDirSelectExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectExA(HWND hwndDlg, LPSTR lpString, int chCount, int idListBox)
     * }
     */
    public static MethodHandle DlgDirSelectExA$handle() {
        return DlgDirSelectExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectExA(HWND hwndDlg, LPSTR lpString, int chCount, int idListBox)
     * }
     */
    public static MemorySegment DlgDirSelectExA$address() {
        return DlgDirSelectExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DlgDirSelectExA(HWND hwndDlg, LPSTR lpString, int chCount, int idListBox)
     * }
     */
    public static int DlgDirSelectExA(MemorySegment hwndDlg, MemorySegment lpString, int chCount, int idListBox) {
        var mh$ = DlgDirSelectExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirSelectExA", hwndDlg, lpString, chCount, idListBox);
            }
            return (int)mh$.invokeExact(hwndDlg, lpString, chCount, idListBox);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirSelectExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DlgDirSelectExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectExW(HWND hwndDlg, LPWSTR lpString, int chCount, int idListBox)
     * }
     */
    public static FunctionDescriptor DlgDirSelectExW$descriptor() {
        return DlgDirSelectExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectExW(HWND hwndDlg, LPWSTR lpString, int chCount, int idListBox)
     * }
     */
    public static MethodHandle DlgDirSelectExW$handle() {
        return DlgDirSelectExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectExW(HWND hwndDlg, LPWSTR lpString, int chCount, int idListBox)
     * }
     */
    public static MemorySegment DlgDirSelectExW$address() {
        return DlgDirSelectExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DlgDirSelectExW(HWND hwndDlg, LPWSTR lpString, int chCount, int idListBox)
     * }
     */
    public static int DlgDirSelectExW(MemorySegment hwndDlg, MemorySegment lpString, int chCount, int idListBox) {
        var mh$ = DlgDirSelectExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirSelectExW", hwndDlg, lpString, chCount, idListBox);
            }
            return (int)mh$.invokeExact(hwndDlg, lpString, chCount, idListBox);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirListComboBoxA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DlgDirListComboBoxA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DlgDirListComboBoxA(HWND hDlg, LPSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static FunctionDescriptor DlgDirListComboBoxA$descriptor() {
        return DlgDirListComboBoxA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DlgDirListComboBoxA(HWND hDlg, LPSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static MethodHandle DlgDirListComboBoxA$handle() {
        return DlgDirListComboBoxA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DlgDirListComboBoxA(HWND hDlg, LPSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static MemorySegment DlgDirListComboBoxA$address() {
        return DlgDirListComboBoxA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DlgDirListComboBoxA(HWND hDlg, LPSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static int DlgDirListComboBoxA(MemorySegment hDlg, MemorySegment lpPathSpec, int nIDComboBox, int nIDStaticPath, int uFiletype) {
        var mh$ = DlgDirListComboBoxA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirListComboBoxA", hDlg, lpPathSpec, nIDComboBox, nIDStaticPath, uFiletype);
            }
            return (int)mh$.invokeExact(hDlg, lpPathSpec, nIDComboBox, nIDStaticPath, uFiletype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirListComboBoxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DlgDirListComboBoxW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static FunctionDescriptor DlgDirListComboBoxW$descriptor() {
        return DlgDirListComboBoxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static MethodHandle DlgDirListComboBoxW$handle() {
        return DlgDirListComboBoxW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static MemorySegment DlgDirListComboBoxW$address() {
        return DlgDirListComboBoxW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static int DlgDirListComboBoxW(MemorySegment hDlg, MemorySegment lpPathSpec, int nIDComboBox, int nIDStaticPath, int uFiletype) {
        var mh$ = DlgDirListComboBoxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirListComboBoxW", hDlg, lpPathSpec, nIDComboBox, nIDStaticPath, uFiletype);
            }
            return (int)mh$.invokeExact(hDlg, lpPathSpec, nIDComboBox, nIDStaticPath, uFiletype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirSelectComboBoxExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DlgDirSelectComboBoxExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExA(HWND hwndDlg, LPSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static FunctionDescriptor DlgDirSelectComboBoxExA$descriptor() {
        return DlgDirSelectComboBoxExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExA(HWND hwndDlg, LPSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static MethodHandle DlgDirSelectComboBoxExA$handle() {
        return DlgDirSelectComboBoxExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExA(HWND hwndDlg, LPSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static MemorySegment DlgDirSelectComboBoxExA$address() {
        return DlgDirSelectComboBoxExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExA(HWND hwndDlg, LPSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static int DlgDirSelectComboBoxExA(MemorySegment hwndDlg, MemorySegment lpString, int cchOut, int idComboBox) {
        var mh$ = DlgDirSelectComboBoxExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirSelectComboBoxExA", hwndDlg, lpString, cchOut, idComboBox);
            }
            return (int)mh$.invokeExact(hwndDlg, lpString, cchOut, idComboBox);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirSelectComboBoxExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DlgDirSelectComboBoxExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExW(HWND hwndDlg, LPWSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static FunctionDescriptor DlgDirSelectComboBoxExW$descriptor() {
        return DlgDirSelectComboBoxExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExW(HWND hwndDlg, LPWSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static MethodHandle DlgDirSelectComboBoxExW$handle() {
        return DlgDirSelectComboBoxExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExW(HWND hwndDlg, LPWSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static MemorySegment DlgDirSelectComboBoxExW$address() {
        return DlgDirSelectComboBoxExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExW(HWND hwndDlg, LPWSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static int DlgDirSelectComboBoxExW(MemorySegment hwndDlg, MemorySegment lpString, int cchOut, int idComboBox) {
        var mh$ = DlgDirSelectComboBoxExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirSelectComboBoxExW", hwndDlg, lpString, cchOut, idComboBox);
            }
            return (int)mh$.invokeExact(hwndDlg, lpString, cchOut, idComboBox);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagSCROLLINFO {
     *     UINT cbSize;
     *     UINT fMask;
     *     int nMin;
     *     int nMax;
     *     UINT nPage;
     *     int nPos;
     *     int nTrackPos;
     * } *LPSCROLLINFO
     * }
     */
    public static final AddressLayout LPSCROLLINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const SCROLLINFO *LPCSCROLLINFO
     * }
     */
    public static final AddressLayout LPCSCROLLINFO = freeglut_h.C_POINTER;

    private static class SetScrollInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetScrollInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw)
     * }
     */
    public static FunctionDescriptor SetScrollInfo$descriptor() {
        return SetScrollInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw)
     * }
     */
    public static MethodHandle SetScrollInfo$handle() {
        return SetScrollInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw)
     * }
     */
    public static MemorySegment SetScrollInfo$address() {
        return SetScrollInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw)
     * }
     */
    public static int SetScrollInfo(MemorySegment hwnd, int nBar, MemorySegment lpsi, int redraw) {
        var mh$ = SetScrollInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetScrollInfo", hwnd, nBar, lpsi, redraw);
            }
            return (int)mh$.invokeExact(hwnd, nBar, lpsi, redraw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScrollInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetScrollInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi)
     * }
     */
    public static FunctionDescriptor GetScrollInfo$descriptor() {
        return GetScrollInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi)
     * }
     */
    public static MethodHandle GetScrollInfo$handle() {
        return GetScrollInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi)
     * }
     */
    public static MemorySegment GetScrollInfo$address() {
        return GetScrollInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi)
     * }
     */
    public static int GetScrollInfo(MemorySegment hwnd, int nBar, MemorySegment lpsi) {
        var mh$ = GetScrollInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScrollInfo", hwnd, nBar, lpsi);
            }
            return (int)mh$.invokeExact(hwnd, nBar, lpsi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMDICREATESTRUCTA {
     *     LPCSTR szClass;
     *     LPCSTR szTitle;
     *     HANDLE hOwner;
     *     int x;
     *     int y;
     *     int cx;
     *     int cy;
     *     DWORD style;
     *     LPARAM lParam;
     * } *LPMDICREATESTRUCTA
     * }
     */
    public static final AddressLayout LPMDICREATESTRUCTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMDICREATESTRUCTW {
     *     LPCWSTR szClass;
     *     LPCWSTR szTitle;
     *     HANDLE hOwner;
     *     int x;
     *     int y;
     *     int cx;
     *     int cy;
     *     DWORD style;
     *     LPARAM lParam;
     * } *LPMDICREATESTRUCTW
     * }
     */
    public static final AddressLayout LPMDICREATESTRUCTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMDICREATESTRUCTA LPMDICREATESTRUCT
     * }
     */
    public static final AddressLayout LPMDICREATESTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCLIENTCREATESTRUCT {
     *     HANDLE hWindowMenu;
     *     UINT idFirstChild;
     * } *LPCLIENTCREATESTRUCT
     * }
     */
    public static final AddressLayout LPCLIENTCREATESTRUCT = freeglut_h.C_POINTER;

    private static class DefFrameProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DefFrameProcA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefFrameProcA(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefFrameProcA$descriptor() {
        return DefFrameProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefFrameProcA(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefFrameProcA$handle() {
        return DefFrameProcA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefFrameProcA(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefFrameProcA$address() {
        return DefFrameProcA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefFrameProcA(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefFrameProcA(MemorySegment hWnd, MemorySegment hWndMDIClient, int uMsg, long wParam, long lParam) {
        var mh$ = DefFrameProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefFrameProcA", hWnd, hWndMDIClient, uMsg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, hWndMDIClient, uMsg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefFrameProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DefFrameProcW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefFrameProcW$descriptor() {
        return DefFrameProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefFrameProcW$handle() {
        return DefFrameProcW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefFrameProcW$address() {
        return DefFrameProcW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefFrameProcW(MemorySegment hWnd, MemorySegment hWndMDIClient, int uMsg, long wParam, long lParam) {
        var mh$ = DefFrameProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefFrameProcW", hWnd, hWndMDIClient, uMsg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, hWndMDIClient, uMsg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefMDIChildProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DefMDIChildProcA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcA(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefMDIChildProcA$descriptor() {
        return DefMDIChildProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcA(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefMDIChildProcA$handle() {
        return DefMDIChildProcA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcA(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefMDIChildProcA$address() {
        return DefMDIChildProcA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcA(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefMDIChildProcA(MemorySegment hWnd, int uMsg, long wParam, long lParam) {
        var mh$ = DefMDIChildProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefMDIChildProcA", hWnd, uMsg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, uMsg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefMDIChildProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DefMDIChildProcW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefMDIChildProcW$descriptor() {
        return DefMDIChildProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefMDIChildProcW$handle() {
        return DefMDIChildProcW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefMDIChildProcW$address() {
        return DefMDIChildProcW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefMDIChildProcW(MemorySegment hWnd, int uMsg, long wParam, long lParam) {
        var mh$ = DefMDIChildProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefMDIChildProcW", hWnd, uMsg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, uMsg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateMDISysAccel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TranslateMDISysAccel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TranslateMDISysAccel(HWND hWndClient, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor TranslateMDISysAccel$descriptor() {
        return TranslateMDISysAccel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TranslateMDISysAccel(HWND hWndClient, LPMSG lpMsg)
     * }
     */
    public static MethodHandle TranslateMDISysAccel$handle() {
        return TranslateMDISysAccel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TranslateMDISysAccel(HWND hWndClient, LPMSG lpMsg)
     * }
     */
    public static MemorySegment TranslateMDISysAccel$address() {
        return TranslateMDISysAccel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TranslateMDISysAccel(HWND hWndClient, LPMSG lpMsg)
     * }
     */
    public static int TranslateMDISysAccel(MemorySegment hWndClient, MemorySegment lpMsg) {
        var mh$ = TranslateMDISysAccel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateMDISysAccel", hWndClient, lpMsg);
            }
            return (int)mh$.invokeExact(hWndClient, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ArrangeIconicWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ArrangeIconicWindows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ArrangeIconicWindows(HWND hWnd)
     * }
     */
    public static FunctionDescriptor ArrangeIconicWindows$descriptor() {
        return ArrangeIconicWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ArrangeIconicWindows(HWND hWnd)
     * }
     */
    public static MethodHandle ArrangeIconicWindows$handle() {
        return ArrangeIconicWindows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ArrangeIconicWindows(HWND hWnd)
     * }
     */
    public static MemorySegment ArrangeIconicWindows$address() {
        return ArrangeIconicWindows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ArrangeIconicWindows(HWND hWnd)
     * }
     */
    public static int ArrangeIconicWindows(MemorySegment hWnd) {
        var mh$ = ArrangeIconicWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ArrangeIconicWindows", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMDIWindowA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMDIWindowA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateMDIWindowA(LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CreateMDIWindowA$descriptor() {
        return CreateMDIWindowA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateMDIWindowA(LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static MethodHandle CreateMDIWindowA$handle() {
        return CreateMDIWindowA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateMDIWindowA(LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static MemorySegment CreateMDIWindowA$address() {
        return CreateMDIWindowA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateMDIWindowA(LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static MemorySegment CreateMDIWindowA(MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hInstance, long lParam) {
        var mh$ = CreateMDIWindowA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMDIWindowA", lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
            }
            return (MemorySegment)mh$.invokeExact(lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMDIWindowW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMDIWindowW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateMDIWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CreateMDIWindowW$descriptor() {
        return CreateMDIWindowW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateMDIWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static MethodHandle CreateMDIWindowW$handle() {
        return CreateMDIWindowW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateMDIWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static MemorySegment CreateMDIWindowW$address() {
        return CreateMDIWindowW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateMDIWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static MemorySegment CreateMDIWindowW(MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hInstance, long lParam) {
        var mh$ = CreateMDIWindowW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMDIWindowW", lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
            }
            return (MemorySegment)mh$.invokeExact(lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TileWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TileWindows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD TileWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static FunctionDescriptor TileWindows$descriptor() {
        return TileWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD TileWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static MethodHandle TileWindows$handle() {
        return TileWindows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD TileWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static MemorySegment TileWindows$address() {
        return TileWindows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD TileWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static short TileWindows(MemorySegment hwndParent, int wHow, MemorySegment lpRect, int cKids, MemorySegment lpKids) {
        var mh$ = TileWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TileWindows", hwndParent, wHow, lpRect, cKids, lpKids);
            }
            return (short)mh$.invokeExact(hwndParent, wHow, lpRect, cKids, lpKids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CascadeWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CascadeWindows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD CascadeWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static FunctionDescriptor CascadeWindows$descriptor() {
        return CascadeWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD CascadeWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static MethodHandle CascadeWindows$handle() {
        return CascadeWindows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD CascadeWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static MemorySegment CascadeWindows$address() {
        return CascadeWindows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD CascadeWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static short CascadeWindows(MemorySegment hwndParent, int wHow, MemorySegment lpRect, int cKids, MemorySegment lpKids) {
        var mh$ = CascadeWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CascadeWindows", hwndParent, wHow, lpRect, cKids, lpKids);
            }
            return (short)mh$.invokeExact(hwndParent, wHow, lpRect, cKids, lpKids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD HELPPOLY
     * }
     */
    public static final OfInt HELPPOLY = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct tagMULTIKEYHELPA {
     *     DWORD mkSize;
     *     CHAR mkKeylist;
     *     CHAR szKeyphrase[1];
     * } *PMULTIKEYHELPA
     * }
     */
    public static final AddressLayout PMULTIKEYHELPA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMULTIKEYHELPA {
     *     DWORD mkSize;
     *     CHAR mkKeylist;
     *     CHAR szKeyphrase[1];
     * } *LPMULTIKEYHELPA
     * }
     */
    public static final AddressLayout LPMULTIKEYHELPA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMULTIKEYHELPW {
     *     DWORD mkSize;
     *     WCHAR mkKeylist;
     *     WCHAR szKeyphrase[1];
     * } *PMULTIKEYHELPW
     * }
     */
    public static final AddressLayout PMULTIKEYHELPW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMULTIKEYHELPW {
     *     DWORD mkSize;
     *     WCHAR mkKeylist;
     *     WCHAR szKeyphrase[1];
     * } *LPMULTIKEYHELPW
     * }
     */
    public static final AddressLayout LPMULTIKEYHELPW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMULTIKEYHELPA PMULTIKEYHELP
     * }
     */
    public static final AddressLayout PMULTIKEYHELP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMULTIKEYHELPA LPMULTIKEYHELP
     * }
     */
    public static final AddressLayout LPMULTIKEYHELP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHELPWININFOA {
     *     int wStructSize;
     *     int x;
     *     int y;
     *     int dx;
     *     int dy;
     *     int wMax;
     *     CHAR rgchMember[2];
     * } *PHELPWININFOA
     * }
     */
    public static final AddressLayout PHELPWININFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHELPWININFOA {
     *     int wStructSize;
     *     int x;
     *     int y;
     *     int dx;
     *     int dy;
     *     int wMax;
     *     CHAR rgchMember[2];
     * } *LPHELPWININFOA
     * }
     */
    public static final AddressLayout LPHELPWININFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHELPWININFOW {
     *     int wStructSize;
     *     int x;
     *     int y;
     *     int dx;
     *     int dy;
     *     int wMax;
     *     WCHAR rgchMember[2];
     * } *PHELPWININFOW
     * }
     */
    public static final AddressLayout PHELPWININFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHELPWININFOW {
     *     int wStructSize;
     *     int x;
     *     int y;
     *     int dx;
     *     int dy;
     *     int wMax;
     *     WCHAR rgchMember[2];
     * } *LPHELPWININFOW
     * }
     */
    public static final AddressLayout LPHELPWININFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PHELPWININFOA PHELPWININFO
     * }
     */
    public static final AddressLayout PHELPWININFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPHELPWININFOA LPHELPWININFO
     * }
     */
    public static final AddressLayout LPHELPWININFO = freeglut_h.C_POINTER;

    private static class WinHelpA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WinHelpA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WinHelpA(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor WinHelpA$descriptor() {
        return WinHelpA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WinHelpA(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle WinHelpA$handle() {
        return WinHelpA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WinHelpA(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static MemorySegment WinHelpA$address() {
        return WinHelpA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WinHelpA(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static int WinHelpA(MemorySegment hWndMain, MemorySegment lpszHelp, int uCommand, long dwData) {
        var mh$ = WinHelpA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WinHelpA", hWndMain, lpszHelp, uCommand, dwData);
            }
            return (int)mh$.invokeExact(hWndMain, lpszHelp, uCommand, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WinHelpW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WinHelpW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor WinHelpW$descriptor() {
        return WinHelpW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle WinHelpW$handle() {
        return WinHelpW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static MemorySegment WinHelpW$address() {
        return WinHelpW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static int WinHelpW(MemorySegment hWndMain, MemorySegment lpszHelp, int uCommand, long dwData) {
        var mh$ = WinHelpW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WinHelpW", hWndMain, lpszHelp, uCommand, dwData);
            }
            return (int)mh$.invokeExact(hWndMain, lpszHelp, uCommand, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGuiResources {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGuiResources");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGuiResources(HANDLE hProcess, DWORD uiFlags)
     * }
     */
    public static FunctionDescriptor GetGuiResources$descriptor() {
        return GetGuiResources.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGuiResources(HANDLE hProcess, DWORD uiFlags)
     * }
     */
    public static MethodHandle GetGuiResources$handle() {
        return GetGuiResources.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGuiResources(HANDLE hProcess, DWORD uiFlags)
     * }
     */
    public static MemorySegment GetGuiResources$address() {
        return GetGuiResources.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGuiResources(HANDLE hProcess, DWORD uiFlags)
     * }
     */
    public static int GetGuiResources(MemorySegment hProcess, int uiFlags) {
        var mh$ = GetGuiResources.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGuiResources", hProcess, uiFlags);
            }
            return (int)mh$.invokeExact(hProcess, uiFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagTouchPredictionParameters {
     *     UINT cbSize;
     *     UINT dwLatency;
     *     UINT dwSampleTime;
     *     UINT bUseHWTimeStamp;
     * } *PTOUCHPREDICTIONPARAMETERS
     * }
     */
    public static final AddressLayout PTOUCHPREDICTIONPARAMETERS = freeglut_h.C_POINTER;
    private static final int HANDEDNESS_LEFT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagHANDEDNESS.HANDEDNESS_LEFT = 0
     * }
     */
    public static int HANDEDNESS_LEFT() {
        return HANDEDNESS_LEFT;
    }
    private static final int HANDEDNESS_RIGHT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagHANDEDNESS.HANDEDNESS_RIGHT = 1
     * }
     */
    public static int HANDEDNESS_RIGHT() {
        return HANDEDNESS_RIGHT;
    }
    /**
     * {@snippet lang=c :
     * typedef enum tagHANDEDNESS {
     *     HANDEDNESS_LEFT = 0,
     *     HANDEDNESS_RIGHT
     * } *PHANDEDNESS
     * }
     */
    public static final AddressLayout PHANDEDNESS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNONCLIENTMETRICSA {
     *     UINT cbSize;
     *     int iBorderWidth;
     *     int iScrollWidth;
     *     int iScrollHeight;
     *     int iCaptionWidth;
     *     int iCaptionHeight;
     *     LOGFONTA lfCaptionFont;
     *     int iSmCaptionWidth;
     *     int iSmCaptionHeight;
     *     LOGFONTA lfSmCaptionFont;
     *     int iMenuWidth;
     *     int iMenuHeight;
     *     LOGFONTA lfMenuFont;
     *     LOGFONTA lfStatusFont;
     *     LOGFONTA lfMessageFont;
     *     int iPaddedBorderWidth;
     * } *PNONCLIENTMETRICSA
     * }
     */
    public static final AddressLayout PNONCLIENTMETRICSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNONCLIENTMETRICSA {
     *     UINT cbSize;
     *     int iBorderWidth;
     *     int iScrollWidth;
     *     int iScrollHeight;
     *     int iCaptionWidth;
     *     int iCaptionHeight;
     *     LOGFONTA lfCaptionFont;
     *     int iSmCaptionWidth;
     *     int iSmCaptionHeight;
     *     LOGFONTA lfSmCaptionFont;
     *     int iMenuWidth;
     *     int iMenuHeight;
     *     LOGFONTA lfMenuFont;
     *     LOGFONTA lfStatusFont;
     *     LOGFONTA lfMessageFont;
     *     int iPaddedBorderWidth;
     * } *LPNONCLIENTMETRICSA
     * }
     */
    public static final AddressLayout LPNONCLIENTMETRICSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNONCLIENTMETRICSW {
     *     UINT cbSize;
     *     int iBorderWidth;
     *     int iScrollWidth;
     *     int iScrollHeight;
     *     int iCaptionWidth;
     *     int iCaptionHeight;
     *     LOGFONTW lfCaptionFont;
     *     int iSmCaptionWidth;
     *     int iSmCaptionHeight;
     *     LOGFONTW lfSmCaptionFont;
     *     int iMenuWidth;
     *     int iMenuHeight;
     *     LOGFONTW lfMenuFont;
     *     LOGFONTW lfStatusFont;
     *     LOGFONTW lfMessageFont;
     *     int iPaddedBorderWidth;
     * } *PNONCLIENTMETRICSW
     * }
     */
    public static final AddressLayout PNONCLIENTMETRICSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNONCLIENTMETRICSW {
     *     UINT cbSize;
     *     int iBorderWidth;
     *     int iScrollWidth;
     *     int iScrollHeight;
     *     int iCaptionWidth;
     *     int iCaptionHeight;
     *     LOGFONTW lfCaptionFont;
     *     int iSmCaptionWidth;
     *     int iSmCaptionHeight;
     *     LOGFONTW lfSmCaptionFont;
     *     int iMenuWidth;
     *     int iMenuHeight;
     *     LOGFONTW lfMenuFont;
     *     LOGFONTW lfStatusFont;
     *     LOGFONTW lfMessageFont;
     *     int iPaddedBorderWidth;
     * } *LPNONCLIENTMETRICSW
     * }
     */
    public static final AddressLayout LPNONCLIENTMETRICSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PNONCLIENTMETRICSA PNONCLIENTMETRICS
     * }
     */
    public static final AddressLayout PNONCLIENTMETRICS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPNONCLIENTMETRICSA LPNONCLIENTMETRICS
     * }
     */
    public static final AddressLayout LPNONCLIENTMETRICS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMINIMIZEDMETRICS {
     *     UINT cbSize;
     *     int iWidth;
     *     int iHorzGap;
     *     int iVertGap;
     *     int iArrange;
     * } *PMINIMIZEDMETRICS
     * }
     */
    public static final AddressLayout PMINIMIZEDMETRICS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMINIMIZEDMETRICS {
     *     UINT cbSize;
     *     int iWidth;
     *     int iHorzGap;
     *     int iVertGap;
     *     int iArrange;
     * } *LPMINIMIZEDMETRICS
     * }
     */
    public static final AddressLayout LPMINIMIZEDMETRICS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagICONMETRICSA {
     *     UINT cbSize;
     *     int iHorzSpacing;
     *     int iVertSpacing;
     *     int iTitleWrap;
     *     LOGFONTA lfFont;
     * } *PICONMETRICSA
     * }
     */
    public static final AddressLayout PICONMETRICSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagICONMETRICSA {
     *     UINT cbSize;
     *     int iHorzSpacing;
     *     int iVertSpacing;
     *     int iTitleWrap;
     *     LOGFONTA lfFont;
     * } *LPICONMETRICSA
     * }
     */
    public static final AddressLayout LPICONMETRICSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagICONMETRICSW {
     *     UINT cbSize;
     *     int iHorzSpacing;
     *     int iVertSpacing;
     *     int iTitleWrap;
     *     LOGFONTW lfFont;
     * } *PICONMETRICSW
     * }
     */
    public static final AddressLayout PICONMETRICSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagICONMETRICSW {
     *     UINT cbSize;
     *     int iHorzSpacing;
     *     int iVertSpacing;
     *     int iTitleWrap;
     *     LOGFONTW lfFont;
     * } *LPICONMETRICSW
     * }
     */
    public static final AddressLayout LPICONMETRICSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PICONMETRICSA PICONMETRICS
     * }
     */
    public static final AddressLayout PICONMETRICS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPICONMETRICSA LPICONMETRICS
     * }
     */
    public static final AddressLayout LPICONMETRICS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagANIMATIONINFO {
     *     UINT cbSize;
     *     int iMinAnimate;
     * } *LPANIMATIONINFO
     * }
     */
    public static final AddressLayout LPANIMATIONINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSERIALKEYSA {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     LPSTR lpszActivePort;
     *     LPSTR lpszPort;
     *     UINT iBaudRate;
     *     UINT iPortState;
     *     UINT iActive;
     * } *LPSERIALKEYSA
     * }
     */
    public static final AddressLayout LPSERIALKEYSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSERIALKEYSW {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     LPWSTR lpszActivePort;
     *     LPWSTR lpszPort;
     *     UINT iBaudRate;
     *     UINT iPortState;
     *     UINT iActive;
     * } *LPSERIALKEYSW
     * }
     */
    public static final AddressLayout LPSERIALKEYSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSERIALKEYSA LPSERIALKEYS
     * }
     */
    public static final AddressLayout LPSERIALKEYS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHIGHCONTRASTA {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     LPSTR lpszDefaultScheme;
     * } *LPHIGHCONTRASTA
     * }
     */
    public static final AddressLayout LPHIGHCONTRASTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHIGHCONTRASTW {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     LPWSTR lpszDefaultScheme;
     * } *LPHIGHCONTRASTW
     * }
     */
    public static final AddressLayout LPHIGHCONTRASTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPHIGHCONTRASTA LPHIGHCONTRAST
     * }
     */
    public static final AddressLayout LPHIGHCONTRAST = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _VIDEOPARAMETERS {
     *     GUID Guid;
     *     ULONG dwOffset;
     *     ULONG dwCommand;
     *     ULONG dwFlags;
     *     ULONG dwMode;
     *     ULONG dwTVStandard;
     *     ULONG dwAvailableModes;
     *     ULONG dwAvailableTVStandard;
     *     ULONG dwFlickerFilter;
     *     ULONG dwOverScanX;
     *     ULONG dwOverScanY;
     *     ULONG dwMaxUnscaledX;
     *     ULONG dwMaxUnscaledY;
     *     ULONG dwPositionX;
     *     ULONG dwPositionY;
     *     ULONG dwBrightness;
     *     ULONG dwContrast;
     *     ULONG dwCPType;
     *     ULONG dwCPCommand;
     *     ULONG dwCPStandard;
     *     ULONG dwCPKey;
     *     ULONG bCP_APSTriggerBits;
     *     UCHAR bOEMCopyProtection[256];
     * } *PVIDEOPARAMETERS
     * }
     */
    public static final AddressLayout PVIDEOPARAMETERS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _VIDEOPARAMETERS {
     *     GUID Guid;
     *     ULONG dwOffset;
     *     ULONG dwCommand;
     *     ULONG dwFlags;
     *     ULONG dwMode;
     *     ULONG dwTVStandard;
     *     ULONG dwAvailableModes;
     *     ULONG dwAvailableTVStandard;
     *     ULONG dwFlickerFilter;
     *     ULONG dwOverScanX;
     *     ULONG dwOverScanY;
     *     ULONG dwMaxUnscaledX;
     *     ULONG dwMaxUnscaledY;
     *     ULONG dwPositionX;
     *     ULONG dwPositionY;
     *     ULONG dwBrightness;
     *     ULONG dwContrast;
     *     ULONG dwCPType;
     *     ULONG dwCPCommand;
     *     ULONG dwCPStandard;
     *     ULONG dwCPKey;
     *     ULONG bCP_APSTriggerBits;
     *     UCHAR bOEMCopyProtection[256];
     * } *LPVIDEOPARAMETERS
     * }
     */
    public static final AddressLayout LPVIDEOPARAMETERS = freeglut_h.C_POINTER;

    private static class ChangeDisplaySettingsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeDisplaySettingsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsA(DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor ChangeDisplaySettingsA$descriptor() {
        return ChangeDisplaySettingsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsA(DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MethodHandle ChangeDisplaySettingsA$handle() {
        return ChangeDisplaySettingsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsA(DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MemorySegment ChangeDisplaySettingsA$address() {
        return ChangeDisplaySettingsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsA(DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static int ChangeDisplaySettingsA(MemorySegment lpDevMode, int dwFlags) {
        var mh$ = ChangeDisplaySettingsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeDisplaySettingsA", lpDevMode, dwFlags);
            }
            return (int)mh$.invokeExact(lpDevMode, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeDisplaySettingsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeDisplaySettingsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsW(DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor ChangeDisplaySettingsW$descriptor() {
        return ChangeDisplaySettingsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsW(DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MethodHandle ChangeDisplaySettingsW$handle() {
        return ChangeDisplaySettingsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsW(DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MemorySegment ChangeDisplaySettingsW$address() {
        return ChangeDisplaySettingsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsW(DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static int ChangeDisplaySettingsW(MemorySegment lpDevMode, int dwFlags) {
        var mh$ = ChangeDisplaySettingsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeDisplaySettingsW", lpDevMode, dwFlags);
            }
            return (int)mh$.invokeExact(lpDevMode, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeDisplaySettingsExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeDisplaySettingsExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, DEVMODEA *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static FunctionDescriptor ChangeDisplaySettingsExA$descriptor() {
        return ChangeDisplaySettingsExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, DEVMODEA *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static MethodHandle ChangeDisplaySettingsExA$handle() {
        return ChangeDisplaySettingsExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, DEVMODEA *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static MemorySegment ChangeDisplaySettingsExA$address() {
        return ChangeDisplaySettingsExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, DEVMODEA *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static int ChangeDisplaySettingsExA(MemorySegment lpszDeviceName, MemorySegment lpDevMode, MemorySegment hwnd, int dwflags, MemorySegment lParam) {
        var mh$ = ChangeDisplaySettingsExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeDisplaySettingsExA", lpszDeviceName, lpDevMode, hwnd, dwflags, lParam);
            }
            return (int)mh$.invokeExact(lpszDeviceName, lpDevMode, hwnd, dwflags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeDisplaySettingsExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeDisplaySettingsExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExW(LPCWSTR lpszDeviceName, DEVMODEW *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static FunctionDescriptor ChangeDisplaySettingsExW$descriptor() {
        return ChangeDisplaySettingsExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExW(LPCWSTR lpszDeviceName, DEVMODEW *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static MethodHandle ChangeDisplaySettingsExW$handle() {
        return ChangeDisplaySettingsExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExW(LPCWSTR lpszDeviceName, DEVMODEW *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static MemorySegment ChangeDisplaySettingsExW$address() {
        return ChangeDisplaySettingsExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExW(LPCWSTR lpszDeviceName, DEVMODEW *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static int ChangeDisplaySettingsExW(MemorySegment lpszDeviceName, MemorySegment lpDevMode, MemorySegment hwnd, int dwflags, MemorySegment lParam) {
        var mh$ = ChangeDisplaySettingsExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeDisplaySettingsExW", lpszDeviceName, lpDevMode, hwnd, dwflags, lParam);
            }
            return (int)mh$.invokeExact(lpszDeviceName, lpDevMode, hwnd, dwflags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplaySettingsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDisplaySettingsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode)
     * }
     */
    public static FunctionDescriptor EnumDisplaySettingsA$descriptor() {
        return EnumDisplaySettingsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode)
     * }
     */
    public static MethodHandle EnumDisplaySettingsA$handle() {
        return EnumDisplaySettingsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode)
     * }
     */
    public static MemorySegment EnumDisplaySettingsA$address() {
        return EnumDisplaySettingsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode)
     * }
     */
    public static int EnumDisplaySettingsA(MemorySegment lpszDeviceName, int iModeNum, MemorySegment lpDevMode) {
        var mh$ = EnumDisplaySettingsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplaySettingsA", lpszDeviceName, iModeNum, lpDevMode);
            }
            return (int)mh$.invokeExact(lpszDeviceName, iModeNum, lpDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplaySettingsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDisplaySettingsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode)
     * }
     */
    public static FunctionDescriptor EnumDisplaySettingsW$descriptor() {
        return EnumDisplaySettingsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode)
     * }
     */
    public static MethodHandle EnumDisplaySettingsW$handle() {
        return EnumDisplaySettingsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode)
     * }
     */
    public static MemorySegment EnumDisplaySettingsW$address() {
        return EnumDisplaySettingsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode)
     * }
     */
    public static int EnumDisplaySettingsW(MemorySegment lpszDeviceName, int iModeNum, MemorySegment lpDevMode) {
        var mh$ = EnumDisplaySettingsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplaySettingsW", lpszDeviceName, iModeNum, lpDevMode);
            }
            return (int)mh$.invokeExact(lpszDeviceName, iModeNum, lpDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplaySettingsExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDisplaySettingsExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDisplaySettingsExA$descriptor() {
        return EnumDisplaySettingsExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDisplaySettingsExA$handle() {
        return EnumDisplaySettingsExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDisplaySettingsExA$address() {
        return EnumDisplaySettingsExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static int EnumDisplaySettingsExA(MemorySegment lpszDeviceName, int iModeNum, MemorySegment lpDevMode, int dwFlags) {
        var mh$ = EnumDisplaySettingsExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplaySettingsExA", lpszDeviceName, iModeNum, lpDevMode, dwFlags);
            }
            return (int)mh$.invokeExact(lpszDeviceName, iModeNum, lpDevMode, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplaySettingsExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDisplaySettingsExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDisplaySettingsExW$descriptor() {
        return EnumDisplaySettingsExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDisplaySettingsExW$handle() {
        return EnumDisplaySettingsExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDisplaySettingsExW$address() {
        return EnumDisplaySettingsExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static int EnumDisplaySettingsExW(MemorySegment lpszDeviceName, int iModeNum, MemorySegment lpDevMode, int dwFlags) {
        var mh$ = EnumDisplaySettingsExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplaySettingsExW", lpszDeviceName, iModeNum, lpDevMode, dwFlags);
            }
            return (int)mh$.invokeExact(lpszDeviceName, iModeNum, lpDevMode, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplayDevicesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDisplayDevicesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesA(LPCSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEA lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDisplayDevicesA$descriptor() {
        return EnumDisplayDevicesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesA(LPCSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEA lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDisplayDevicesA$handle() {
        return EnumDisplayDevicesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesA(LPCSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEA lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDisplayDevicesA$address() {
        return EnumDisplayDevicesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesA(LPCSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEA lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static int EnumDisplayDevicesA(MemorySegment lpDevice, int iDevNum, MemorySegment lpDisplayDevice, int dwFlags) {
        var mh$ = EnumDisplayDevicesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplayDevicesA", lpDevice, iDevNum, lpDisplayDevice, dwFlags);
            }
            return (int)mh$.invokeExact(lpDevice, iDevNum, lpDisplayDevice, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplayDevicesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDisplayDevicesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesW(LPCWSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEW lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDisplayDevicesW$descriptor() {
        return EnumDisplayDevicesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesW(LPCWSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEW lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDisplayDevicesW$handle() {
        return EnumDisplayDevicesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesW(LPCWSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEW lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDisplayDevicesW$address() {
        return EnumDisplayDevicesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesW(LPCWSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEW lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static int EnumDisplayDevicesW(MemorySegment lpDevice, int iDevNum, MemorySegment lpDisplayDevice, int dwFlags) {
        var mh$ = EnumDisplayDevicesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplayDevicesW", lpDevice, iDevNum, lpDisplayDevice, dwFlags);
            }
            return (int)mh$.invokeExact(lpDevice, iDevNum, lpDisplayDevice, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDisplayConfigBufferSizes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDisplayConfigBufferSizes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetDisplayConfigBufferSizes(UINT32 flags, UINT32 *numPathArrayElements, UINT32 *numModeInfoArrayElements)
     * }
     */
    public static FunctionDescriptor GetDisplayConfigBufferSizes$descriptor() {
        return GetDisplayConfigBufferSizes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetDisplayConfigBufferSizes(UINT32 flags, UINT32 *numPathArrayElements, UINT32 *numModeInfoArrayElements)
     * }
     */
    public static MethodHandle GetDisplayConfigBufferSizes$handle() {
        return GetDisplayConfigBufferSizes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG GetDisplayConfigBufferSizes(UINT32 flags, UINT32 *numPathArrayElements, UINT32 *numModeInfoArrayElements)
     * }
     */
    public static MemorySegment GetDisplayConfigBufferSizes$address() {
        return GetDisplayConfigBufferSizes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG GetDisplayConfigBufferSizes(UINT32 flags, UINT32 *numPathArrayElements, UINT32 *numModeInfoArrayElements)
     * }
     */
    public static int GetDisplayConfigBufferSizes(int flags, MemorySegment numPathArrayElements, MemorySegment numModeInfoArrayElements) {
        var mh$ = GetDisplayConfigBufferSizes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDisplayConfigBufferSizes", flags, numPathArrayElements, numModeInfoArrayElements);
            }
            return (int)mh$.invokeExact(flags, numPathArrayElements, numModeInfoArrayElements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDisplayConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDisplayConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG SetDisplayConfig(UINT32 numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, UINT32 flags)
     * }
     */
    public static FunctionDescriptor SetDisplayConfig$descriptor() {
        return SetDisplayConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG SetDisplayConfig(UINT32 numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, UINT32 flags)
     * }
     */
    public static MethodHandle SetDisplayConfig$handle() {
        return SetDisplayConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG SetDisplayConfig(UINT32 numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, UINT32 flags)
     * }
     */
    public static MemorySegment SetDisplayConfig$address() {
        return SetDisplayConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG SetDisplayConfig(UINT32 numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, UINT32 flags)
     * }
     */
    public static int SetDisplayConfig(int numPathArrayElements, MemorySegment pathArray, int numModeInfoArrayElements, MemorySegment modeInfoArray, int flags) {
        var mh$ = SetDisplayConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDisplayConfig", numPathArrayElements, pathArray, numModeInfoArrayElements, modeInfoArray, flags);
            }
            return (int)mh$.invokeExact(numPathArrayElements, pathArray, numModeInfoArrayElements, modeInfoArray, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDisplayConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryDisplayConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG QueryDisplayConfig(UINT32 flags, UINT32 *numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 *numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, DISPLAYCONFIG_TOPOLOGY_ID *currentTopologyId)
     * }
     */
    public static FunctionDescriptor QueryDisplayConfig$descriptor() {
        return QueryDisplayConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG QueryDisplayConfig(UINT32 flags, UINT32 *numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 *numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, DISPLAYCONFIG_TOPOLOGY_ID *currentTopologyId)
     * }
     */
    public static MethodHandle QueryDisplayConfig$handle() {
        return QueryDisplayConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG QueryDisplayConfig(UINT32 flags, UINT32 *numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 *numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, DISPLAYCONFIG_TOPOLOGY_ID *currentTopologyId)
     * }
     */
    public static MemorySegment QueryDisplayConfig$address() {
        return QueryDisplayConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG QueryDisplayConfig(UINT32 flags, UINT32 *numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 *numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, DISPLAYCONFIG_TOPOLOGY_ID *currentTopologyId)
     * }
     */
    public static int QueryDisplayConfig(int flags, MemorySegment numPathArrayElements, MemorySegment pathArray, MemorySegment numModeInfoArrayElements, MemorySegment modeInfoArray, MemorySegment currentTopologyId) {
        var mh$ = QueryDisplayConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDisplayConfig", flags, numPathArrayElements, pathArray, numModeInfoArrayElements, modeInfoArray, currentTopologyId);
            }
            return (int)mh$.invokeExact(flags, numPathArrayElements, pathArray, numModeInfoArrayElements, modeInfoArray, currentTopologyId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisplayConfigGetDeviceInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DisplayConfigGetDeviceInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG DisplayConfigGetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *requestPacket)
     * }
     */
    public static FunctionDescriptor DisplayConfigGetDeviceInfo$descriptor() {
        return DisplayConfigGetDeviceInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG DisplayConfigGetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *requestPacket)
     * }
     */
    public static MethodHandle DisplayConfigGetDeviceInfo$handle() {
        return DisplayConfigGetDeviceInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG DisplayConfigGetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *requestPacket)
     * }
     */
    public static MemorySegment DisplayConfigGetDeviceInfo$address() {
        return DisplayConfigGetDeviceInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG DisplayConfigGetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *requestPacket)
     * }
     */
    public static int DisplayConfigGetDeviceInfo(MemorySegment requestPacket) {
        var mh$ = DisplayConfigGetDeviceInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisplayConfigGetDeviceInfo", requestPacket);
            }
            return (int)mh$.invokeExact(requestPacket);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisplayConfigSetDeviceInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DisplayConfigSetDeviceInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG DisplayConfigSetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *setPacket)
     * }
     */
    public static FunctionDescriptor DisplayConfigSetDeviceInfo$descriptor() {
        return DisplayConfigSetDeviceInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG DisplayConfigSetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *setPacket)
     * }
     */
    public static MethodHandle DisplayConfigSetDeviceInfo$handle() {
        return DisplayConfigSetDeviceInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG DisplayConfigSetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *setPacket)
     * }
     */
    public static MemorySegment DisplayConfigSetDeviceInfo$address() {
        return DisplayConfigSetDeviceInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG DisplayConfigSetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *setPacket)
     * }
     */
    public static int DisplayConfigSetDeviceInfo(MemorySegment setPacket) {
        var mh$ = DisplayConfigSetDeviceInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisplayConfigSetDeviceInfo", setPacket);
            }
            return (int)mh$.invokeExact(setPacket);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemParametersInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SystemParametersInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static FunctionDescriptor SystemParametersInfoA$descriptor() {
        return SystemParametersInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static MethodHandle SystemParametersInfoA$handle() {
        return SystemParametersInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static MemorySegment SystemParametersInfoA$address() {
        return SystemParametersInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static int SystemParametersInfoA(int uiAction, int uiParam, MemorySegment pvParam, int fWinIni) {
        var mh$ = SystemParametersInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemParametersInfoA", uiAction, uiParam, pvParam, fWinIni);
            }
            return (int)mh$.invokeExact(uiAction, uiParam, pvParam, fWinIni);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemParametersInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SystemParametersInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static FunctionDescriptor SystemParametersInfoW$descriptor() {
        return SystemParametersInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static MethodHandle SystemParametersInfoW$handle() {
        return SystemParametersInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static MemorySegment SystemParametersInfoW$address() {
        return SystemParametersInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static int SystemParametersInfoW(int uiAction, int uiParam, MemorySegment pvParam, int fWinIni) {
        var mh$ = SystemParametersInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemParametersInfoW", uiAction, uiParam, pvParam, fWinIni);
            }
            return (int)mh$.invokeExact(uiAction, uiParam, pvParam, fWinIni);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemParametersInfoForDpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SystemParametersInfoForDpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoForDpi(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni, UINT dpi)
     * }
     */
    public static FunctionDescriptor SystemParametersInfoForDpi$descriptor() {
        return SystemParametersInfoForDpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoForDpi(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni, UINT dpi)
     * }
     */
    public static MethodHandle SystemParametersInfoForDpi$handle() {
        return SystemParametersInfoForDpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoForDpi(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni, UINT dpi)
     * }
     */
    public static MemorySegment SystemParametersInfoForDpi$address() {
        return SystemParametersInfoForDpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SystemParametersInfoForDpi(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni, UINT dpi)
     * }
     */
    public static int SystemParametersInfoForDpi(int uiAction, int uiParam, MemorySegment pvParam, int fWinIni, int dpi) {
        var mh$ = SystemParametersInfoForDpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemParametersInfoForDpi", uiAction, uiParam, pvParam, fWinIni, dpi);
            }
            return (int)mh$.invokeExact(uiAction, uiParam, pvParam, fWinIni, dpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagFILTERKEYS {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD iWaitMSec;
     *     DWORD iDelayMSec;
     *     DWORD iRepeatMSec;
     *     DWORD iBounceMSec;
     * } *LPFILTERKEYS
     * }
     */
    public static final AddressLayout LPFILTERKEYS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTICKYKEYS {
     *     UINT cbSize;
     *     DWORD dwFlags;
     * } *LPSTICKYKEYS
     * }
     */
    public static final AddressLayout LPSTICKYKEYS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEKEYS {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD iMaxSpeed;
     *     DWORD iTimeToMaxSpeed;
     *     DWORD iCtrlSpeed;
     *     DWORD dwReserved1;
     *     DWORD dwReserved2;
     * } *LPMOUSEKEYS
     * }
     */
    public static final AddressLayout LPMOUSEKEYS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACCESSTIMEOUT {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD iTimeOutMSec;
     * } *LPACCESSTIMEOUT
     * }
     */
    public static final AddressLayout LPACCESSTIMEOUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSOUNDSENTRYA {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD iFSTextEffect;
     *     DWORD iFSTextEffectMSec;
     *     DWORD iFSTextEffectColorBits;
     *     DWORD iFSGrafEffect;
     *     DWORD iFSGrafEffectMSec;
     *     DWORD iFSGrafEffectColor;
     *     DWORD iWindowsEffect;
     *     DWORD iWindowsEffectMSec;
     *     LPSTR lpszWindowsEffectDLL;
     *     DWORD iWindowsEffectOrdinal;
     * } *LPSOUNDSENTRYA
     * }
     */
    public static final AddressLayout LPSOUNDSENTRYA = freeglut_h.C_POINTER;
}

