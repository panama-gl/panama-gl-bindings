// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * union _IMAGE_AUX_SYMBOL {
 *     struct {
 *         DWORD TagIndex;
 *         union {
 *             struct {
 *                 WORD Linenumber;
 *                 WORD Size;
 *             } LnSz;
 *             DWORD TotalSize;
 *         } Misc;
 *         union {
 *             struct {
 *                 DWORD PointerToLinenumber;
 *                 DWORD PointerToNextFunction;
 *             } Function;
 *             struct {
 *                 WORD Dimension[4];
 *             } Array;
 *         } FcnAry;
 *         WORD TvIndex;
 *     } Sym;
 *     struct {
 *         BYTE Name[18];
 *     } File;
 *     struct {
 *         DWORD Length;
 *         WORD NumberOfRelocations;
 *         WORD NumberOfLinenumbers;
 *         DWORD CheckSum;
 *         SHORT Number;
 *         BYTE Selection;
 *         BYTE bReserved;
 *         SHORT HighNumber;
 *     } Section;
 *     IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
 *     struct {
 *         DWORD crc;
 *         BYTE rgbReserved[14];
 *     } CRC;
 * }
 * }
 */
public class _IMAGE_AUX_SYMBOL {

    _IMAGE_AUX_SYMBOL() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
        _IMAGE_AUX_SYMBOL.Sym.layout().withName("Sym"),
        _IMAGE_AUX_SYMBOL.File.layout().withName("File"),
        _IMAGE_AUX_SYMBOL.Section.layout().withName("Section"),
        IMAGE_AUX_SYMBOL_TOKEN_DEF.layout().withName("TokenDef"),
        _IMAGE_AUX_SYMBOL.CRC.layout().withName("CRC")
    ).withName("_IMAGE_AUX_SYMBOL");

    /**
     * The layout of this union
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     DWORD TagIndex;
     *     union {
     *         struct {
     *             WORD Linenumber;
     *             WORD Size;
     *         } LnSz;
     *         DWORD TotalSize;
     *     } Misc;
     *     union {
     *         struct {
     *             DWORD PointerToLinenumber;
     *             DWORD PointerToNextFunction;
     *         } Function;
     *         struct {
     *             WORD Dimension[4];
     *         } Array;
     *     } FcnAry;
     *     WORD TvIndex;
     * }
     * }
     */
    public static class Sym {

        Sym() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            wgl_h.align(wgl_h.C_LONG, 2).withName("TagIndex"),
            _IMAGE_AUX_SYMBOL.Sym.Misc.layout().withName("Misc"),
            _IMAGE_AUX_SYMBOL.Sym.FcnAry.layout().withName("FcnAry"),
            wgl_h.C_SHORT.withName("TvIndex")
        ).withName("$anon$17574:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt TagIndex$LAYOUT = (OfInt)$LAYOUT.select(groupElement("TagIndex"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * DWORD TagIndex
         * }
         */
        public static final OfInt TagIndex$layout() {
            return TagIndex$LAYOUT;
        }

        private static final long TagIndex$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * DWORD TagIndex
         * }
         */
        public static final long TagIndex$offset() {
            return TagIndex$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * DWORD TagIndex
         * }
         */
        public static int TagIndex(MemorySegment struct) {
            return struct.get(TagIndex$LAYOUT, TagIndex$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * DWORD TagIndex
         * }
         */
        public static void TagIndex(MemorySegment struct, int fieldValue) {
            struct.set(TagIndex$LAYOUT, TagIndex$OFFSET, fieldValue);
        }

        /**
         * {@snippet lang=c :
         * union {
         *     struct {
         *         WORD Linenumber;
         *         WORD Size;
         *     } LnSz;
         *     DWORD TotalSize;
         * }
         * }
         */
        public static class Misc {

            Misc() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
                _IMAGE_AUX_SYMBOL.Sym.Misc.LnSz.layout().withName("LnSz"),
                wgl_h.align(wgl_h.C_LONG, 2).withName("TotalSize")
            ).withName("$anon$17576:9");

            /**
             * The layout of this union
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            /**
             * {@snippet lang=c :
             * struct {
             *     WORD Linenumber;
             *     WORD Size;
             * }
             * }
             */
            public static class LnSz {

                LnSz() {
                    // Should not be called directly
                }

                private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                    wgl_h.C_SHORT.withName("Linenumber"),
                    wgl_h.C_SHORT.withName("Size")
                ).withName("$anon$17577:13");

                /**
                 * The layout of this struct
                 */
                public static final GroupLayout layout() {
                    return $LAYOUT;
                }

                private static final OfShort Linenumber$LAYOUT = (OfShort)$LAYOUT.select(groupElement("Linenumber"));

                /**
                 * Layout for field:
                 * {@snippet lang=c :
                 * WORD Linenumber
                 * }
                 */
                public static final OfShort Linenumber$layout() {
                    return Linenumber$LAYOUT;
                }

                private static final long Linenumber$OFFSET = 0;

                /**
                 * Offset for field:
                 * {@snippet lang=c :
                 * WORD Linenumber
                 * }
                 */
                public static final long Linenumber$offset() {
                    return Linenumber$OFFSET;
                }

                /**
                 * Getter for field:
                 * {@snippet lang=c :
                 * WORD Linenumber
                 * }
                 */
                public static short Linenumber(MemorySegment struct) {
                    return struct.get(Linenumber$LAYOUT, Linenumber$OFFSET);
                }

                /**
                 * Setter for field:
                 * {@snippet lang=c :
                 * WORD Linenumber
                 * }
                 */
                public static void Linenumber(MemorySegment struct, short fieldValue) {
                    struct.set(Linenumber$LAYOUT, Linenumber$OFFSET, fieldValue);
                }

                private static final OfShort Size$LAYOUT = (OfShort)$LAYOUT.select(groupElement("Size"));

                /**
                 * Layout for field:
                 * {@snippet lang=c :
                 * WORD Size
                 * }
                 */
                public static final OfShort Size$layout() {
                    return Size$LAYOUT;
                }

                private static final long Size$OFFSET = 2;

                /**
                 * Offset for field:
                 * {@snippet lang=c :
                 * WORD Size
                 * }
                 */
                public static final long Size$offset() {
                    return Size$OFFSET;
                }

                /**
                 * Getter for field:
                 * {@snippet lang=c :
                 * WORD Size
                 * }
                 */
                public static short Size(MemorySegment struct) {
                    return struct.get(Size$LAYOUT, Size$OFFSET);
                }

                /**
                 * Setter for field:
                 * {@snippet lang=c :
                 * WORD Size
                 * }
                 */
                public static void Size(MemorySegment struct, short fieldValue) {
                    struct.set(Size$LAYOUT, Size$OFFSET, fieldValue);
                }

                /**
                 * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
                 * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
                 */
                public static MemorySegment asSlice(MemorySegment array, long index) {
                    return array.asSlice(layout().byteSize() * index);
                }

                /**
                 * The size (in bytes) of this struct
                 */
                public static long sizeof() { return layout().byteSize(); }

                /**
                 * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
                 */
                public static MemorySegment allocate(SegmentAllocator allocator) {
                    return allocator.allocate(layout());
                }

                /**
                 * Allocate an array of size {@code elementCount} using {@code allocator}.
                 * The returned segment has size {@code elementCount * layout().byteSize()}.
                 */
                public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                    return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
                }

                /**
                 * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                 * The returned segment has size {@code layout().byteSize()}
                 */
                public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                    return reinterpret(addr, 1, arena, cleanup);
                }

                /**
                 * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                 * The returned segment has size {@code elementCount * layout().byteSize()}
                 */
                public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                    return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
                }
            }

            private static final GroupLayout LnSz$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("LnSz"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * struct {
             *     WORD Linenumber;
             *     WORD Size;
             * } LnSz
             * }
             */
            public static final GroupLayout LnSz$layout() {
                return LnSz$LAYOUT;
            }

            private static final long LnSz$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * struct {
             *     WORD Linenumber;
             *     WORD Size;
             * } LnSz
             * }
             */
            public static final long LnSz$offset() {
                return LnSz$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * struct {
             *     WORD Linenumber;
             *     WORD Size;
             * } LnSz
             * }
             */
            public static MemorySegment LnSz(MemorySegment union) {
                return union.asSlice(LnSz$OFFSET, LnSz$LAYOUT.byteSize());
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * struct {
             *     WORD Linenumber;
             *     WORD Size;
             * } LnSz
             * }
             */
            public static void LnSz(MemorySegment union, MemorySegment fieldValue) {
                MemorySegment.copy(fieldValue, 0L, union, LnSz$OFFSET, LnSz$LAYOUT.byteSize());
            }

            private static final OfInt TotalSize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("TotalSize"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD TotalSize
             * }
             */
            public static final OfInt TotalSize$layout() {
                return TotalSize$LAYOUT;
            }

            private static final long TotalSize$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD TotalSize
             * }
             */
            public static final long TotalSize$offset() {
                return TotalSize$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD TotalSize
             * }
             */
            public static int TotalSize(MemorySegment union) {
                return union.get(TotalSize$LAYOUT, TotalSize$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD TotalSize
             * }
             */
            public static void TotalSize(MemorySegment union, int fieldValue) {
                union.set(TotalSize$LAYOUT, TotalSize$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this union
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout Misc$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Misc"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * union {
         *     struct {
         *         WORD Linenumber;
         *         WORD Size;
         *     } LnSz;
         *     DWORD TotalSize;
         * } Misc
         * }
         */
        public static final GroupLayout Misc$layout() {
            return Misc$LAYOUT;
        }

        private static final long Misc$OFFSET = 4;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * union {
         *     struct {
         *         WORD Linenumber;
         *         WORD Size;
         *     } LnSz;
         *     DWORD TotalSize;
         * } Misc
         * }
         */
        public static final long Misc$offset() {
            return Misc$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * union {
         *     struct {
         *         WORD Linenumber;
         *         WORD Size;
         *     } LnSz;
         *     DWORD TotalSize;
         * } Misc
         * }
         */
        public static MemorySegment Misc(MemorySegment struct) {
            return struct.asSlice(Misc$OFFSET, Misc$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * union {
         *     struct {
         *         WORD Linenumber;
         *         WORD Size;
         *     } LnSz;
         *     DWORD TotalSize;
         * } Misc
         * }
         */
        public static void Misc(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, Misc$OFFSET, Misc$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * union {
         *     struct {
         *         DWORD PointerToLinenumber;
         *         DWORD PointerToNextFunction;
         *     } Function;
         *     struct {
         *         WORD Dimension[4];
         *     } Array;
         * }
         * }
         */
        public static class FcnAry {

            FcnAry() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
                _IMAGE_AUX_SYMBOL.Sym.FcnAry.Function.layout().withName("Function"),
                _IMAGE_AUX_SYMBOL.Sym.FcnAry.Array.layout().withName("Array")
            ).withName("$anon$17583:9");

            /**
             * The layout of this union
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            /**
             * {@snippet lang=c :
             * struct {
             *     DWORD PointerToLinenumber;
             *     DWORD PointerToNextFunction;
             * }
             * }
             */
            public static class Function {

                Function() {
                    // Should not be called directly
                }

                private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                    wgl_h.align(wgl_h.C_LONG, 2).withName("PointerToLinenumber"),
                    wgl_h.align(wgl_h.C_LONG, 2).withName("PointerToNextFunction")
                ).withName("$anon$17584:13");

                /**
                 * The layout of this struct
                 */
                public static final GroupLayout layout() {
                    return $LAYOUT;
                }

                private static final OfInt PointerToLinenumber$LAYOUT = (OfInt)$LAYOUT.select(groupElement("PointerToLinenumber"));

                /**
                 * Layout for field:
                 * {@snippet lang=c :
                 * DWORD PointerToLinenumber
                 * }
                 */
                public static final OfInt PointerToLinenumber$layout() {
                    return PointerToLinenumber$LAYOUT;
                }

                private static final long PointerToLinenumber$OFFSET = 0;

                /**
                 * Offset for field:
                 * {@snippet lang=c :
                 * DWORD PointerToLinenumber
                 * }
                 */
                public static final long PointerToLinenumber$offset() {
                    return PointerToLinenumber$OFFSET;
                }

                /**
                 * Getter for field:
                 * {@snippet lang=c :
                 * DWORD PointerToLinenumber
                 * }
                 */
                public static int PointerToLinenumber(MemorySegment struct) {
                    return struct.get(PointerToLinenumber$LAYOUT, PointerToLinenumber$OFFSET);
                }

                /**
                 * Setter for field:
                 * {@snippet lang=c :
                 * DWORD PointerToLinenumber
                 * }
                 */
                public static void PointerToLinenumber(MemorySegment struct, int fieldValue) {
                    struct.set(PointerToLinenumber$LAYOUT, PointerToLinenumber$OFFSET, fieldValue);
                }

                private static final OfInt PointerToNextFunction$LAYOUT = (OfInt)$LAYOUT.select(groupElement("PointerToNextFunction"));

                /**
                 * Layout for field:
                 * {@snippet lang=c :
                 * DWORD PointerToNextFunction
                 * }
                 */
                public static final OfInt PointerToNextFunction$layout() {
                    return PointerToNextFunction$LAYOUT;
                }

                private static final long PointerToNextFunction$OFFSET = 4;

                /**
                 * Offset for field:
                 * {@snippet lang=c :
                 * DWORD PointerToNextFunction
                 * }
                 */
                public static final long PointerToNextFunction$offset() {
                    return PointerToNextFunction$OFFSET;
                }

                /**
                 * Getter for field:
                 * {@snippet lang=c :
                 * DWORD PointerToNextFunction
                 * }
                 */
                public static int PointerToNextFunction(MemorySegment struct) {
                    return struct.get(PointerToNextFunction$LAYOUT, PointerToNextFunction$OFFSET);
                }

                /**
                 * Setter for field:
                 * {@snippet lang=c :
                 * DWORD PointerToNextFunction
                 * }
                 */
                public static void PointerToNextFunction(MemorySegment struct, int fieldValue) {
                    struct.set(PointerToNextFunction$LAYOUT, PointerToNextFunction$OFFSET, fieldValue);
                }

                /**
                 * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
                 * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
                 */
                public static MemorySegment asSlice(MemorySegment array, long index) {
                    return array.asSlice(layout().byteSize() * index);
                }

                /**
                 * The size (in bytes) of this struct
                 */
                public static long sizeof() { return layout().byteSize(); }

                /**
                 * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
                 */
                public static MemorySegment allocate(SegmentAllocator allocator) {
                    return allocator.allocate(layout());
                }

                /**
                 * Allocate an array of size {@code elementCount} using {@code allocator}.
                 * The returned segment has size {@code elementCount * layout().byteSize()}.
                 */
                public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                    return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
                }

                /**
                 * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                 * The returned segment has size {@code layout().byteSize()}
                 */
                public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                    return reinterpret(addr, 1, arena, cleanup);
                }

                /**
                 * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                 * The returned segment has size {@code elementCount * layout().byteSize()}
                 */
                public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                    return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
                }
            }

            private static final GroupLayout Function$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Function"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * struct {
             *     DWORD PointerToLinenumber;
             *     DWORD PointerToNextFunction;
             * } Function
             * }
             */
            public static final GroupLayout Function$layout() {
                return Function$LAYOUT;
            }

            private static final long Function$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * struct {
             *     DWORD PointerToLinenumber;
             *     DWORD PointerToNextFunction;
             * } Function
             * }
             */
            public static final long Function$offset() {
                return Function$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * struct {
             *     DWORD PointerToLinenumber;
             *     DWORD PointerToNextFunction;
             * } Function
             * }
             */
            public static MemorySegment Function(MemorySegment union) {
                return union.asSlice(Function$OFFSET, Function$LAYOUT.byteSize());
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * struct {
             *     DWORD PointerToLinenumber;
             *     DWORD PointerToNextFunction;
             * } Function
             * }
             */
            public static void Function(MemorySegment union, MemorySegment fieldValue) {
                MemorySegment.copy(fieldValue, 0L, union, Function$OFFSET, Function$LAYOUT.byteSize());
            }

            /**
             * {@snippet lang=c :
             * struct {
             *     WORD Dimension[4];
             * }
             * }
             */
            public static class Array {

                Array() {
                    // Should not be called directly
                }

                private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                    MemoryLayout.sequenceLayout(4, wgl_h.C_SHORT).withName("Dimension")
                ).withName("$anon$17588:13");

                /**
                 * The layout of this struct
                 */
                public static final GroupLayout layout() {
                    return $LAYOUT;
                }

                private static final SequenceLayout Dimension$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("Dimension"));

                /**
                 * Layout for field:
                 * {@snippet lang=c :
                 * WORD Dimension[4]
                 * }
                 */
                public static final SequenceLayout Dimension$layout() {
                    return Dimension$LAYOUT;
                }

                private static final long Dimension$OFFSET = 0;

                /**
                 * Offset for field:
                 * {@snippet lang=c :
                 * WORD Dimension[4]
                 * }
                 */
                public static final long Dimension$offset() {
                    return Dimension$OFFSET;
                }

                /**
                 * Getter for field:
                 * {@snippet lang=c :
                 * WORD Dimension[4]
                 * }
                 */
                public static MemorySegment Dimension(MemorySegment struct) {
                    return struct.asSlice(Dimension$OFFSET, Dimension$LAYOUT.byteSize());
                }

                /**
                 * Setter for field:
                 * {@snippet lang=c :
                 * WORD Dimension[4]
                 * }
                 */
                public static void Dimension(MemorySegment struct, MemorySegment fieldValue) {
                    MemorySegment.copy(fieldValue, 0L, struct, Dimension$OFFSET, Dimension$LAYOUT.byteSize());
                }

                private static long[] Dimension$DIMS = { 4 };

                /**
                 * Dimensions for array field:
                 * {@snippet lang=c :
                 * WORD Dimension[4]
                 * }
                 */
                public static long[] Dimension$dimensions() {
                    return Dimension$DIMS;
                }
                private static final VarHandle Dimension$ELEM_HANDLE = Dimension$LAYOUT.varHandle(sequenceElement());

                /**
                 * Indexed getter for field:
                 * {@snippet lang=c :
                 * WORD Dimension[4]
                 * }
                 */
                public static short Dimension(MemorySegment struct, long index0) {
                    return (short)Dimension$ELEM_HANDLE.get(struct, 0L, index0);
                }

                /**
                 * Indexed setter for field:
                 * {@snippet lang=c :
                 * WORD Dimension[4]
                 * }
                 */
                public static void Dimension(MemorySegment struct, long index0, short fieldValue) {
                    Dimension$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
                }

                /**
                 * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
                 * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
                 */
                public static MemorySegment asSlice(MemorySegment array, long index) {
                    return array.asSlice(layout().byteSize() * index);
                }

                /**
                 * The size (in bytes) of this struct
                 */
                public static long sizeof() { return layout().byteSize(); }

                /**
                 * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
                 */
                public static MemorySegment allocate(SegmentAllocator allocator) {
                    return allocator.allocate(layout());
                }

                /**
                 * Allocate an array of size {@code elementCount} using {@code allocator}.
                 * The returned segment has size {@code elementCount * layout().byteSize()}.
                 */
                public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                    return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
                }

                /**
                 * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                 * The returned segment has size {@code layout().byteSize()}
                 */
                public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                    return reinterpret(addr, 1, arena, cleanup);
                }

                /**
                 * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                 * The returned segment has size {@code elementCount * layout().byteSize()}
                 */
                public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                    return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
                }
            }

            private static final GroupLayout Array$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Array"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * struct {
             *     WORD Dimension[4];
             * } Array
             * }
             */
            public static final GroupLayout Array$layout() {
                return Array$LAYOUT;
            }

            private static final long Array$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * struct {
             *     WORD Dimension[4];
             * } Array
             * }
             */
            public static final long Array$offset() {
                return Array$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * struct {
             *     WORD Dimension[4];
             * } Array
             * }
             */
            public static MemorySegment Array(MemorySegment union) {
                return union.asSlice(Array$OFFSET, Array$LAYOUT.byteSize());
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * struct {
             *     WORD Dimension[4];
             * } Array
             * }
             */
            public static void Array(MemorySegment union, MemorySegment fieldValue) {
                MemorySegment.copy(fieldValue, 0L, union, Array$OFFSET, Array$LAYOUT.byteSize());
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this union
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout FcnAry$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("FcnAry"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * union {
         *     struct {
         *         DWORD PointerToLinenumber;
         *         DWORD PointerToNextFunction;
         *     } Function;
         *     struct {
         *         WORD Dimension[4];
         *     } Array;
         * } FcnAry
         * }
         */
        public static final GroupLayout FcnAry$layout() {
            return FcnAry$LAYOUT;
        }

        private static final long FcnAry$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * union {
         *     struct {
         *         DWORD PointerToLinenumber;
         *         DWORD PointerToNextFunction;
         *     } Function;
         *     struct {
         *         WORD Dimension[4];
         *     } Array;
         * } FcnAry
         * }
         */
        public static final long FcnAry$offset() {
            return FcnAry$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * union {
         *     struct {
         *         DWORD PointerToLinenumber;
         *         DWORD PointerToNextFunction;
         *     } Function;
         *     struct {
         *         WORD Dimension[4];
         *     } Array;
         * } FcnAry
         * }
         */
        public static MemorySegment FcnAry(MemorySegment struct) {
            return struct.asSlice(FcnAry$OFFSET, FcnAry$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * union {
         *     struct {
         *         DWORD PointerToLinenumber;
         *         DWORD PointerToNextFunction;
         *     } Function;
         *     struct {
         *         WORD Dimension[4];
         *     } Array;
         * } FcnAry
         * }
         */
        public static void FcnAry(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, FcnAry$OFFSET, FcnAry$LAYOUT.byteSize());
        }

        private static final OfShort TvIndex$LAYOUT = (OfShort)$LAYOUT.select(groupElement("TvIndex"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * WORD TvIndex
         * }
         */
        public static final OfShort TvIndex$layout() {
            return TvIndex$LAYOUT;
        }

        private static final long TvIndex$OFFSET = 16;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * WORD TvIndex
         * }
         */
        public static final long TvIndex$offset() {
            return TvIndex$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * WORD TvIndex
         * }
         */
        public static short TvIndex(MemorySegment struct) {
            return struct.get(TvIndex$LAYOUT, TvIndex$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * WORD TvIndex
         * }
         */
        public static void TvIndex(MemorySegment struct, short fieldValue) {
            struct.set(TvIndex$LAYOUT, TvIndex$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout Sym$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Sym"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD TagIndex;
     *     union {
     *         struct {
     *             WORD Linenumber;
     *             WORD Size;
     *         } LnSz;
     *         DWORD TotalSize;
     *     } Misc;
     *     union {
     *         struct {
     *             DWORD PointerToLinenumber;
     *             DWORD PointerToNextFunction;
     *         } Function;
     *         struct {
     *             WORD Dimension[4];
     *         } Array;
     *     } FcnAry;
     *     WORD TvIndex;
     * } Sym
     * }
     */
    public static final GroupLayout Sym$layout() {
        return Sym$LAYOUT;
    }

    private static final long Sym$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD TagIndex;
     *     union {
     *         struct {
     *             WORD Linenumber;
     *             WORD Size;
     *         } LnSz;
     *         DWORD TotalSize;
     *     } Misc;
     *     union {
     *         struct {
     *             DWORD PointerToLinenumber;
     *             DWORD PointerToNextFunction;
     *         } Function;
     *         struct {
     *             WORD Dimension[4];
     *         } Array;
     *     } FcnAry;
     *     WORD TvIndex;
     * } Sym
     * }
     */
    public static final long Sym$offset() {
        return Sym$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD TagIndex;
     *     union {
     *         struct {
     *             WORD Linenumber;
     *             WORD Size;
     *         } LnSz;
     *         DWORD TotalSize;
     *     } Misc;
     *     union {
     *         struct {
     *             DWORD PointerToLinenumber;
     *             DWORD PointerToNextFunction;
     *         } Function;
     *         struct {
     *             WORD Dimension[4];
     *         } Array;
     *     } FcnAry;
     *     WORD TvIndex;
     * } Sym
     * }
     */
    public static MemorySegment Sym(MemorySegment union) {
        return union.asSlice(Sym$OFFSET, Sym$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD TagIndex;
     *     union {
     *         struct {
     *             WORD Linenumber;
     *             WORD Size;
     *         } LnSz;
     *         DWORD TotalSize;
     *     } Misc;
     *     union {
     *         struct {
     *             DWORD PointerToLinenumber;
     *             DWORD PointerToNextFunction;
     *         } Function;
     *         struct {
     *             WORD Dimension[4];
     *         } Array;
     *     } FcnAry;
     *     WORD TvIndex;
     * } Sym
     * }
     */
    public static void Sym(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, Sym$OFFSET, Sym$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     BYTE Name[18];
     * }
     * }
     */
    public static class File {

        File() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            MemoryLayout.sequenceLayout(18, wgl_h.C_CHAR).withName("Name")
        ).withName("$anon$17594:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final SequenceLayout Name$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("Name"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * BYTE Name[18]
         * }
         */
        public static final SequenceLayout Name$layout() {
            return Name$LAYOUT;
        }

        private static final long Name$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * BYTE Name[18]
         * }
         */
        public static final long Name$offset() {
            return Name$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * BYTE Name[18]
         * }
         */
        public static MemorySegment Name(MemorySegment struct) {
            return struct.asSlice(Name$OFFSET, Name$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * BYTE Name[18]
         * }
         */
        public static void Name(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, Name$OFFSET, Name$LAYOUT.byteSize());
        }

        private static long[] Name$DIMS = { 18 };

        /**
         * Dimensions for array field:
         * {@snippet lang=c :
         * BYTE Name[18]
         * }
         */
        public static long[] Name$dimensions() {
            return Name$DIMS;
        }
        private static final VarHandle Name$ELEM_HANDLE = Name$LAYOUT.varHandle(sequenceElement());

        /**
         * Indexed getter for field:
         * {@snippet lang=c :
         * BYTE Name[18]
         * }
         */
        public static byte Name(MemorySegment struct, long index0) {
            return (byte)Name$ELEM_HANDLE.get(struct, 0L, index0);
        }

        /**
         * Indexed setter for field:
         * {@snippet lang=c :
         * BYTE Name[18]
         * }
         */
        public static void Name(MemorySegment struct, long index0, byte fieldValue) {
            Name$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout File$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("File"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     BYTE Name[18];
     * } File
     * }
     */
    public static final GroupLayout File$layout() {
        return File$LAYOUT;
    }

    private static final long File$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     BYTE Name[18];
     * } File
     * }
     */
    public static final long File$offset() {
        return File$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     BYTE Name[18];
     * } File
     * }
     */
    public static MemorySegment File(MemorySegment union) {
        return union.asSlice(File$OFFSET, File$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     BYTE Name[18];
     * } File
     * }
     */
    public static void File(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, File$OFFSET, File$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     DWORD Length;
     *     WORD NumberOfRelocations;
     *     WORD NumberOfLinenumbers;
     *     DWORD CheckSum;
     *     SHORT Number;
     *     BYTE Selection;
     *     BYTE bReserved;
     *     SHORT HighNumber;
     * }
     * }
     */
    public static class Section {

        Section() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            wgl_h.align(wgl_h.C_LONG, 2).withName("Length"),
            wgl_h.C_SHORT.withName("NumberOfRelocations"),
            wgl_h.C_SHORT.withName("NumberOfLinenumbers"),
            wgl_h.align(wgl_h.C_LONG, 2).withName("CheckSum"),
            wgl_h.C_SHORT.withName("Number"),
            wgl_h.C_CHAR.withName("Selection"),
            wgl_h.C_CHAR.withName("bReserved"),
            wgl_h.C_SHORT.withName("HighNumber")
        ).withName("$anon$17597:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt Length$LAYOUT = (OfInt)$LAYOUT.select(groupElement("Length"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * DWORD Length
         * }
         */
        public static final OfInt Length$layout() {
            return Length$LAYOUT;
        }

        private static final long Length$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * DWORD Length
         * }
         */
        public static final long Length$offset() {
            return Length$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * DWORD Length
         * }
         */
        public static int Length(MemorySegment struct) {
            return struct.get(Length$LAYOUT, Length$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * DWORD Length
         * }
         */
        public static void Length(MemorySegment struct, int fieldValue) {
            struct.set(Length$LAYOUT, Length$OFFSET, fieldValue);
        }

        private static final OfShort NumberOfRelocations$LAYOUT = (OfShort)$LAYOUT.select(groupElement("NumberOfRelocations"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * WORD NumberOfRelocations
         * }
         */
        public static final OfShort NumberOfRelocations$layout() {
            return NumberOfRelocations$LAYOUT;
        }

        private static final long NumberOfRelocations$OFFSET = 4;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * WORD NumberOfRelocations
         * }
         */
        public static final long NumberOfRelocations$offset() {
            return NumberOfRelocations$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * WORD NumberOfRelocations
         * }
         */
        public static short NumberOfRelocations(MemorySegment struct) {
            return struct.get(NumberOfRelocations$LAYOUT, NumberOfRelocations$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * WORD NumberOfRelocations
         * }
         */
        public static void NumberOfRelocations(MemorySegment struct, short fieldValue) {
            struct.set(NumberOfRelocations$LAYOUT, NumberOfRelocations$OFFSET, fieldValue);
        }

        private static final OfShort NumberOfLinenumbers$LAYOUT = (OfShort)$LAYOUT.select(groupElement("NumberOfLinenumbers"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * WORD NumberOfLinenumbers
         * }
         */
        public static final OfShort NumberOfLinenumbers$layout() {
            return NumberOfLinenumbers$LAYOUT;
        }

        private static final long NumberOfLinenumbers$OFFSET = 6;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * WORD NumberOfLinenumbers
         * }
         */
        public static final long NumberOfLinenumbers$offset() {
            return NumberOfLinenumbers$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * WORD NumberOfLinenumbers
         * }
         */
        public static short NumberOfLinenumbers(MemorySegment struct) {
            return struct.get(NumberOfLinenumbers$LAYOUT, NumberOfLinenumbers$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * WORD NumberOfLinenumbers
         * }
         */
        public static void NumberOfLinenumbers(MemorySegment struct, short fieldValue) {
            struct.set(NumberOfLinenumbers$LAYOUT, NumberOfLinenumbers$OFFSET, fieldValue);
        }

        private static final OfInt CheckSum$LAYOUT = (OfInt)$LAYOUT.select(groupElement("CheckSum"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * DWORD CheckSum
         * }
         */
        public static final OfInt CheckSum$layout() {
            return CheckSum$LAYOUT;
        }

        private static final long CheckSum$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * DWORD CheckSum
         * }
         */
        public static final long CheckSum$offset() {
            return CheckSum$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * DWORD CheckSum
         * }
         */
        public static int CheckSum(MemorySegment struct) {
            return struct.get(CheckSum$LAYOUT, CheckSum$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * DWORD CheckSum
         * }
         */
        public static void CheckSum(MemorySegment struct, int fieldValue) {
            struct.set(CheckSum$LAYOUT, CheckSum$OFFSET, fieldValue);
        }

        private static final OfShort Number$LAYOUT = (OfShort)$LAYOUT.select(groupElement("Number"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * SHORT Number
         * }
         */
        public static final OfShort Number$layout() {
            return Number$LAYOUT;
        }

        private static final long Number$OFFSET = 12;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * SHORT Number
         * }
         */
        public static final long Number$offset() {
            return Number$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * SHORT Number
         * }
         */
        public static short Number(MemorySegment struct) {
            return struct.get(Number$LAYOUT, Number$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * SHORT Number
         * }
         */
        public static void Number(MemorySegment struct, short fieldValue) {
            struct.set(Number$LAYOUT, Number$OFFSET, fieldValue);
        }

        private static final OfByte Selection$LAYOUT = (OfByte)$LAYOUT.select(groupElement("Selection"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * BYTE Selection
         * }
         */
        public static final OfByte Selection$layout() {
            return Selection$LAYOUT;
        }

        private static final long Selection$OFFSET = 14;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * BYTE Selection
         * }
         */
        public static final long Selection$offset() {
            return Selection$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * BYTE Selection
         * }
         */
        public static byte Selection(MemorySegment struct) {
            return struct.get(Selection$LAYOUT, Selection$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * BYTE Selection
         * }
         */
        public static void Selection(MemorySegment struct, byte fieldValue) {
            struct.set(Selection$LAYOUT, Selection$OFFSET, fieldValue);
        }

        private static final OfByte bReserved$LAYOUT = (OfByte)$LAYOUT.select(groupElement("bReserved"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * BYTE bReserved
         * }
         */
        public static final OfByte bReserved$layout() {
            return bReserved$LAYOUT;
        }

        private static final long bReserved$OFFSET = 15;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * BYTE bReserved
         * }
         */
        public static final long bReserved$offset() {
            return bReserved$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * BYTE bReserved
         * }
         */
        public static byte bReserved(MemorySegment struct) {
            return struct.get(bReserved$LAYOUT, bReserved$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * BYTE bReserved
         * }
         */
        public static void bReserved(MemorySegment struct, byte fieldValue) {
            struct.set(bReserved$LAYOUT, bReserved$OFFSET, fieldValue);
        }

        private static final OfShort HighNumber$LAYOUT = (OfShort)$LAYOUT.select(groupElement("HighNumber"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * SHORT HighNumber
         * }
         */
        public static final OfShort HighNumber$layout() {
            return HighNumber$LAYOUT;
        }

        private static final long HighNumber$OFFSET = 16;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * SHORT HighNumber
         * }
         */
        public static final long HighNumber$offset() {
            return HighNumber$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * SHORT HighNumber
         * }
         */
        public static short HighNumber(MemorySegment struct) {
            return struct.get(HighNumber$LAYOUT, HighNumber$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * SHORT HighNumber
         * }
         */
        public static void HighNumber(MemorySegment struct, short fieldValue) {
            struct.set(HighNumber$LAYOUT, HighNumber$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout Section$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Section"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD Length;
     *     WORD NumberOfRelocations;
     *     WORD NumberOfLinenumbers;
     *     DWORD CheckSum;
     *     SHORT Number;
     *     BYTE Selection;
     *     BYTE bReserved;
     *     SHORT HighNumber;
     * } Section
     * }
     */
    public static final GroupLayout Section$layout() {
        return Section$LAYOUT;
    }

    private static final long Section$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD Length;
     *     WORD NumberOfRelocations;
     *     WORD NumberOfLinenumbers;
     *     DWORD CheckSum;
     *     SHORT Number;
     *     BYTE Selection;
     *     BYTE bReserved;
     *     SHORT HighNumber;
     * } Section
     * }
     */
    public static final long Section$offset() {
        return Section$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD Length;
     *     WORD NumberOfRelocations;
     *     WORD NumberOfLinenumbers;
     *     DWORD CheckSum;
     *     SHORT Number;
     *     BYTE Selection;
     *     BYTE bReserved;
     *     SHORT HighNumber;
     * } Section
     * }
     */
    public static MemorySegment Section(MemorySegment union) {
        return union.asSlice(Section$OFFSET, Section$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD Length;
     *     WORD NumberOfRelocations;
     *     WORD NumberOfLinenumbers;
     *     DWORD CheckSum;
     *     SHORT Number;
     *     BYTE Selection;
     *     BYTE bReserved;
     *     SHORT HighNumber;
     * } Section
     * }
     */
    public static void Section(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, Section$OFFSET, Section$LAYOUT.byteSize());
    }

    private static final GroupLayout TokenDef$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("TokenDef"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef
     * }
     */
    public static final GroupLayout TokenDef$layout() {
        return TokenDef$LAYOUT;
    }

    private static final long TokenDef$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef
     * }
     */
    public static final long TokenDef$offset() {
        return TokenDef$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef
     * }
     */
    public static MemorySegment TokenDef(MemorySegment union) {
        return union.asSlice(TokenDef$OFFSET, TokenDef$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef
     * }
     */
    public static void TokenDef(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, TokenDef$OFFSET, TokenDef$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     DWORD crc;
     *     BYTE rgbReserved[14];
     * }
     * }
     */
    public static class CRC {

        CRC() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            wgl_h.align(wgl_h.C_LONG, 2).withName("crc"),
            MemoryLayout.sequenceLayout(14, wgl_h.C_CHAR).withName("rgbReserved")
        ).withName("$anon$17608:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt crc$LAYOUT = (OfInt)$LAYOUT.select(groupElement("crc"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * DWORD crc
         * }
         */
        public static final OfInt crc$layout() {
            return crc$LAYOUT;
        }

        private static final long crc$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * DWORD crc
         * }
         */
        public static final long crc$offset() {
            return crc$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * DWORD crc
         * }
         */
        public static int crc(MemorySegment struct) {
            return struct.get(crc$LAYOUT, crc$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * DWORD crc
         * }
         */
        public static void crc(MemorySegment struct, int fieldValue) {
            struct.set(crc$LAYOUT, crc$OFFSET, fieldValue);
        }

        private static final SequenceLayout rgbReserved$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("rgbReserved"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * BYTE rgbReserved[14]
         * }
         */
        public static final SequenceLayout rgbReserved$layout() {
            return rgbReserved$LAYOUT;
        }

        private static final long rgbReserved$OFFSET = 4;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * BYTE rgbReserved[14]
         * }
         */
        public static final long rgbReserved$offset() {
            return rgbReserved$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * BYTE rgbReserved[14]
         * }
         */
        public static MemorySegment rgbReserved(MemorySegment struct) {
            return struct.asSlice(rgbReserved$OFFSET, rgbReserved$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * BYTE rgbReserved[14]
         * }
         */
        public static void rgbReserved(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, rgbReserved$OFFSET, rgbReserved$LAYOUT.byteSize());
        }

        private static long[] rgbReserved$DIMS = { 14 };

        /**
         * Dimensions for array field:
         * {@snippet lang=c :
         * BYTE rgbReserved[14]
         * }
         */
        public static long[] rgbReserved$dimensions() {
            return rgbReserved$DIMS;
        }
        private static final VarHandle rgbReserved$ELEM_HANDLE = rgbReserved$LAYOUT.varHandle(sequenceElement());

        /**
         * Indexed getter for field:
         * {@snippet lang=c :
         * BYTE rgbReserved[14]
         * }
         */
        public static byte rgbReserved(MemorySegment struct, long index0) {
            return (byte)rgbReserved$ELEM_HANDLE.get(struct, 0L, index0);
        }

        /**
         * Indexed setter for field:
         * {@snippet lang=c :
         * BYTE rgbReserved[14]
         * }
         */
        public static void rgbReserved(MemorySegment struct, long index0, byte fieldValue) {
            rgbReserved$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout CRC$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("CRC"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD crc;
     *     BYTE rgbReserved[14];
     * } CRC
     * }
     */
    public static final GroupLayout CRC$layout() {
        return CRC$LAYOUT;
    }

    private static final long CRC$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD crc;
     *     BYTE rgbReserved[14];
     * } CRC
     * }
     */
    public static final long CRC$offset() {
        return CRC$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD crc;
     *     BYTE rgbReserved[14];
     * } CRC
     * }
     */
    public static MemorySegment CRC(MemorySegment union) {
        return union.asSlice(CRC$OFFSET, CRC$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD crc;
     *     BYTE rgbReserved[14];
     * } CRC
     * }
     */
    public static void CRC(MemorySegment union, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, union, CRC$OFFSET, CRC$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this union
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

