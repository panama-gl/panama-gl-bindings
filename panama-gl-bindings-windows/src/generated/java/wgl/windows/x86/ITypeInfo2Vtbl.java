// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ITypeInfo2Vtbl {
 *     HRESULT (*QueryInterface)(ITypeInfo2 *, const IID *const, void **) __attribute__((stdcall));
 *     ULONG (*AddRef)(ITypeInfo2 *) __attribute__((stdcall));
 *     ULONG (*Release)(ITypeInfo2 *) __attribute__((stdcall));
 *     HRESULT (*GetTypeAttr)(ITypeInfo2 *, TYPEATTR **) __attribute__((stdcall));
 *     HRESULT (*GetTypeComp)(ITypeInfo2 *, ITypeComp **) __attribute__((stdcall));
 *     HRESULT (*GetFuncDesc)(ITypeInfo2 *, UINT, FUNCDESC **) __attribute__((stdcall));
 *     HRESULT (*GetVarDesc)(ITypeInfo2 *, UINT, VARDESC **) __attribute__((stdcall));
 *     HRESULT (*GetNames)(ITypeInfo2 *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall));
 *     HRESULT (*GetRefTypeOfImplType)(ITypeInfo2 *, UINT, HREFTYPE *) __attribute__((stdcall));
 *     HRESULT (*GetImplTypeFlags)(ITypeInfo2 *, UINT, INT *) __attribute__((stdcall));
 *     HRESULT (*GetIDsOfNames)(ITypeInfo2 *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall));
 *     HRESULT (*Invoke)(ITypeInfo2 *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall));
 *     HRESULT (*GetDocumentation)(ITypeInfo2 *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetDllEntry)(ITypeInfo2 *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall));
 *     HRESULT (*GetRefTypeInfo)(ITypeInfo2 *, HREFTYPE, ITypeInfo **) __attribute__((stdcall));
 *     HRESULT (*AddressOfMember)(ITypeInfo2 *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall));
 *     HRESULT (*CreateInstance)(ITypeInfo2 *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall));
 *     HRESULT (*GetMops)(ITypeInfo2 *, MEMBERID, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetContainingTypeLib)(ITypeInfo2 *, ITypeLib **, UINT *) __attribute__((stdcall));
 *     void (*ReleaseTypeAttr)(ITypeInfo2 *, TYPEATTR *) __attribute__((stdcall));
 *     void (*ReleaseFuncDesc)(ITypeInfo2 *, FUNCDESC *) __attribute__((stdcall));
 *     void (*ReleaseVarDesc)(ITypeInfo2 *, VARDESC *) __attribute__((stdcall));
 *     HRESULT (*GetTypeKind)(ITypeInfo2 *, TYPEKIND *) __attribute__((stdcall));
 *     HRESULT (*GetTypeFlags)(ITypeInfo2 *, ULONG *) __attribute__((stdcall));
 *     HRESULT (*GetFuncIndexOfMemId)(ITypeInfo2 *, MEMBERID, INVOKEKIND, UINT *) __attribute__((stdcall));
 *     HRESULT (*GetVarIndexOfMemId)(ITypeInfo2 *, MEMBERID, UINT *) __attribute__((stdcall));
 *     HRESULT (*GetCustData)(ITypeInfo2 *, const GUID *const, VARIANT *) __attribute__((stdcall));
 *     HRESULT (*GetFuncCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall));
 *     HRESULT (*GetParamCustData)(ITypeInfo2 *, UINT, UINT, const GUID *const, VARIANT *) __attribute__((stdcall));
 *     HRESULT (*GetVarCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall));
 *     HRESULT (*GetImplTypeCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall));
 *     HRESULT (*GetDocumentation2)(ITypeInfo2 *, MEMBERID, LCID, BSTR *, DWORD *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetAllCustData)(ITypeInfo2 *, CUSTDATA *) __attribute__((stdcall));
 *     HRESULT (*GetAllFuncCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall));
 *     HRESULT (*GetAllParamCustData)(ITypeInfo2 *, UINT, UINT, CUSTDATA *) __attribute__((stdcall));
 *     HRESULT (*GetAllVarCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall));
 *     HRESULT (*GetAllImplTypeCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall));
 * }
 * }
 */
public class ITypeInfo2Vtbl {

    ITypeInfo2Vtbl() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        wgl_h.C_POINTER.withName("QueryInterface"),
        wgl_h.C_POINTER.withName("AddRef"),
        wgl_h.C_POINTER.withName("Release"),
        wgl_h.C_POINTER.withName("GetTypeAttr"),
        wgl_h.C_POINTER.withName("GetTypeComp"),
        wgl_h.C_POINTER.withName("GetFuncDesc"),
        wgl_h.C_POINTER.withName("GetVarDesc"),
        wgl_h.C_POINTER.withName("GetNames"),
        wgl_h.C_POINTER.withName("GetRefTypeOfImplType"),
        wgl_h.C_POINTER.withName("GetImplTypeFlags"),
        wgl_h.C_POINTER.withName("GetIDsOfNames"),
        wgl_h.C_POINTER.withName("Invoke"),
        wgl_h.C_POINTER.withName("GetDocumentation"),
        wgl_h.C_POINTER.withName("GetDllEntry"),
        wgl_h.C_POINTER.withName("GetRefTypeInfo"),
        wgl_h.C_POINTER.withName("AddressOfMember"),
        wgl_h.C_POINTER.withName("CreateInstance"),
        wgl_h.C_POINTER.withName("GetMops"),
        wgl_h.C_POINTER.withName("GetContainingTypeLib"),
        wgl_h.C_POINTER.withName("ReleaseTypeAttr"),
        wgl_h.C_POINTER.withName("ReleaseFuncDesc"),
        wgl_h.C_POINTER.withName("ReleaseVarDesc"),
        wgl_h.C_POINTER.withName("GetTypeKind"),
        wgl_h.C_POINTER.withName("GetTypeFlags"),
        wgl_h.C_POINTER.withName("GetFuncIndexOfMemId"),
        wgl_h.C_POINTER.withName("GetVarIndexOfMemId"),
        wgl_h.C_POINTER.withName("GetCustData"),
        wgl_h.C_POINTER.withName("GetFuncCustData"),
        wgl_h.C_POINTER.withName("GetParamCustData"),
        wgl_h.C_POINTER.withName("GetVarCustData"),
        wgl_h.C_POINTER.withName("GetImplTypeCustData"),
        wgl_h.C_POINTER.withName("GetDocumentation2"),
        wgl_h.C_POINTER.withName("GetAllCustData"),
        wgl_h.C_POINTER.withName("GetAllFuncCustData"),
        wgl_h.C_POINTER.withName("GetAllParamCustData"),
        wgl_h.C_POINTER.withName("GetAllVarCustData"),
        wgl_h.C_POINTER.withName("GetAllImplTypeCustData")
    ).withName("ITypeInfo2Vtbl");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(ITypeInfo2 *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static class QueryInterface {

        QueryInterface() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(QueryInterface.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(QueryInterface.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout QueryInterface$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("QueryInterface"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(ITypeInfo2 *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout QueryInterface$layout() {
        return QueryInterface$LAYOUT;
    }

    private static final long QueryInterface$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(ITypeInfo2 *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static final long QueryInterface$offset() {
        return QueryInterface$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(ITypeInfo2 *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment QueryInterface(MemorySegment struct) {
        return struct.get(QueryInterface$LAYOUT, QueryInterface$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(ITypeInfo2 *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static void QueryInterface(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(QueryInterface$LAYOUT, QueryInterface$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ULONG (*AddRef)(ITypeInfo2 *) __attribute__((stdcall))
     * }
     */
    public static class AddRef {

        AddRef() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(AddRef.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddRef.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddRef$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddRef"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(ITypeInfo2 *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout AddRef$layout() {
        return AddRef$LAYOUT;
    }

    private static final long AddRef$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(ITypeInfo2 *) __attribute__((stdcall))
     * }
     */
    public static final long AddRef$offset() {
        return AddRef$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(ITypeInfo2 *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment AddRef(MemorySegment struct) {
        return struct.get(AddRef$LAYOUT, AddRef$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(ITypeInfo2 *) __attribute__((stdcall))
     * }
     */
    public static void AddRef(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddRef$LAYOUT, AddRef$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ULONG (*Release)(ITypeInfo2 *) __attribute__((stdcall))
     * }
     */
    public static class Release {

        Release() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(Release.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Release.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Release$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Release"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG (*Release)(ITypeInfo2 *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout Release$layout() {
        return Release$LAYOUT;
    }

    private static final long Release$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG (*Release)(ITypeInfo2 *) __attribute__((stdcall))
     * }
     */
    public static final long Release$offset() {
        return Release$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG (*Release)(ITypeInfo2 *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment Release(MemorySegment struct) {
        return struct.get(Release$LAYOUT, Release$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG (*Release)(ITypeInfo2 *) __attribute__((stdcall))
     * }
     */
    public static void Release(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Release$LAYOUT, Release$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetTypeAttr)(ITypeInfo2 *, TYPEATTR **) __attribute__((stdcall))
     * }
     */
    public static class GetTypeAttr {

        GetTypeAttr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetTypeAttr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTypeAttr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTypeAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTypeAttr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeAttr)(ITypeInfo2 *, TYPEATTR **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetTypeAttr$layout() {
        return GetTypeAttr$LAYOUT;
    }

    private static final long GetTypeAttr$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeAttr)(ITypeInfo2 *, TYPEATTR **) __attribute__((stdcall))
     * }
     */
    public static final long GetTypeAttr$offset() {
        return GetTypeAttr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeAttr)(ITypeInfo2 *, TYPEATTR **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetTypeAttr(MemorySegment struct) {
        return struct.get(GetTypeAttr$LAYOUT, GetTypeAttr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeAttr)(ITypeInfo2 *, TYPEATTR **) __attribute__((stdcall))
     * }
     */
    public static void GetTypeAttr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTypeAttr$LAYOUT, GetTypeAttr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetTypeComp)(ITypeInfo2 *, ITypeComp **) __attribute__((stdcall))
     * }
     */
    public static class GetTypeComp {

        GetTypeComp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetTypeComp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTypeComp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTypeComp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTypeComp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeComp)(ITypeInfo2 *, ITypeComp **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetTypeComp$layout() {
        return GetTypeComp$LAYOUT;
    }

    private static final long GetTypeComp$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeComp)(ITypeInfo2 *, ITypeComp **) __attribute__((stdcall))
     * }
     */
    public static final long GetTypeComp$offset() {
        return GetTypeComp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeComp)(ITypeInfo2 *, ITypeComp **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetTypeComp(MemorySegment struct) {
        return struct.get(GetTypeComp$LAYOUT, GetTypeComp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeComp)(ITypeInfo2 *, ITypeComp **) __attribute__((stdcall))
     * }
     */
    public static void GetTypeComp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTypeComp$LAYOUT, GetTypeComp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetFuncDesc)(ITypeInfo2 *, UINT, FUNCDESC **) __attribute__((stdcall))
     * }
     */
    public static class GetFuncDesc {

        GetFuncDesc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetFuncDesc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFuncDesc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFuncDesc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFuncDesc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncDesc)(ITypeInfo2 *, UINT, FUNCDESC **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetFuncDesc$layout() {
        return GetFuncDesc$LAYOUT;
    }

    private static final long GetFuncDesc$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncDesc)(ITypeInfo2 *, UINT, FUNCDESC **) __attribute__((stdcall))
     * }
     */
    public static final long GetFuncDesc$offset() {
        return GetFuncDesc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncDesc)(ITypeInfo2 *, UINT, FUNCDESC **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetFuncDesc(MemorySegment struct) {
        return struct.get(GetFuncDesc$LAYOUT, GetFuncDesc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncDesc)(ITypeInfo2 *, UINT, FUNCDESC **) __attribute__((stdcall))
     * }
     */
    public static void GetFuncDesc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFuncDesc$LAYOUT, GetFuncDesc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetVarDesc)(ITypeInfo2 *, UINT, VARDESC **) __attribute__((stdcall))
     * }
     */
    public static class GetVarDesc {

        GetVarDesc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetVarDesc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetVarDesc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetVarDesc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetVarDesc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarDesc)(ITypeInfo2 *, UINT, VARDESC **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetVarDesc$layout() {
        return GetVarDesc$LAYOUT;
    }

    private static final long GetVarDesc$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarDesc)(ITypeInfo2 *, UINT, VARDESC **) __attribute__((stdcall))
     * }
     */
    public static final long GetVarDesc$offset() {
        return GetVarDesc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarDesc)(ITypeInfo2 *, UINT, VARDESC **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetVarDesc(MemorySegment struct) {
        return struct.get(GetVarDesc$LAYOUT, GetVarDesc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarDesc)(ITypeInfo2 *, UINT, VARDESC **) __attribute__((stdcall))
     * }
     */
    public static void GetVarDesc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetVarDesc$LAYOUT, GetVarDesc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetNames)(ITypeInfo2 *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall))
     * }
     */
    public static class GetNames {

        GetNames() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetNames.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetNames.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetNames$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetNames"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetNames)(ITypeInfo2 *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetNames$layout() {
        return GetNames$LAYOUT;
    }

    private static final long GetNames$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetNames)(ITypeInfo2 *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall))
     * }
     */
    public static final long GetNames$offset() {
        return GetNames$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetNames)(ITypeInfo2 *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetNames(MemorySegment struct) {
        return struct.get(GetNames$LAYOUT, GetNames$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetNames)(ITypeInfo2 *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall))
     * }
     */
    public static void GetNames(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetNames$LAYOUT, GetNames$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeOfImplType)(ITypeInfo2 *, UINT, HREFTYPE *) __attribute__((stdcall))
     * }
     */
    public static class GetRefTypeOfImplType {

        GetRefTypeOfImplType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetRefTypeOfImplType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetRefTypeOfImplType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetRefTypeOfImplType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetRefTypeOfImplType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeOfImplType)(ITypeInfo2 *, UINT, HREFTYPE *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetRefTypeOfImplType$layout() {
        return GetRefTypeOfImplType$LAYOUT;
    }

    private static final long GetRefTypeOfImplType$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeOfImplType)(ITypeInfo2 *, UINT, HREFTYPE *) __attribute__((stdcall))
     * }
     */
    public static final long GetRefTypeOfImplType$offset() {
        return GetRefTypeOfImplType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeOfImplType)(ITypeInfo2 *, UINT, HREFTYPE *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetRefTypeOfImplType(MemorySegment struct) {
        return struct.get(GetRefTypeOfImplType$LAYOUT, GetRefTypeOfImplType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeOfImplType)(ITypeInfo2 *, UINT, HREFTYPE *) __attribute__((stdcall))
     * }
     */
    public static void GetRefTypeOfImplType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetRefTypeOfImplType$LAYOUT, GetRefTypeOfImplType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeFlags)(ITypeInfo2 *, UINT, INT *) __attribute__((stdcall))
     * }
     */
    public static class GetImplTypeFlags {

        GetImplTypeFlags() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetImplTypeFlags.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetImplTypeFlags.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetImplTypeFlags$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetImplTypeFlags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeFlags)(ITypeInfo2 *, UINT, INT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetImplTypeFlags$layout() {
        return GetImplTypeFlags$LAYOUT;
    }

    private static final long GetImplTypeFlags$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeFlags)(ITypeInfo2 *, UINT, INT *) __attribute__((stdcall))
     * }
     */
    public static final long GetImplTypeFlags$offset() {
        return GetImplTypeFlags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeFlags)(ITypeInfo2 *, UINT, INT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetImplTypeFlags(MemorySegment struct) {
        return struct.get(GetImplTypeFlags$LAYOUT, GetImplTypeFlags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeFlags)(ITypeInfo2 *, UINT, INT *) __attribute__((stdcall))
     * }
     */
    public static void GetImplTypeFlags(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetImplTypeFlags$LAYOUT, GetImplTypeFlags$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(ITypeInfo2 *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall))
     * }
     */
    public static class GetIDsOfNames {

        GetIDsOfNames() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetIDsOfNames.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetIDsOfNames.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetIDsOfNames$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetIDsOfNames"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(ITypeInfo2 *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetIDsOfNames$layout() {
        return GetIDsOfNames$LAYOUT;
    }

    private static final long GetIDsOfNames$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(ITypeInfo2 *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall))
     * }
     */
    public static final long GetIDsOfNames$offset() {
        return GetIDsOfNames$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(ITypeInfo2 *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetIDsOfNames(MemorySegment struct) {
        return struct.get(GetIDsOfNames$LAYOUT, GetIDsOfNames$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(ITypeInfo2 *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall))
     * }
     */
    public static void GetIDsOfNames(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetIDsOfNames$LAYOUT, GetIDsOfNames$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*Invoke)(ITypeInfo2 *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static class Invoke {

        Invoke() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, short _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(Invoke.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Invoke.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, short _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Invoke$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Invoke"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(ITypeInfo2 *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout Invoke$layout() {
        return Invoke$LAYOUT;
    }

    private static final long Invoke$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(ITypeInfo2 *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static final long Invoke$offset() {
        return Invoke$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(ITypeInfo2 *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment Invoke(MemorySegment struct) {
        return struct.get(Invoke$LAYOUT, Invoke$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(ITypeInfo2 *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static void Invoke(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Invoke$LAYOUT, Invoke$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation)(ITypeInfo2 *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetDocumentation {

        GetDocumentation() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetDocumentation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDocumentation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDocumentation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDocumentation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation)(ITypeInfo2 *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetDocumentation$layout() {
        return GetDocumentation$LAYOUT;
    }

    private static final long GetDocumentation$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation)(ITypeInfo2 *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetDocumentation$offset() {
        return GetDocumentation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation)(ITypeInfo2 *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetDocumentation(MemorySegment struct) {
        return struct.get(GetDocumentation$LAYOUT, GetDocumentation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation)(ITypeInfo2 *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetDocumentation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDocumentation$LAYOUT, GetDocumentation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetDllEntry)(ITypeInfo2 *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall))
     * }
     */
    public static class GetDllEntry {

        GetDllEntry() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetDllEntry.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDllEntry.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDllEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDllEntry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetDllEntry)(ITypeInfo2 *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetDllEntry$layout() {
        return GetDllEntry$LAYOUT;
    }

    private static final long GetDllEntry$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetDllEntry)(ITypeInfo2 *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall))
     * }
     */
    public static final long GetDllEntry$offset() {
        return GetDllEntry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDllEntry)(ITypeInfo2 *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetDllEntry(MemorySegment struct) {
        return struct.get(GetDllEntry$LAYOUT, GetDllEntry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDllEntry)(ITypeInfo2 *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall))
     * }
     */
    public static void GetDllEntry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDllEntry$LAYOUT, GetDllEntry$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeInfo)(ITypeInfo2 *, HREFTYPE, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static class GetRefTypeInfo {

        GetRefTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetRefTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetRefTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetRefTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetRefTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeInfo)(ITypeInfo2 *, HREFTYPE, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetRefTypeInfo$layout() {
        return GetRefTypeInfo$LAYOUT;
    }

    private static final long GetRefTypeInfo$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeInfo)(ITypeInfo2 *, HREFTYPE, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static final long GetRefTypeInfo$offset() {
        return GetRefTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeInfo)(ITypeInfo2 *, HREFTYPE, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetRefTypeInfo(MemorySegment struct) {
        return struct.get(GetRefTypeInfo$LAYOUT, GetRefTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeInfo)(ITypeInfo2 *, HREFTYPE, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static void GetRefTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetRefTypeInfo$LAYOUT, GetRefTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*AddressOfMember)(ITypeInfo2 *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall))
     * }
     */
    public static class AddressOfMember {

        AddressOfMember() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(AddressOfMember.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddressOfMember.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddressOfMember$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddressOfMember"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*AddressOfMember)(ITypeInfo2 *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout AddressOfMember$layout() {
        return AddressOfMember$LAYOUT;
    }

    private static final long AddressOfMember$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*AddressOfMember)(ITypeInfo2 *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall))
     * }
     */
    public static final long AddressOfMember$offset() {
        return AddressOfMember$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*AddressOfMember)(ITypeInfo2 *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment AddressOfMember(MemorySegment struct) {
        return struct.get(AddressOfMember$LAYOUT, AddressOfMember$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*AddressOfMember)(ITypeInfo2 *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall))
     * }
     */
    public static void AddressOfMember(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddressOfMember$LAYOUT, AddressOfMember$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*CreateInstance)(ITypeInfo2 *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall))
     * }
     */
    public static class CreateInstance {

        CreateInstance() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(CreateInstance.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateInstance.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateInstance$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateInstance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*CreateInstance)(ITypeInfo2 *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout CreateInstance$layout() {
        return CreateInstance$LAYOUT;
    }

    private static final long CreateInstance$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*CreateInstance)(ITypeInfo2 *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall))
     * }
     */
    public static final long CreateInstance$offset() {
        return CreateInstance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*CreateInstance)(ITypeInfo2 *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment CreateInstance(MemorySegment struct) {
        return struct.get(CreateInstance$LAYOUT, CreateInstance$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*CreateInstance)(ITypeInfo2 *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall))
     * }
     */
    public static void CreateInstance(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateInstance$LAYOUT, CreateInstance$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetMops)(ITypeInfo2 *, MEMBERID, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetMops {

        GetMops() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetMops.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMops.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMops$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMops"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetMops)(ITypeInfo2 *, MEMBERID, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetMops$layout() {
        return GetMops$LAYOUT;
    }

    private static final long GetMops$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetMops)(ITypeInfo2 *, MEMBERID, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetMops$offset() {
        return GetMops$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetMops)(ITypeInfo2 *, MEMBERID, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetMops(MemorySegment struct) {
        return struct.get(GetMops$LAYOUT, GetMops$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetMops)(ITypeInfo2 *, MEMBERID, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetMops(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMops$LAYOUT, GetMops$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetContainingTypeLib)(ITypeInfo2 *, ITypeLib **, UINT *) __attribute__((stdcall))
     * }
     */
    public static class GetContainingTypeLib {

        GetContainingTypeLib() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetContainingTypeLib.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetContainingTypeLib.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetContainingTypeLib$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetContainingTypeLib"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetContainingTypeLib)(ITypeInfo2 *, ITypeLib **, UINT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetContainingTypeLib$layout() {
        return GetContainingTypeLib$LAYOUT;
    }

    private static final long GetContainingTypeLib$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetContainingTypeLib)(ITypeInfo2 *, ITypeLib **, UINT *) __attribute__((stdcall))
     * }
     */
    public static final long GetContainingTypeLib$offset() {
        return GetContainingTypeLib$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetContainingTypeLib)(ITypeInfo2 *, ITypeLib **, UINT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetContainingTypeLib(MemorySegment struct) {
        return struct.get(GetContainingTypeLib$LAYOUT, GetContainingTypeLib$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetContainingTypeLib)(ITypeInfo2 *, ITypeLib **, UINT *) __attribute__((stdcall))
     * }
     */
    public static void GetContainingTypeLib(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetContainingTypeLib$LAYOUT, GetContainingTypeLib$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseTypeAttr)(ITypeInfo2 *, TYPEATTR *) __attribute__((stdcall))
     * }
     */
    public static class ReleaseTypeAttr {

        ReleaseTypeAttr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(ReleaseTypeAttr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseTypeAttr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseTypeAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseTypeAttr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeAttr)(ITypeInfo2 *, TYPEATTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout ReleaseTypeAttr$layout() {
        return ReleaseTypeAttr$LAYOUT;
    }

    private static final long ReleaseTypeAttr$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeAttr)(ITypeInfo2 *, TYPEATTR *) __attribute__((stdcall))
     * }
     */
    public static final long ReleaseTypeAttr$offset() {
        return ReleaseTypeAttr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeAttr)(ITypeInfo2 *, TYPEATTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment ReleaseTypeAttr(MemorySegment struct) {
        return struct.get(ReleaseTypeAttr$LAYOUT, ReleaseTypeAttr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeAttr)(ITypeInfo2 *, TYPEATTR *) __attribute__((stdcall))
     * }
     */
    public static void ReleaseTypeAttr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseTypeAttr$LAYOUT, ReleaseTypeAttr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseFuncDesc)(ITypeInfo2 *, FUNCDESC *) __attribute__((stdcall))
     * }
     */
    public static class ReleaseFuncDesc {

        ReleaseFuncDesc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(ReleaseFuncDesc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseFuncDesc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseFuncDesc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseFuncDesc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseFuncDesc)(ITypeInfo2 *, FUNCDESC *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout ReleaseFuncDesc$layout() {
        return ReleaseFuncDesc$LAYOUT;
    }

    private static final long ReleaseFuncDesc$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseFuncDesc)(ITypeInfo2 *, FUNCDESC *) __attribute__((stdcall))
     * }
     */
    public static final long ReleaseFuncDesc$offset() {
        return ReleaseFuncDesc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseFuncDesc)(ITypeInfo2 *, FUNCDESC *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment ReleaseFuncDesc(MemorySegment struct) {
        return struct.get(ReleaseFuncDesc$LAYOUT, ReleaseFuncDesc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseFuncDesc)(ITypeInfo2 *, FUNCDESC *) __attribute__((stdcall))
     * }
     */
    public static void ReleaseFuncDesc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseFuncDesc$LAYOUT, ReleaseFuncDesc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseVarDesc)(ITypeInfo2 *, VARDESC *) __attribute__((stdcall))
     * }
     */
    public static class ReleaseVarDesc {

        ReleaseVarDesc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(ReleaseVarDesc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseVarDesc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseVarDesc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseVarDesc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseVarDesc)(ITypeInfo2 *, VARDESC *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout ReleaseVarDesc$layout() {
        return ReleaseVarDesc$LAYOUT;
    }

    private static final long ReleaseVarDesc$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseVarDesc)(ITypeInfo2 *, VARDESC *) __attribute__((stdcall))
     * }
     */
    public static final long ReleaseVarDesc$offset() {
        return ReleaseVarDesc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseVarDesc)(ITypeInfo2 *, VARDESC *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment ReleaseVarDesc(MemorySegment struct) {
        return struct.get(ReleaseVarDesc$LAYOUT, ReleaseVarDesc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseVarDesc)(ITypeInfo2 *, VARDESC *) __attribute__((stdcall))
     * }
     */
    public static void ReleaseVarDesc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseVarDesc$LAYOUT, ReleaseVarDesc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetTypeKind)(ITypeInfo2 *, TYPEKIND *) __attribute__((stdcall))
     * }
     */
    public static class GetTypeKind {

        GetTypeKind() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetTypeKind.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTypeKind.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTypeKind$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTypeKind"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeKind)(ITypeInfo2 *, TYPEKIND *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetTypeKind$layout() {
        return GetTypeKind$LAYOUT;
    }

    private static final long GetTypeKind$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeKind)(ITypeInfo2 *, TYPEKIND *) __attribute__((stdcall))
     * }
     */
    public static final long GetTypeKind$offset() {
        return GetTypeKind$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeKind)(ITypeInfo2 *, TYPEKIND *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetTypeKind(MemorySegment struct) {
        return struct.get(GetTypeKind$LAYOUT, GetTypeKind$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeKind)(ITypeInfo2 *, TYPEKIND *) __attribute__((stdcall))
     * }
     */
    public static void GetTypeKind(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTypeKind$LAYOUT, GetTypeKind$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetTypeFlags)(ITypeInfo2 *, ULONG *) __attribute__((stdcall))
     * }
     */
    public static class GetTypeFlags {

        GetTypeFlags() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetTypeFlags.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTypeFlags.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTypeFlags$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTypeFlags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeFlags)(ITypeInfo2 *, ULONG *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetTypeFlags$layout() {
        return GetTypeFlags$LAYOUT;
    }

    private static final long GetTypeFlags$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeFlags)(ITypeInfo2 *, ULONG *) __attribute__((stdcall))
     * }
     */
    public static final long GetTypeFlags$offset() {
        return GetTypeFlags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeFlags)(ITypeInfo2 *, ULONG *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetTypeFlags(MemorySegment struct) {
        return struct.get(GetTypeFlags$LAYOUT, GetTypeFlags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeFlags)(ITypeInfo2 *, ULONG *) __attribute__((stdcall))
     * }
     */
    public static void GetTypeFlags(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTypeFlags$LAYOUT, GetTypeFlags$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetFuncIndexOfMemId)(ITypeInfo2 *, MEMBERID, INVOKEKIND, UINT *) __attribute__((stdcall))
     * }
     */
    public static class GetFuncIndexOfMemId {

        GetFuncIndexOfMemId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetFuncIndexOfMemId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFuncIndexOfMemId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFuncIndexOfMemId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFuncIndexOfMemId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncIndexOfMemId)(ITypeInfo2 *, MEMBERID, INVOKEKIND, UINT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetFuncIndexOfMemId$layout() {
        return GetFuncIndexOfMemId$LAYOUT;
    }

    private static final long GetFuncIndexOfMemId$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncIndexOfMemId)(ITypeInfo2 *, MEMBERID, INVOKEKIND, UINT *) __attribute__((stdcall))
     * }
     */
    public static final long GetFuncIndexOfMemId$offset() {
        return GetFuncIndexOfMemId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncIndexOfMemId)(ITypeInfo2 *, MEMBERID, INVOKEKIND, UINT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetFuncIndexOfMemId(MemorySegment struct) {
        return struct.get(GetFuncIndexOfMemId$LAYOUT, GetFuncIndexOfMemId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncIndexOfMemId)(ITypeInfo2 *, MEMBERID, INVOKEKIND, UINT *) __attribute__((stdcall))
     * }
     */
    public static void GetFuncIndexOfMemId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFuncIndexOfMemId$LAYOUT, GetFuncIndexOfMemId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetVarIndexOfMemId)(ITypeInfo2 *, MEMBERID, UINT *) __attribute__((stdcall))
     * }
     */
    public static class GetVarIndexOfMemId {

        GetVarIndexOfMemId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetVarIndexOfMemId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetVarIndexOfMemId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetVarIndexOfMemId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetVarIndexOfMemId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarIndexOfMemId)(ITypeInfo2 *, MEMBERID, UINT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetVarIndexOfMemId$layout() {
        return GetVarIndexOfMemId$LAYOUT;
    }

    private static final long GetVarIndexOfMemId$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarIndexOfMemId)(ITypeInfo2 *, MEMBERID, UINT *) __attribute__((stdcall))
     * }
     */
    public static final long GetVarIndexOfMemId$offset() {
        return GetVarIndexOfMemId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarIndexOfMemId)(ITypeInfo2 *, MEMBERID, UINT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetVarIndexOfMemId(MemorySegment struct) {
        return struct.get(GetVarIndexOfMemId$LAYOUT, GetVarIndexOfMemId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarIndexOfMemId)(ITypeInfo2 *, MEMBERID, UINT *) __attribute__((stdcall))
     * }
     */
    public static void GetVarIndexOfMemId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetVarIndexOfMemId$LAYOUT, GetVarIndexOfMemId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetCustData)(ITypeInfo2 *, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static class GetCustData {

        GetCustData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetCustData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCustData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCustData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCustData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetCustData)(ITypeInfo2 *, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetCustData$layout() {
        return GetCustData$LAYOUT;
    }

    private static final long GetCustData$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetCustData)(ITypeInfo2 *, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final long GetCustData$offset() {
        return GetCustData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetCustData)(ITypeInfo2 *, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetCustData(MemorySegment struct) {
        return struct.get(GetCustData$LAYOUT, GetCustData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetCustData)(ITypeInfo2 *, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static void GetCustData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCustData$LAYOUT, GetCustData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetFuncCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static class GetFuncCustData {

        GetFuncCustData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetFuncCustData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFuncCustData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFuncCustData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFuncCustData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetFuncCustData$layout() {
        return GetFuncCustData$LAYOUT;
    }

    private static final long GetFuncCustData$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final long GetFuncCustData$offset() {
        return GetFuncCustData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetFuncCustData(MemorySegment struct) {
        return struct.get(GetFuncCustData$LAYOUT, GetFuncCustData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static void GetFuncCustData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFuncCustData$LAYOUT, GetFuncCustData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetParamCustData)(ITypeInfo2 *, UINT, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static class GetParamCustData {

        GetParamCustData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetParamCustData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetParamCustData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetParamCustData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetParamCustData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetParamCustData)(ITypeInfo2 *, UINT, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetParamCustData$layout() {
        return GetParamCustData$LAYOUT;
    }

    private static final long GetParamCustData$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetParamCustData)(ITypeInfo2 *, UINT, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final long GetParamCustData$offset() {
        return GetParamCustData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetParamCustData)(ITypeInfo2 *, UINT, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetParamCustData(MemorySegment struct) {
        return struct.get(GetParamCustData$LAYOUT, GetParamCustData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetParamCustData)(ITypeInfo2 *, UINT, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static void GetParamCustData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetParamCustData$LAYOUT, GetParamCustData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetVarCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static class GetVarCustData {

        GetVarCustData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetVarCustData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetVarCustData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetVarCustData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetVarCustData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetVarCustData$layout() {
        return GetVarCustData$LAYOUT;
    }

    private static final long GetVarCustData$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final long GetVarCustData$offset() {
        return GetVarCustData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetVarCustData(MemorySegment struct) {
        return struct.get(GetVarCustData$LAYOUT, GetVarCustData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static void GetVarCustData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetVarCustData$LAYOUT, GetVarCustData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static class GetImplTypeCustData {

        GetImplTypeCustData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetImplTypeCustData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetImplTypeCustData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetImplTypeCustData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetImplTypeCustData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetImplTypeCustData$layout() {
        return GetImplTypeCustData$LAYOUT;
    }

    private static final long GetImplTypeCustData$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final long GetImplTypeCustData$offset() {
        return GetImplTypeCustData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetImplTypeCustData(MemorySegment struct) {
        return struct.get(GetImplTypeCustData$LAYOUT, GetImplTypeCustData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeCustData)(ITypeInfo2 *, UINT, const GUID *const, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static void GetImplTypeCustData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetImplTypeCustData$LAYOUT, GetImplTypeCustData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation2)(ITypeInfo2 *, MEMBERID, LCID, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetDocumentation2 {

        GetDocumentation2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetDocumentation2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDocumentation2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDocumentation2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDocumentation2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation2)(ITypeInfo2 *, MEMBERID, LCID, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetDocumentation2$layout() {
        return GetDocumentation2$LAYOUT;
    }

    private static final long GetDocumentation2$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation2)(ITypeInfo2 *, MEMBERID, LCID, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetDocumentation2$offset() {
        return GetDocumentation2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation2)(ITypeInfo2 *, MEMBERID, LCID, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetDocumentation2(MemorySegment struct) {
        return struct.get(GetDocumentation2$LAYOUT, GetDocumentation2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation2)(ITypeInfo2 *, MEMBERID, LCID, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetDocumentation2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDocumentation2$LAYOUT, GetDocumentation2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetAllCustData)(ITypeInfo2 *, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static class GetAllCustData {

        GetAllCustData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetAllCustData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAllCustData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAllCustData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAllCustData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllCustData)(ITypeInfo2 *, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetAllCustData$layout() {
        return GetAllCustData$LAYOUT;
    }

    private static final long GetAllCustData$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllCustData)(ITypeInfo2 *, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static final long GetAllCustData$offset() {
        return GetAllCustData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllCustData)(ITypeInfo2 *, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetAllCustData(MemorySegment struct) {
        return struct.get(GetAllCustData$LAYOUT, GetAllCustData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllCustData)(ITypeInfo2 *, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static void GetAllCustData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAllCustData$LAYOUT, GetAllCustData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetAllFuncCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static class GetAllFuncCustData {

        GetAllFuncCustData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetAllFuncCustData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAllFuncCustData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAllFuncCustData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAllFuncCustData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllFuncCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetAllFuncCustData$layout() {
        return GetAllFuncCustData$LAYOUT;
    }

    private static final long GetAllFuncCustData$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllFuncCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static final long GetAllFuncCustData$offset() {
        return GetAllFuncCustData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllFuncCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetAllFuncCustData(MemorySegment struct) {
        return struct.get(GetAllFuncCustData$LAYOUT, GetAllFuncCustData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllFuncCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static void GetAllFuncCustData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAllFuncCustData$LAYOUT, GetAllFuncCustData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetAllParamCustData)(ITypeInfo2 *, UINT, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static class GetAllParamCustData {

        GetAllParamCustData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetAllParamCustData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAllParamCustData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAllParamCustData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAllParamCustData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllParamCustData)(ITypeInfo2 *, UINT, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetAllParamCustData$layout() {
        return GetAllParamCustData$LAYOUT;
    }

    private static final long GetAllParamCustData$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllParamCustData)(ITypeInfo2 *, UINT, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static final long GetAllParamCustData$offset() {
        return GetAllParamCustData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllParamCustData)(ITypeInfo2 *, UINT, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetAllParamCustData(MemorySegment struct) {
        return struct.get(GetAllParamCustData$LAYOUT, GetAllParamCustData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllParamCustData)(ITypeInfo2 *, UINT, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static void GetAllParamCustData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAllParamCustData$LAYOUT, GetAllParamCustData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetAllVarCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static class GetAllVarCustData {

        GetAllVarCustData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetAllVarCustData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAllVarCustData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAllVarCustData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAllVarCustData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllVarCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetAllVarCustData$layout() {
        return GetAllVarCustData$LAYOUT;
    }

    private static final long GetAllVarCustData$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllVarCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static final long GetAllVarCustData$offset() {
        return GetAllVarCustData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllVarCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetAllVarCustData(MemorySegment struct) {
        return struct.get(GetAllVarCustData$LAYOUT, GetAllVarCustData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllVarCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static void GetAllVarCustData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAllVarCustData$LAYOUT, GetAllVarCustData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetAllImplTypeCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static class GetAllImplTypeCustData {

        GetAllImplTypeCustData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetAllImplTypeCustData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAllImplTypeCustData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAllImplTypeCustData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAllImplTypeCustData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllImplTypeCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetAllImplTypeCustData$layout() {
        return GetAllImplTypeCustData$LAYOUT;
    }

    private static final long GetAllImplTypeCustData$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllImplTypeCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static final long GetAllImplTypeCustData$offset() {
        return GetAllImplTypeCustData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllImplTypeCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetAllImplTypeCustData(MemorySegment struct) {
        return struct.get(GetAllImplTypeCustData$LAYOUT, GetAllImplTypeCustData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAllImplTypeCustData)(ITypeInfo2 *, UINT, CUSTDATA *) __attribute__((stdcall))
     * }
     */
    public static void GetAllImplTypeCustData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAllImplTypeCustData$LAYOUT, GetAllImplTypeCustData$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

