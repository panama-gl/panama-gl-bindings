// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _DEVICE_MEDIA_INFO {
 *     union {
 *         struct {
 *             LARGE_INTEGER Cylinders;
 *             STORAGE_MEDIA_TYPE MediaType;
 *             DWORD TracksPerCylinder;
 *             DWORD SectorsPerTrack;
 *             DWORD BytesPerSector;
 *             DWORD NumberMediaSides;
 *             DWORD MediaCharacteristics;
 *         } DiskInfo;
 *         struct {
 *             LARGE_INTEGER Cylinders;
 *             STORAGE_MEDIA_TYPE MediaType;
 *             DWORD TracksPerCylinder;
 *             DWORD SectorsPerTrack;
 *             DWORD BytesPerSector;
 *             DWORD NumberMediaSides;
 *             DWORD MediaCharacteristics;
 *         } RemovableDiskInfo;
 *         struct {
 *             STORAGE_MEDIA_TYPE MediaType;
 *             DWORD MediaCharacteristics;
 *             DWORD CurrentBlockSize;
 *             STORAGE_BUS_TYPE BusType;
 *             union {
 *                 struct {
 *                     BYTE MediumType;
 *                     BYTE DensityCode;
 *                 } ScsiInformation;
 *             } BusSpecificData;
 *         } TapeInfo;
 *     } DeviceSpecific;
 * }
 * }
 */
public class _DEVICE_MEDIA_INFO {

    _DEVICE_MEDIA_INFO() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _DEVICE_MEDIA_INFO.DeviceSpecific.layout().withName("DeviceSpecific")
    ).withName("_DEVICE_MEDIA_INFO");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * union {
     *     struct {
     *         LARGE_INTEGER Cylinders;
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD TracksPerCylinder;
     *         DWORD SectorsPerTrack;
     *         DWORD BytesPerSector;
     *         DWORD NumberMediaSides;
     *         DWORD MediaCharacteristics;
     *     } DiskInfo;
     *     struct {
     *         LARGE_INTEGER Cylinders;
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD TracksPerCylinder;
     *         DWORD SectorsPerTrack;
     *         DWORD BytesPerSector;
     *         DWORD NumberMediaSides;
     *         DWORD MediaCharacteristics;
     *     } RemovableDiskInfo;
     *     struct {
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD MediaCharacteristics;
     *         DWORD CurrentBlockSize;
     *         STORAGE_BUS_TYPE BusType;
     *         union {
     *             struct {
     *                 BYTE MediumType;
     *                 BYTE DensityCode;
     *             } ScsiInformation;
     *         } BusSpecificData;
     *     } TapeInfo;
     * }
     * }
     */
    public static class DeviceSpecific {

        DeviceSpecific() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
            _DEVICE_MEDIA_INFO.DeviceSpecific.DiskInfo.layout().withName("DiskInfo"),
            _DEVICE_MEDIA_INFO.DeviceSpecific.RemovableDiskInfo.layout().withName("RemovableDiskInfo"),
            _DEVICE_MEDIA_INFO.DeviceSpecific.TapeInfo.layout().withName("TapeInfo")
        ).withName("$anon$948:5");

        /**
         * The layout of this union
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     LARGE_INTEGER Cylinders;
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD TracksPerCylinder;
         *     DWORD SectorsPerTrack;
         *     DWORD BytesPerSector;
         *     DWORD NumberMediaSides;
         *     DWORD MediaCharacteristics;
         * }
         * }
         */
        public static class DiskInfo {

            DiskInfo() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                _LARGE_INTEGER.layout().withName("Cylinders"),
                wgl_h.C_INT.withName("MediaType"),
                wgl_h.C_LONG.withName("TracksPerCylinder"),
                wgl_h.C_LONG.withName("SectorsPerTrack"),
                wgl_h.C_LONG.withName("BytesPerSector"),
                wgl_h.C_LONG.withName("NumberMediaSides"),
                wgl_h.C_LONG.withName("MediaCharacteristics")
            ).withName("$anon$949:9");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final GroupLayout Cylinders$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Cylinders"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * LARGE_INTEGER Cylinders
             * }
             */
            public static final GroupLayout Cylinders$layout() {
                return Cylinders$LAYOUT;
            }

            private static final long Cylinders$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * LARGE_INTEGER Cylinders
             * }
             */
            public static final long Cylinders$offset() {
                return Cylinders$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * LARGE_INTEGER Cylinders
             * }
             */
            public static MemorySegment Cylinders(MemorySegment struct) {
                return struct.asSlice(Cylinders$OFFSET, Cylinders$LAYOUT.byteSize());
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * LARGE_INTEGER Cylinders
             * }
             */
            public static void Cylinders(MemorySegment struct, MemorySegment fieldValue) {
                MemorySegment.copy(fieldValue, 0L, struct, Cylinders$OFFSET, Cylinders$LAYOUT.byteSize());
            }

            private static final OfInt MediaType$LAYOUT = (OfInt)$LAYOUT.select(groupElement("MediaType"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static final OfInt MediaType$layout() {
                return MediaType$LAYOUT;
            }

            private static final long MediaType$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static final long MediaType$offset() {
                return MediaType$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static int MediaType(MemorySegment struct) {
                return struct.get(MediaType$LAYOUT, MediaType$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static void MediaType(MemorySegment struct, int fieldValue) {
                struct.set(MediaType$LAYOUT, MediaType$OFFSET, fieldValue);
            }

            private static final OfInt TracksPerCylinder$LAYOUT = (OfInt)$LAYOUT.select(groupElement("TracksPerCylinder"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD TracksPerCylinder
             * }
             */
            public static final OfInt TracksPerCylinder$layout() {
                return TracksPerCylinder$LAYOUT;
            }

            private static final long TracksPerCylinder$OFFSET = 12;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD TracksPerCylinder
             * }
             */
            public static final long TracksPerCylinder$offset() {
                return TracksPerCylinder$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD TracksPerCylinder
             * }
             */
            public static int TracksPerCylinder(MemorySegment struct) {
                return struct.get(TracksPerCylinder$LAYOUT, TracksPerCylinder$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD TracksPerCylinder
             * }
             */
            public static void TracksPerCylinder(MemorySegment struct, int fieldValue) {
                struct.set(TracksPerCylinder$LAYOUT, TracksPerCylinder$OFFSET, fieldValue);
            }

            private static final OfInt SectorsPerTrack$LAYOUT = (OfInt)$LAYOUT.select(groupElement("SectorsPerTrack"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD SectorsPerTrack
             * }
             */
            public static final OfInt SectorsPerTrack$layout() {
                return SectorsPerTrack$LAYOUT;
            }

            private static final long SectorsPerTrack$OFFSET = 16;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD SectorsPerTrack
             * }
             */
            public static final long SectorsPerTrack$offset() {
                return SectorsPerTrack$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD SectorsPerTrack
             * }
             */
            public static int SectorsPerTrack(MemorySegment struct) {
                return struct.get(SectorsPerTrack$LAYOUT, SectorsPerTrack$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD SectorsPerTrack
             * }
             */
            public static void SectorsPerTrack(MemorySegment struct, int fieldValue) {
                struct.set(SectorsPerTrack$LAYOUT, SectorsPerTrack$OFFSET, fieldValue);
            }

            private static final OfInt BytesPerSector$LAYOUT = (OfInt)$LAYOUT.select(groupElement("BytesPerSector"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD BytesPerSector
             * }
             */
            public static final OfInt BytesPerSector$layout() {
                return BytesPerSector$LAYOUT;
            }

            private static final long BytesPerSector$OFFSET = 20;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD BytesPerSector
             * }
             */
            public static final long BytesPerSector$offset() {
                return BytesPerSector$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD BytesPerSector
             * }
             */
            public static int BytesPerSector(MemorySegment struct) {
                return struct.get(BytesPerSector$LAYOUT, BytesPerSector$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD BytesPerSector
             * }
             */
            public static void BytesPerSector(MemorySegment struct, int fieldValue) {
                struct.set(BytesPerSector$LAYOUT, BytesPerSector$OFFSET, fieldValue);
            }

            private static final OfInt NumberMediaSides$LAYOUT = (OfInt)$LAYOUT.select(groupElement("NumberMediaSides"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD NumberMediaSides
             * }
             */
            public static final OfInt NumberMediaSides$layout() {
                return NumberMediaSides$LAYOUT;
            }

            private static final long NumberMediaSides$OFFSET = 24;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD NumberMediaSides
             * }
             */
            public static final long NumberMediaSides$offset() {
                return NumberMediaSides$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD NumberMediaSides
             * }
             */
            public static int NumberMediaSides(MemorySegment struct) {
                return struct.get(NumberMediaSides$LAYOUT, NumberMediaSides$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD NumberMediaSides
             * }
             */
            public static void NumberMediaSides(MemorySegment struct, int fieldValue) {
                struct.set(NumberMediaSides$LAYOUT, NumberMediaSides$OFFSET, fieldValue);
            }

            private static final OfInt MediaCharacteristics$LAYOUT = (OfInt)$LAYOUT.select(groupElement("MediaCharacteristics"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static final OfInt MediaCharacteristics$layout() {
                return MediaCharacteristics$LAYOUT;
            }

            private static final long MediaCharacteristics$OFFSET = 28;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static final long MediaCharacteristics$offset() {
                return MediaCharacteristics$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static int MediaCharacteristics(MemorySegment struct) {
                return struct.get(MediaCharacteristics$LAYOUT, MediaCharacteristics$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static void MediaCharacteristics(MemorySegment struct, int fieldValue) {
                struct.set(MediaCharacteristics$LAYOUT, MediaCharacteristics$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout DiskInfo$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("DiskInfo"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     LARGE_INTEGER Cylinders;
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD TracksPerCylinder;
         *     DWORD SectorsPerTrack;
         *     DWORD BytesPerSector;
         *     DWORD NumberMediaSides;
         *     DWORD MediaCharacteristics;
         * } DiskInfo
         * }
         */
        public static final GroupLayout DiskInfo$layout() {
            return DiskInfo$LAYOUT;
        }

        private static final long DiskInfo$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     LARGE_INTEGER Cylinders;
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD TracksPerCylinder;
         *     DWORD SectorsPerTrack;
         *     DWORD BytesPerSector;
         *     DWORD NumberMediaSides;
         *     DWORD MediaCharacteristics;
         * } DiskInfo
         * }
         */
        public static final long DiskInfo$offset() {
            return DiskInfo$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     LARGE_INTEGER Cylinders;
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD TracksPerCylinder;
         *     DWORD SectorsPerTrack;
         *     DWORD BytesPerSector;
         *     DWORD NumberMediaSides;
         *     DWORD MediaCharacteristics;
         * } DiskInfo
         * }
         */
        public static MemorySegment DiskInfo(MemorySegment union) {
            return union.asSlice(DiskInfo$OFFSET, DiskInfo$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     LARGE_INTEGER Cylinders;
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD TracksPerCylinder;
         *     DWORD SectorsPerTrack;
         *     DWORD BytesPerSector;
         *     DWORD NumberMediaSides;
         *     DWORD MediaCharacteristics;
         * } DiskInfo
         * }
         */
        public static void DiskInfo(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, DiskInfo$OFFSET, DiskInfo$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     LARGE_INTEGER Cylinders;
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD TracksPerCylinder;
         *     DWORD SectorsPerTrack;
         *     DWORD BytesPerSector;
         *     DWORD NumberMediaSides;
         *     DWORD MediaCharacteristics;
         * }
         * }
         */
        public static class RemovableDiskInfo {

            RemovableDiskInfo() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                _LARGE_INTEGER.layout().withName("Cylinders"),
                wgl_h.C_INT.withName("MediaType"),
                wgl_h.C_LONG.withName("TracksPerCylinder"),
                wgl_h.C_LONG.withName("SectorsPerTrack"),
                wgl_h.C_LONG.withName("BytesPerSector"),
                wgl_h.C_LONG.withName("NumberMediaSides"),
                wgl_h.C_LONG.withName("MediaCharacteristics")
            ).withName("$anon$959:9");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final GroupLayout Cylinders$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Cylinders"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * LARGE_INTEGER Cylinders
             * }
             */
            public static final GroupLayout Cylinders$layout() {
                return Cylinders$LAYOUT;
            }

            private static final long Cylinders$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * LARGE_INTEGER Cylinders
             * }
             */
            public static final long Cylinders$offset() {
                return Cylinders$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * LARGE_INTEGER Cylinders
             * }
             */
            public static MemorySegment Cylinders(MemorySegment struct) {
                return struct.asSlice(Cylinders$OFFSET, Cylinders$LAYOUT.byteSize());
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * LARGE_INTEGER Cylinders
             * }
             */
            public static void Cylinders(MemorySegment struct, MemorySegment fieldValue) {
                MemorySegment.copy(fieldValue, 0L, struct, Cylinders$OFFSET, Cylinders$LAYOUT.byteSize());
            }

            private static final OfInt MediaType$LAYOUT = (OfInt)$LAYOUT.select(groupElement("MediaType"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static final OfInt MediaType$layout() {
                return MediaType$LAYOUT;
            }

            private static final long MediaType$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static final long MediaType$offset() {
                return MediaType$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static int MediaType(MemorySegment struct) {
                return struct.get(MediaType$LAYOUT, MediaType$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static void MediaType(MemorySegment struct, int fieldValue) {
                struct.set(MediaType$LAYOUT, MediaType$OFFSET, fieldValue);
            }

            private static final OfInt TracksPerCylinder$LAYOUT = (OfInt)$LAYOUT.select(groupElement("TracksPerCylinder"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD TracksPerCylinder
             * }
             */
            public static final OfInt TracksPerCylinder$layout() {
                return TracksPerCylinder$LAYOUT;
            }

            private static final long TracksPerCylinder$OFFSET = 12;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD TracksPerCylinder
             * }
             */
            public static final long TracksPerCylinder$offset() {
                return TracksPerCylinder$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD TracksPerCylinder
             * }
             */
            public static int TracksPerCylinder(MemorySegment struct) {
                return struct.get(TracksPerCylinder$LAYOUT, TracksPerCylinder$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD TracksPerCylinder
             * }
             */
            public static void TracksPerCylinder(MemorySegment struct, int fieldValue) {
                struct.set(TracksPerCylinder$LAYOUT, TracksPerCylinder$OFFSET, fieldValue);
            }

            private static final OfInt SectorsPerTrack$LAYOUT = (OfInt)$LAYOUT.select(groupElement("SectorsPerTrack"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD SectorsPerTrack
             * }
             */
            public static final OfInt SectorsPerTrack$layout() {
                return SectorsPerTrack$LAYOUT;
            }

            private static final long SectorsPerTrack$OFFSET = 16;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD SectorsPerTrack
             * }
             */
            public static final long SectorsPerTrack$offset() {
                return SectorsPerTrack$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD SectorsPerTrack
             * }
             */
            public static int SectorsPerTrack(MemorySegment struct) {
                return struct.get(SectorsPerTrack$LAYOUT, SectorsPerTrack$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD SectorsPerTrack
             * }
             */
            public static void SectorsPerTrack(MemorySegment struct, int fieldValue) {
                struct.set(SectorsPerTrack$LAYOUT, SectorsPerTrack$OFFSET, fieldValue);
            }

            private static final OfInt BytesPerSector$LAYOUT = (OfInt)$LAYOUT.select(groupElement("BytesPerSector"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD BytesPerSector
             * }
             */
            public static final OfInt BytesPerSector$layout() {
                return BytesPerSector$LAYOUT;
            }

            private static final long BytesPerSector$OFFSET = 20;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD BytesPerSector
             * }
             */
            public static final long BytesPerSector$offset() {
                return BytesPerSector$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD BytesPerSector
             * }
             */
            public static int BytesPerSector(MemorySegment struct) {
                return struct.get(BytesPerSector$LAYOUT, BytesPerSector$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD BytesPerSector
             * }
             */
            public static void BytesPerSector(MemorySegment struct, int fieldValue) {
                struct.set(BytesPerSector$LAYOUT, BytesPerSector$OFFSET, fieldValue);
            }

            private static final OfInt NumberMediaSides$LAYOUT = (OfInt)$LAYOUT.select(groupElement("NumberMediaSides"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD NumberMediaSides
             * }
             */
            public static final OfInt NumberMediaSides$layout() {
                return NumberMediaSides$LAYOUT;
            }

            private static final long NumberMediaSides$OFFSET = 24;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD NumberMediaSides
             * }
             */
            public static final long NumberMediaSides$offset() {
                return NumberMediaSides$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD NumberMediaSides
             * }
             */
            public static int NumberMediaSides(MemorySegment struct) {
                return struct.get(NumberMediaSides$LAYOUT, NumberMediaSides$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD NumberMediaSides
             * }
             */
            public static void NumberMediaSides(MemorySegment struct, int fieldValue) {
                struct.set(NumberMediaSides$LAYOUT, NumberMediaSides$OFFSET, fieldValue);
            }

            private static final OfInt MediaCharacteristics$LAYOUT = (OfInt)$LAYOUT.select(groupElement("MediaCharacteristics"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static final OfInt MediaCharacteristics$layout() {
                return MediaCharacteristics$LAYOUT;
            }

            private static final long MediaCharacteristics$OFFSET = 28;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static final long MediaCharacteristics$offset() {
                return MediaCharacteristics$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static int MediaCharacteristics(MemorySegment struct) {
                return struct.get(MediaCharacteristics$LAYOUT, MediaCharacteristics$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static void MediaCharacteristics(MemorySegment struct, int fieldValue) {
                struct.set(MediaCharacteristics$LAYOUT, MediaCharacteristics$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout RemovableDiskInfo$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("RemovableDiskInfo"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     LARGE_INTEGER Cylinders;
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD TracksPerCylinder;
         *     DWORD SectorsPerTrack;
         *     DWORD BytesPerSector;
         *     DWORD NumberMediaSides;
         *     DWORD MediaCharacteristics;
         * } RemovableDiskInfo
         * }
         */
        public static final GroupLayout RemovableDiskInfo$layout() {
            return RemovableDiskInfo$LAYOUT;
        }

        private static final long RemovableDiskInfo$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     LARGE_INTEGER Cylinders;
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD TracksPerCylinder;
         *     DWORD SectorsPerTrack;
         *     DWORD BytesPerSector;
         *     DWORD NumberMediaSides;
         *     DWORD MediaCharacteristics;
         * } RemovableDiskInfo
         * }
         */
        public static final long RemovableDiskInfo$offset() {
            return RemovableDiskInfo$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     LARGE_INTEGER Cylinders;
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD TracksPerCylinder;
         *     DWORD SectorsPerTrack;
         *     DWORD BytesPerSector;
         *     DWORD NumberMediaSides;
         *     DWORD MediaCharacteristics;
         * } RemovableDiskInfo
         * }
         */
        public static MemorySegment RemovableDiskInfo(MemorySegment union) {
            return union.asSlice(RemovableDiskInfo$OFFSET, RemovableDiskInfo$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     LARGE_INTEGER Cylinders;
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD TracksPerCylinder;
         *     DWORD SectorsPerTrack;
         *     DWORD BytesPerSector;
         *     DWORD NumberMediaSides;
         *     DWORD MediaCharacteristics;
         * } RemovableDiskInfo
         * }
         */
        public static void RemovableDiskInfo(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, RemovableDiskInfo$OFFSET, RemovableDiskInfo$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD MediaCharacteristics;
         *     DWORD CurrentBlockSize;
         *     STORAGE_BUS_TYPE BusType;
         *     union {
         *         struct {
         *             BYTE MediumType;
         *             BYTE DensityCode;
         *         } ScsiInformation;
         *     } BusSpecificData;
         * }
         * }
         */
        public static class TapeInfo {

            TapeInfo() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                wgl_h.C_INT.withName("MediaType"),
                wgl_h.C_LONG.withName("MediaCharacteristics"),
                wgl_h.C_LONG.withName("CurrentBlockSize"),
                wgl_h.C_INT.withName("BusType"),
                _DEVICE_MEDIA_INFO.DeviceSpecific.TapeInfo.BusSpecificData.layout().withName("BusSpecificData"),
                MemoryLayout.paddingLayout(2)
            ).withName("$anon$969:9");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfInt MediaType$LAYOUT = (OfInt)$LAYOUT.select(groupElement("MediaType"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static final OfInt MediaType$layout() {
                return MediaType$LAYOUT;
            }

            private static final long MediaType$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static final long MediaType$offset() {
                return MediaType$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static int MediaType(MemorySegment struct) {
                return struct.get(MediaType$LAYOUT, MediaType$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * STORAGE_MEDIA_TYPE MediaType
             * }
             */
            public static void MediaType(MemorySegment struct, int fieldValue) {
                struct.set(MediaType$LAYOUT, MediaType$OFFSET, fieldValue);
            }

            private static final OfInt MediaCharacteristics$LAYOUT = (OfInt)$LAYOUT.select(groupElement("MediaCharacteristics"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static final OfInt MediaCharacteristics$layout() {
                return MediaCharacteristics$LAYOUT;
            }

            private static final long MediaCharacteristics$OFFSET = 4;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static final long MediaCharacteristics$offset() {
                return MediaCharacteristics$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static int MediaCharacteristics(MemorySegment struct) {
                return struct.get(MediaCharacteristics$LAYOUT, MediaCharacteristics$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD MediaCharacteristics
             * }
             */
            public static void MediaCharacteristics(MemorySegment struct, int fieldValue) {
                struct.set(MediaCharacteristics$LAYOUT, MediaCharacteristics$OFFSET, fieldValue);
            }

            private static final OfInt CurrentBlockSize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("CurrentBlockSize"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD CurrentBlockSize
             * }
             */
            public static final OfInt CurrentBlockSize$layout() {
                return CurrentBlockSize$LAYOUT;
            }

            private static final long CurrentBlockSize$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD CurrentBlockSize
             * }
             */
            public static final long CurrentBlockSize$offset() {
                return CurrentBlockSize$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD CurrentBlockSize
             * }
             */
            public static int CurrentBlockSize(MemorySegment struct) {
                return struct.get(CurrentBlockSize$LAYOUT, CurrentBlockSize$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD CurrentBlockSize
             * }
             */
            public static void CurrentBlockSize(MemorySegment struct, int fieldValue) {
                struct.set(CurrentBlockSize$LAYOUT, CurrentBlockSize$OFFSET, fieldValue);
            }

            private static final OfInt BusType$LAYOUT = (OfInt)$LAYOUT.select(groupElement("BusType"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * STORAGE_BUS_TYPE BusType
             * }
             */
            public static final OfInt BusType$layout() {
                return BusType$LAYOUT;
            }

            private static final long BusType$OFFSET = 12;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * STORAGE_BUS_TYPE BusType
             * }
             */
            public static final long BusType$offset() {
                return BusType$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * STORAGE_BUS_TYPE BusType
             * }
             */
            public static int BusType(MemorySegment struct) {
                return struct.get(BusType$LAYOUT, BusType$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * STORAGE_BUS_TYPE BusType
             * }
             */
            public static void BusType(MemorySegment struct, int fieldValue) {
                struct.set(BusType$LAYOUT, BusType$OFFSET, fieldValue);
            }

            /**
             * {@snippet lang=c :
             * union {
             *     struct {
             *         BYTE MediumType;
             *         BYTE DensityCode;
             *     } ScsiInformation;
             * }
             * }
             */
            public static class BusSpecificData {

                BusSpecificData() {
                    // Should not be called directly
                }

                private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
                    _DEVICE_MEDIA_INFO.DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.layout().withName("ScsiInformation")
                ).withName("$anon$979:13");

                /**
                 * The layout of this union
                 */
                public static final GroupLayout layout() {
                    return $LAYOUT;
                }

                /**
                 * {@snippet lang=c :
                 * struct {
                 *     BYTE MediumType;
                 *     BYTE DensityCode;
                 * }
                 * }
                 */
                public static class ScsiInformation {

                    ScsiInformation() {
                        // Should not be called directly
                    }

                    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                        wgl_h.C_CHAR.withName("MediumType"),
                        wgl_h.C_CHAR.withName("DensityCode")
                    ).withName("$anon$980:17");

                    /**
                     * The layout of this struct
                     */
                    public static final GroupLayout layout() {
                        return $LAYOUT;
                    }

                    private static final OfByte MediumType$LAYOUT = (OfByte)$LAYOUT.select(groupElement("MediumType"));

                    /**
                     * Layout for field:
                     * {@snippet lang=c :
                     * BYTE MediumType
                     * }
                     */
                    public static final OfByte MediumType$layout() {
                        return MediumType$LAYOUT;
                    }

                    private static final long MediumType$OFFSET = 0;

                    /**
                     * Offset for field:
                     * {@snippet lang=c :
                     * BYTE MediumType
                     * }
                     */
                    public static final long MediumType$offset() {
                        return MediumType$OFFSET;
                    }

                    /**
                     * Getter for field:
                     * {@snippet lang=c :
                     * BYTE MediumType
                     * }
                     */
                    public static byte MediumType(MemorySegment struct) {
                        return struct.get(MediumType$LAYOUT, MediumType$OFFSET);
                    }

                    /**
                     * Setter for field:
                     * {@snippet lang=c :
                     * BYTE MediumType
                     * }
                     */
                    public static void MediumType(MemorySegment struct, byte fieldValue) {
                        struct.set(MediumType$LAYOUT, MediumType$OFFSET, fieldValue);
                    }

                    private static final OfByte DensityCode$LAYOUT = (OfByte)$LAYOUT.select(groupElement("DensityCode"));

                    /**
                     * Layout for field:
                     * {@snippet lang=c :
                     * BYTE DensityCode
                     * }
                     */
                    public static final OfByte DensityCode$layout() {
                        return DensityCode$LAYOUT;
                    }

                    private static final long DensityCode$OFFSET = 1;

                    /**
                     * Offset for field:
                     * {@snippet lang=c :
                     * BYTE DensityCode
                     * }
                     */
                    public static final long DensityCode$offset() {
                        return DensityCode$OFFSET;
                    }

                    /**
                     * Getter for field:
                     * {@snippet lang=c :
                     * BYTE DensityCode
                     * }
                     */
                    public static byte DensityCode(MemorySegment struct) {
                        return struct.get(DensityCode$LAYOUT, DensityCode$OFFSET);
                    }

                    /**
                     * Setter for field:
                     * {@snippet lang=c :
                     * BYTE DensityCode
                     * }
                     */
                    public static void DensityCode(MemorySegment struct, byte fieldValue) {
                        struct.set(DensityCode$LAYOUT, DensityCode$OFFSET, fieldValue);
                    }

                    /**
                     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
                     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
                     */
                    public static MemorySegment asSlice(MemorySegment array, long index) {
                        return array.asSlice(layout().byteSize() * index);
                    }

                    /**
                     * The size (in bytes) of this struct
                     */
                    public static long sizeof() { return layout().byteSize(); }

                    /**
                     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
                     */
                    public static MemorySegment allocate(SegmentAllocator allocator) {
                        return allocator.allocate(layout());
                    }

                    /**
                     * Allocate an array of size {@code elementCount} using {@code allocator}.
                     * The returned segment has size {@code elementCount * layout().byteSize()}.
                     */
                    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
                    }

                    /**
                     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                     * The returned segment has size {@code layout().byteSize()}
                     */
                    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                        return reinterpret(addr, 1, arena, cleanup);
                    }

                    /**
                     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                     * The returned segment has size {@code elementCount * layout().byteSize()}
                     */
                    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
                    }
                }

                private static final GroupLayout ScsiInformation$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("ScsiInformation"));

                /**
                 * Layout for field:
                 * {@snippet lang=c :
                 * struct {
                 *     BYTE MediumType;
                 *     BYTE DensityCode;
                 * } ScsiInformation
                 * }
                 */
                public static final GroupLayout ScsiInformation$layout() {
                    return ScsiInformation$LAYOUT;
                }

                private static final long ScsiInformation$OFFSET = 0;

                /**
                 * Offset for field:
                 * {@snippet lang=c :
                 * struct {
                 *     BYTE MediumType;
                 *     BYTE DensityCode;
                 * } ScsiInformation
                 * }
                 */
                public static final long ScsiInformation$offset() {
                    return ScsiInformation$OFFSET;
                }

                /**
                 * Getter for field:
                 * {@snippet lang=c :
                 * struct {
                 *     BYTE MediumType;
                 *     BYTE DensityCode;
                 * } ScsiInformation
                 * }
                 */
                public static MemorySegment ScsiInformation(MemorySegment union) {
                    return union.asSlice(ScsiInformation$OFFSET, ScsiInformation$LAYOUT.byteSize());
                }

                /**
                 * Setter for field:
                 * {@snippet lang=c :
                 * struct {
                 *     BYTE MediumType;
                 *     BYTE DensityCode;
                 * } ScsiInformation
                 * }
                 */
                public static void ScsiInformation(MemorySegment union, MemorySegment fieldValue) {
                    MemorySegment.copy(fieldValue, 0L, union, ScsiInformation$OFFSET, ScsiInformation$LAYOUT.byteSize());
                }

                /**
                 * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
                 * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
                 */
                public static MemorySegment asSlice(MemorySegment array, long index) {
                    return array.asSlice(layout().byteSize() * index);
                }

                /**
                 * The size (in bytes) of this union
                 */
                public static long sizeof() { return layout().byteSize(); }

                /**
                 * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
                 */
                public static MemorySegment allocate(SegmentAllocator allocator) {
                    return allocator.allocate(layout());
                }

                /**
                 * Allocate an array of size {@code elementCount} using {@code allocator}.
                 * The returned segment has size {@code elementCount * layout().byteSize()}.
                 */
                public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                    return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
                }

                /**
                 * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                 * The returned segment has size {@code layout().byteSize()}
                 */
                public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                    return reinterpret(addr, 1, arena, cleanup);
                }

                /**
                 * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                 * The returned segment has size {@code elementCount * layout().byteSize()}
                 */
                public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                    return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
                }
            }

            private static final GroupLayout BusSpecificData$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("BusSpecificData"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * union {
             *     struct {
             *         BYTE MediumType;
             *         BYTE DensityCode;
             *     } ScsiInformation;
             * } BusSpecificData
             * }
             */
            public static final GroupLayout BusSpecificData$layout() {
                return BusSpecificData$LAYOUT;
            }

            private static final long BusSpecificData$OFFSET = 16;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * union {
             *     struct {
             *         BYTE MediumType;
             *         BYTE DensityCode;
             *     } ScsiInformation;
             * } BusSpecificData
             * }
             */
            public static final long BusSpecificData$offset() {
                return BusSpecificData$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * union {
             *     struct {
             *         BYTE MediumType;
             *         BYTE DensityCode;
             *     } ScsiInformation;
             * } BusSpecificData
             * }
             */
            public static MemorySegment BusSpecificData(MemorySegment struct) {
                return struct.asSlice(BusSpecificData$OFFSET, BusSpecificData$LAYOUT.byteSize());
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * union {
             *     struct {
             *         BYTE MediumType;
             *         BYTE DensityCode;
             *     } ScsiInformation;
             * } BusSpecificData
             * }
             */
            public static void BusSpecificData(MemorySegment struct, MemorySegment fieldValue) {
                MemorySegment.copy(fieldValue, 0L, struct, BusSpecificData$OFFSET, BusSpecificData$LAYOUT.byteSize());
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout TapeInfo$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("TapeInfo"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD MediaCharacteristics;
         *     DWORD CurrentBlockSize;
         *     STORAGE_BUS_TYPE BusType;
         *     union {
         *         struct {
         *             BYTE MediumType;
         *             BYTE DensityCode;
         *         } ScsiInformation;
         *     } BusSpecificData;
         * } TapeInfo
         * }
         */
        public static final GroupLayout TapeInfo$layout() {
            return TapeInfo$LAYOUT;
        }

        private static final long TapeInfo$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD MediaCharacteristics;
         *     DWORD CurrentBlockSize;
         *     STORAGE_BUS_TYPE BusType;
         *     union {
         *         struct {
         *             BYTE MediumType;
         *             BYTE DensityCode;
         *         } ScsiInformation;
         *     } BusSpecificData;
         * } TapeInfo
         * }
         */
        public static final long TapeInfo$offset() {
            return TapeInfo$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD MediaCharacteristics;
         *     DWORD CurrentBlockSize;
         *     STORAGE_BUS_TYPE BusType;
         *     union {
         *         struct {
         *             BYTE MediumType;
         *             BYTE DensityCode;
         *         } ScsiInformation;
         *     } BusSpecificData;
         * } TapeInfo
         * }
         */
        public static MemorySegment TapeInfo(MemorySegment union) {
            return union.asSlice(TapeInfo$OFFSET, TapeInfo$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     STORAGE_MEDIA_TYPE MediaType;
         *     DWORD MediaCharacteristics;
         *     DWORD CurrentBlockSize;
         *     STORAGE_BUS_TYPE BusType;
         *     union {
         *         struct {
         *             BYTE MediumType;
         *             BYTE DensityCode;
         *         } ScsiInformation;
         *     } BusSpecificData;
         * } TapeInfo
         * }
         */
        public static void TapeInfo(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, TapeInfo$OFFSET, TapeInfo$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this union
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout DeviceSpecific$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("DeviceSpecific"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * union {
     *     struct {
     *         LARGE_INTEGER Cylinders;
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD TracksPerCylinder;
     *         DWORD SectorsPerTrack;
     *         DWORD BytesPerSector;
     *         DWORD NumberMediaSides;
     *         DWORD MediaCharacteristics;
     *     } DiskInfo;
     *     struct {
     *         LARGE_INTEGER Cylinders;
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD TracksPerCylinder;
     *         DWORD SectorsPerTrack;
     *         DWORD BytesPerSector;
     *         DWORD NumberMediaSides;
     *         DWORD MediaCharacteristics;
     *     } RemovableDiskInfo;
     *     struct {
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD MediaCharacteristics;
     *         DWORD CurrentBlockSize;
     *         STORAGE_BUS_TYPE BusType;
     *         union {
     *             struct {
     *                 BYTE MediumType;
     *                 BYTE DensityCode;
     *             } ScsiInformation;
     *         } BusSpecificData;
     *     } TapeInfo;
     * } DeviceSpecific
     * }
     */
    public static final GroupLayout DeviceSpecific$layout() {
        return DeviceSpecific$LAYOUT;
    }

    private static final long DeviceSpecific$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * union {
     *     struct {
     *         LARGE_INTEGER Cylinders;
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD TracksPerCylinder;
     *         DWORD SectorsPerTrack;
     *         DWORD BytesPerSector;
     *         DWORD NumberMediaSides;
     *         DWORD MediaCharacteristics;
     *     } DiskInfo;
     *     struct {
     *         LARGE_INTEGER Cylinders;
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD TracksPerCylinder;
     *         DWORD SectorsPerTrack;
     *         DWORD BytesPerSector;
     *         DWORD NumberMediaSides;
     *         DWORD MediaCharacteristics;
     *     } RemovableDiskInfo;
     *     struct {
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD MediaCharacteristics;
     *         DWORD CurrentBlockSize;
     *         STORAGE_BUS_TYPE BusType;
     *         union {
     *             struct {
     *                 BYTE MediumType;
     *                 BYTE DensityCode;
     *             } ScsiInformation;
     *         } BusSpecificData;
     *     } TapeInfo;
     * } DeviceSpecific
     * }
     */
    public static final long DeviceSpecific$offset() {
        return DeviceSpecific$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * union {
     *     struct {
     *         LARGE_INTEGER Cylinders;
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD TracksPerCylinder;
     *         DWORD SectorsPerTrack;
     *         DWORD BytesPerSector;
     *         DWORD NumberMediaSides;
     *         DWORD MediaCharacteristics;
     *     } DiskInfo;
     *     struct {
     *         LARGE_INTEGER Cylinders;
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD TracksPerCylinder;
     *         DWORD SectorsPerTrack;
     *         DWORD BytesPerSector;
     *         DWORD NumberMediaSides;
     *         DWORD MediaCharacteristics;
     *     } RemovableDiskInfo;
     *     struct {
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD MediaCharacteristics;
     *         DWORD CurrentBlockSize;
     *         STORAGE_BUS_TYPE BusType;
     *         union {
     *             struct {
     *                 BYTE MediumType;
     *                 BYTE DensityCode;
     *             } ScsiInformation;
     *         } BusSpecificData;
     *     } TapeInfo;
     * } DeviceSpecific
     * }
     */
    public static MemorySegment DeviceSpecific(MemorySegment struct) {
        return struct.asSlice(DeviceSpecific$OFFSET, DeviceSpecific$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * union {
     *     struct {
     *         LARGE_INTEGER Cylinders;
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD TracksPerCylinder;
     *         DWORD SectorsPerTrack;
     *         DWORD BytesPerSector;
     *         DWORD NumberMediaSides;
     *         DWORD MediaCharacteristics;
     *     } DiskInfo;
     *     struct {
     *         LARGE_INTEGER Cylinders;
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD TracksPerCylinder;
     *         DWORD SectorsPerTrack;
     *         DWORD BytesPerSector;
     *         DWORD NumberMediaSides;
     *         DWORD MediaCharacteristics;
     *     } RemovableDiskInfo;
     *     struct {
     *         STORAGE_MEDIA_TYPE MediaType;
     *         DWORD MediaCharacteristics;
     *         DWORD CurrentBlockSize;
     *         STORAGE_BUS_TYPE BusType;
     *         union {
     *             struct {
     *                 BYTE MediumType;
     *                 BYTE DensityCode;
     *             } ScsiInformation;
     *         } BusSpecificData;
     *     } TapeInfo;
     * } DeviceSpecific
     * }
     */
    public static void DeviceSpecific(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, DeviceSpecific$OFFSET, DeviceSpecific$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

