// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class wgl_h_20 extends wgl_h_21 {

    wgl_h_20() {
        // Should not be called directly
    }
    private static final int SIID_FOLDEROPEN = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_FOLDEROPEN = 4
     * }
     */
    public static int SIID_FOLDEROPEN() {
        return SIID_FOLDEROPEN;
    }
    private static final int SIID_DRIVE525 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVE525 = 5
     * }
     */
    public static int SIID_DRIVE525() {
        return SIID_DRIVE525;
    }
    private static final int SIID_DRIVE35 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVE35 = 6
     * }
     */
    public static int SIID_DRIVE35() {
        return SIID_DRIVE35;
    }
    private static final int SIID_DRIVEREMOVE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEREMOVE = 7
     * }
     */
    public static int SIID_DRIVEREMOVE() {
        return SIID_DRIVEREMOVE;
    }
    private static final int SIID_DRIVEFIXED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEFIXED = 8
     * }
     */
    public static int SIID_DRIVEFIXED() {
        return SIID_DRIVEFIXED;
    }
    private static final int SIID_DRIVENET = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVENET = 9
     * }
     */
    public static int SIID_DRIVENET() {
        return SIID_DRIVENET;
    }
    private static final int SIID_DRIVENETDISABLED = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVENETDISABLED = 10
     * }
     */
    public static int SIID_DRIVENETDISABLED() {
        return SIID_DRIVENETDISABLED;
    }
    private static final int SIID_DRIVECD = (int)11L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVECD = 11
     * }
     */
    public static int SIID_DRIVECD() {
        return SIID_DRIVECD;
    }
    private static final int SIID_DRIVERAM = (int)12L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVERAM = 12
     * }
     */
    public static int SIID_DRIVERAM() {
        return SIID_DRIVERAM;
    }
    private static final int SIID_WORLD = (int)13L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_WORLD = 13
     * }
     */
    public static int SIID_WORLD() {
        return SIID_WORLD;
    }
    private static final int SIID_SERVER = (int)15L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SERVER = 15
     * }
     */
    public static int SIID_SERVER() {
        return SIID_SERVER;
    }
    private static final int SIID_PRINTER = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_PRINTER = 16
     * }
     */
    public static int SIID_PRINTER() {
        return SIID_PRINTER;
    }
    private static final int SIID_MYNETWORK = (int)17L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MYNETWORK = 17
     * }
     */
    public static int SIID_MYNETWORK() {
        return SIID_MYNETWORK;
    }
    private static final int SIID_FIND = (int)22L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_FIND = 22
     * }
     */
    public static int SIID_FIND() {
        return SIID_FIND;
    }
    private static final int SIID_HELP = (int)23L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_HELP = 23
     * }
     */
    public static int SIID_HELP() {
        return SIID_HELP;
    }
    private static final int SIID_SHARE = (int)28L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SHARE = 28
     * }
     */
    public static int SIID_SHARE() {
        return SIID_SHARE;
    }
    private static final int SIID_LINK = (int)29L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_LINK = 29
     * }
     */
    public static int SIID_LINK() {
        return SIID_LINK;
    }
    private static final int SIID_SLOWFILE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SLOWFILE = 30
     * }
     */
    public static int SIID_SLOWFILE() {
        return SIID_SLOWFILE;
    }
    private static final int SIID_RECYCLER = (int)31L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_RECYCLER = 31
     * }
     */
    public static int SIID_RECYCLER() {
        return SIID_RECYCLER;
    }
    private static final int SIID_RECYCLERFULL = (int)32L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_RECYCLERFULL = 32
     * }
     */
    public static int SIID_RECYCLERFULL() {
        return SIID_RECYCLERFULL;
    }
    private static final int SIID_MEDIACDAUDIO = (int)40L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDAUDIO = 40
     * }
     */
    public static int SIID_MEDIACDAUDIO() {
        return SIID_MEDIACDAUDIO;
    }
    private static final int SIID_LOCK = (int)47L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_LOCK = 47
     * }
     */
    public static int SIID_LOCK() {
        return SIID_LOCK;
    }
    private static final int SIID_AUTOLIST = (int)49L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_AUTOLIST = 49
     * }
     */
    public static int SIID_AUTOLIST() {
        return SIID_AUTOLIST;
    }
    private static final int SIID_PRINTERNET = (int)50L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_PRINTERNET = 50
     * }
     */
    public static int SIID_PRINTERNET() {
        return SIID_PRINTERNET;
    }
    private static final int SIID_SERVERSHARE = (int)51L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SERVERSHARE = 51
     * }
     */
    public static int SIID_SERVERSHARE() {
        return SIID_SERVERSHARE;
    }
    private static final int SIID_PRINTERFAX = (int)52L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_PRINTERFAX = 52
     * }
     */
    public static int SIID_PRINTERFAX() {
        return SIID_PRINTERFAX;
    }
    private static final int SIID_PRINTERFAXNET = (int)53L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_PRINTERFAXNET = 53
     * }
     */
    public static int SIID_PRINTERFAXNET() {
        return SIID_PRINTERFAXNET;
    }
    private static final int SIID_PRINTERFILE = (int)54L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_PRINTERFILE = 54
     * }
     */
    public static int SIID_PRINTERFILE() {
        return SIID_PRINTERFILE;
    }
    private static final int SIID_STACK = (int)55L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_STACK = 55
     * }
     */
    public static int SIID_STACK() {
        return SIID_STACK;
    }
    private static final int SIID_MEDIASVCD = (int)56L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIASVCD = 56
     * }
     */
    public static int SIID_MEDIASVCD() {
        return SIID_MEDIASVCD;
    }
    private static final int SIID_STUFFEDFOLDER = (int)57L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_STUFFEDFOLDER = 57
     * }
     */
    public static int SIID_STUFFEDFOLDER() {
        return SIID_STUFFEDFOLDER;
    }
    private static final int SIID_DRIVEUNKNOWN = (int)58L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEUNKNOWN = 58
     * }
     */
    public static int SIID_DRIVEUNKNOWN() {
        return SIID_DRIVEUNKNOWN;
    }
    private static final int SIID_DRIVEDVD = (int)59L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEDVD = 59
     * }
     */
    public static int SIID_DRIVEDVD() {
        return SIID_DRIVEDVD;
    }
    private static final int SIID_MEDIADVD = (int)60L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVD = 60
     * }
     */
    public static int SIID_MEDIADVD() {
        return SIID_MEDIADVD;
    }
    private static final int SIID_MEDIADVDRAM = (int)61L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDRAM = 61
     * }
     */
    public static int SIID_MEDIADVDRAM() {
        return SIID_MEDIADVDRAM;
    }
    private static final int SIID_MEDIADVDRW = (int)62L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDRW = 62
     * }
     */
    public static int SIID_MEDIADVDRW() {
        return SIID_MEDIADVDRW;
    }
    private static final int SIID_MEDIADVDR = (int)63L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDR = 63
     * }
     */
    public static int SIID_MEDIADVDR() {
        return SIID_MEDIADVDR;
    }
    private static final int SIID_MEDIADVDROM = (int)64L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDROM = 64
     * }
     */
    public static int SIID_MEDIADVDROM() {
        return SIID_MEDIADVDROM;
    }
    private static final int SIID_MEDIACDAUDIOPLUS = (int)65L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDAUDIOPLUS = 65
     * }
     */
    public static int SIID_MEDIACDAUDIOPLUS() {
        return SIID_MEDIACDAUDIOPLUS;
    }
    private static final int SIID_MEDIACDRW = (int)66L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDRW = 66
     * }
     */
    public static int SIID_MEDIACDRW() {
        return SIID_MEDIACDRW;
    }
    private static final int SIID_MEDIACDR = (int)67L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDR = 67
     * }
     */
    public static int SIID_MEDIACDR() {
        return SIID_MEDIACDR;
    }
    private static final int SIID_MEDIACDBURN = (int)68L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDBURN = 68
     * }
     */
    public static int SIID_MEDIACDBURN() {
        return SIID_MEDIACDBURN;
    }
    private static final int SIID_MEDIABLANKCD = (int)69L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIABLANKCD = 69
     * }
     */
    public static int SIID_MEDIABLANKCD() {
        return SIID_MEDIABLANKCD;
    }
    private static final int SIID_MEDIACDROM = (int)70L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDROM = 70
     * }
     */
    public static int SIID_MEDIACDROM() {
        return SIID_MEDIACDROM;
    }
    private static final int SIID_AUDIOFILES = (int)71L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_AUDIOFILES = 71
     * }
     */
    public static int SIID_AUDIOFILES() {
        return SIID_AUDIOFILES;
    }
    private static final int SIID_IMAGEFILES = (int)72L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_IMAGEFILES = 72
     * }
     */
    public static int SIID_IMAGEFILES() {
        return SIID_IMAGEFILES;
    }
    private static final int SIID_VIDEOFILES = (int)73L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_VIDEOFILES = 73
     * }
     */
    public static int SIID_VIDEOFILES() {
        return SIID_VIDEOFILES;
    }
    private static final int SIID_MIXEDFILES = (int)74L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MIXEDFILES = 74
     * }
     */
    public static int SIID_MIXEDFILES() {
        return SIID_MIXEDFILES;
    }
    private static final int SIID_FOLDERBACK = (int)75L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_FOLDERBACK = 75
     * }
     */
    public static int SIID_FOLDERBACK() {
        return SIID_FOLDERBACK;
    }
    private static final int SIID_FOLDERFRONT = (int)76L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_FOLDERFRONT = 76
     * }
     */
    public static int SIID_FOLDERFRONT() {
        return SIID_FOLDERFRONT;
    }
    private static final int SIID_SHIELD = (int)77L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SHIELD = 77
     * }
     */
    public static int SIID_SHIELD() {
        return SIID_SHIELD;
    }
    private static final int SIID_WARNING = (int)78L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_WARNING = 78
     * }
     */
    public static int SIID_WARNING() {
        return SIID_WARNING;
    }
    private static final int SIID_INFO = (int)79L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_INFO = 79
     * }
     */
    public static int SIID_INFO() {
        return SIID_INFO;
    }
    private static final int SIID_ERROR = (int)80L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_ERROR = 80
     * }
     */
    public static int SIID_ERROR() {
        return SIID_ERROR;
    }
    private static final int SIID_KEY = (int)81L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_KEY = 81
     * }
     */
    public static int SIID_KEY() {
        return SIID_KEY;
    }
    private static final int SIID_SOFTWARE = (int)82L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SOFTWARE = 82
     * }
     */
    public static int SIID_SOFTWARE() {
        return SIID_SOFTWARE;
    }
    private static final int SIID_RENAME = (int)83L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_RENAME = 83
     * }
     */
    public static int SIID_RENAME() {
        return SIID_RENAME;
    }
    private static final int SIID_DELETE = (int)84L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DELETE = 84
     * }
     */
    public static int SIID_DELETE() {
        return SIID_DELETE;
    }
    private static final int SIID_MEDIAAUDIODVD = (int)85L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAAUDIODVD = 85
     * }
     */
    public static int SIID_MEDIAAUDIODVD() {
        return SIID_MEDIAAUDIODVD;
    }
    private static final int SIID_MEDIAMOVIEDVD = (int)86L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAMOVIEDVD = 86
     * }
     */
    public static int SIID_MEDIAMOVIEDVD() {
        return SIID_MEDIAMOVIEDVD;
    }
    private static final int SIID_MEDIAENHANCEDCD = (int)87L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAENHANCEDCD = 87
     * }
     */
    public static int SIID_MEDIAENHANCEDCD() {
        return SIID_MEDIAENHANCEDCD;
    }
    private static final int SIID_MEDIAENHANCEDDVD = (int)88L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAENHANCEDDVD = 88
     * }
     */
    public static int SIID_MEDIAENHANCEDDVD() {
        return SIID_MEDIAENHANCEDDVD;
    }
    private static final int SIID_MEDIAHDDVD = (int)89L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAHDDVD = 89
     * }
     */
    public static int SIID_MEDIAHDDVD() {
        return SIID_MEDIAHDDVD;
    }
    private static final int SIID_MEDIABLURAY = (int)90L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIABLURAY = 90
     * }
     */
    public static int SIID_MEDIABLURAY() {
        return SIID_MEDIABLURAY;
    }
    private static final int SIID_MEDIAVCD = (int)91L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAVCD = 91
     * }
     */
    public static int SIID_MEDIAVCD() {
        return SIID_MEDIAVCD;
    }
    private static final int SIID_MEDIADVDPLUSR = (int)92L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDPLUSR = 92
     * }
     */
    public static int SIID_MEDIADVDPLUSR() {
        return SIID_MEDIADVDPLUSR;
    }
    private static final int SIID_MEDIADVDPLUSRW = (int)93L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDPLUSRW = 93
     * }
     */
    public static int SIID_MEDIADVDPLUSRW() {
        return SIID_MEDIADVDPLUSRW;
    }
    private static final int SIID_DESKTOPPC = (int)94L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DESKTOPPC = 94
     * }
     */
    public static int SIID_DESKTOPPC() {
        return SIID_DESKTOPPC;
    }
    private static final int SIID_MOBILEPC = (int)95L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MOBILEPC = 95
     * }
     */
    public static int SIID_MOBILEPC() {
        return SIID_MOBILEPC;
    }
    private static final int SIID_USERS = (int)96L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_USERS = 96
     * }
     */
    public static int SIID_USERS() {
        return SIID_USERS;
    }
    private static final int SIID_MEDIASMARTMEDIA = (int)97L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIASMARTMEDIA = 97
     * }
     */
    public static int SIID_MEDIASMARTMEDIA() {
        return SIID_MEDIASMARTMEDIA;
    }
    private static final int SIID_MEDIACOMPACTFLASH = (int)98L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACOMPACTFLASH = 98
     * }
     */
    public static int SIID_MEDIACOMPACTFLASH() {
        return SIID_MEDIACOMPACTFLASH;
    }
    private static final int SIID_DEVICECELLPHONE = (int)99L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DEVICECELLPHONE = 99
     * }
     */
    public static int SIID_DEVICECELLPHONE() {
        return SIID_DEVICECELLPHONE;
    }
    private static final int SIID_DEVICECAMERA = (int)100L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DEVICECAMERA = 100
     * }
     */
    public static int SIID_DEVICECAMERA() {
        return SIID_DEVICECAMERA;
    }
    private static final int SIID_DEVICEVIDEOCAMERA = (int)101L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DEVICEVIDEOCAMERA = 101
     * }
     */
    public static int SIID_DEVICEVIDEOCAMERA() {
        return SIID_DEVICEVIDEOCAMERA;
    }
    private static final int SIID_DEVICEAUDIOPLAYER = (int)102L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DEVICEAUDIOPLAYER = 102
     * }
     */
    public static int SIID_DEVICEAUDIOPLAYER() {
        return SIID_DEVICEAUDIOPLAYER;
    }
    private static final int SIID_NETWORKCONNECT = (int)103L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_NETWORKCONNECT = 103
     * }
     */
    public static int SIID_NETWORKCONNECT() {
        return SIID_NETWORKCONNECT;
    }
    private static final int SIID_INTERNET = (int)104L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_INTERNET = 104
     * }
     */
    public static int SIID_INTERNET() {
        return SIID_INTERNET;
    }
    private static final int SIID_ZIPFILE = (int)105L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_ZIPFILE = 105
     * }
     */
    public static int SIID_ZIPFILE() {
        return SIID_ZIPFILE;
    }
    private static final int SIID_SETTINGS = (int)106L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SETTINGS = 106
     * }
     */
    public static int SIID_SETTINGS() {
        return SIID_SETTINGS;
    }
    private static final int SIID_DRIVEHDDVD = (int)132L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEHDDVD = 132
     * }
     */
    public static int SIID_DRIVEHDDVD() {
        return SIID_DRIVEHDDVD;
    }
    private static final int SIID_DRIVEBD = (int)133L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEBD = 133
     * }
     */
    public static int SIID_DRIVEBD() {
        return SIID_DRIVEBD;
    }
    private static final int SIID_MEDIAHDDVDROM = (int)134L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAHDDVDROM = 134
     * }
     */
    public static int SIID_MEDIAHDDVDROM() {
        return SIID_MEDIAHDDVDROM;
    }
    private static final int SIID_MEDIAHDDVDR = (int)135L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAHDDVDR = 135
     * }
     */
    public static int SIID_MEDIAHDDVDR() {
        return SIID_MEDIAHDDVDR;
    }
    private static final int SIID_MEDIAHDDVDRAM = (int)136L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAHDDVDRAM = 136
     * }
     */
    public static int SIID_MEDIAHDDVDRAM() {
        return SIID_MEDIAHDDVDRAM;
    }
    private static final int SIID_MEDIABDROM = (int)137L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIABDROM = 137
     * }
     */
    public static int SIID_MEDIABDROM() {
        return SIID_MEDIABDROM;
    }
    private static final int SIID_MEDIABDR = (int)138L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIABDR = 138
     * }
     */
    public static int SIID_MEDIABDR() {
        return SIID_MEDIABDR;
    }
    private static final int SIID_MEDIABDRE = (int)139L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIABDRE = 139
     * }
     */
    public static int SIID_MEDIABDRE() {
        return SIID_MEDIABDRE;
    }
    private static final int SIID_CLUSTEREDDRIVE = (int)140L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_CLUSTEREDDRIVE = 140
     * }
     */
    public static int SIID_CLUSTEREDDRIVE() {
        return SIID_CLUSTEREDDRIVE;
    }
    private static final int SIID_MAX_ICONS = (int)181L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MAX_ICONS = 181
     * }
     */
    public static int SIID_MAX_ICONS() {
        return SIID_MAX_ICONS;
    }

    private static class SHGetStockIconInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHGetStockIconInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetStockIconInfo(SHSTOCKICONID siid, UINT uFlags, SHSTOCKICONINFO *psii)
     * }
     */
    public static FunctionDescriptor SHGetStockIconInfo$descriptor() {
        return SHGetStockIconInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetStockIconInfo(SHSTOCKICONID siid, UINT uFlags, SHSTOCKICONINFO *psii)
     * }
     */
    public static MethodHandle SHGetStockIconInfo$handle() {
        return SHGetStockIconInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHGetStockIconInfo(SHSTOCKICONID siid, UINT uFlags, SHSTOCKICONINFO *psii)
     * }
     */
    public static MemorySegment SHGetStockIconInfo$address() {
        return SHGetStockIconInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetStockIconInfo(SHSTOCKICONID siid, UINT uFlags, SHSTOCKICONINFO *psii)
     * }
     */
    public static int SHGetStockIconInfo(int siid, int uFlags, MemorySegment psii) {
        var mh$ = SHGetStockIconInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetStockIconInfo", siid, uFlags, psii);
            }
            return (int)mh$.invokeExact(siid, uFlags, psii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetDiskFreeSpaceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHGetDiskFreeSpaceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static FunctionDescriptor SHGetDiskFreeSpaceExA$descriptor() {
        return SHGetDiskFreeSpaceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static MethodHandle SHGetDiskFreeSpaceExA$handle() {
        return SHGetDiskFreeSpaceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static MemorySegment SHGetDiskFreeSpaceExA$address() {
        return SHGetDiskFreeSpaceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static int SHGetDiskFreeSpaceExA(MemorySegment pszDirectoryName, MemorySegment pulFreeBytesAvailableToCaller, MemorySegment pulTotalNumberOfBytes, MemorySegment pulTotalNumberOfFreeBytes) {
        var mh$ = SHGetDiskFreeSpaceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetDiskFreeSpaceExA", pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
            }
            return (int)mh$.invokeExact(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetDiskFreeSpaceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHGetDiskFreeSpaceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static FunctionDescriptor SHGetDiskFreeSpaceExW$descriptor() {
        return SHGetDiskFreeSpaceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static MethodHandle SHGetDiskFreeSpaceExW$handle() {
        return SHGetDiskFreeSpaceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static MemorySegment SHGetDiskFreeSpaceExW$address() {
        return SHGetDiskFreeSpaceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static int SHGetDiskFreeSpaceExW(MemorySegment pszDirectoryName, MemorySegment pulFreeBytesAvailableToCaller, MemorySegment pulTotalNumberOfBytes, MemorySegment pulTotalNumberOfFreeBytes) {
        var mh$ = SHGetDiskFreeSpaceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetDiskFreeSpaceExW", pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
            }
            return (int)mh$.invokeExact(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetNewLinkInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHGetNewLinkInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor SHGetNewLinkInfoA$descriptor() {
        return SHGetNewLinkInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static MethodHandle SHGetNewLinkInfoA$handle() {
        return SHGetNewLinkInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static MemorySegment SHGetNewLinkInfoA$address() {
        return SHGetNewLinkInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static int SHGetNewLinkInfoA(MemorySegment pszLinkTo, MemorySegment pszDir, MemorySegment pszName, MemorySegment pfMustCopy, int uFlags) {
        var mh$ = SHGetNewLinkInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetNewLinkInfoA", pszLinkTo, pszDir, pszName, pfMustCopy, uFlags);
            }
            return (int)mh$.invokeExact(pszLinkTo, pszDir, pszName, pfMustCopy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetNewLinkInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHGetNewLinkInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor SHGetNewLinkInfoW$descriptor() {
        return SHGetNewLinkInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static MethodHandle SHGetNewLinkInfoW$handle() {
        return SHGetNewLinkInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static MemorySegment SHGetNewLinkInfoW$address() {
        return SHGetNewLinkInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static int SHGetNewLinkInfoW(MemorySegment pszLinkTo, MemorySegment pszDir, MemorySegment pszName, MemorySegment pfMustCopy, int uFlags) {
        var mh$ = SHGetNewLinkInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetNewLinkInfoW", pszLinkTo, pszDir, pszName, pfMustCopy, uFlags);
            }
            return (int)mh$.invokeExact(pszLinkTo, pszDir, pszName, pfMustCopy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHInvokePrinterCommandA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHInvokePrinterCommandA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandA(HWND hwnd, UINT uAction, LPCSTR lpBuf1, LPCSTR lpBuf2, BOOL fModal)
     * }
     */
    public static FunctionDescriptor SHInvokePrinterCommandA$descriptor() {
        return SHInvokePrinterCommandA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandA(HWND hwnd, UINT uAction, LPCSTR lpBuf1, LPCSTR lpBuf2, BOOL fModal)
     * }
     */
    public static MethodHandle SHInvokePrinterCommandA$handle() {
        return SHInvokePrinterCommandA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandA(HWND hwnd, UINT uAction, LPCSTR lpBuf1, LPCSTR lpBuf2, BOOL fModal)
     * }
     */
    public static MemorySegment SHInvokePrinterCommandA$address() {
        return SHInvokePrinterCommandA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandA(HWND hwnd, UINT uAction, LPCSTR lpBuf1, LPCSTR lpBuf2, BOOL fModal)
     * }
     */
    public static int SHInvokePrinterCommandA(MemorySegment hwnd, int uAction, MemorySegment lpBuf1, MemorySegment lpBuf2, int fModal) {
        var mh$ = SHInvokePrinterCommandA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHInvokePrinterCommandA", hwnd, uAction, lpBuf1, lpBuf2, fModal);
            }
            return (int)mh$.invokeExact(hwnd, uAction, lpBuf1, lpBuf2, fModal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHInvokePrinterCommandW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHInvokePrinterCommandW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandW(HWND hwnd, UINT uAction, LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal)
     * }
     */
    public static FunctionDescriptor SHInvokePrinterCommandW$descriptor() {
        return SHInvokePrinterCommandW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandW(HWND hwnd, UINT uAction, LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal)
     * }
     */
    public static MethodHandle SHInvokePrinterCommandW$handle() {
        return SHInvokePrinterCommandW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandW(HWND hwnd, UINT uAction, LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal)
     * }
     */
    public static MemorySegment SHInvokePrinterCommandW$address() {
        return SHInvokePrinterCommandW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandW(HWND hwnd, UINT uAction, LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal)
     * }
     */
    public static int SHInvokePrinterCommandW(MemorySegment hwnd, int uAction, MemorySegment lpBuf1, MemorySegment lpBuf2, int fModal) {
        var mh$ = SHInvokePrinterCommandW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHInvokePrinterCommandW", hwnd, uAction, lpBuf1, lpBuf2, fModal);
            }
            return (int)mh$.invokeExact(hwnd, uAction, lpBuf1, lpBuf2, fModal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _OPEN_PRINTER_PROPS_INFOA {
     *     DWORD dwSize;
     *     LPSTR pszSheetName;
     *     UINT uSheetIndex;
     *     DWORD dwFlags;
     *     BOOL bModal;
     * } *POPEN_PRINTER_PROPS_INFOA
     * }
     */
    public static final AddressLayout POPEN_PRINTER_PROPS_INFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OPEN_PRINTER_PROPS_INFOW {
     *     DWORD dwSize;
     *     LPWSTR pszSheetName;
     *     UINT uSheetIndex;
     *     DWORD dwFlags;
     *     BOOL bModal;
     * } *POPEN_PRINTER_PROPS_INFOW
     * }
     */
    public static final AddressLayout POPEN_PRINTER_PROPS_INFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef POPEN_PRINTER_PROPS_INFOA POPEN_PRINTER_PROPS_INFO
     * }
     */
    public static final AddressLayout POPEN_PRINTER_PROPS_INFO = wgl_h.C_POINTER;

    private static class SHLoadNonloadedIconOverlayIdentifiers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHLoadNonloadedIconOverlayIdentifiers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHLoadNonloadedIconOverlayIdentifiers()
     * }
     */
    public static FunctionDescriptor SHLoadNonloadedIconOverlayIdentifiers$descriptor() {
        return SHLoadNonloadedIconOverlayIdentifiers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHLoadNonloadedIconOverlayIdentifiers()
     * }
     */
    public static MethodHandle SHLoadNonloadedIconOverlayIdentifiers$handle() {
        return SHLoadNonloadedIconOverlayIdentifiers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHLoadNonloadedIconOverlayIdentifiers()
     * }
     */
    public static MemorySegment SHLoadNonloadedIconOverlayIdentifiers$address() {
        return SHLoadNonloadedIconOverlayIdentifiers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHLoadNonloadedIconOverlayIdentifiers()
     * }
     */
    public static int SHLoadNonloadedIconOverlayIdentifiers() {
        var mh$ = SHLoadNonloadedIconOverlayIdentifiers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHLoadNonloadedIconOverlayIdentifiers");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHIsFileAvailableOffline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHIsFileAvailableOffline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHIsFileAvailableOffline(PCWSTR pwszPath, DWORD *pdwStatus)
     * }
     */
    public static FunctionDescriptor SHIsFileAvailableOffline$descriptor() {
        return SHIsFileAvailableOffline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHIsFileAvailableOffline(PCWSTR pwszPath, DWORD *pdwStatus)
     * }
     */
    public static MethodHandle SHIsFileAvailableOffline$handle() {
        return SHIsFileAvailableOffline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHIsFileAvailableOffline(PCWSTR pwszPath, DWORD *pdwStatus)
     * }
     */
    public static MemorySegment SHIsFileAvailableOffline$address() {
        return SHIsFileAvailableOffline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHIsFileAvailableOffline(PCWSTR pwszPath, DWORD *pdwStatus)
     * }
     */
    public static int SHIsFileAvailableOffline(MemorySegment pwszPath, MemorySegment pdwStatus) {
        var mh$ = SHIsFileAvailableOffline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHIsFileAvailableOffline", pwszPath, pdwStatus);
            }
            return (int)mh$.invokeExact(pwszPath, pdwStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHSetLocalizedName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHSetLocalizedName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHSetLocalizedName(PCWSTR pszPath, PCWSTR pszResModule, int idsRes)
     * }
     */
    public static FunctionDescriptor SHSetLocalizedName$descriptor() {
        return SHSetLocalizedName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHSetLocalizedName(PCWSTR pszPath, PCWSTR pszResModule, int idsRes)
     * }
     */
    public static MethodHandle SHSetLocalizedName$handle() {
        return SHSetLocalizedName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHSetLocalizedName(PCWSTR pszPath, PCWSTR pszResModule, int idsRes)
     * }
     */
    public static MemorySegment SHSetLocalizedName$address() {
        return SHSetLocalizedName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHSetLocalizedName(PCWSTR pszPath, PCWSTR pszResModule, int idsRes)
     * }
     */
    public static int SHSetLocalizedName(MemorySegment pszPath, MemorySegment pszResModule, int idsRes) {
        var mh$ = SHSetLocalizedName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHSetLocalizedName", pszPath, pszResModule, idsRes);
            }
            return (int)mh$.invokeExact(pszPath, pszResModule, idsRes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHRemoveLocalizedName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHRemoveLocalizedName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHRemoveLocalizedName(PCWSTR pszPath)
     * }
     */
    public static FunctionDescriptor SHRemoveLocalizedName$descriptor() {
        return SHRemoveLocalizedName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHRemoveLocalizedName(PCWSTR pszPath)
     * }
     */
    public static MethodHandle SHRemoveLocalizedName$handle() {
        return SHRemoveLocalizedName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHRemoveLocalizedName(PCWSTR pszPath)
     * }
     */
    public static MemorySegment SHRemoveLocalizedName$address() {
        return SHRemoveLocalizedName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHRemoveLocalizedName(PCWSTR pszPath)
     * }
     */
    public static int SHRemoveLocalizedName(MemorySegment pszPath) {
        var mh$ = SHRemoveLocalizedName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHRemoveLocalizedName", pszPath);
            }
            return (int)mh$.invokeExact(pszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetLocalizedName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHGetLocalizedName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetLocalizedName(PCWSTR pszPath, PWSTR pszResModule, UINT cch, int *pidsRes)
     * }
     */
    public static FunctionDescriptor SHGetLocalizedName$descriptor() {
        return SHGetLocalizedName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetLocalizedName(PCWSTR pszPath, PWSTR pszResModule, UINT cch, int *pidsRes)
     * }
     */
    public static MethodHandle SHGetLocalizedName$handle() {
        return SHGetLocalizedName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHGetLocalizedName(PCWSTR pszPath, PWSTR pszResModule, UINT cch, int *pidsRes)
     * }
     */
    public static MemorySegment SHGetLocalizedName$address() {
        return SHGetLocalizedName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetLocalizedName(PCWSTR pszPath, PWSTR pszResModule, UINT cch, int *pidsRes)
     * }
     */
    public static int SHGetLocalizedName(MemorySegment pszPath, MemorySegment pszResModule, int cch, MemorySegment pidsRes) {
        var mh$ = SHGetLocalizedName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetLocalizedName", pszPath, pszResModule, cch, pidsRes);
            }
            return (int)mh$.invokeExact(pszPath, pszResModule, cch, pidsRes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int ShellMessageBoxA(HINSTANCE hAppInst, HWND hWnd, LPCSTR lpcText, LPCSTR lpcTitle, UINT fuStyle, ...)
     * }
     */
    public static class ShellMessageBoxA {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                wgl_h.C_INT,
                wgl_h.C_POINTER,
                wgl_h.C_POINTER,
                wgl_h.C_POINTER,
                wgl_h.C_POINTER,
                wgl_h.C_INT
            );
        private static final MemorySegment ADDR = wgl_h.findOrThrow("ShellMessageBoxA");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ShellMessageBoxA(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int ShellMessageBoxA(HINSTANCE hAppInst, HWND hWnd, LPCSTR lpcText, LPCSTR lpcTitle, UINT fuStyle, ...)
         * }
         */
        public static ShellMessageBoxA makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ShellMessageBoxA(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment hAppInst, MemorySegment hWnd, MemorySegment lpcText, MemorySegment lpcTitle, int fuStyle, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ShellMessageBoxA", hAppInst, hWnd, lpcText, lpcTitle, fuStyle, x5);
                }
                return (int)spreader.invokeExact(hAppInst, hWnd, lpcText, lpcTitle, fuStyle, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int ShellMessageBoxW(HINSTANCE hAppInst, HWND hWnd, LPCWSTR lpcText, LPCWSTR lpcTitle, UINT fuStyle, ...)
     * }
     */
    public static class ShellMessageBoxW {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                wgl_h.C_INT,
                wgl_h.C_POINTER,
                wgl_h.C_POINTER,
                wgl_h.C_POINTER,
                wgl_h.C_POINTER,
                wgl_h.C_INT
            );
        private static final MemorySegment ADDR = wgl_h.findOrThrow("ShellMessageBoxW");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ShellMessageBoxW(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int ShellMessageBoxW(HINSTANCE hAppInst, HWND hWnd, LPCWSTR lpcText, LPCWSTR lpcTitle, UINT fuStyle, ...)
         * }
         */
        public static ShellMessageBoxW makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ShellMessageBoxW(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment hAppInst, MemorySegment hWnd, MemorySegment lpcText, MemorySegment lpcTitle, int fuStyle, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ShellMessageBoxW", hAppInst, hWnd, lpcText, lpcTitle, fuStyle, x5);
                }
                return (int)spreader.invokeExact(hAppInst, hWnd, lpcText, lpcTitle, fuStyle, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class IsLFNDriveA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsLFNDriveA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveA(LPCSTR pszPath)
     * }
     */
    public static FunctionDescriptor IsLFNDriveA$descriptor() {
        return IsLFNDriveA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveA(LPCSTR pszPath)
     * }
     */
    public static MethodHandle IsLFNDriveA$handle() {
        return IsLFNDriveA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveA(LPCSTR pszPath)
     * }
     */
    public static MemorySegment IsLFNDriveA$address() {
        return IsLFNDriveA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveA(LPCSTR pszPath)
     * }
     */
    public static int IsLFNDriveA(MemorySegment pszPath) {
        var mh$ = IsLFNDriveA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsLFNDriveA", pszPath);
            }
            return (int)mh$.invokeExact(pszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsLFNDriveW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsLFNDriveW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveW(LPCWSTR pszPath)
     * }
     */
    public static FunctionDescriptor IsLFNDriveW$descriptor() {
        return IsLFNDriveW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveW(LPCWSTR pszPath)
     * }
     */
    public static MethodHandle IsLFNDriveW$handle() {
        return IsLFNDriveW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveW(LPCWSTR pszPath)
     * }
     */
    public static MemorySegment IsLFNDriveW$address() {
        return IsLFNDriveW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveW(LPCWSTR pszPath)
     * }
     */
    public static int IsLFNDriveW(MemorySegment pszPath) {
        var mh$ = IsLFNDriveW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsLFNDriveW", pszPath);
            }
            return (int)mh$.invokeExact(pszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHEnumerateUnreadMailAccountsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHEnumerateUnreadMailAccountsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsA(HKEY hKeyUser, DWORD dwIndex, LPSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static FunctionDescriptor SHEnumerateUnreadMailAccountsA$descriptor() {
        return SHEnumerateUnreadMailAccountsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsA(HKEY hKeyUser, DWORD dwIndex, LPSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static MethodHandle SHEnumerateUnreadMailAccountsA$handle() {
        return SHEnumerateUnreadMailAccountsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsA(HKEY hKeyUser, DWORD dwIndex, LPSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static MemorySegment SHEnumerateUnreadMailAccountsA$address() {
        return SHEnumerateUnreadMailAccountsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsA(HKEY hKeyUser, DWORD dwIndex, LPSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static int SHEnumerateUnreadMailAccountsA(MemorySegment hKeyUser, int dwIndex, MemorySegment pszMailAddress, int cchMailAddress) {
        var mh$ = SHEnumerateUnreadMailAccountsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHEnumerateUnreadMailAccountsA", hKeyUser, dwIndex, pszMailAddress, cchMailAddress);
            }
            return (int)mh$.invokeExact(hKeyUser, dwIndex, pszMailAddress, cchMailAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHEnumerateUnreadMailAccountsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHEnumerateUnreadMailAccountsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsW(HKEY hKeyUser, DWORD dwIndex, LPWSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static FunctionDescriptor SHEnumerateUnreadMailAccountsW$descriptor() {
        return SHEnumerateUnreadMailAccountsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsW(HKEY hKeyUser, DWORD dwIndex, LPWSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static MethodHandle SHEnumerateUnreadMailAccountsW$handle() {
        return SHEnumerateUnreadMailAccountsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsW(HKEY hKeyUser, DWORD dwIndex, LPWSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static MemorySegment SHEnumerateUnreadMailAccountsW$address() {
        return SHEnumerateUnreadMailAccountsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsW(HKEY hKeyUser, DWORD dwIndex, LPWSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static int SHEnumerateUnreadMailAccountsW(MemorySegment hKeyUser, int dwIndex, MemorySegment pszMailAddress, int cchMailAddress) {
        var mh$ = SHEnumerateUnreadMailAccountsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHEnumerateUnreadMailAccountsW", hKeyUser, dwIndex, pszMailAddress, cchMailAddress);
            }
            return (int)mh$.invokeExact(hKeyUser, dwIndex, pszMailAddress, cchMailAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetUnreadMailCountA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHGetUnreadMailCountA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountA(HKEY hKeyUser, LPCSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static FunctionDescriptor SHGetUnreadMailCountA$descriptor() {
        return SHGetUnreadMailCountA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountA(HKEY hKeyUser, LPCSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static MethodHandle SHGetUnreadMailCountA$handle() {
        return SHGetUnreadMailCountA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountA(HKEY hKeyUser, LPCSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static MemorySegment SHGetUnreadMailCountA$address() {
        return SHGetUnreadMailCountA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountA(HKEY hKeyUser, LPCSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static int SHGetUnreadMailCountA(MemorySegment hKeyUser, MemorySegment pszMailAddress, MemorySegment pdwCount, MemorySegment pFileTime, MemorySegment pszShellExecuteCommand, int cchShellExecuteCommand) {
        var mh$ = SHGetUnreadMailCountA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetUnreadMailCountA", hKeyUser, pszMailAddress, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
            }
            return (int)mh$.invokeExact(hKeyUser, pszMailAddress, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetUnreadMailCountW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHGetUnreadMailCountW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountW(HKEY hKeyUser, LPCWSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPWSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static FunctionDescriptor SHGetUnreadMailCountW$descriptor() {
        return SHGetUnreadMailCountW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountW(HKEY hKeyUser, LPCWSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPWSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static MethodHandle SHGetUnreadMailCountW$handle() {
        return SHGetUnreadMailCountW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountW(HKEY hKeyUser, LPCWSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPWSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static MemorySegment SHGetUnreadMailCountW$address() {
        return SHGetUnreadMailCountW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountW(HKEY hKeyUser, LPCWSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPWSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static int SHGetUnreadMailCountW(MemorySegment hKeyUser, MemorySegment pszMailAddress, MemorySegment pdwCount, MemorySegment pFileTime, MemorySegment pszShellExecuteCommand, int cchShellExecuteCommand) {
        var mh$ = SHGetUnreadMailCountW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetUnreadMailCountW", hKeyUser, pszMailAddress, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
            }
            return (int)mh$.invokeExact(hKeyUser, pszMailAddress, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHSetUnreadMailCountA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHSetUnreadMailCountA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountA(LPCSTR pszMailAddress, DWORD dwCount, LPCSTR pszShellExecuteCommand)
     * }
     */
    public static FunctionDescriptor SHSetUnreadMailCountA$descriptor() {
        return SHSetUnreadMailCountA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountA(LPCSTR pszMailAddress, DWORD dwCount, LPCSTR pszShellExecuteCommand)
     * }
     */
    public static MethodHandle SHSetUnreadMailCountA$handle() {
        return SHSetUnreadMailCountA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountA(LPCSTR pszMailAddress, DWORD dwCount, LPCSTR pszShellExecuteCommand)
     * }
     */
    public static MemorySegment SHSetUnreadMailCountA$address() {
        return SHSetUnreadMailCountA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountA(LPCSTR pszMailAddress, DWORD dwCount, LPCSTR pszShellExecuteCommand)
     * }
     */
    public static int SHSetUnreadMailCountA(MemorySegment pszMailAddress, int dwCount, MemorySegment pszShellExecuteCommand) {
        var mh$ = SHSetUnreadMailCountA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHSetUnreadMailCountA", pszMailAddress, dwCount, pszShellExecuteCommand);
            }
            return (int)mh$.invokeExact(pszMailAddress, dwCount, pszShellExecuteCommand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHSetUnreadMailCountW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHSetUnreadMailCountW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountW(LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand)
     * }
     */
    public static FunctionDescriptor SHSetUnreadMailCountW$descriptor() {
        return SHSetUnreadMailCountW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountW(LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand)
     * }
     */
    public static MethodHandle SHSetUnreadMailCountW$handle() {
        return SHSetUnreadMailCountW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountW(LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand)
     * }
     */
    public static MemorySegment SHSetUnreadMailCountW$address() {
        return SHSetUnreadMailCountW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountW(LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand)
     * }
     */
    public static int SHSetUnreadMailCountW(MemorySegment pszMailAddress, int dwCount, MemorySegment pszShellExecuteCommand) {
        var mh$ = SHSetUnreadMailCountW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHSetUnreadMailCountW", pszMailAddress, dwCount, pszShellExecuteCommand);
            }
            return (int)mh$.invokeExact(pszMailAddress, dwCount, pszShellExecuteCommand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHTestTokenMembership {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHTestTokenMembership");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHTestTokenMembership(HANDLE hToken, ULONG ulRID)
     * }
     */
    public static FunctionDescriptor SHTestTokenMembership$descriptor() {
        return SHTestTokenMembership.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHTestTokenMembership(HANDLE hToken, ULONG ulRID)
     * }
     */
    public static MethodHandle SHTestTokenMembership$handle() {
        return SHTestTokenMembership.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL SHTestTokenMembership(HANDLE hToken, ULONG ulRID)
     * }
     */
    public static MemorySegment SHTestTokenMembership$address() {
        return SHTestTokenMembership.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL SHTestTokenMembership(HANDLE hToken, ULONG ulRID)
     * }
     */
    public static int SHTestTokenMembership(MemorySegment hToken, int ulRID) {
        var mh$ = SHTestTokenMembership.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHTestTokenMembership", hToken, ulRID);
            }
            return (int)mh$.invokeExact(hToken, ulRID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetImageList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHGetImageList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetImageList(int iImageList, const IID *const riid, void **ppvObj)
     * }
     */
    public static FunctionDescriptor SHGetImageList$descriptor() {
        return SHGetImageList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetImageList(int iImageList, const IID *const riid, void **ppvObj)
     * }
     */
    public static MethodHandle SHGetImageList$handle() {
        return SHGetImageList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHGetImageList(int iImageList, const IID *const riid, void **ppvObj)
     * }
     */
    public static MemorySegment SHGetImageList$address() {
        return SHGetImageList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetImageList(int iImageList, const IID *const riid, void **ppvObj)
     * }
     */
    public static int SHGetImageList(int iImageList, MemorySegment riid, MemorySegment ppvObj) {
        var mh$ = SHGetImageList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetImageList", iImageList, riid, ppvObj);
            }
            return (int)mh$.invokeExact(iImageList, riid, ppvObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitNetworkAddressControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitNetworkAddressControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL InitNetworkAddressControl()
     * }
     */
    public static FunctionDescriptor InitNetworkAddressControl$descriptor() {
        return InitNetworkAddressControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL InitNetworkAddressControl()
     * }
     */
    public static MethodHandle InitNetworkAddressControl$handle() {
        return InitNetworkAddressControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL InitNetworkAddressControl()
     * }
     */
    public static MemorySegment InitNetworkAddressControl$address() {
        return InitNetworkAddressControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL InitNetworkAddressControl()
     * }
     */
    public static int InitNetworkAddressControl() {
        var mh$ = InitNetworkAddressControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitNetworkAddressControl");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagNC_ADDRESS {
     *     struct NET_ADDRESS_INFO_ *pAddrInfo;
     *     USHORT PortNumber;
     *     BYTE PrefixLength;
     * } *PNC_ADDRESS
     * }
     */
    public static final AddressLayout PNC_ADDRESS = wgl_h.C_POINTER;

    private static class SHGetDriveMedia {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SHGetDriveMedia");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetDriveMedia(PCWSTR pszDrive, DWORD *pdwMediaContent)
     * }
     */
    public static FunctionDescriptor SHGetDriveMedia$descriptor() {
        return SHGetDriveMedia.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetDriveMedia(PCWSTR pszDrive, DWORD *pdwMediaContent)
     * }
     */
    public static MethodHandle SHGetDriveMedia$handle() {
        return SHGetDriveMedia.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SHGetDriveMedia(PCWSTR pszDrive, DWORD *pdwMediaContent)
     * }
     */
    public static MemorySegment SHGetDriveMedia$address() {
        return SHGetDriveMedia.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetDriveMedia(PCWSTR pszDrive, DWORD *pdwMediaContent)
     * }
     */
    public static int SHGetDriveMedia(MemorySegment pszDrive, MemorySegment pdwMediaContent) {
        var mh$ = SHGetDriveMedia.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetDriveMedia", pszDrive, pdwMediaContent);
            }
            return (int)mh$.invokeExact(pszDrive, pdwMediaContent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _PERF_DATA_BLOCK {
     *     WCHAR Signature[4];
     *     DWORD LittleEndian;
     *     DWORD Version;
     *     DWORD Revision;
     *     DWORD TotalByteLength;
     *     DWORD HeaderLength;
     *     DWORD NumObjectTypes;
     *     LONG DefaultObject;
     *     SYSTEMTIME SystemTime;
     *     LARGE_INTEGER PerfTime;
     *     LARGE_INTEGER PerfFreq;
     *     LARGE_INTEGER PerfTime100nSec;
     *     DWORD SystemNameLength;
     *     DWORD SystemNameOffset;
     * } *PPERF_DATA_BLOCK
     * }
     */
    public static final AddressLayout PPERF_DATA_BLOCK = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PERF_OBJECT_TYPE {
     *     DWORD TotalByteLength;
     *     DWORD DefinitionLength;
     *     DWORD HeaderLength;
     *     DWORD ObjectNameTitleIndex;
     *     DWORD ObjectNameTitle;
     *     DWORD ObjectHelpTitleIndex;
     *     DWORD ObjectHelpTitle;
     *     DWORD DetailLevel;
     *     DWORD NumCounters;
     *     LONG DefaultCounter;
     *     LONG NumInstances;
     *     DWORD CodePage;
     *     LARGE_INTEGER PerfTime;
     *     LARGE_INTEGER PerfFreq;
     * } *PPERF_OBJECT_TYPE
     * }
     */
    public static final AddressLayout PPERF_OBJECT_TYPE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PERF_COUNTER_DEFINITION {
     *     DWORD ByteLength;
     *     DWORD CounterNameTitleIndex;
     *     DWORD CounterNameTitle;
     *     DWORD CounterHelpTitleIndex;
     *     DWORD CounterHelpTitle;
     *     LONG DefaultScale;
     *     DWORD DetailLevel;
     *     DWORD CounterType;
     *     DWORD CounterSize;
     *     DWORD CounterOffset;
     * } *PPERF_COUNTER_DEFINITION
     * }
     */
    public static final AddressLayout PPERF_COUNTER_DEFINITION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PERF_INSTANCE_DEFINITION {
     *     DWORD ByteLength;
     *     DWORD ParentObjectTitleIndex;
     *     DWORD ParentObjectInstance;
     *     LONG UniqueID;
     *     DWORD NameOffset;
     *     DWORD NameLength;
     * } *PPERF_INSTANCE_DEFINITION
     * }
     */
    public static final AddressLayout PPERF_INSTANCE_DEFINITION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PERF_COUNTER_BLOCK {
     *     DWORD ByteLength;
     * } *PPERF_COUNTER_BLOCK
     * }
     */
    public static final AddressLayout PPERF_COUNTER_BLOCK = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_char
     * }
     */
    public static final OfByte u_char = wgl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_short
     * }
     */
    public static final OfShort u_short = wgl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int
     * }
     */
    public static final OfInt u_int = wgl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long u_long
     * }
     */
    public static final OfInt u_long = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef UINT_PTR SOCKET
     * }
     */
    public static final OfLong SOCKET = wgl_h.C_LONG_LONG;

    private static class __WSAFDIsSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("__WSAFDIsSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __WSAFDIsSet(SOCKET, fd_set *)
     * }
     */
    public static FunctionDescriptor __WSAFDIsSet$descriptor() {
        return __WSAFDIsSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __WSAFDIsSet(SOCKET, fd_set *)
     * }
     */
    public static MethodHandle __WSAFDIsSet$handle() {
        return __WSAFDIsSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __WSAFDIsSet(SOCKET, fd_set *)
     * }
     */
    public static MemorySegment __WSAFDIsSet$address() {
        return __WSAFDIsSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __WSAFDIsSet(SOCKET, fd_set *)
     * }
     */
    public static int __WSAFDIsSet(long x0, MemorySegment x1) {
        var mh$ = __WSAFDIsSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__WSAFDIsSet", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct in_addr {
     *     union {
     *         struct {
     *             UCHAR s_b1;
     *             UCHAR s_b2;
     *             UCHAR s_b3;
     *             UCHAR s_b4;
     *         } S_un_b;
     *         struct {
     *             USHORT s_w1;
     *             USHORT s_w2;
     *         } S_un_w;
     *         ULONG S_addr;
     *     } S_un;
     * } *PIN_ADDR
     * }
     */
    public static final AddressLayout PIN_ADDR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct in_addr {
     *     union {
     *         struct {
     *             UCHAR s_b1;
     *             UCHAR s_b2;
     *             UCHAR s_b3;
     *             UCHAR s_b4;
     *         } S_un_b;
     *         struct {
     *             USHORT s_w1;
     *             USHORT s_w2;
     *         } S_un_w;
     *         ULONG S_addr;
     *     } S_un;
     * } *LPIN_ADDR
     * }
     */
    public static final AddressLayout LPIN_ADDR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WSADATA *LPWSADATA
     * }
     */
    public static final AddressLayout LPWSADATA = wgl_h.C_POINTER;

    private static class accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SOCKET accept(SOCKET s, struct sockaddr *addr, int *addrlen)
     * }
     */
    public static FunctionDescriptor accept$descriptor() {
        return accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SOCKET accept(SOCKET s, struct sockaddr *addr, int *addrlen)
     * }
     */
    public static MethodHandle accept$handle() {
        return accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SOCKET accept(SOCKET s, struct sockaddr *addr, int *addrlen)
     * }
     */
    public static MemorySegment accept$address() {
        return accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SOCKET accept(SOCKET s, struct sockaddr *addr, int *addrlen)
     * }
     */
    public static long accept(long s, MemorySegment addr, MemorySegment addrlen) {
        var mh$ = accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accept", s, addr, addrlen);
            }
            return (long)mh$.invokeExact(s, addr, addrlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("bind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bind(SOCKET s, const struct sockaddr *addr, int namelen)
     * }
     */
    public static FunctionDescriptor bind$descriptor() {
        return bind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bind(SOCKET s, const struct sockaddr *addr, int namelen)
     * }
     */
    public static MethodHandle bind$handle() {
        return bind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bind(SOCKET s, const struct sockaddr *addr, int namelen)
     * }
     */
    public static MemorySegment bind$address() {
        return bind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bind(SOCKET s, const struct sockaddr *addr, int namelen)
     * }
     */
    public static int bind(long s, MemorySegment addr, int namelen) {
        var mh$ = bind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bind", s, addr, namelen);
            }
            return (int)mh$.invokeExact(s, addr, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class closesocket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("closesocket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int closesocket(SOCKET s)
     * }
     */
    public static FunctionDescriptor closesocket$descriptor() {
        return closesocket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int closesocket(SOCKET s)
     * }
     */
    public static MethodHandle closesocket$handle() {
        return closesocket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int closesocket(SOCKET s)
     * }
     */
    public static MemorySegment closesocket$address() {
        return closesocket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int closesocket(SOCKET s)
     * }
     */
    public static int closesocket(long s) {
        var mh$ = closesocket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("closesocket", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class connect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("connect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int connect(SOCKET s, const struct sockaddr *name, int namelen)
     * }
     */
    public static FunctionDescriptor connect$descriptor() {
        return connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int connect(SOCKET s, const struct sockaddr *name, int namelen)
     * }
     */
    public static MethodHandle connect$handle() {
        return connect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int connect(SOCKET s, const struct sockaddr *name, int namelen)
     * }
     */
    public static MemorySegment connect$address() {
        return connect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int connect(SOCKET s, const struct sockaddr *name, int namelen)
     * }
     */
    public static int connect(long s, MemorySegment name, int namelen) {
        var mh$ = connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("connect", s, name, namelen);
            }
            return (int)mh$.invokeExact(s, name, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ioctlsocket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ioctlsocket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ioctlsocket(SOCKET s, long cmd, u_long *argp)
     * }
     */
    public static FunctionDescriptor ioctlsocket$descriptor() {
        return ioctlsocket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ioctlsocket(SOCKET s, long cmd, u_long *argp)
     * }
     */
    public static MethodHandle ioctlsocket$handle() {
        return ioctlsocket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ioctlsocket(SOCKET s, long cmd, u_long *argp)
     * }
     */
    public static MemorySegment ioctlsocket$address() {
        return ioctlsocket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ioctlsocket(SOCKET s, long cmd, u_long *argp)
     * }
     */
    public static int ioctlsocket(long s, int cmd, MemorySegment argp) {
        var mh$ = ioctlsocket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ioctlsocket", s, cmd, argp);
            }
            return (int)mh$.invokeExact(s, cmd, argp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeername {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("getpeername");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpeername(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static FunctionDescriptor getpeername$descriptor() {
        return getpeername.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpeername(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static MethodHandle getpeername$handle() {
        return getpeername.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpeername(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static MemorySegment getpeername$address() {
        return getpeername.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpeername(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static int getpeername(long s, MemorySegment name, MemorySegment namelen) {
        var mh$ = getpeername.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeername", s, name, namelen);
            }
            return (int)mh$.invokeExact(s, name, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("getsockname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsockname(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static FunctionDescriptor getsockname$descriptor() {
        return getsockname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsockname(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static MethodHandle getsockname$handle() {
        return getsockname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsockname(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static MemorySegment getsockname$address() {
        return getsockname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsockname(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static int getsockname(long s, MemorySegment name, MemorySegment namelen) {
        var mh$ = getsockname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockname", s, name, namelen);
            }
            return (int)mh$.invokeExact(s, name, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("getsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsockopt(SOCKET s, int level, int optname, char *optval, int *optlen)
     * }
     */
    public static FunctionDescriptor getsockopt$descriptor() {
        return getsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsockopt(SOCKET s, int level, int optname, char *optval, int *optlen)
     * }
     */
    public static MethodHandle getsockopt$handle() {
        return getsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsockopt(SOCKET s, int level, int optname, char *optval, int *optlen)
     * }
     */
    public static MemorySegment getsockopt$address() {
        return getsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsockopt(SOCKET s, int level, int optname, char *optval, int *optlen)
     * }
     */
    public static int getsockopt(long s, int level, int optname, MemorySegment optval, MemorySegment optlen) {
        var mh$ = getsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockopt", s, level, optname, optval, optlen);
            }
            return (int)mh$.invokeExact(s, level, optname, optval, optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class htonl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("htonl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * u_long htonl(u_long hostlong)
     * }
     */
    public static FunctionDescriptor htonl$descriptor() {
        return htonl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * u_long htonl(u_long hostlong)
     * }
     */
    public static MethodHandle htonl$handle() {
        return htonl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * u_long htonl(u_long hostlong)
     * }
     */
    public static MemorySegment htonl$address() {
        return htonl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * u_long htonl(u_long hostlong)
     * }
     */
    public static int htonl(int hostlong) {
        var mh$ = htonl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("htonl", hostlong);
            }
            return (int)mh$.invokeExact(hostlong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class htons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("htons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * u_short htons(u_short hostshort)
     * }
     */
    public static FunctionDescriptor htons$descriptor() {
        return htons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * u_short htons(u_short hostshort)
     * }
     */
    public static MethodHandle htons$handle() {
        return htons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * u_short htons(u_short hostshort)
     * }
     */
    public static MemorySegment htons$address() {
        return htons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * u_short htons(u_short hostshort)
     * }
     */
    public static short htons(short hostshort) {
        var mh$ = htons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("htons", hostshort);
            }
            return (short)mh$.invokeExact(hostshort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet_addr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("inet_addr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long inet_addr(const char *cp)
     * }
     */
    public static FunctionDescriptor inet_addr$descriptor() {
        return inet_addr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long inet_addr(const char *cp)
     * }
     */
    public static MethodHandle inet_addr$handle() {
        return inet_addr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long inet_addr(const char *cp)
     * }
     */
    public static MemorySegment inet_addr$address() {
        return inet_addr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long inet_addr(const char *cp)
     * }
     */
    public static int inet_addr(MemorySegment cp) {
        var mh$ = inet_addr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet_addr", cp);
            }
            return (int)mh$.invokeExact(cp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet_ntoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            in_addr.layout()
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("inet_ntoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *inet_ntoa(struct in_addr in)
     * }
     */
    public static FunctionDescriptor inet_ntoa$descriptor() {
        return inet_ntoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *inet_ntoa(struct in_addr in)
     * }
     */
    public static MethodHandle inet_ntoa$handle() {
        return inet_ntoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *inet_ntoa(struct in_addr in)
     * }
     */
    public static MemorySegment inet_ntoa$address() {
        return inet_ntoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *inet_ntoa(struct in_addr in)
     * }
     */
    public static MemorySegment inet_ntoa(MemorySegment in) {
        var mh$ = inet_ntoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet_ntoa", in);
            }
            return (MemorySegment)mh$.invokeExact(in);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class listen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("listen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int listen(SOCKET s, int backlog)
     * }
     */
    public static FunctionDescriptor listen$descriptor() {
        return listen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int listen(SOCKET s, int backlog)
     * }
     */
    public static MethodHandle listen$handle() {
        return listen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int listen(SOCKET s, int backlog)
     * }
     */
    public static MemorySegment listen$address() {
        return listen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int listen(SOCKET s, int backlog)
     * }
     */
    public static int listen(long s, int backlog) {
        var mh$ = listen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("listen", s, backlog);
            }
            return (int)mh$.invokeExact(s, backlog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ntohl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ntohl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * u_long ntohl(u_long netlong)
     * }
     */
    public static FunctionDescriptor ntohl$descriptor() {
        return ntohl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * u_long ntohl(u_long netlong)
     * }
     */
    public static MethodHandle ntohl$handle() {
        return ntohl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * u_long ntohl(u_long netlong)
     * }
     */
    public static MemorySegment ntohl$address() {
        return ntohl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * u_long ntohl(u_long netlong)
     * }
     */
    public static int ntohl(int netlong) {
        var mh$ = ntohl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntohl", netlong);
            }
            return (int)mh$.invokeExact(netlong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ntohs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ntohs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * u_short ntohs(u_short netshort)
     * }
     */
    public static FunctionDescriptor ntohs$descriptor() {
        return ntohs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * u_short ntohs(u_short netshort)
     * }
     */
    public static MethodHandle ntohs$handle() {
        return ntohs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * u_short ntohs(u_short netshort)
     * }
     */
    public static MemorySegment ntohs$address() {
        return ntohs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * u_short ntohs(u_short netshort)
     * }
     */
    public static short ntohs(short netshort) {
        var mh$ = ntohs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntohs", netshort);
            }
            return (short)mh$.invokeExact(netshort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("recv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int recv(SOCKET s, char *buf, int len, int flags)
     * }
     */
    public static FunctionDescriptor recv$descriptor() {
        return recv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int recv(SOCKET s, char *buf, int len, int flags)
     * }
     */
    public static MethodHandle recv$handle() {
        return recv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int recv(SOCKET s, char *buf, int len, int flags)
     * }
     */
    public static MemorySegment recv$address() {
        return recv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int recv(SOCKET s, char *buf, int len, int flags)
     * }
     */
    public static int recv(long s, MemorySegment buf, int len, int flags) {
        var mh$ = recv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recv", s, buf, len, flags);
            }
            return (int)mh$.invokeExact(s, buf, len, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvfrom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("recvfrom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen)
     * }
     */
    public static FunctionDescriptor recvfrom$descriptor() {
        return recvfrom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen)
     * }
     */
    public static MethodHandle recvfrom$handle() {
        return recvfrom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen)
     * }
     */
    public static MemorySegment recvfrom$address() {
        return recvfrom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen)
     * }
     */
    public static int recvfrom(long s, MemorySegment buf, int len, int flags, MemorySegment from, MemorySegment fromlen) {
        var mh$ = recvfrom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvfrom", s, buf, len, flags, from, fromlen);
            }
            return (int)mh$.invokeExact(s, buf, len, flags, from, fromlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout)
     * }
     */
    public static int select(int nfds, MemorySegment readfds, MemorySegment writefds, MemorySegment exceptfds, MemorySegment timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", nfds, readfds, writefds, exceptfds, timeout);
            }
            return (int)mh$.invokeExact(nfds, readfds, writefds, exceptfds, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int send(SOCKET s, const char *buf, int len, int flags)
     * }
     */
    public static FunctionDescriptor send$descriptor() {
        return send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int send(SOCKET s, const char *buf, int len, int flags)
     * }
     */
    public static MethodHandle send$handle() {
        return send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int send(SOCKET s, const char *buf, int len, int flags)
     * }
     */
    public static MemorySegment send$address() {
        return send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int send(SOCKET s, const char *buf, int len, int flags)
     * }
     */
    public static int send(long s, MemorySegment buf, int len, int flags) {
        var mh$ = send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("send", s, buf, len, flags);
            }
            return (int)mh$.invokeExact(s, buf, len, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("sendto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen)
     * }
     */
    public static FunctionDescriptor sendto$descriptor() {
        return sendto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen)
     * }
     */
    public static MethodHandle sendto$handle() {
        return sendto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen)
     * }
     */
    public static MemorySegment sendto$address() {
        return sendto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen)
     * }
     */
    public static int sendto(long s, MemorySegment buf, int len, int flags, MemorySegment to, int tolen) {
        var mh$ = sendto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendto", s, buf, len, flags, to, tolen);
            }
            return (int)mh$.invokeExact(s, buf, len, flags, to, tolen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("setsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
     * }
     */
    public static FunctionDescriptor setsockopt$descriptor() {
        return setsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
     * }
     */
    public static MethodHandle setsockopt$handle() {
        return setsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
     * }
     */
    public static MemorySegment setsockopt$address() {
        return setsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
     * }
     */
    public static int setsockopt(long s, int level, int optname, MemorySegment optval, int optlen) {
        var mh$ = setsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsockopt", s, level, optname, optval, optlen);
            }
            return (int)mh$.invokeExact(s, level, optname, optval, optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("shutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int shutdown(SOCKET s, int how)
     * }
     */
    public static FunctionDescriptor shutdown$descriptor() {
        return shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int shutdown(SOCKET s, int how)
     * }
     */
    public static MethodHandle shutdown$handle() {
        return shutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int shutdown(SOCKET s, int how)
     * }
     */
    public static MemorySegment shutdown$address() {
        return shutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int shutdown(SOCKET s, int how)
     * }
     */
    public static int shutdown(long s, int how) {
        var mh$ = shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shutdown", s, how);
            }
            return (int)mh$.invokeExact(s, how);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SOCKET socket(int af, int type, int protocol)
     * }
     */
    public static FunctionDescriptor socket$descriptor() {
        return socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SOCKET socket(int af, int type, int protocol)
     * }
     */
    public static MethodHandle socket$handle() {
        return socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SOCKET socket(int af, int type, int protocol)
     * }
     */
    public static MemorySegment socket$address() {
        return socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SOCKET socket(int af, int type, int protocol)
     * }
     */
    public static long socket(int af, int type, int protocol) {
        var mh$ = socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socket", af, type, protocol);
            }
            return (long)mh$.invokeExact(af, type, protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostbyaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gethostbyaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct hostent *gethostbyaddr(const char *addr, int len, int type)
     * }
     */
    public static FunctionDescriptor gethostbyaddr$descriptor() {
        return gethostbyaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct hostent *gethostbyaddr(const char *addr, int len, int type)
     * }
     */
    public static MethodHandle gethostbyaddr$handle() {
        return gethostbyaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct hostent *gethostbyaddr(const char *addr, int len, int type)
     * }
     */
    public static MemorySegment gethostbyaddr$address() {
        return gethostbyaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct hostent *gethostbyaddr(const char *addr, int len, int type)
     * }
     */
    public static MemorySegment gethostbyaddr(MemorySegment addr, int len, int type) {
        var mh$ = gethostbyaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostbyaddr", addr, len, type);
            }
            return (MemorySegment)mh$.invokeExact(addr, len, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostbyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gethostbyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct hostent *gethostbyname(const char *name)
     * }
     */
    public static FunctionDescriptor gethostbyname$descriptor() {
        return gethostbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct hostent *gethostbyname(const char *name)
     * }
     */
    public static MethodHandle gethostbyname$handle() {
        return gethostbyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct hostent *gethostbyname(const char *name)
     * }
     */
    public static MemorySegment gethostbyname$address() {
        return gethostbyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct hostent *gethostbyname(const char *name)
     * }
     */
    public static MemorySegment gethostbyname(MemorySegment name) {
        var mh$ = gethostbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostbyname", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostname(char *name, int namelen)
     * }
     */
    public static FunctionDescriptor gethostname$descriptor() {
        return gethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostname(char *name, int namelen)
     * }
     */
    public static MethodHandle gethostname$handle() {
        return gethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gethostname(char *name, int namelen)
     * }
     */
    public static MemorySegment gethostname$address() {
        return gethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gethostname(char *name, int namelen)
     * }
     */
    public static int gethostname(MemorySegment name, int namelen) {
        var mh$ = gethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostname", name, namelen);
            }
            return (int)mh$.invokeExact(name, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getservbyport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("getservbyport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct servent *getservbyport(int port, const char *proto)
     * }
     */
    public static FunctionDescriptor getservbyport$descriptor() {
        return getservbyport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct servent *getservbyport(int port, const char *proto)
     * }
     */
    public static MethodHandle getservbyport$handle() {
        return getservbyport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct servent *getservbyport(int port, const char *proto)
     * }
     */
    public static MemorySegment getservbyport$address() {
        return getservbyport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct servent *getservbyport(int port, const char *proto)
     * }
     */
    public static MemorySegment getservbyport(int port, MemorySegment proto) {
        var mh$ = getservbyport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getservbyport", port, proto);
            }
            return (MemorySegment)mh$.invokeExact(port, proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getservbyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("getservbyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct servent *getservbyname(const char *name, const char *proto)
     * }
     */
    public static FunctionDescriptor getservbyname$descriptor() {
        return getservbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct servent *getservbyname(const char *name, const char *proto)
     * }
     */
    public static MethodHandle getservbyname$handle() {
        return getservbyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct servent *getservbyname(const char *name, const char *proto)
     * }
     */
    public static MemorySegment getservbyname$address() {
        return getservbyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct servent *getservbyname(const char *name, const char *proto)
     * }
     */
    public static MemorySegment getservbyname(MemorySegment name, MemorySegment proto) {
        var mh$ = getservbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getservbyname", name, proto);
            }
            return (MemorySegment)mh$.invokeExact(name, proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprotobynumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("getprotobynumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct protoent *getprotobynumber(int proto)
     * }
     */
    public static FunctionDescriptor getprotobynumber$descriptor() {
        return getprotobynumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct protoent *getprotobynumber(int proto)
     * }
     */
    public static MethodHandle getprotobynumber$handle() {
        return getprotobynumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct protoent *getprotobynumber(int proto)
     * }
     */
    public static MemorySegment getprotobynumber$address() {
        return getprotobynumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct protoent *getprotobynumber(int proto)
     * }
     */
    public static MemorySegment getprotobynumber(int proto) {
        var mh$ = getprotobynumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprotobynumber", proto);
            }
            return (MemorySegment)mh$.invokeExact(proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprotobyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("getprotobyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct protoent *getprotobyname(const char *name)
     * }
     */
    public static FunctionDescriptor getprotobyname$descriptor() {
        return getprotobyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct protoent *getprotobyname(const char *name)
     * }
     */
    public static MethodHandle getprotobyname$handle() {
        return getprotobyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct protoent *getprotobyname(const char *name)
     * }
     */
    public static MemorySegment getprotobyname$address() {
        return getprotobyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct protoent *getprotobyname(const char *name)
     * }
     */
    public static MemorySegment getprotobyname(MemorySegment name) {
        var mh$ = getprotobyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprotobyname", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAStartup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSAStartup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData)
     * }
     */
    public static FunctionDescriptor WSAStartup$descriptor() {
        return WSAStartup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData)
     * }
     */
    public static MethodHandle WSAStartup$handle() {
        return WSAStartup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData)
     * }
     */
    public static MemorySegment WSAStartup$address() {
        return WSAStartup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData)
     * }
     */
    public static int WSAStartup(short wVersionRequired, MemorySegment lpWSAData) {
        var mh$ = WSAStartup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAStartup", wVersionRequired, lpWSAData);
            }
            return (int)mh$.invokeExact(wVersionRequired, lpWSAData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSACleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSACleanup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSACleanup()
     * }
     */
    public static FunctionDescriptor WSACleanup$descriptor() {
        return WSACleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSACleanup()
     * }
     */
    public static MethodHandle WSACleanup$handle() {
        return WSACleanup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSACleanup()
     * }
     */
    public static MemorySegment WSACleanup$address() {
        return WSACleanup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSACleanup()
     * }
     */
    public static int WSACleanup() {
        var mh$ = WSACleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSACleanup");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSASetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSASetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WSASetLastError(int iError)
     * }
     */
    public static FunctionDescriptor WSASetLastError$descriptor() {
        return WSASetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WSASetLastError(int iError)
     * }
     */
    public static MethodHandle WSASetLastError$handle() {
        return WSASetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WSASetLastError(int iError)
     * }
     */
    public static MemorySegment WSASetLastError$address() {
        return WSASetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WSASetLastError(int iError)
     * }
     */
    public static void WSASetLastError(int iError) {
        var mh$ = WSASetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSASetLastError", iError);
            }
            mh$.invokeExact(iError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAGetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSAGetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAGetLastError()
     * }
     */
    public static FunctionDescriptor WSAGetLastError$descriptor() {
        return WSAGetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAGetLastError()
     * }
     */
    public static MethodHandle WSAGetLastError$handle() {
        return WSAGetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSAGetLastError()
     * }
     */
    public static MemorySegment WSAGetLastError$address() {
        return WSAGetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSAGetLastError()
     * }
     */
    public static int WSAGetLastError() {
        var mh$ = WSAGetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAGetLastError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAIsBlocking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSAIsBlocking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WSAIsBlocking()
     * }
     */
    public static FunctionDescriptor WSAIsBlocking$descriptor() {
        return WSAIsBlocking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WSAIsBlocking()
     * }
     */
    public static MethodHandle WSAIsBlocking$handle() {
        return WSAIsBlocking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WSAIsBlocking()
     * }
     */
    public static MemorySegment WSAIsBlocking$address() {
        return WSAIsBlocking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WSAIsBlocking()
     * }
     */
    public static int WSAIsBlocking() {
        var mh$ = WSAIsBlocking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAIsBlocking");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAUnhookBlockingHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSAUnhookBlockingHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAUnhookBlockingHook()
     * }
     */
    public static FunctionDescriptor WSAUnhookBlockingHook$descriptor() {
        return WSAUnhookBlockingHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAUnhookBlockingHook()
     * }
     */
    public static MethodHandle WSAUnhookBlockingHook$handle() {
        return WSAUnhookBlockingHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSAUnhookBlockingHook()
     * }
     */
    public static MemorySegment WSAUnhookBlockingHook$address() {
        return WSAUnhookBlockingHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSAUnhookBlockingHook()
     * }
     */
    public static int WSAUnhookBlockingHook() {
        var mh$ = WSAUnhookBlockingHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAUnhookBlockingHook");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSASetBlockingHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSASetBlockingHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FARPROC WSASetBlockingHook(FARPROC lpBlockFunc)
     * }
     */
    public static FunctionDescriptor WSASetBlockingHook$descriptor() {
        return WSASetBlockingHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FARPROC WSASetBlockingHook(FARPROC lpBlockFunc)
     * }
     */
    public static MethodHandle WSASetBlockingHook$handle() {
        return WSASetBlockingHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FARPROC WSASetBlockingHook(FARPROC lpBlockFunc)
     * }
     */
    public static MemorySegment WSASetBlockingHook$address() {
        return WSASetBlockingHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FARPROC WSASetBlockingHook(FARPROC lpBlockFunc)
     * }
     */
    public static MemorySegment WSASetBlockingHook(MemorySegment lpBlockFunc) {
        var mh$ = WSASetBlockingHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSASetBlockingHook", lpBlockFunc);
            }
            return (MemorySegment)mh$.invokeExact(lpBlockFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSACancelBlockingCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSACancelBlockingCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSACancelBlockingCall()
     * }
     */
    public static FunctionDescriptor WSACancelBlockingCall$descriptor() {
        return WSACancelBlockingCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSACancelBlockingCall()
     * }
     */
    public static MethodHandle WSACancelBlockingCall$handle() {
        return WSACancelBlockingCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSACancelBlockingCall()
     * }
     */
    public static MemorySegment WSACancelBlockingCall$address() {
        return WSACancelBlockingCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSACancelBlockingCall()
     * }
     */
    public static int WSACancelBlockingCall() {
        var mh$ = WSACancelBlockingCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSACancelBlockingCall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetServByName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSAAsyncGetServByName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByName(HWND hWnd, u_int wMsg, const char *name, const char *proto, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetServByName$descriptor() {
        return WSAAsyncGetServByName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByName(HWND hWnd, u_int wMsg, const char *name, const char *proto, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetServByName$handle() {
        return WSAAsyncGetServByName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByName(HWND hWnd, u_int wMsg, const char *name, const char *proto, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetServByName$address() {
        return WSAAsyncGetServByName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByName(HWND hWnd, u_int wMsg, const char *name, const char *proto, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetServByName(MemorySegment hWnd, int wMsg, MemorySegment name, MemorySegment proto, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetServByName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetServByName", hWnd, wMsg, name, proto, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, name, proto, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetServByPort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSAAsyncGetServByPort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port, const char *proto, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetServByPort$descriptor() {
        return WSAAsyncGetServByPort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port, const char *proto, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetServByPort$handle() {
        return WSAAsyncGetServByPort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port, const char *proto, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetServByPort$address() {
        return WSAAsyncGetServByPort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port, const char *proto, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetServByPort(MemorySegment hWnd, int wMsg, int port, MemorySegment proto, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetServByPort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetServByPort", hWnd, wMsg, port, proto, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, port, proto, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetProtoByName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSAAsyncGetProtoByName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetProtoByName$descriptor() {
        return WSAAsyncGetProtoByName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetProtoByName$handle() {
        return WSAAsyncGetProtoByName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetProtoByName$address() {
        return WSAAsyncGetProtoByName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetProtoByName(MemorySegment hWnd, int wMsg, MemorySegment name, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetProtoByName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetProtoByName", hWnd, wMsg, name, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, name, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetProtoByNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSAAsyncGetProtoByNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg, int number, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetProtoByNumber$descriptor() {
        return WSAAsyncGetProtoByNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg, int number, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetProtoByNumber$handle() {
        return WSAAsyncGetProtoByNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg, int number, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetProtoByNumber$address() {
        return WSAAsyncGetProtoByNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg, int number, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetProtoByNumber(MemorySegment hWnd, int wMsg, int number, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetProtoByNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetProtoByNumber", hWnd, wMsg, number, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, number, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetHostByName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSAAsyncGetHostByName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetHostByName$descriptor() {
        return WSAAsyncGetHostByName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetHostByName$handle() {
        return WSAAsyncGetHostByName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetHostByName$address() {
        return WSAAsyncGetHostByName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetHostByName(MemorySegment hWnd, int wMsg, MemorySegment name, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetHostByName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetHostByName", hWnd, wMsg, name, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, name, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetHostByAddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSAAsyncGetHostByAddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg, const char *addr, int len, int type, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetHostByAddr$descriptor() {
        return WSAAsyncGetHostByAddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg, const char *addr, int len, int type, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetHostByAddr$handle() {
        return WSAAsyncGetHostByAddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg, const char *addr, int len, int type, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetHostByAddr$address() {
        return WSAAsyncGetHostByAddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg, const char *addr, int len, int type, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetHostByAddr(MemorySegment hWnd, int wMsg, MemorySegment addr, int len, int type, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetHostByAddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetHostByAddr", hWnd, wMsg, addr, len, type, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, addr, len, type, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSACancelAsyncRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSACancelAsyncRequest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSACancelAsyncRequest(HANDLE hAsyncTaskHandle)
     * }
     */
    public static FunctionDescriptor WSACancelAsyncRequest$descriptor() {
        return WSACancelAsyncRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSACancelAsyncRequest(HANDLE hAsyncTaskHandle)
     * }
     */
    public static MethodHandle WSACancelAsyncRequest$handle() {
        return WSACancelAsyncRequest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSACancelAsyncRequest(HANDLE hAsyncTaskHandle)
     * }
     */
    public static MemorySegment WSACancelAsyncRequest$address() {
        return WSACancelAsyncRequest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSACancelAsyncRequest(HANDLE hAsyncTaskHandle)
     * }
     */
    public static int WSACancelAsyncRequest(MemorySegment hAsyncTaskHandle) {
        var mh$ = WSACancelAsyncRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSACancelAsyncRequest", hAsyncTaskHandle);
            }
            return (int)mh$.invokeExact(hAsyncTaskHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncSelect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSAAsyncSelect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg, long lEvent)
     * }
     */
    public static FunctionDescriptor WSAAsyncSelect$descriptor() {
        return WSAAsyncSelect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg, long lEvent)
     * }
     */
    public static MethodHandle WSAAsyncSelect$handle() {
        return WSAAsyncSelect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg, long lEvent)
     * }
     */
    public static MemorySegment WSAAsyncSelect$address() {
        return WSAAsyncSelect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg, long lEvent)
     * }
     */
    public static int WSAAsyncSelect(long s, MemorySegment hWnd, int wMsg, int lEvent) {
        var mh$ = WSAAsyncSelect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncSelect", s, hWnd, wMsg, lEvent);
            }
            return (int)mh$.invokeExact(s, hWnd, wMsg, lEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSARecvEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WSARecvEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSARecvEx(SOCKET s, char *buf, int len, int *flags)
     * }
     */
    public static FunctionDescriptor WSARecvEx$descriptor() {
        return WSARecvEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSARecvEx(SOCKET s, char *buf, int len, int *flags)
     * }
     */
    public static MethodHandle WSARecvEx$handle() {
        return WSARecvEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSARecvEx(SOCKET s, char *buf, int len, int *flags)
     * }
     */
    public static MemorySegment WSARecvEx$address() {
        return WSARecvEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSARecvEx(SOCKET s, char *buf, int len, int *flags)
     * }
     */
    public static int WSARecvEx(long s, MemorySegment buf, int len, MemorySegment flags) {
        var mh$ = WSARecvEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSARecvEx", s, buf, len, flags);
            }
            return (int)mh$.invokeExact(s, buf, len, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSMIT_FILE_BUFFERS {
     *     PVOID Head;
     *     DWORD HeadLength;
     *     PVOID Tail;
     *     DWORD TailLength;
     * } *PTRANSMIT_FILE_BUFFERS
     * }
     */
    public static final AddressLayout PTRANSMIT_FILE_BUFFERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSMIT_FILE_BUFFERS {
     *     PVOID Head;
     *     DWORD HeadLength;
     *     PVOID Tail;
     *     DWORD TailLength;
     * } *LPTRANSMIT_FILE_BUFFERS
     * }
     */
    public static final AddressLayout LPTRANSMIT_FILE_BUFFERS = wgl_h.C_POINTER;

    private static class TransmitFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TransmitFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransmitFile(SOCKET hSocket, HANDLE hFile, DWORD nNumberOfBytesToWrite, DWORD nNumberOfBytesPerSend, LPOVERLAPPED lpOverlapped, LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, DWORD dwReserved)
     * }
     */
    public static FunctionDescriptor TransmitFile$descriptor() {
        return TransmitFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransmitFile(SOCKET hSocket, HANDLE hFile, DWORD nNumberOfBytesToWrite, DWORD nNumberOfBytesPerSend, LPOVERLAPPED lpOverlapped, LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, DWORD dwReserved)
     * }
     */
    public static MethodHandle TransmitFile$handle() {
        return TransmitFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TransmitFile(SOCKET hSocket, HANDLE hFile, DWORD nNumberOfBytesToWrite, DWORD nNumberOfBytesPerSend, LPOVERLAPPED lpOverlapped, LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, DWORD dwReserved)
     * }
     */
    public static MemorySegment TransmitFile$address() {
        return TransmitFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TransmitFile(SOCKET hSocket, HANDLE hFile, DWORD nNumberOfBytesToWrite, DWORD nNumberOfBytesPerSend, LPOVERLAPPED lpOverlapped, LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, DWORD dwReserved)
     * }
     */
    public static int TransmitFile(long hSocket, MemorySegment hFile, int nNumberOfBytesToWrite, int nNumberOfBytesPerSend, MemorySegment lpOverlapped, MemorySegment lpTransmitBuffers, int dwReserved) {
        var mh$ = TransmitFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmitFile", hSocket, hFile, nNumberOfBytesToWrite, nNumberOfBytesPerSend, lpOverlapped, lpTransmitBuffers, dwReserved);
            }
            return (int)mh$.invokeExact(hSocket, hFile, nNumberOfBytesToWrite, nNumberOfBytesPerSend, lpOverlapped, lpTransmitBuffers, dwReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcceptEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AcceptEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AcceptEx(SOCKET sListenSocket, SOCKET sAcceptSocket, PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, LPDWORD lpdwBytesReceived, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor AcceptEx$descriptor() {
        return AcceptEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AcceptEx(SOCKET sListenSocket, SOCKET sAcceptSocket, PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, LPDWORD lpdwBytesReceived, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle AcceptEx$handle() {
        return AcceptEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AcceptEx(SOCKET sListenSocket, SOCKET sAcceptSocket, PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, LPDWORD lpdwBytesReceived, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment AcceptEx$address() {
        return AcceptEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AcceptEx(SOCKET sListenSocket, SOCKET sAcceptSocket, PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, LPDWORD lpdwBytesReceived, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int AcceptEx(long sListenSocket, long sAcceptSocket, MemorySegment lpOutputBuffer, int dwReceiveDataLength, int dwLocalAddressLength, int dwRemoteAddressLength, MemorySegment lpdwBytesReceived, MemorySegment lpOverlapped) {
        var mh$ = AcceptEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcceptEx", sListenSocket, sAcceptSocket, lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, lpdwBytesReceived, lpOverlapped);
            }
            return (int)mh$.invokeExact(sListenSocket, sAcceptSocket, lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, lpdwBytesReceived, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAcceptExSockaddrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetAcceptExSockaddrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetAcceptExSockaddrs(PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, struct sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, struct sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength)
     * }
     */
    public static FunctionDescriptor GetAcceptExSockaddrs$descriptor() {
        return GetAcceptExSockaddrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetAcceptExSockaddrs(PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, struct sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, struct sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength)
     * }
     */
    public static MethodHandle GetAcceptExSockaddrs$handle() {
        return GetAcceptExSockaddrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetAcceptExSockaddrs(PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, struct sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, struct sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength)
     * }
     */
    public static MemorySegment GetAcceptExSockaddrs$address() {
        return GetAcceptExSockaddrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetAcceptExSockaddrs(PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, struct sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, struct sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength)
     * }
     */
    public static void GetAcceptExSockaddrs(MemorySegment lpOutputBuffer, int dwReceiveDataLength, int dwLocalAddressLength, int dwRemoteAddressLength, MemorySegment LocalSockaddr, MemorySegment LocalSockaddrLength, MemorySegment RemoteSockaddr, MemorySegment RemoteSockaddrLength) {
        var mh$ = GetAcceptExSockaddrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAcceptExSockaddrs", lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, LocalSockaddr, LocalSockaddrLength, RemoteSockaddr, RemoteSockaddrLength);
            }
            mh$.invokeExact(lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, LocalSockaddr, LocalSockaddrLength, RemoteSockaddr, RemoteSockaddrLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct sockaddr {
     *     u_short sa_family;
     *     char sa_data[14];
     * } *PSOCKADDR
     * }
     */
    public static final AddressLayout PSOCKADDR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct sockaddr {
     *     u_short sa_family;
     *     char sa_data[14];
     * } *LPSOCKADDR
     * }
     */
    public static final AddressLayout LPSOCKADDR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct sockaddr_in {
     *     short sin_family;
     *     u_short sin_port;
     *     struct in_addr sin_addr;
     *     char sin_zero[8];
     * } *PSOCKADDR_IN
     * }
     */
    public static final AddressLayout PSOCKADDR_IN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct sockaddr_in {
     *     short sin_family;
     *     u_short sin_port;
     *     struct in_addr sin_addr;
     *     char sin_zero[8];
     * } *LPSOCKADDR_IN
     * }
     */
    public static final AddressLayout LPSOCKADDR_IN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct linger {
     *     u_short l_onoff;
     *     u_short l_linger;
     * } *PLINGER
     * }
     */
    public static final AddressLayout PLINGER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct linger {
     *     u_short l_onoff;
     *     u_short l_linger;
     * } *LPLINGER
     * }
     */
    public static final AddressLayout LPLINGER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct fd_set {
     *     u_int fd_count;
     *     SOCKET fd_array[64];
     * } *PFD_SET
     * }
     */
    public static final AddressLayout PFD_SET = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct fd_set {
     *     u_int fd_count;
     *     SOCKET fd_array[64];
     * } *LPFD_SET
     * }
     */
    public static final AddressLayout LPFD_SET = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct hostent {
     *     char *h_name;
     *     char **h_aliases;
     *     short h_addrtype;
     *     short h_length;
     *     char **h_addr_list;
     * } *PHOSTENT
     * }
     */
    public static final AddressLayout PHOSTENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct hostent {
     *     char *h_name;
     *     char **h_aliases;
     *     short h_addrtype;
     *     short h_length;
     *     char **h_addr_list;
     * } *LPHOSTENT
     * }
     */
    public static final AddressLayout LPHOSTENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct servent {
     *     char *s_name;
     *     char **s_aliases;
     *     char *s_proto;
     *     short s_port;
     * } *PSERVENT
     * }
     */
    public static final AddressLayout PSERVENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct servent {
     *     char *s_name;
     *     char **s_aliases;
     *     char *s_proto;
     *     short s_port;
     * } *LPSERVENT
     * }
     */
    public static final AddressLayout LPSERVENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct protoent {
     *     char *p_name;
     *     char **p_aliases;
     *     short p_proto;
     * } *PPROTOENT
     * }
     */
    public static final AddressLayout PPROTOENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct protoent {
     *     char *p_name;
     *     char **p_aliases;
     *     short p_proto;
     * } *LPPROTOENT
     * }
     */
    public static final AddressLayout LPPROTOENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct timeval {
     *     long tv_sec;
     *     long tv_usec;
     * } *PTIMEVAL
     * }
     */
    public static final AddressLayout PTIMEVAL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct timeval {
     *     long tv_sec;
     *     long tv_usec;
     * } *LPTIMEVAL
     * }
     */
    public static final AddressLayout LPTIMEVAL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned int ALG_ID
     * }
     */
    public static final OfInt ALG_ID = wgl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR HCRYPTPROV
     * }
     */
    public static final OfLong HCRYPTPROV = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR HCRYPTKEY
     * }
     */
    public static final OfLong HCRYPTKEY = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR HCRYPTHASH
     * }
     */
    public static final OfLong HCRYPTHASH = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _CMS_KEY_INFO {
     *     DWORD dwVersion;
     *     ALG_ID Algid;
     *     BYTE *pbOID;
     *     DWORD cbOID;
     * } *PCMS_KEY_INFO
     * }
     */
    public static final AddressLayout PCMS_KEY_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _HMAC_Info {
     *     ALG_ID HashAlgid;
     *     BYTE *pbInnerString;
     *     DWORD cbInnerString;
     *     BYTE *pbOuterString;
     *     DWORD cbOuterString;
     * } *PHMAC_INFO
     * }
     */
    public static final AddressLayout PHMAC_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SCHANNEL_ALG {
     *     DWORD dwUse;
     *     ALG_ID Algid;
     *     DWORD cBits;
     *     DWORD dwFlags;
     *     DWORD dwReserved;
     * } *PSCHANNEL_ALG
     * }
     */
    public static final AddressLayout PSCHANNEL_ALG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KEY_TYPE_SUBTYPE {
     *     DWORD dwKeySpec;
     *     GUID Type;
     *     GUID Subtype;
     * } *PKEY_TYPE_SUBTYPE
     * }
     */
    public static final AddressLayout PKEY_TYPE_SUBTYPE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RC4_KEY_STATE {
     *     unsigned char Key[16];
     *     unsigned char SBox[256];
     *     unsigned char i;
     *     unsigned char j;
     * } *PCRYPT_RC4_KEY_STATE
     * }
     */
    public static final AddressLayout PCRYPT_RC4_KEY_STATE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_DES_KEY_STATE {
     *     unsigned char Key[8];
     *     unsigned char IV[8];
     *     unsigned char Feedback[8];
     * } *PCRYPT_DES_KEY_STATE
     * }
     */
    public static final AddressLayout PCRYPT_DES_KEY_STATE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_3DES_KEY_STATE {
     *     unsigned char Key[24];
     *     unsigned char IV[8];
     *     unsigned char Feedback[8];
     * } *PCRYPT_3DES_KEY_STATE
     * }
     */
    public static final AddressLayout PCRYPT_3DES_KEY_STATE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_AES_128_KEY_STATE {
     *     unsigned char Key[16];
     *     unsigned char IV[16];
     *     unsigned char EncryptionState[11][16];
     *     unsigned char DecryptionState[11][16];
     *     unsigned char Feedback[16];
     * } *PCRYPT_AES_128_KEY_STATE
     * }
     */
    public static final AddressLayout PCRYPT_AES_128_KEY_STATE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_AES_256_KEY_STATE {
     *     unsigned char Key[32];
     *     unsigned char IV[16];
     *     unsigned char EncryptionState[15][16];
     *     unsigned char DecryptionState[15][16];
     *     unsigned char Feedback[16];
     * } *PCRYPT_AES_256_KEY_STATE
     * }
     */
    public static final AddressLayout PCRYPT_AES_256_KEY_STATE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_INTEGER_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_INTEGER_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_UINT_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_UINT_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_OBJID_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_OBJID_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCERT_NAME_BLOB
     * }
     */
    public static final AddressLayout PCERT_NAME_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCERT_RDN_VALUE_BLOB
     * }
     */
    public static final AddressLayout PCERT_RDN_VALUE_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCERT_BLOB
     * }
     */
    public static final AddressLayout PCERT_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRL_BLOB
     * }
     */
    public static final AddressLayout PCRL_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PDATA_BLOB
     * }
     */
    public static final AddressLayout PDATA_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_DATA_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_DATA_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_HASH_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_HASH_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_DIGEST_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_DIGEST_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_DER_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_DER_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_ATTR_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_ATTR_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMS_DH_KEY_INFO {
     *     DWORD dwVersion;
     *     ALG_ID Algid;
     *     LPSTR pszContentEncObjId;
     *     CRYPT_DATA_BLOB PubInfo;
     *     void *pReserved;
     * } *PCMS_DH_KEY_INFO
     * }
     */
    public static final AddressLayout PCMS_DH_KEY_INFO = wgl_h.C_POINTER;

    private static class CryptAcquireContextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptAcquireContextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptAcquireContextA$descriptor() {
        return CryptAcquireContextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptAcquireContextA$handle() {
        return CryptAcquireContextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptAcquireContextA$address() {
        return CryptAcquireContextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static int CryptAcquireContextA(MemorySegment phProv, MemorySegment szContainer, MemorySegment szProvider, int dwProvType, int dwFlags) {
        var mh$ = CryptAcquireContextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptAcquireContextA", phProv, szContainer, szProvider, dwProvType, dwFlags);
            }
            return (int)mh$.invokeExact(phProv, szContainer, szProvider, dwProvType, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptAcquireContextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptAcquireContextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptAcquireContextW(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptAcquireContextW$descriptor() {
        return CryptAcquireContextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptAcquireContextW(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptAcquireContextW$handle() {
        return CryptAcquireContextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptAcquireContextW(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptAcquireContextW$address() {
        return CryptAcquireContextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptAcquireContextW(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static int CryptAcquireContextW(MemorySegment phProv, MemorySegment szContainer, MemorySegment szProvider, int dwProvType, int dwFlags) {
        var mh$ = CryptAcquireContextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptAcquireContextW", phProv, szContainer, szProvider, dwProvType, dwFlags);
            }
            return (int)mh$.invokeExact(phProv, szContainer, szProvider, dwProvType, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptReleaseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptReleaseContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptReleaseContext$descriptor() {
        return CryptReleaseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptReleaseContext$handle() {
        return CryptReleaseContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptReleaseContext$address() {
        return CryptReleaseContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags)
     * }
     */
    public static int CryptReleaseContext(long hProv, int dwFlags) {
        var mh$ = CryptReleaseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptReleaseContext", hProv, dwFlags);
            }
            return (int)mh$.invokeExact(hProv, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGenKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGenKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGenKey(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptGenKey$descriptor() {
        return CryptGenKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGenKey(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptGenKey$handle() {
        return CryptGenKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGenKey(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MemorySegment CryptGenKey$address() {
        return CryptGenKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGenKey(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptGenKey(long hProv, int Algid, int dwFlags, MemorySegment phKey) {
        var mh$ = CryptGenKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGenKey", hProv, Algid, dwFlags, phKey);
            }
            return (int)mh$.invokeExact(hProv, Algid, dwFlags, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDeriveKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptDeriveKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptDeriveKey$descriptor() {
        return CryptDeriveKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptDeriveKey$handle() {
        return CryptDeriveKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MemorySegment CryptDeriveKey$address() {
        return CryptDeriveKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptDeriveKey(long hProv, int Algid, long hBaseData, int dwFlags, MemorySegment phKey) {
        var mh$ = CryptDeriveKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDeriveKey", hProv, Algid, hBaseData, dwFlags, phKey);
            }
            return (int)mh$.invokeExact(hProv, Algid, hBaseData, dwFlags, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDestroyKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptDestroyKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDestroyKey(HCRYPTKEY hKey)
     * }
     */
    public static FunctionDescriptor CryptDestroyKey$descriptor() {
        return CryptDestroyKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDestroyKey(HCRYPTKEY hKey)
     * }
     */
    public static MethodHandle CryptDestroyKey$handle() {
        return CryptDestroyKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDestroyKey(HCRYPTKEY hKey)
     * }
     */
    public static MemorySegment CryptDestroyKey$address() {
        return CryptDestroyKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDestroyKey(HCRYPTKEY hKey)
     * }
     */
    public static int CryptDestroyKey(long hKey) {
        var mh$ = CryptDestroyKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDestroyKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetKeyParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSetKeyParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetKeyParam(HCRYPTKEY hKey, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptSetKeyParam$descriptor() {
        return CryptSetKeyParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetKeyParam(HCRYPTKEY hKey, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptSetKeyParam$handle() {
        return CryptSetKeyParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetKeyParam(HCRYPTKEY hKey, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptSetKeyParam$address() {
        return CryptSetKeyParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetKeyParam(HCRYPTKEY hKey, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static int CryptSetKeyParam(long hKey, int dwParam, MemorySegment pbData, int dwFlags) {
        var mh$ = CryptSetKeyParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetKeyParam", hKey, dwParam, pbData, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, dwParam, pbData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetKeyParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetKeyParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetKeyParam(HCRYPTKEY hKey, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptGetKeyParam$descriptor() {
        return CryptGetKeyParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetKeyParam(HCRYPTKEY hKey, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptGetKeyParam$handle() {
        return CryptGetKeyParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetKeyParam(HCRYPTKEY hKey, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptGetKeyParam$address() {
        return CryptGetKeyParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetKeyParam(HCRYPTKEY hKey, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static int CryptGetKeyParam(long hKey, int dwParam, MemorySegment pbData, MemorySegment pdwDataLen, int dwFlags) {
        var mh$ = CryptGetKeyParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetKeyParam", hKey, dwParam, pbData, pdwDataLen, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, dwParam, pbData, pdwDataLen, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetHashParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSetHashParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetHashParam(HCRYPTHASH hHash, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptSetHashParam$descriptor() {
        return CryptSetHashParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetHashParam(HCRYPTHASH hHash, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptSetHashParam$handle() {
        return CryptSetHashParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetHashParam(HCRYPTHASH hHash, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptSetHashParam$address() {
        return CryptSetHashParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetHashParam(HCRYPTHASH hHash, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static int CryptSetHashParam(long hHash, int dwParam, MemorySegment pbData, int dwFlags) {
        var mh$ = CryptSetHashParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetHashParam", hHash, dwParam, pbData, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, dwParam, pbData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetHashParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetHashParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptGetHashParam$descriptor() {
        return CryptGetHashParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptGetHashParam$handle() {
        return CryptGetHashParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptGetHashParam$address() {
        return CryptGetHashParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static int CryptGetHashParam(long hHash, int dwParam, MemorySegment pbData, MemorySegment pdwDataLen, int dwFlags) {
        var mh$ = CryptGetHashParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetHashParam", hHash, dwParam, pbData, pdwDataLen, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, dwParam, pbData, pdwDataLen, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetProvParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSetProvParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetProvParam(HCRYPTPROV hProv, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptSetProvParam$descriptor() {
        return CryptSetProvParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetProvParam(HCRYPTPROV hProv, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptSetProvParam$handle() {
        return CryptSetProvParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetProvParam(HCRYPTPROV hProv, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptSetProvParam$address() {
        return CryptSetProvParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetProvParam(HCRYPTPROV hProv, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static int CryptSetProvParam(long hProv, int dwParam, MemorySegment pbData, int dwFlags) {
        var mh$ = CryptSetProvParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetProvParam", hProv, dwParam, pbData, dwFlags);
            }
            return (int)mh$.invokeExact(hProv, dwParam, pbData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetProvParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetProvParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetProvParam(HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptGetProvParam$descriptor() {
        return CryptGetProvParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetProvParam(HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptGetProvParam$handle() {
        return CryptGetProvParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetProvParam(HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptGetProvParam$address() {
        return CryptGetProvParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetProvParam(HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static int CryptGetProvParam(long hProv, int dwParam, MemorySegment pbData, MemorySegment pdwDataLen, int dwFlags) {
        var mh$ = CryptGetProvParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetProvParam", hProv, dwParam, pbData, pdwDataLen, dwFlags);
            }
            return (int)mh$.invokeExact(hProv, dwParam, pbData, pdwDataLen, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGenRandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGenRandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer)
     * }
     */
    public static FunctionDescriptor CryptGenRandom$descriptor() {
        return CryptGenRandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer)
     * }
     */
    public static MethodHandle CryptGenRandom$handle() {
        return CryptGenRandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer)
     * }
     */
    public static MemorySegment CryptGenRandom$address() {
        return CryptGenRandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer)
     * }
     */
    public static int CryptGenRandom(long hProv, int dwLen, MemorySegment pbBuffer) {
        var mh$ = CryptGenRandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGenRandom", hProv, dwLen, pbBuffer);
            }
            return (int)mh$.invokeExact(hProv, dwLen, pbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetUserKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetUserKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetUserKey(HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY *phUserKey)
     * }
     */
    public static FunctionDescriptor CryptGetUserKey$descriptor() {
        return CryptGetUserKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetUserKey(HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY *phUserKey)
     * }
     */
    public static MethodHandle CryptGetUserKey$handle() {
        return CryptGetUserKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetUserKey(HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY *phUserKey)
     * }
     */
    public static MemorySegment CryptGetUserKey$address() {
        return CryptGetUserKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetUserKey(HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY *phUserKey)
     * }
     */
    public static int CryptGetUserKey(long hProv, int dwKeySpec, MemorySegment phUserKey) {
        var mh$ = CryptGetUserKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetUserKey", hProv, dwKeySpec, phUserKey);
            }
            return (int)mh$.invokeExact(hProv, dwKeySpec, phUserKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptExportKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportKey(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static FunctionDescriptor CryptExportKey$descriptor() {
        return CryptExportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportKey(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static MethodHandle CryptExportKey$handle() {
        return CryptExportKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptExportKey(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static MemorySegment CryptExportKey$address() {
        return CryptExportKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptExportKey(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static int CryptExportKey(long hKey, long hExpKey, int dwBlobType, int dwFlags, MemorySegment pbData, MemorySegment pdwDataLen) {
        var mh$ = CryptExportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportKey", hKey, hExpKey, dwBlobType, dwFlags, pbData, pdwDataLen);
            }
            return (int)mh$.invokeExact(hKey, hExpKey, dwBlobType, dwFlags, pbData, pdwDataLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptImportKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportKey(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptImportKey$descriptor() {
        return CryptImportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportKey(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptImportKey$handle() {
        return CryptImportKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptImportKey(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MemorySegment CryptImportKey$address() {
        return CryptImportKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptImportKey(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptImportKey(long hProv, MemorySegment pbData, int dwDataLen, long hPubKey, int dwFlags, MemorySegment phKey) {
        var mh$ = CryptImportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportKey", hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey);
            }
            return (int)mh$.invokeExact(hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEncrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptEncrypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor CryptEncrypt$descriptor() {
        return CryptEncrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen)
     * }
     */
    public static MethodHandle CryptEncrypt$handle() {
        return CryptEncrypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen)
     * }
     */
    public static MemorySegment CryptEncrypt$address() {
        return CryptEncrypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen)
     * }
     */
    public static int CryptEncrypt(long hKey, long hHash, int Final, int dwFlags, MemorySegment pbData, MemorySegment pdwDataLen, int dwBufLen) {
        var mh$ = CryptEncrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEncrypt", hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);
            }
            return (int)mh$.invokeExact(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptDecrypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static FunctionDescriptor CryptDecrypt$descriptor() {
        return CryptDecrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static MethodHandle CryptDecrypt$handle() {
        return CryptDecrypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static MemorySegment CryptDecrypt$address() {
        return CryptDecrypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static int CryptDecrypt(long hKey, long hHash, int Final, int dwFlags, MemorySegment pbData, MemorySegment pdwDataLen) {
        var mh$ = CryptDecrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecrypt", hKey, hHash, Final, dwFlags, pbData, pdwDataLen);
            }
            return (int)mh$.invokeExact(hKey, hHash, Final, dwFlags, pbData, pdwDataLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptCreateHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptCreateHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static FunctionDescriptor CryptCreateHash$descriptor() {
        return CryptCreateHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static MethodHandle CryptCreateHash$handle() {
        return CryptCreateHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static MemorySegment CryptCreateHash$address() {
        return CryptCreateHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static int CryptCreateHash(long hProv, int Algid, long hKey, int dwFlags, MemorySegment phHash) {
        var mh$ = CryptCreateHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptCreateHash", hProv, Algid, hKey, dwFlags, phHash);
            }
            return (int)mh$.invokeExact(hProv, Algid, hKey, dwFlags, phHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptHashData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptHashData$descriptor() {
        return CryptHashData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptHashData$handle() {
        return CryptHashData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptHashData$address() {
        return CryptHashData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags)
     * }
     */
    public static int CryptHashData(long hHash, MemorySegment pbData, int dwDataLen, int dwFlags) {
        var mh$ = CryptHashData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashData", hHash, pbData, dwDataLen, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbData, dwDataLen, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashSessionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptHashSessionKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashSessionKey(HCRYPTHASH hHash, HCRYPTKEY hKey, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptHashSessionKey$descriptor() {
        return CryptHashSessionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashSessionKey(HCRYPTHASH hHash, HCRYPTKEY hKey, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptHashSessionKey$handle() {
        return CryptHashSessionKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashSessionKey(HCRYPTHASH hHash, HCRYPTKEY hKey, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptHashSessionKey$address() {
        return CryptHashSessionKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashSessionKey(HCRYPTHASH hHash, HCRYPTKEY hKey, DWORD dwFlags)
     * }
     */
    public static int CryptHashSessionKey(long hHash, long hKey, int dwFlags) {
        var mh$ = CryptHashSessionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashSessionKey", hHash, hKey, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, hKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDestroyHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptDestroyHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDestroyHash(HCRYPTHASH hHash)
     * }
     */
    public static FunctionDescriptor CryptDestroyHash$descriptor() {
        return CryptDestroyHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDestroyHash(HCRYPTHASH hHash)
     * }
     */
    public static MethodHandle CryptDestroyHash$handle() {
        return CryptDestroyHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDestroyHash(HCRYPTHASH hHash)
     * }
     */
    public static MemorySegment CryptDestroyHash$address() {
        return CryptDestroyHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDestroyHash(HCRYPTHASH hHash)
     * }
     */
    public static int CryptDestroyHash(long hHash) {
        var mh$ = CryptDestroyHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDestroyHash", hHash);
            }
            return (int)mh$.invokeExact(hHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignHashA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSignHashA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignHashA(HCRYPTHASH hHash, DWORD dwKeySpec, LPCSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static FunctionDescriptor CryptSignHashA$descriptor() {
        return CryptSignHashA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignHashA(HCRYPTHASH hHash, DWORD dwKeySpec, LPCSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static MethodHandle CryptSignHashA$handle() {
        return CryptSignHashA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignHashA(HCRYPTHASH hHash, DWORD dwKeySpec, LPCSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static MemorySegment CryptSignHashA$address() {
        return CryptSignHashA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignHashA(HCRYPTHASH hHash, DWORD dwKeySpec, LPCSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static int CryptSignHashA(long hHash, int dwKeySpec, MemorySegment szDescription, int dwFlags, MemorySegment pbSignature, MemorySegment pdwSigLen) {
        var mh$ = CryptSignHashA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignHashA", hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen);
            }
            return (int)mh$.invokeExact(hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignHashW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSignHashW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignHashW(HCRYPTHASH hHash, DWORD dwKeySpec, LPCWSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static FunctionDescriptor CryptSignHashW$descriptor() {
        return CryptSignHashW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignHashW(HCRYPTHASH hHash, DWORD dwKeySpec, LPCWSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static MethodHandle CryptSignHashW$handle() {
        return CryptSignHashW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignHashW(HCRYPTHASH hHash, DWORD dwKeySpec, LPCWSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static MemorySegment CryptSignHashW$address() {
        return CryptSignHashW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignHashW(HCRYPTHASH hHash, DWORD dwKeySpec, LPCWSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static int CryptSignHashW(long hHash, int dwKeySpec, MemorySegment szDescription, int dwFlags, MemorySegment pbSignature, MemorySegment pdwSigLen) {
        var mh$ = CryptSignHashW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignHashW", hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen);
            }
            return (int)mh$.invokeExact(hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifySignatureA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptVerifySignatureA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureA(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCSTR szDescription, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptVerifySignatureA$descriptor() {
        return CryptVerifySignatureA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureA(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCSTR szDescription, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptVerifySignatureA$handle() {
        return CryptVerifySignatureA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureA(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCSTR szDescription, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptVerifySignatureA$address() {
        return CryptVerifySignatureA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureA(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCSTR szDescription, DWORD dwFlags)
     * }
     */
    public static int CryptVerifySignatureA(long hHash, MemorySegment pbSignature, int dwSigLen, long hPubKey, MemorySegment szDescription, int dwFlags) {
        var mh$ = CryptVerifySignatureA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifySignatureA", hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifySignatureW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptVerifySignatureW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureW(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCWSTR szDescription, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptVerifySignatureW$descriptor() {
        return CryptVerifySignatureW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureW(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCWSTR szDescription, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptVerifySignatureW$handle() {
        return CryptVerifySignatureW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureW(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCWSTR szDescription, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptVerifySignatureW$address() {
        return CryptVerifySignatureW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureW(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCWSTR szDescription, DWORD dwFlags)
     * }
     */
    public static int CryptVerifySignatureW(long hHash, MemorySegment pbSignature, int dwSigLen, long hPubKey, MemorySegment szDescription, int dwFlags) {
        var mh$ = CryptVerifySignatureW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifySignatureW", hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetProviderA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSetProviderA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderA(LPCSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static FunctionDescriptor CryptSetProviderA$descriptor() {
        return CryptSetProviderA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderA(LPCSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static MethodHandle CryptSetProviderA$handle() {
        return CryptSetProviderA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderA(LPCSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static MemorySegment CryptSetProviderA$address() {
        return CryptSetProviderA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetProviderA(LPCSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static int CryptSetProviderA(MemorySegment pszProvName, int dwProvType) {
        var mh$ = CryptSetProviderA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetProviderA", pszProvName, dwProvType);
            }
            return (int)mh$.invokeExact(pszProvName, dwProvType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetProviderW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSetProviderW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderW(LPCWSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static FunctionDescriptor CryptSetProviderW$descriptor() {
        return CryptSetProviderW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderW(LPCWSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static MethodHandle CryptSetProviderW$handle() {
        return CryptSetProviderW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderW(LPCWSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static MemorySegment CryptSetProviderW$address() {
        return CryptSetProviderW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetProviderW(LPCWSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static int CryptSetProviderW(MemorySegment pszProvName, int dwProvType) {
        var mh$ = CryptSetProviderW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetProviderW", pszProvName, dwProvType);
            }
            return (int)mh$.invokeExact(pszProvName, dwProvType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetProviderExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSetProviderExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderExA(LPCSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptSetProviderExA$descriptor() {
        return CryptSetProviderExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderExA(LPCSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptSetProviderExA$handle() {
        return CryptSetProviderExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderExA(LPCSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptSetProviderExA$address() {
        return CryptSetProviderExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetProviderExA(LPCSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static int CryptSetProviderExA(MemorySegment pszProvName, int dwProvType, MemorySegment pdwReserved, int dwFlags) {
        var mh$ = CryptSetProviderExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetProviderExA", pszProvName, dwProvType, pdwReserved, dwFlags);
            }
            return (int)mh$.invokeExact(pszProvName, dwProvType, pdwReserved, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetProviderExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSetProviderExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderExW(LPCWSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptSetProviderExW$descriptor() {
        return CryptSetProviderExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderExW(LPCWSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptSetProviderExW$handle() {
        return CryptSetProviderExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderExW(LPCWSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptSetProviderExW$address() {
        return CryptSetProviderExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetProviderExW(LPCWSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static int CryptSetProviderExW(MemorySegment pszProvName, int dwProvType, MemorySegment pdwReserved, int dwFlags) {
        var mh$ = CryptSetProviderExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetProviderExW", pszProvName, dwProvType, pdwReserved, dwFlags);
            }
            return (int)mh$.invokeExact(pszProvName, dwProvType, pdwReserved, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetDefaultProviderA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetDefaultProviderA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderA(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static FunctionDescriptor CryptGetDefaultProviderA$descriptor() {
        return CryptGetDefaultProviderA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderA(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static MethodHandle CryptGetDefaultProviderA$handle() {
        return CryptGetDefaultProviderA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderA(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static MemorySegment CryptGetDefaultProviderA$address() {
        return CryptGetDefaultProviderA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderA(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static int CryptGetDefaultProviderA(int dwProvType, MemorySegment pdwReserved, int dwFlags, MemorySegment pszProvName, MemorySegment pcbProvName) {
        var mh$ = CryptGetDefaultProviderA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetDefaultProviderA", dwProvType, pdwReserved, dwFlags, pszProvName, pcbProvName);
            }
            return (int)mh$.invokeExact(dwProvType, pdwReserved, dwFlags, pszProvName, pcbProvName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetDefaultProviderW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetDefaultProviderW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderW(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPWSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static FunctionDescriptor CryptGetDefaultProviderW$descriptor() {
        return CryptGetDefaultProviderW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderW(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPWSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static MethodHandle CryptGetDefaultProviderW$handle() {
        return CryptGetDefaultProviderW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderW(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPWSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static MemorySegment CryptGetDefaultProviderW$address() {
        return CryptGetDefaultProviderW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderW(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPWSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static int CryptGetDefaultProviderW(int dwProvType, MemorySegment pdwReserved, int dwFlags, MemorySegment pszProvName, MemorySegment pcbProvName) {
        var mh$ = CryptGetDefaultProviderW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetDefaultProviderW", dwProvType, pdwReserved, dwFlags, pszProvName, pcbProvName);
            }
            return (int)mh$.invokeExact(dwProvType, pdwReserved, dwFlags, pszProvName, pcbProvName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumProviderTypesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptEnumProviderTypesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static FunctionDescriptor CryptEnumProviderTypesA$descriptor() {
        return CryptEnumProviderTypesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static MethodHandle CryptEnumProviderTypesA$handle() {
        return CryptEnumProviderTypesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static MemorySegment CryptEnumProviderTypesA$address() {
        return CryptEnumProviderTypesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static int CryptEnumProviderTypesA(int dwIndex, MemorySegment pdwReserved, int dwFlags, MemorySegment pdwProvType, MemorySegment szTypeName, MemorySegment pcbTypeName) {
        var mh$ = CryptEnumProviderTypesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumProviderTypesA", dwIndex, pdwReserved, dwFlags, pdwProvType, szTypeName, pcbTypeName);
            }
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szTypeName, pcbTypeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumProviderTypesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptEnumProviderTypesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static FunctionDescriptor CryptEnumProviderTypesW$descriptor() {
        return CryptEnumProviderTypesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static MethodHandle CryptEnumProviderTypesW$handle() {
        return CryptEnumProviderTypesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static MemorySegment CryptEnumProviderTypesW$address() {
        return CryptEnumProviderTypesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static int CryptEnumProviderTypesW(int dwIndex, MemorySegment pdwReserved, int dwFlags, MemorySegment pdwProvType, MemorySegment szTypeName, MemorySegment pcbTypeName) {
        var mh$ = CryptEnumProviderTypesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumProviderTypesW", dwIndex, pdwReserved, dwFlags, pdwProvType, szTypeName, pcbTypeName);
            }
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szTypeName, pcbTypeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumProvidersA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptEnumProvidersA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static FunctionDescriptor CryptEnumProvidersA$descriptor() {
        return CryptEnumProvidersA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static MethodHandle CryptEnumProvidersA$handle() {
        return CryptEnumProvidersA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static MemorySegment CryptEnumProvidersA$address() {
        return CryptEnumProvidersA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static int CryptEnumProvidersA(int dwIndex, MemorySegment pdwReserved, int dwFlags, MemorySegment pdwProvType, MemorySegment szProvName, MemorySegment pcbProvName) {
        var mh$ = CryptEnumProvidersA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumProvidersA", dwIndex, pdwReserved, dwFlags, pdwProvType, szProvName, pcbProvName);
            }
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szProvName, pcbProvName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumProvidersW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptEnumProvidersW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static FunctionDescriptor CryptEnumProvidersW$descriptor() {
        return CryptEnumProvidersW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static MethodHandle CryptEnumProvidersW$handle() {
        return CryptEnumProvidersW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static MemorySegment CryptEnumProvidersW$address() {
        return CryptEnumProvidersW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static int CryptEnumProvidersW(int dwIndex, MemorySegment pdwReserved, int dwFlags, MemorySegment pdwProvType, MemorySegment szProvName, MemorySegment pcbProvName) {
        var mh$ = CryptEnumProvidersW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumProvidersW", dwIndex, pdwReserved, dwFlags, pdwProvType, szProvName, pcbProvName);
            }
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szProvName, pcbProvName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptContextAddRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptContextAddRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptContextAddRef(HCRYPTPROV hProv, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptContextAddRef$descriptor() {
        return CryptContextAddRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptContextAddRef(HCRYPTPROV hProv, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptContextAddRef$handle() {
        return CryptContextAddRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptContextAddRef(HCRYPTPROV hProv, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptContextAddRef$address() {
        return CryptContextAddRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptContextAddRef(HCRYPTPROV hProv, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static int CryptContextAddRef(long hProv, MemorySegment pdwReserved, int dwFlags) {
        var mh$ = CryptContextAddRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptContextAddRef", hProv, pdwReserved, dwFlags);
            }
            return (int)mh$.invokeExact(hProv, pdwReserved, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDuplicateKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptDuplicateKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDuplicateKey(HCRYPTKEY hKey, DWORD *pdwReserved, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptDuplicateKey$descriptor() {
        return CryptDuplicateKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDuplicateKey(HCRYPTKEY hKey, DWORD *pdwReserved, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptDuplicateKey$handle() {
        return CryptDuplicateKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDuplicateKey(HCRYPTKEY hKey, DWORD *pdwReserved, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MemorySegment CryptDuplicateKey$address() {
        return CryptDuplicateKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDuplicateKey(HCRYPTKEY hKey, DWORD *pdwReserved, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptDuplicateKey(long hKey, MemorySegment pdwReserved, int dwFlags, MemorySegment phKey) {
        var mh$ = CryptDuplicateKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDuplicateKey", hKey, pdwReserved, dwFlags, phKey);
            }
            return (int)mh$.invokeExact(hKey, pdwReserved, dwFlags, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDuplicateHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptDuplicateHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDuplicateHash(HCRYPTHASH hHash, DWORD *pdwReserved, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static FunctionDescriptor CryptDuplicateHash$descriptor() {
        return CryptDuplicateHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDuplicateHash(HCRYPTHASH hHash, DWORD *pdwReserved, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static MethodHandle CryptDuplicateHash$handle() {
        return CryptDuplicateHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDuplicateHash(HCRYPTHASH hHash, DWORD *pdwReserved, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static MemorySegment CryptDuplicateHash$address() {
        return CryptDuplicateHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDuplicateHash(HCRYPTHASH hHash, DWORD *pdwReserved, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static int CryptDuplicateHash(long hHash, MemorySegment pdwReserved, int dwFlags, MemorySegment phHash) {
        var mh$ = CryptDuplicateHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDuplicateHash", hHash, pdwReserved, dwFlags, phHash);
            }
            return (int)mh$.invokeExact(hHash, pdwReserved, dwFlags, phHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEncSChannel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEncSChannel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetEncSChannel(BYTE **pData, DWORD *dwDecSize)
     * }
     */
    public static FunctionDescriptor GetEncSChannel$descriptor() {
        return GetEncSChannel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetEncSChannel(BYTE **pData, DWORD *dwDecSize)
     * }
     */
    public static MethodHandle GetEncSChannel$handle() {
        return GetEncSChannel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetEncSChannel(BYTE **pData, DWORD *dwDecSize)
     * }
     */
    public static MemorySegment GetEncSChannel$address() {
        return GetEncSChannel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetEncSChannel(BYTE **pData, DWORD *dwDecSize)
     * }
     */
    public static int GetEncSChannel(MemorySegment pData, MemorySegment dwDecSize) {
        var mh$ = GetEncSChannel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEncSChannel", pData, dwDecSize);
            }
            return (int)mh$.invokeExact(pData, dwDecSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef LONG NTSTATUS
     * }
     */
    public static final OfInt NTSTATUS = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef NTSTATUS *PNTSTATUS
     * }
     */
    public static final AddressLayout PNTSTATUS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO {
     *     ULONG cbSize;
     *     ULONG dwInfoVersion;
     *     PUCHAR pbNonce;
     *     ULONG cbNonce;
     *     PUCHAR pbAuthData;
     *     ULONG cbAuthData;
     *     PUCHAR pbTag;
     *     ULONG cbTag;
     *     PUCHAR pbMacContext;
     *     ULONG cbMacContext;
     *     ULONG cbAAD;
     *     ULONGLONG cbData;
     *     ULONG dwFlags;
     * } *PBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO
     * }
     */
    public static final AddressLayout PBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCryptBuffer {
     *     ULONG cbBuffer;
     *     ULONG BufferType;
     *     PVOID pvBuffer;
     * } *PBCryptBuffer
     * }
     */
    public static final AddressLayout PBCryptBuffer = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCryptBufferDesc {
     *     ULONG ulVersion;
     *     ULONG cBuffers;
     *     PBCryptBuffer pBuffers;
     * } *PBCryptBufferDesc
     * }
     */
    public static final AddressLayout PBCryptBufferDesc = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_HANDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_ALG_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_ALG_HANDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_KEY_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_KEY_HANDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_HASH_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_HASH_HANDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_SECRET_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_SECRET_HANDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_ECCKEY_BLOB {
     *     ULONG dwMagic;
     *     ULONG cbKey;
     * } *PBCRYPT_ECCKEY_BLOB
     * }
     */
    public static final AddressLayout PBCRYPT_ECCKEY_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SSL_ECCKEY_BLOB {
     *     ULONG dwCurveType;
     *     ULONG cbKey;
     * } *PSSL_ECCKEY_BLOB
     * }
     */
    public static final AddressLayout PSSL_ECCKEY_BLOB = wgl_h.C_POINTER;
    private static final int BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = 1
     * }
     */
    public static int BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE() {
        return BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE;
    }
    private static final int BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = 2
     * }
     */
    public static int BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE() {
        return BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE;
    }
    private static final int BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = 3
     * }
     */
    public static int BCRYPT_ECC_PRIME_MONTGOMERY_CURVE() {
        return BCRYPT_ECC_PRIME_MONTGOMERY_CURVE;
    }
    private static final int BCRYPT_NO_CURVE_GENERATION_ALG_ID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_NO_CURVE_GENERATION_ALG_ID = 0
     * }
     */
    public static int BCRYPT_NO_CURVE_GENERATION_ALG_ID() {
        return BCRYPT_NO_CURVE_GENERATION_ALG_ID;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_ECCFULLKEY_BLOB {
     *     ULONG dwMagic;
     *     ULONG dwVersion;
     *     ECC_CURVE_TYPE_ENUM dwCurveType;
     *     ECC_CURVE_ALG_ID_ENUM dwCurveGenerationAlgId;
     *     ULONG cbFieldLength;
     *     ULONG cbSubgroupOrder;
     *     ULONG cbCofactor;
     *     ULONG cbSeed;
     * } *PBCRYPT_ECCFULLKEY_BLOB
     * }
     */
    public static final AddressLayout PBCRYPT_ECCFULLKEY_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_DH_KEY_BLOB {
     *     ULONG dwMagic;
     *     ULONG cbKey;
     * } *PBCRYPT_DH_KEY_BLOB
     * }
     */
    public static final AddressLayout PBCRYPT_DH_KEY_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_DSA_KEY_BLOB {
     *     ULONG dwMagic;
     *     ULONG cbKey;
     *     UCHAR Count[4];
     *     UCHAR Seed[20];
     *     UCHAR q[20];
     * } *PBCRYPT_DSA_KEY_BLOB
     * }
     */
    public static final AddressLayout PBCRYPT_DSA_KEY_BLOB = wgl_h.C_POINTER;
    private static final int DSA_HASH_ALGORITHM_SHA1 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DSA_HASH_ALGORITHM_SHA1 = 0
     * }
     */
    public static int DSA_HASH_ALGORITHM_SHA1() {
        return DSA_HASH_ALGORITHM_SHA1;
    }
    private static final int DSA_HASH_ALGORITHM_SHA256 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DSA_HASH_ALGORITHM_SHA256 = 1
     * }
     */
    public static int DSA_HASH_ALGORITHM_SHA256() {
        return DSA_HASH_ALGORITHM_SHA256;
    }
    private static final int DSA_HASH_ALGORITHM_SHA512 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DSA_HASH_ALGORITHM_SHA512 = 2
     * }
     */
    public static int DSA_HASH_ALGORITHM_SHA512() {
        return DSA_HASH_ALGORITHM_SHA512;
    }
    private static final int DSA_FIPS186_2 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DSA_FIPS186_2 = 0
     * }
     */
    public static int DSA_FIPS186_2() {
        return DSA_FIPS186_2;
    }
    private static final int DSA_FIPS186_3 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DSA_FIPS186_3 = 1
     * }
     */
    public static int DSA_FIPS186_3() {
        return DSA_FIPS186_3;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_DSA_KEY_BLOB_V2 {
     *     ULONG dwMagic;
     *     ULONG cbKey;
     *     HASHALGORITHM_ENUM hashAlgorithm;
     *     DSAFIPSVERSION_ENUM standardVersion;
     *     ULONG cbSeedLength;
     *     ULONG cbGroupSize;
     *     UCHAR Count[4];
     * } *PBCRYPT_DSA_KEY_BLOB_V2
     * }
     */
    public static final AddressLayout PBCRYPT_DSA_KEY_BLOB_V2 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_KEY_DATA_BLOB_HEADER {
     *     ULONG dwMagic;
     *     ULONG dwVersion;
     *     ULONG cbKeyData;
     * } *PBCRYPT_KEY_DATA_BLOB_HEADER
     * }
     */
    public static final AddressLayout PBCRYPT_KEY_DATA_BLOB_HEADER = wgl_h.C_POINTER;
    private static final int BCRYPT_HASH_OPERATION_HASH_DATA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_HASH_OPERATION_HASH_DATA = 1
     * }
     */
    public static int BCRYPT_HASH_OPERATION_HASH_DATA() {
        return BCRYPT_HASH_OPERATION_HASH_DATA;
    }
    private static final int BCRYPT_HASH_OPERATION_FINISH_HASH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_HASH_OPERATION_FINISH_HASH = 2
     * }
     */
    public static int BCRYPT_HASH_OPERATION_FINISH_HASH() {
        return BCRYPT_HASH_OPERATION_FINISH_HASH;
    }
    private static final int BCRYPT_OPERATION_TYPE_HASH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_OPERATION_TYPE_HASH = 1
     * }
     */
    public static int BCRYPT_OPERATION_TYPE_HASH() {
        return BCRYPT_OPERATION_TYPE_HASH;
    }

    private static class BCryptOpenAlgorithmProvider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptOpenAlgorithmProvider");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptOpenAlgorithmProvider$descriptor() {
        return BCryptOpenAlgorithmProvider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptOpenAlgorithmProvider$handle() {
        return BCryptOpenAlgorithmProvider.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptOpenAlgorithmProvider$address() {
        return BCryptOpenAlgorithmProvider.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags)
     * }
     */
    public static int BCryptOpenAlgorithmProvider(MemorySegment phAlgorithm, MemorySegment pszAlgId, MemorySegment pszImplementation, int dwFlags) {
        var mh$ = BCryptOpenAlgorithmProvider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptOpenAlgorithmProvider", phAlgorithm, pszAlgId, pszImplementation, dwFlags);
            }
            return (int)mh$.invokeExact(phAlgorithm, pszAlgId, pszImplementation, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumAlgorithms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptEnumAlgorithms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumAlgorithms(ULONG dwAlgOperations, ULONG *pAlgCount, BCRYPT_ALGORITHM_IDENTIFIER **ppAlgList, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptEnumAlgorithms$descriptor() {
        return BCryptEnumAlgorithms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumAlgorithms(ULONG dwAlgOperations, ULONG *pAlgCount, BCRYPT_ALGORITHM_IDENTIFIER **ppAlgList, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptEnumAlgorithms$handle() {
        return BCryptEnumAlgorithms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumAlgorithms(ULONG dwAlgOperations, ULONG *pAlgCount, BCRYPT_ALGORITHM_IDENTIFIER **ppAlgList, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptEnumAlgorithms$address() {
        return BCryptEnumAlgorithms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumAlgorithms(ULONG dwAlgOperations, ULONG *pAlgCount, BCRYPT_ALGORITHM_IDENTIFIER **ppAlgList, ULONG dwFlags)
     * }
     */
    public static int BCryptEnumAlgorithms(int dwAlgOperations, MemorySegment pAlgCount, MemorySegment ppAlgList, int dwFlags) {
        var mh$ = BCryptEnumAlgorithms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumAlgorithms", dwAlgOperations, pAlgCount, ppAlgList, dwFlags);
            }
            return (int)mh$.invokeExact(dwAlgOperations, pAlgCount, ppAlgList, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumProviders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptEnumProviders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumProviders(LPCWSTR pszAlgId, ULONG *pImplCount, BCRYPT_PROVIDER_NAME **ppImplList, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptEnumProviders$descriptor() {
        return BCryptEnumProviders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumProviders(LPCWSTR pszAlgId, ULONG *pImplCount, BCRYPT_PROVIDER_NAME **ppImplList, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptEnumProviders$handle() {
        return BCryptEnumProviders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumProviders(LPCWSTR pszAlgId, ULONG *pImplCount, BCRYPT_PROVIDER_NAME **ppImplList, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptEnumProviders$address() {
        return BCryptEnumProviders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumProviders(LPCWSTR pszAlgId, ULONG *pImplCount, BCRYPT_PROVIDER_NAME **ppImplList, ULONG dwFlags)
     * }
     */
    public static int BCryptEnumProviders(MemorySegment pszAlgId, MemorySegment pImplCount, MemorySegment ppImplList, int dwFlags) {
        var mh$ = BCryptEnumProviders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumProviders", pszAlgId, pImplCount, ppImplList, dwFlags);
            }
            return (int)mh$.invokeExact(pszAlgId, pImplCount, ppImplList, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptGetProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptGetProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptGetProperty$descriptor() {
        return BCryptGetProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptGetProperty$handle() {
        return BCryptGetProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptGetProperty$address() {
        return BCryptGetProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptGetProperty(MemorySegment hObject, MemorySegment pszProperty, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptGetProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptGetProperty", hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptSetProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptSetProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptSetProperty$descriptor() {
        return BCryptSetProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptSetProperty$handle() {
        return BCryptSetProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptSetProperty$address() {
        return BCryptSetProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptSetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static int BCryptSetProperty(MemorySegment hObject, MemorySegment pszProperty, MemorySegment pbInput, int cbInput, int dwFlags) {
        var mh$ = BCryptSetProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptSetProperty", hObject, pszProperty, pbInput, cbInput, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, pszProperty, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptCloseAlgorithmProvider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptCloseAlgorithmProvider");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptCloseAlgorithmProvider$descriptor() {
        return BCryptCloseAlgorithmProvider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptCloseAlgorithmProvider$handle() {
        return BCryptCloseAlgorithmProvider.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptCloseAlgorithmProvider$address() {
        return BCryptCloseAlgorithmProvider.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags)
     * }
     */
    public static int BCryptCloseAlgorithmProvider(MemorySegment hAlgorithm, int dwFlags) {
        var mh$ = BCryptCloseAlgorithmProvider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptCloseAlgorithmProvider", hAlgorithm, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptFreeBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptFreeBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BCryptFreeBuffer(PVOID pvBuffer)
     * }
     */
    public static FunctionDescriptor BCryptFreeBuffer$descriptor() {
        return BCryptFreeBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BCryptFreeBuffer(PVOID pvBuffer)
     * }
     */
    public static MethodHandle BCryptFreeBuffer$handle() {
        return BCryptFreeBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BCryptFreeBuffer(PVOID pvBuffer)
     * }
     */
    public static MemorySegment BCryptFreeBuffer$address() {
        return BCryptFreeBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BCryptFreeBuffer(PVOID pvBuffer)
     * }
     */
    public static void BCryptFreeBuffer(MemorySegment pvBuffer) {
        var mh$ = BCryptFreeBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptFreeBuffer", pvBuffer);
            }
            mh$.invokeExact(pvBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptGenerateSymmetricKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptGenerateSymmetricKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateSymmetricKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptGenerateSymmetricKey$descriptor() {
        return BCryptGenerateSymmetricKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateSymmetricKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptGenerateSymmetricKey$handle() {
        return BCryptGenerateSymmetricKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateSymmetricKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptGenerateSymmetricKey$address() {
        return BCryptGenerateSymmetricKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateSymmetricKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static int BCryptGenerateSymmetricKey(MemorySegment hAlgorithm, MemorySegment phKey, MemorySegment pbKeyObject, int cbKeyObject, MemorySegment pbSecret, int cbSecret, int dwFlags) {
        var mh$ = BCryptGenerateSymmetricKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptGenerateSymmetricKey", hAlgorithm, phKey, pbKeyObject, cbKeyObject, pbSecret, cbSecret, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, phKey, pbKeyObject, cbKeyObject, pbSecret, cbSecret, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptGenerateKeyPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptGenerateKeyPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, ULONG dwLength, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptGenerateKeyPair$descriptor() {
        return BCryptGenerateKeyPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, ULONG dwLength, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptGenerateKeyPair$handle() {
        return BCryptGenerateKeyPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, ULONG dwLength, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptGenerateKeyPair$address() {
        return BCryptGenerateKeyPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, ULONG dwLength, ULONG dwFlags)
     * }
     */
    public static int BCryptGenerateKeyPair(MemorySegment hAlgorithm, MemorySegment phKey, int dwLength, int dwFlags) {
        var mh$ = BCryptGenerateKeyPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptGenerateKeyPair", hAlgorithm, phKey, dwLength, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, phKey, dwLength, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEncrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptEncrypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEncrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptEncrypt$descriptor() {
        return BCryptEncrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEncrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptEncrypt$handle() {
        return BCryptEncrypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEncrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptEncrypt$address() {
        return BCryptEncrypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEncrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptEncrypt(MemorySegment hKey, MemorySegment pbInput, int cbInput, MemorySegment pPaddingInfo, MemorySegment pbIV, int cbIV, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptEncrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEncrypt", hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDecrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptDecrypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDecrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDecrypt$descriptor() {
        return BCryptDecrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDecrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDecrypt$handle() {
        return BCryptDecrypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDecrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptDecrypt$address() {
        return BCryptDecrypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDecrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptDecrypt(MemorySegment hKey, MemorySegment pbInput, int cbInput, MemorySegment pPaddingInfo, MemorySegment pbIV, int cbIV, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptDecrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDecrypt", hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptExportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptExportKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptExportKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptExportKey$descriptor() {
        return BCryptExportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptExportKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptExportKey$handle() {
        return BCryptExportKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptExportKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptExportKey$address() {
        return BCryptExportKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptExportKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptExportKey(MemorySegment hKey, MemorySegment hExportKey, MemorySegment pszBlobType, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptExportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptExportKey", hKey, hExportKey, pszBlobType, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, hExportKey, pszBlobType, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptImportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptImportKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptImportKey$descriptor() {
        return BCryptImportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptImportKey$handle() {
        return BCryptImportKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptImportKey$address() {
        return BCryptImportKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static int BCryptImportKey(MemorySegment hAlgorithm, MemorySegment hImportKey, MemorySegment pszBlobType, MemorySegment phKey, MemorySegment pbKeyObject, int cbKeyObject, MemorySegment pbInput, int cbInput, int dwFlags) {
        var mh$ = BCryptImportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptImportKey", hAlgorithm, hImportKey, pszBlobType, phKey, pbKeyObject, cbKeyObject, pbInput, cbInput, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, hImportKey, pszBlobType, phKey, pbKeyObject, cbKeyObject, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptImportKeyPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptImportKeyPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptImportKeyPair$descriptor() {
        return BCryptImportKeyPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptImportKeyPair$handle() {
        return BCryptImportKeyPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptImportKeyPair$address() {
        return BCryptImportKeyPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static int BCryptImportKeyPair(MemorySegment hAlgorithm, MemorySegment hImportKey, MemorySegment pszBlobType, MemorySegment phKey, MemorySegment pbInput, int cbInput, int dwFlags) {
        var mh$ = BCryptImportKeyPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptImportKeyPair", hAlgorithm, hImportKey, pszBlobType, phKey, pbInput, cbInput, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, hImportKey, pszBlobType, phKey, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDuplicateKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptDuplicateKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE *phNewKey, PUCHAR pbKeyObject, ULONG cbKeyObject, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDuplicateKey$descriptor() {
        return BCryptDuplicateKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE *phNewKey, PUCHAR pbKeyObject, ULONG cbKeyObject, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDuplicateKey$handle() {
        return BCryptDuplicateKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE *phNewKey, PUCHAR pbKeyObject, ULONG cbKeyObject, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptDuplicateKey$address() {
        return BCryptDuplicateKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE *phNewKey, PUCHAR pbKeyObject, ULONG cbKeyObject, ULONG dwFlags)
     * }
     */
    public static int BCryptDuplicateKey(MemorySegment hKey, MemorySegment phNewKey, MemorySegment pbKeyObject, int cbKeyObject, int dwFlags) {
        var mh$ = BCryptDuplicateKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDuplicateKey", hKey, phNewKey, pbKeyObject, cbKeyObject, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, phNewKey, pbKeyObject, cbKeyObject, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptFinalizeKeyPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptFinalizeKeyPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinalizeKeyPair(BCRYPT_KEY_HANDLE hKey, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptFinalizeKeyPair$descriptor() {
        return BCryptFinalizeKeyPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinalizeKeyPair(BCRYPT_KEY_HANDLE hKey, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptFinalizeKeyPair$handle() {
        return BCryptFinalizeKeyPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinalizeKeyPair(BCRYPT_KEY_HANDLE hKey, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptFinalizeKeyPair$address() {
        return BCryptFinalizeKeyPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptFinalizeKeyPair(BCRYPT_KEY_HANDLE hKey, ULONG dwFlags)
     * }
     */
    public static int BCryptFinalizeKeyPair(MemorySegment hKey, int dwFlags) {
        var mh$ = BCryptFinalizeKeyPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptFinalizeKeyPair", hKey, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDestroyKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptDestroyKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyKey(BCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static FunctionDescriptor BCryptDestroyKey$descriptor() {
        return BCryptDestroyKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyKey(BCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static MethodHandle BCryptDestroyKey$handle() {
        return BCryptDestroyKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyKey(BCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static MemorySegment BCryptDestroyKey$address() {
        return BCryptDestroyKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyKey(BCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static int BCryptDestroyKey(MemorySegment hKey) {
        var mh$ = BCryptDestroyKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDestroyKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDestroySecret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptDestroySecret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroySecret(BCRYPT_SECRET_HANDLE hSecret)
     * }
     */
    public static FunctionDescriptor BCryptDestroySecret$descriptor() {
        return BCryptDestroySecret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroySecret(BCRYPT_SECRET_HANDLE hSecret)
     * }
     */
    public static MethodHandle BCryptDestroySecret$handle() {
        return BCryptDestroySecret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroySecret(BCRYPT_SECRET_HANDLE hSecret)
     * }
     */
    public static MemorySegment BCryptDestroySecret$address() {
        return BCryptDestroySecret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroySecret(BCRYPT_SECRET_HANDLE hSecret)
     * }
     */
    public static int BCryptDestroySecret(MemorySegment hSecret) {
        var mh$ = BCryptDestroySecret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDestroySecret", hSecret);
            }
            return (int)mh$.invokeExact(hSecret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptSignHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptSignHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSignHash(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptSignHash$descriptor() {
        return BCryptSignHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSignHash(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptSignHash$handle() {
        return BCryptSignHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSignHash(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptSignHash$address() {
        return BCryptSignHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptSignHash(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptSignHash(MemorySegment hKey, MemorySegment pPaddingInfo, MemorySegment pbInput, int cbInput, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptSignHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptSignHash", hKey, pPaddingInfo, pbInput, cbInput, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbInput, cbInput, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptVerifySignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptVerifySignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptVerifySignature(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbHash, ULONG cbHash, PUCHAR pbSignature, ULONG cbSignature, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptVerifySignature$descriptor() {
        return BCryptVerifySignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptVerifySignature(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbHash, ULONG cbHash, PUCHAR pbSignature, ULONG cbSignature, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptVerifySignature$handle() {
        return BCryptVerifySignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptVerifySignature(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbHash, ULONG cbHash, PUCHAR pbSignature, ULONG cbSignature, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptVerifySignature$address() {
        return BCryptVerifySignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptVerifySignature(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbHash, ULONG cbHash, PUCHAR pbSignature, ULONG cbSignature, ULONG dwFlags)
     * }
     */
    public static int BCryptVerifySignature(MemorySegment hKey, MemorySegment pPaddingInfo, MemorySegment pbHash, int cbHash, MemorySegment pbSignature, int cbSignature, int dwFlags) {
        var mh$ = BCryptVerifySignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptVerifySignature", hKey, pPaddingInfo, pbHash, cbHash, pbSignature, cbSignature, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbHash, cbHash, pbSignature, cbSignature, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptSecretAgreement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptSecretAgreement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSecretAgreement(BCRYPT_KEY_HANDLE hPrivKey, BCRYPT_KEY_HANDLE hPubKey, BCRYPT_SECRET_HANDLE *phAgreedSecret, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptSecretAgreement$descriptor() {
        return BCryptSecretAgreement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSecretAgreement(BCRYPT_KEY_HANDLE hPrivKey, BCRYPT_KEY_HANDLE hPubKey, BCRYPT_SECRET_HANDLE *phAgreedSecret, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptSecretAgreement$handle() {
        return BCryptSecretAgreement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSecretAgreement(BCRYPT_KEY_HANDLE hPrivKey, BCRYPT_KEY_HANDLE hPubKey, BCRYPT_SECRET_HANDLE *phAgreedSecret, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptSecretAgreement$address() {
        return BCryptSecretAgreement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptSecretAgreement(BCRYPT_KEY_HANDLE hPrivKey, BCRYPT_KEY_HANDLE hPubKey, BCRYPT_SECRET_HANDLE *phAgreedSecret, ULONG dwFlags)
     * }
     */
    public static int BCryptSecretAgreement(MemorySegment hPrivKey, MemorySegment hPubKey, MemorySegment phAgreedSecret, int dwFlags) {
        var mh$ = BCryptSecretAgreement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptSecretAgreement", hPrivKey, hPubKey, phAgreedSecret, dwFlags);
            }
            return (int)mh$.invokeExact(hPrivKey, hPubKey, phAgreedSecret, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDeriveKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptDeriveKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKey(BCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDeriveKey$descriptor() {
        return BCryptDeriveKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKey(BCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDeriveKey$handle() {
        return BCryptDeriveKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKey(BCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptDeriveKey$address() {
        return BCryptDeriveKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKey(BCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptDeriveKey(MemorySegment hSharedSecret, MemorySegment pwszKDF, MemorySegment pParameterList, MemorySegment pbDerivedKey, int cbDerivedKey, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptDeriveKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDeriveKey", hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptKeyDerivation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptKeyDerivation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptKeyDerivation(BCRYPT_KEY_HANDLE hKey, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptKeyDerivation$descriptor() {
        return BCryptKeyDerivation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptKeyDerivation(BCRYPT_KEY_HANDLE hKey, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptKeyDerivation$handle() {
        return BCryptKeyDerivation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptKeyDerivation(BCRYPT_KEY_HANDLE hKey, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptKeyDerivation$address() {
        return BCryptKeyDerivation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptKeyDerivation(BCRYPT_KEY_HANDLE hKey, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptKeyDerivation(MemorySegment hKey, MemorySegment pParameterList, MemorySegment pbDerivedKey, int cbDerivedKey, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptKeyDerivation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptKeyDerivation", hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptCreateHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptCreateHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptCreateHash$descriptor() {
        return BCryptCreateHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptCreateHash$handle() {
        return BCryptCreateHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptCreateHash$address() {
        return BCryptCreateHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static int BCryptCreateHash(MemorySegment hAlgorithm, MemorySegment phHash, MemorySegment pbHashObject, int cbHashObject, MemorySegment pbSecret, int cbSecret, int dwFlags) {
        var mh$ = BCryptCreateHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptCreateHash", hAlgorithm, phHash, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, phHash, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptHashData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptHashData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptHashData$descriptor() {
        return BCryptHashData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptHashData$handle() {
        return BCryptHashData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptHashData$address() {
        return BCryptHashData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static int BCryptHashData(MemorySegment hHash, MemorySegment pbInput, int cbInput, int dwFlags) {
        var mh$ = BCryptHashData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptHashData", hHash, pbInput, cbInput, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptFinishHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptFinishHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptFinishHash$descriptor() {
        return BCryptFinishHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptFinishHash$handle() {
        return BCryptFinishHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptFinishHash$address() {
        return BCryptFinishHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags)
     * }
     */
    public static int BCryptFinishHash(MemorySegment hHash, MemorySegment pbOutput, int cbOutput, int dwFlags) {
        var mh$ = BCryptFinishHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptFinishHash", hHash, pbOutput, cbOutput, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbOutput, cbOutput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptCreateMultiHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptCreateMultiHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateMultiHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, ULONG nHashes, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptCreateMultiHash$descriptor() {
        return BCryptCreateMultiHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateMultiHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, ULONG nHashes, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptCreateMultiHash$handle() {
        return BCryptCreateMultiHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateMultiHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, ULONG nHashes, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptCreateMultiHash$address() {
        return BCryptCreateMultiHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateMultiHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, ULONG nHashes, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static int BCryptCreateMultiHash(MemorySegment hAlgorithm, MemorySegment phHash, int nHashes, MemorySegment pbHashObject, int cbHashObject, MemorySegment pbSecret, int cbSecret, int dwFlags) {
        var mh$ = BCryptCreateMultiHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptCreateMultiHash", hAlgorithm, phHash, nHashes, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, phHash, nHashes, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptProcessMultiOperations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptProcessMultiOperations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptProcessMultiOperations(BCRYPT_HANDLE hObject, BCRYPT_MULTI_OPERATION_TYPE operationType, PVOID pOperations, ULONG cbOperations, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptProcessMultiOperations$descriptor() {
        return BCryptProcessMultiOperations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptProcessMultiOperations(BCRYPT_HANDLE hObject, BCRYPT_MULTI_OPERATION_TYPE operationType, PVOID pOperations, ULONG cbOperations, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptProcessMultiOperations$handle() {
        return BCryptProcessMultiOperations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptProcessMultiOperations(BCRYPT_HANDLE hObject, BCRYPT_MULTI_OPERATION_TYPE operationType, PVOID pOperations, ULONG cbOperations, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptProcessMultiOperations$address() {
        return BCryptProcessMultiOperations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptProcessMultiOperations(BCRYPT_HANDLE hObject, BCRYPT_MULTI_OPERATION_TYPE operationType, PVOID pOperations, ULONG cbOperations, ULONG dwFlags)
     * }
     */
    public static int BCryptProcessMultiOperations(MemorySegment hObject, int operationType, MemorySegment pOperations, int cbOperations, int dwFlags) {
        var mh$ = BCryptProcessMultiOperations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptProcessMultiOperations", hObject, operationType, pOperations, cbOperations, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, operationType, pOperations, cbOperations, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDuplicateHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptDuplicateHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateHash(BCRYPT_HASH_HANDLE hHash, BCRYPT_HASH_HANDLE *phNewHash, PUCHAR pbHashObject, ULONG cbHashObject, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDuplicateHash$descriptor() {
        return BCryptDuplicateHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateHash(BCRYPT_HASH_HANDLE hHash, BCRYPT_HASH_HANDLE *phNewHash, PUCHAR pbHashObject, ULONG cbHashObject, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDuplicateHash$handle() {
        return BCryptDuplicateHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateHash(BCRYPT_HASH_HANDLE hHash, BCRYPT_HASH_HANDLE *phNewHash, PUCHAR pbHashObject, ULONG cbHashObject, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptDuplicateHash$address() {
        return BCryptDuplicateHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateHash(BCRYPT_HASH_HANDLE hHash, BCRYPT_HASH_HANDLE *phNewHash, PUCHAR pbHashObject, ULONG cbHashObject, ULONG dwFlags)
     * }
     */
    public static int BCryptDuplicateHash(MemorySegment hHash, MemorySegment phNewHash, MemorySegment pbHashObject, int cbHashObject, int dwFlags) {
        var mh$ = BCryptDuplicateHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDuplicateHash", hHash, phNewHash, pbHashObject, cbHashObject, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, phNewHash, pbHashObject, cbHashObject, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDestroyHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptDestroyHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash)
     * }
     */
    public static FunctionDescriptor BCryptDestroyHash$descriptor() {
        return BCryptDestroyHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash)
     * }
     */
    public static MethodHandle BCryptDestroyHash$handle() {
        return BCryptDestroyHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash)
     * }
     */
    public static MemorySegment BCryptDestroyHash$address() {
        return BCryptDestroyHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash)
     * }
     */
    public static int BCryptDestroyHash(MemorySegment hHash) {
        var mh$ = BCryptDestroyHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDestroyHash", hHash);
            }
            return (int)mh$.invokeExact(hHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHash(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbSecret, ULONG cbSecret, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput)
     * }
     */
    public static FunctionDescriptor BCryptHash$descriptor() {
        return BCryptHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHash(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbSecret, ULONG cbSecret, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput)
     * }
     */
    public static MethodHandle BCryptHash$handle() {
        return BCryptHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHash(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbSecret, ULONG cbSecret, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput)
     * }
     */
    public static MemorySegment BCryptHash$address() {
        return BCryptHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptHash(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbSecret, ULONG cbSecret, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput)
     * }
     */
    public static int BCryptHash(MemorySegment hAlgorithm, MemorySegment pbSecret, int cbSecret, MemorySegment pbInput, int cbInput, MemorySegment pbOutput, int cbOutput) {
        var mh$ = BCryptHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptHash", hAlgorithm, pbSecret, cbSecret, pbInput, cbInput, pbOutput, cbOutput);
            }
            return (int)mh$.invokeExact(hAlgorithm, pbSecret, cbSecret, pbInput, cbInput, pbOutput, cbOutput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptGenRandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptGenRandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenRandom(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbBuffer, ULONG cbBuffer, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptGenRandom$descriptor() {
        return BCryptGenRandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenRandom(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbBuffer, ULONG cbBuffer, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptGenRandom$handle() {
        return BCryptGenRandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenRandom(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbBuffer, ULONG cbBuffer, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptGenRandom$address() {
        return BCryptGenRandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptGenRandom(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbBuffer, ULONG cbBuffer, ULONG dwFlags)
     * }
     */
    public static int BCryptGenRandom(MemorySegment hAlgorithm, MemorySegment pbBuffer, int cbBuffer, int dwFlags) {
        var mh$ = BCryptGenRandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptGenRandom", hAlgorithm, pbBuffer, cbBuffer, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, pbBuffer, cbBuffer, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDeriveKeyCapi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptDeriveKeyCapi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyCapi(BCRYPT_HASH_HANDLE hHash, BCRYPT_ALG_HANDLE hTargetAlg, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDeriveKeyCapi$descriptor() {
        return BCryptDeriveKeyCapi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyCapi(BCRYPT_HASH_HANDLE hHash, BCRYPT_ALG_HANDLE hTargetAlg, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDeriveKeyCapi$handle() {
        return BCryptDeriveKeyCapi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyCapi(BCRYPT_HASH_HANDLE hHash, BCRYPT_ALG_HANDLE hTargetAlg, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptDeriveKeyCapi$address() {
        return BCryptDeriveKeyCapi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyCapi(BCRYPT_HASH_HANDLE hHash, BCRYPT_ALG_HANDLE hTargetAlg, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static int BCryptDeriveKeyCapi(MemorySegment hHash, MemorySegment hTargetAlg, MemorySegment pbDerivedKey, int cbDerivedKey, int dwFlags) {
        var mh$ = BCryptDeriveKeyCapi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDeriveKeyCapi", hHash, hTargetAlg, pbDerivedKey, cbDerivedKey, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, hTargetAlg, pbDerivedKey, cbDerivedKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDeriveKeyPBKDF2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptDeriveKeyPBKDF2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyPBKDF2(BCRYPT_ALG_HANDLE hPrf, PUCHAR pbPassword, ULONG cbPassword, PUCHAR pbSalt, ULONG cbSalt, ULONGLONG cIterations, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDeriveKeyPBKDF2$descriptor() {
        return BCryptDeriveKeyPBKDF2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyPBKDF2(BCRYPT_ALG_HANDLE hPrf, PUCHAR pbPassword, ULONG cbPassword, PUCHAR pbSalt, ULONG cbSalt, ULONGLONG cIterations, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDeriveKeyPBKDF2$handle() {
        return BCryptDeriveKeyPBKDF2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyPBKDF2(BCRYPT_ALG_HANDLE hPrf, PUCHAR pbPassword, ULONG cbPassword, PUCHAR pbSalt, ULONG cbSalt, ULONGLONG cIterations, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptDeriveKeyPBKDF2$address() {
        return BCryptDeriveKeyPBKDF2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyPBKDF2(BCRYPT_ALG_HANDLE hPrf, PUCHAR pbPassword, ULONG cbPassword, PUCHAR pbSalt, ULONG cbSalt, ULONGLONG cIterations, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static int BCryptDeriveKeyPBKDF2(MemorySegment hPrf, MemorySegment pbPassword, int cbPassword, MemorySegment pbSalt, int cbSalt, long cIterations, MemorySegment pbDerivedKey, int cbDerivedKey, int dwFlags) {
        var mh$ = BCryptDeriveKeyPBKDF2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDeriveKeyPBKDF2", hPrf, pbPassword, cbPassword, pbSalt, cbSalt, cIterations, pbDerivedKey, cbDerivedKey, dwFlags);
            }
            return (int)mh$.invokeExact(hPrf, pbPassword, cbPassword, pbSalt, cbSalt, cIterations, pbDerivedKey, cbDerivedKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_INTERFACE_VERSION {
     *     USHORT MajorVersion;
     *     USHORT MinorVersion;
     * } *PBCRYPT_INTERFACE_VERSION
     * }
     */
    public static final AddressLayout PBCRYPT_INTERFACE_VERSION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_INTERFACE_REG {
     *     ULONG dwInterface;
     *     ULONG dwFlags;
     *     ULONG cFunctions;
     *     PWSTR *rgpszFunctions;
     * } *PCRYPT_INTERFACE_REG
     * }
     */
    public static final AddressLayout PCRYPT_INTERFACE_REG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_IMAGE_REG {
     *     PWSTR pszImage;
     *     ULONG cInterfaces;
     *     PCRYPT_INTERFACE_REG *rgpInterfaces;
     * } *PCRYPT_IMAGE_REG
     * }
     */
    public static final AddressLayout PCRYPT_IMAGE_REG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PROVIDER_REG {
     *     ULONG cAliases;
     *     PWSTR *rgpszAliases;
     *     PCRYPT_IMAGE_REG pUM;
     *     PCRYPT_IMAGE_REG pKM;
     * } *PCRYPT_PROVIDER_REG
     * }
     */
    public static final AddressLayout PCRYPT_PROVIDER_REG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PROVIDERS {
     *     ULONG cProviders;
     *     PWSTR *rgpszProviders;
     * } *PCRYPT_PROVIDERS
     * }
     */
    public static final AddressLayout PCRYPT_PROVIDERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTEXT_CONFIG {
     *     ULONG dwFlags;
     *     ULONG dwReserved;
     * } *PCRYPT_CONTEXT_CONFIG
     * }
     */
    public static final AddressLayout PCRYPT_CONTEXT_CONFIG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTEXT_FUNCTION_CONFIG {
     *     ULONG dwFlags;
     *     ULONG dwReserved;
     * } *PCRYPT_CONTEXT_FUNCTION_CONFIG
     * }
     */
    public static final AddressLayout PCRYPT_CONTEXT_FUNCTION_CONFIG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTEXTS {
     *     ULONG cContexts;
     *     PWSTR *rgpszContexts;
     * } *PCRYPT_CONTEXTS
     * }
     */
    public static final AddressLayout PCRYPT_CONTEXTS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTEXT_FUNCTIONS {
     *     ULONG cFunctions;
     *     PWSTR *rgpszFunctions;
     * } *PCRYPT_CONTEXT_FUNCTIONS
     * }
     */
    public static final AddressLayout PCRYPT_CONTEXT_FUNCTIONS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTEXT_FUNCTION_PROVIDERS {
     *     ULONG cProviders;
     *     PWSTR *rgpszProviders;
     * } *PCRYPT_CONTEXT_FUNCTION_PROVIDERS
     * }
     */
    public static final AddressLayout PCRYPT_CONTEXT_FUNCTION_PROVIDERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PROPERTY_REF {
     *     PWSTR pszProperty;
     *     ULONG cbValue;
     *     PUCHAR pbValue;
     * } *PCRYPT_PROPERTY_REF
     * }
     */
    public static final AddressLayout PCRYPT_PROPERTY_REF = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_IMAGE_REF {
     *     PWSTR pszImage;
     *     ULONG dwFlags;
     * } *PCRYPT_IMAGE_REF
     * }
     */
    public static final AddressLayout PCRYPT_IMAGE_REF = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PROVIDER_REF {
     *     ULONG dwInterface;
     *     PWSTR pszFunction;
     *     PWSTR pszProvider;
     *     ULONG cProperties;
     *     PCRYPT_PROPERTY_REF *rgpProperties;
     *     PCRYPT_IMAGE_REF pUM;
     *     PCRYPT_IMAGE_REF pKM;
     * } *PCRYPT_PROVIDER_REF
     * }
     */
    public static final AddressLayout PCRYPT_PROVIDER_REF = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PROVIDER_REFS {
     *     ULONG cProviders;
     *     PCRYPT_PROVIDER_REF *rgpProviders;
     * } *PCRYPT_PROVIDER_REFS
     * }
     */
    public static final AddressLayout PCRYPT_PROVIDER_REFS = wgl_h.C_POINTER;

    private static class BCryptQueryProviderRegistration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptQueryProviderRegistration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryProviderRegistration(LPCWSTR pszProvider, ULONG dwMode, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_PROVIDER_REG *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptQueryProviderRegistration$descriptor() {
        return BCryptQueryProviderRegistration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryProviderRegistration(LPCWSTR pszProvider, ULONG dwMode, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_PROVIDER_REG *ppBuffer)
     * }
     */
    public static MethodHandle BCryptQueryProviderRegistration$handle() {
        return BCryptQueryProviderRegistration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryProviderRegistration(LPCWSTR pszProvider, ULONG dwMode, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_PROVIDER_REG *ppBuffer)
     * }
     */
    public static MemorySegment BCryptQueryProviderRegistration$address() {
        return BCryptQueryProviderRegistration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryProviderRegistration(LPCWSTR pszProvider, ULONG dwMode, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_PROVIDER_REG *ppBuffer)
     * }
     */
    public static int BCryptQueryProviderRegistration(MemorySegment pszProvider, int dwMode, int dwInterface, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptQueryProviderRegistration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptQueryProviderRegistration", pszProvider, dwMode, dwInterface, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(pszProvider, dwMode, dwInterface, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumRegisteredProviders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptEnumRegisteredProviders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumRegisteredProviders(ULONG *pcbBuffer, PCRYPT_PROVIDERS *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptEnumRegisteredProviders$descriptor() {
        return BCryptEnumRegisteredProviders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumRegisteredProviders(ULONG *pcbBuffer, PCRYPT_PROVIDERS *ppBuffer)
     * }
     */
    public static MethodHandle BCryptEnumRegisteredProviders$handle() {
        return BCryptEnumRegisteredProviders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumRegisteredProviders(ULONG *pcbBuffer, PCRYPT_PROVIDERS *ppBuffer)
     * }
     */
    public static MemorySegment BCryptEnumRegisteredProviders$address() {
        return BCryptEnumRegisteredProviders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumRegisteredProviders(ULONG *pcbBuffer, PCRYPT_PROVIDERS *ppBuffer)
     * }
     */
    public static int BCryptEnumRegisteredProviders(MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptEnumRegisteredProviders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumRegisteredProviders", pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptCreateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static FunctionDescriptor BCryptCreateContext$descriptor() {
        return BCryptCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static MethodHandle BCryptCreateContext$handle() {
        return BCryptCreateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static MemorySegment BCryptCreateContext$address() {
        return BCryptCreateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static int BCryptCreateContext(int dwTable, MemorySegment pszContext, MemorySegment pConfig) {
        var mh$ = BCryptCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptCreateContext", dwTable, pszContext, pConfig);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, pConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDeleteContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptDeleteContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeleteContext(ULONG dwTable, LPCWSTR pszContext)
     * }
     */
    public static FunctionDescriptor BCryptDeleteContext$descriptor() {
        return BCryptDeleteContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeleteContext(ULONG dwTable, LPCWSTR pszContext)
     * }
     */
    public static MethodHandle BCryptDeleteContext$handle() {
        return BCryptDeleteContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeleteContext(ULONG dwTable, LPCWSTR pszContext)
     * }
     */
    public static MemorySegment BCryptDeleteContext$address() {
        return BCryptDeleteContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDeleteContext(ULONG dwTable, LPCWSTR pszContext)
     * }
     */
    public static int BCryptDeleteContext(int dwTable, MemorySegment pszContext) {
        var mh$ = BCryptDeleteContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDeleteContext", dwTable, pszContext);
            }
            return (int)mh$.invokeExact(dwTable, pszContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumContexts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptEnumContexts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContexts(ULONG dwTable, ULONG *pcbBuffer, PCRYPT_CONTEXTS *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptEnumContexts$descriptor() {
        return BCryptEnumContexts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContexts(ULONG dwTable, ULONG *pcbBuffer, PCRYPT_CONTEXTS *ppBuffer)
     * }
     */
    public static MethodHandle BCryptEnumContexts$handle() {
        return BCryptEnumContexts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContexts(ULONG dwTable, ULONG *pcbBuffer, PCRYPT_CONTEXTS *ppBuffer)
     * }
     */
    public static MemorySegment BCryptEnumContexts$address() {
        return BCryptEnumContexts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContexts(ULONG dwTable, ULONG *pcbBuffer, PCRYPT_CONTEXTS *ppBuffer)
     * }
     */
    public static int BCryptEnumContexts(int dwTable, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptEnumContexts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumContexts", dwTable, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(dwTable, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptConfigureContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptConfigureContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static FunctionDescriptor BCryptConfigureContext$descriptor() {
        return BCryptConfigureContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static MethodHandle BCryptConfigureContext$handle() {
        return BCryptConfigureContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static MemorySegment BCryptConfigureContext$address() {
        return BCryptConfigureContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static int BCryptConfigureContext(int dwTable, MemorySegment pszContext, MemorySegment pConfig) {
        var mh$ = BCryptConfigureContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptConfigureContext", dwTable, pszContext, pConfig);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, pConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptQueryContextConfiguration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptQueryContextConfiguration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG *pcbBuffer, PCRYPT_CONTEXT_CONFIG *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptQueryContextConfiguration$descriptor() {
        return BCryptQueryContextConfiguration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG *pcbBuffer, PCRYPT_CONTEXT_CONFIG *ppBuffer)
     * }
     */
    public static MethodHandle BCryptQueryContextConfiguration$handle() {
        return BCryptQueryContextConfiguration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG *pcbBuffer, PCRYPT_CONTEXT_CONFIG *ppBuffer)
     * }
     */
    public static MemorySegment BCryptQueryContextConfiguration$address() {
        return BCryptQueryContextConfiguration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG *pcbBuffer, PCRYPT_CONTEXT_CONFIG *ppBuffer)
     * }
     */
    public static int BCryptQueryContextConfiguration(int dwTable, MemorySegment pszContext, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptQueryContextConfiguration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptQueryContextConfiguration", dwTable, pszContext, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptAddContextFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptAddContextFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptAddContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG dwPosition)
     * }
     */
    public static FunctionDescriptor BCryptAddContextFunction$descriptor() {
        return BCryptAddContextFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptAddContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG dwPosition)
     * }
     */
    public static MethodHandle BCryptAddContextFunction$handle() {
        return BCryptAddContextFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptAddContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG dwPosition)
     * }
     */
    public static MemorySegment BCryptAddContextFunction$address() {
        return BCryptAddContextFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptAddContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG dwPosition)
     * }
     */
    public static int BCryptAddContextFunction(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, int dwPosition) {
        var mh$ = BCryptAddContextFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptAddContextFunction", dwTable, pszContext, dwInterface, pszFunction, dwPosition);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, dwPosition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptRemoveContextFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptRemoveContextFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptRemoveContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction)
     * }
     */
    public static FunctionDescriptor BCryptRemoveContextFunction$descriptor() {
        return BCryptRemoveContextFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptRemoveContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction)
     * }
     */
    public static MethodHandle BCryptRemoveContextFunction$handle() {
        return BCryptRemoveContextFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptRemoveContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction)
     * }
     */
    public static MemorySegment BCryptRemoveContextFunction$address() {
        return BCryptRemoveContextFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptRemoveContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction)
     * }
     */
    public static int BCryptRemoveContextFunction(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction) {
        var mh$ = BCryptRemoveContextFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptRemoveContextFunction", dwTable, pszContext, dwInterface, pszFunction);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumContextFunctions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptEnumContextFunctions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctions(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTIONS *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptEnumContextFunctions$descriptor() {
        return BCryptEnumContextFunctions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctions(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTIONS *ppBuffer)
     * }
     */
    public static MethodHandle BCryptEnumContextFunctions$handle() {
        return BCryptEnumContextFunctions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctions(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTIONS *ppBuffer)
     * }
     */
    public static MemorySegment BCryptEnumContextFunctions$address() {
        return BCryptEnumContextFunctions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctions(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTIONS *ppBuffer)
     * }
     */
    public static int BCryptEnumContextFunctions(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptEnumContextFunctions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumContextFunctions", dwTable, pszContext, dwInterface, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptConfigureContextFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptConfigureContextFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, PCRYPT_CONTEXT_FUNCTION_CONFIG pConfig)
     * }
     */
    public static FunctionDescriptor BCryptConfigureContextFunction$descriptor() {
        return BCryptConfigureContextFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, PCRYPT_CONTEXT_FUNCTION_CONFIG pConfig)
     * }
     */
    public static MethodHandle BCryptConfigureContextFunction$handle() {
        return BCryptConfigureContextFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, PCRYPT_CONTEXT_FUNCTION_CONFIG pConfig)
     * }
     */
    public static MemorySegment BCryptConfigureContextFunction$address() {
        return BCryptConfigureContextFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, PCRYPT_CONTEXT_FUNCTION_CONFIG pConfig)
     * }
     */
    public static int BCryptConfigureContextFunction(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pConfig) {
        var mh$ = BCryptConfigureContextFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptConfigureContextFunction", dwTable, pszContext, dwInterface, pszFunction, pConfig);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptQueryContextFunctionConfiguration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptQueryContextFunctionConfiguration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_CONFIG *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptQueryContextFunctionConfiguration$descriptor() {
        return BCryptQueryContextFunctionConfiguration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_CONFIG *ppBuffer)
     * }
     */
    public static MethodHandle BCryptQueryContextFunctionConfiguration$handle() {
        return BCryptQueryContextFunctionConfiguration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_CONFIG *ppBuffer)
     * }
     */
    public static MemorySegment BCryptQueryContextFunctionConfiguration$address() {
        return BCryptQueryContextFunctionConfiguration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_CONFIG *ppBuffer)
     * }
     */
    public static int BCryptQueryContextFunctionConfiguration(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptQueryContextFunctionConfiguration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptQueryContextFunctionConfiguration", dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumContextFunctionProviders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptEnumContextFunctionProviders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctionProviders(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_PROVIDERS *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptEnumContextFunctionProviders$descriptor() {
        return BCryptEnumContextFunctionProviders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctionProviders(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_PROVIDERS *ppBuffer)
     * }
     */
    public static MethodHandle BCryptEnumContextFunctionProviders$handle() {
        return BCryptEnumContextFunctionProviders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctionProviders(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_PROVIDERS *ppBuffer)
     * }
     */
    public static MemorySegment BCryptEnumContextFunctionProviders$address() {
        return BCryptEnumContextFunctionProviders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctionProviders(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_PROVIDERS *ppBuffer)
     * }
     */
    public static int BCryptEnumContextFunctionProviders(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptEnumContextFunctionProviders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumContextFunctionProviders", dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptSetContextFunctionProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptSetContextFunctionProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSetContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG cbValue, PUCHAR pbValue)
     * }
     */
    public static FunctionDescriptor BCryptSetContextFunctionProperty$descriptor() {
        return BCryptSetContextFunctionProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSetContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG cbValue, PUCHAR pbValue)
     * }
     */
    public static MethodHandle BCryptSetContextFunctionProperty$handle() {
        return BCryptSetContextFunctionProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSetContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG cbValue, PUCHAR pbValue)
     * }
     */
    public static MemorySegment BCryptSetContextFunctionProperty$address() {
        return BCryptSetContextFunctionProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptSetContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG cbValue, PUCHAR pbValue)
     * }
     */
    public static int BCryptSetContextFunctionProperty(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pszProperty, int cbValue, MemorySegment pbValue) {
        var mh$ = BCryptSetContextFunctionProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptSetContextFunctionProperty", dwTable, pszContext, dwInterface, pszFunction, pszProperty, cbValue, pbValue);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pszProperty, cbValue, pbValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptQueryContextFunctionProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptQueryContextFunctionProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG *pcbValue, PUCHAR *ppbValue)
     * }
     */
    public static FunctionDescriptor BCryptQueryContextFunctionProperty$descriptor() {
        return BCryptQueryContextFunctionProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG *pcbValue, PUCHAR *ppbValue)
     * }
     */
    public static MethodHandle BCryptQueryContextFunctionProperty$handle() {
        return BCryptQueryContextFunctionProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG *pcbValue, PUCHAR *ppbValue)
     * }
     */
    public static MemorySegment BCryptQueryContextFunctionProperty$address() {
        return BCryptQueryContextFunctionProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG *pcbValue, PUCHAR *ppbValue)
     * }
     */
    public static int BCryptQueryContextFunctionProperty(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pszProperty, MemorySegment pcbValue, MemorySegment ppbValue) {
        var mh$ = BCryptQueryContextFunctionProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptQueryContextFunctionProperty", dwTable, pszContext, dwInterface, pszFunction, pszProperty, pcbValue, ppbValue);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pszProperty, pcbValue, ppbValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptRegisterConfigChangeNotify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptRegisterConfigChangeNotify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptRegisterConfigChangeNotify(HANDLE *phEvent)
     * }
     */
    public static FunctionDescriptor BCryptRegisterConfigChangeNotify$descriptor() {
        return BCryptRegisterConfigChangeNotify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptRegisterConfigChangeNotify(HANDLE *phEvent)
     * }
     */
    public static MethodHandle BCryptRegisterConfigChangeNotify$handle() {
        return BCryptRegisterConfigChangeNotify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptRegisterConfigChangeNotify(HANDLE *phEvent)
     * }
     */
    public static MemorySegment BCryptRegisterConfigChangeNotify$address() {
        return BCryptRegisterConfigChangeNotify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptRegisterConfigChangeNotify(HANDLE *phEvent)
     * }
     */
    public static int BCryptRegisterConfigChangeNotify(MemorySegment phEvent) {
        var mh$ = BCryptRegisterConfigChangeNotify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptRegisterConfigChangeNotify", phEvent);
            }
            return (int)mh$.invokeExact(phEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptUnregisterConfigChangeNotify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptUnregisterConfigChangeNotify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptUnregisterConfigChangeNotify(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor BCryptUnregisterConfigChangeNotify$descriptor() {
        return BCryptUnregisterConfigChangeNotify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptUnregisterConfigChangeNotify(HANDLE hEvent)
     * }
     */
    public static MethodHandle BCryptUnregisterConfigChangeNotify$handle() {
        return BCryptUnregisterConfigChangeNotify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptUnregisterConfigChangeNotify(HANDLE hEvent)
     * }
     */
    public static MemorySegment BCryptUnregisterConfigChangeNotify$address() {
        return BCryptUnregisterConfigChangeNotify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptUnregisterConfigChangeNotify(HANDLE hEvent)
     * }
     */
    public static int BCryptUnregisterConfigChangeNotify(MemorySegment hEvent) {
        var mh$ = BCryptUnregisterConfigChangeNotify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptUnregisterConfigChangeNotify", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptResolveProviders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptResolveProviders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptResolveProviders(LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProvider, ULONG dwMode, ULONG dwFlags, ULONG *pcbBuffer, PCRYPT_PROVIDER_REFS *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptResolveProviders$descriptor() {
        return BCryptResolveProviders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptResolveProviders(LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProvider, ULONG dwMode, ULONG dwFlags, ULONG *pcbBuffer, PCRYPT_PROVIDER_REFS *ppBuffer)
     * }
     */
    public static MethodHandle BCryptResolveProviders$handle() {
        return BCryptResolveProviders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptResolveProviders(LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProvider, ULONG dwMode, ULONG dwFlags, ULONG *pcbBuffer, PCRYPT_PROVIDER_REFS *ppBuffer)
     * }
     */
    public static MemorySegment BCryptResolveProviders$address() {
        return BCryptResolveProviders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptResolveProviders(LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProvider, ULONG dwMode, ULONG dwFlags, ULONG *pcbBuffer, PCRYPT_PROVIDER_REFS *ppBuffer)
     * }
     */
    public static int BCryptResolveProviders(MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pszProvider, int dwMode, int dwFlags, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptResolveProviders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptResolveProviders", pszContext, dwInterface, pszFunction, pszProvider, dwMode, dwFlags, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(pszContext, dwInterface, pszFunction, pszProvider, dwMode, dwFlags, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptGetFipsAlgorithmMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BCryptGetFipsAlgorithmMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetFipsAlgorithmMode(BOOLEAN *pfEnabled)
     * }
     */
    public static FunctionDescriptor BCryptGetFipsAlgorithmMode$descriptor() {
        return BCryptGetFipsAlgorithmMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetFipsAlgorithmMode(BOOLEAN *pfEnabled)
     * }
     */
    public static MethodHandle BCryptGetFipsAlgorithmMode$handle() {
        return BCryptGetFipsAlgorithmMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetFipsAlgorithmMode(BOOLEAN *pfEnabled)
     * }
     */
    public static MemorySegment BCryptGetFipsAlgorithmMode$address() {
        return BCryptGetFipsAlgorithmMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptGetFipsAlgorithmMode(BOOLEAN *pfEnabled)
     * }
     */
    public static int BCryptGetFipsAlgorithmMode(MemorySegment pfEnabled) {
        var mh$ = BCryptGetFipsAlgorithmMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptGetFipsAlgorithmMode", pfEnabled);
            }
            return (int)mh$.invokeExact(pfEnabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CngGetFipsAlgorithmMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CngGetFipsAlgorithmMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CngGetFipsAlgorithmMode()
     * }
     */
    public static FunctionDescriptor CngGetFipsAlgorithmMode$descriptor() {
        return CngGetFipsAlgorithmMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CngGetFipsAlgorithmMode()
     * }
     */
    public static MethodHandle CngGetFipsAlgorithmMode$handle() {
        return CngGetFipsAlgorithmMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CngGetFipsAlgorithmMode()
     * }
     */
    public static MemorySegment CngGetFipsAlgorithmMode$address() {
        return CngGetFipsAlgorithmMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CngGetFipsAlgorithmMode()
     * }
     */
    public static byte CngGetFipsAlgorithmMode() {
        var mh$ = CngGetFipsAlgorithmMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CngGetFipsAlgorithmMode");
            }
            return (byte)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef LONG SECURITY_STATUS
     * }
     */
    public static final OfInt SECURITY_STATUS = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef BCryptBuffer *PNCryptBuffer
     * }
     */
    public static final AddressLayout PNCryptBuffer = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef BCryptBufferDesc *PNCryptBufferDesc
     * }
     */
    public static final AddressLayout PNCryptBufferDesc = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR NCRYPT_HANDLE
     * }
     */
    public static final OfLong NCRYPT_HANDLE = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR NCRYPT_PROV_HANDLE
     * }
     */
    public static final OfLong NCRYPT_PROV_HANDLE = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR NCRYPT_KEY_HANDLE
     * }
     */
    public static final OfLong NCRYPT_KEY_HANDLE = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR NCRYPT_HASH_HANDLE
     * }
     */
    public static final OfLong NCRYPT_HASH_HANDLE = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR NCRYPT_SECRET_HANDLE
     * }
     */
    public static final OfLong NCRYPT_SECRET_HANDLE = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_CIPHER_PADDING_INFO {
     *     ULONG cbSize;
     *     DWORD dwFlags;
     *     PUCHAR pbIV;
     *     ULONG cbIV;
     *     PUCHAR pbOtherInfo;
     *     ULONG cbOtherInfo;
     * } *PNCRYPT_CIPHER_PADDING_INFO
     * }
     */
    public static final AddressLayout PNCRYPT_CIPHER_PADDING_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES {
     *     ULONG Version;
     *     ULONG Flags;
     *     ULONG cbPublicKeyBlob;
     * } *PNCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES
     * }
     */
    public static final AddressLayout PNCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_VSM_KEY_ATTESTATION_STATEMENT {
     *     ULONG Magic;
     *     ULONG Version;
     *     ULONG cbSignature;
     *     ULONG cbReport;
     *     ULONG cbAttributes;
     * } *PNCRYPT_VSM_KEY_ATTESTATION_STATEMENT
     * }
     */
    public static final AddressLayout PNCRYPT_VSM_KEY_ATTESTATION_STATEMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS {
     *     ULONG Version;
     *     ULONGLONG TrustletId;
     *     ULONG MinSvn;
     *     ULONG FlagsMask;
     *     ULONG FlagsExpected;
     *     ULONG AllowDebugging : 1;
     *     ULONG Reserved : 31;
     * } *PNCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS
     * }
     */
    public static final AddressLayout PNCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_EXPORTED_ISOLATED_KEY_HEADER {
     *     ULONG Version;
     *     ULONG KeyUsage;
     *     ULONG PerBootKey : 1;
     *     ULONG Reserved : 31;
     *     ULONG cbAlgName;
     *     ULONG cbNonce;
     *     ULONG cbAuthTag;
     *     ULONG cbWrappingKey;
     *     ULONG cbIsolatedKey;
     * } *PNCRYPT_EXPORTED_ISOLATED_KEY_HEADER
     * }
     */
    public static final AddressLayout PNCRYPT_EXPORTED_ISOLATED_KEY_HEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE {
     *     NCRYPT_EXPORTED_ISOLATED_KEY_HEADER Header;
     * } *PNCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE
     * }
     */
    public static final AddressLayout PNCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct __NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT {
     *     UINT32 Magic;
     *     UINT32 Version;
     *     UINT32 HeaderSize;
     *     UINT32 cbCertifyInfo;
     *     UINT32 cbSignature;
     *     UINT32 cbTpmPublic;
     * } *PNCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT
     * }
     */
    public static final AddressLayout PNCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT {
     *     ULONG Magic;
     *     ULONG Version;
     *     ULONG pcrAlg;
     *     ULONG cbSignature;
     *     ULONG cbQuote;
     *     ULONG cbPcrs;
     * } *PNCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT
     * }
     */
    public static final AddressLayout PNCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = wgl_h.C_POINTER;

    private static class NCryptOpenStorageProvider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptOpenStorageProvider");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenStorageProvider(NCRYPT_PROV_HANDLE *phProvider, LPCWSTR pszProviderName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptOpenStorageProvider$descriptor() {
        return NCryptOpenStorageProvider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenStorageProvider(NCRYPT_PROV_HANDLE *phProvider, LPCWSTR pszProviderName, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptOpenStorageProvider$handle() {
        return NCryptOpenStorageProvider.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenStorageProvider(NCRYPT_PROV_HANDLE *phProvider, LPCWSTR pszProviderName, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptOpenStorageProvider$address() {
        return NCryptOpenStorageProvider.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenStorageProvider(NCRYPT_PROV_HANDLE *phProvider, LPCWSTR pszProviderName, DWORD dwFlags)
     * }
     */
    public static int NCryptOpenStorageProvider(MemorySegment phProvider, MemorySegment pszProviderName, int dwFlags) {
        var mh$ = NCryptOpenStorageProvider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptOpenStorageProvider", phProvider, pszProviderName, dwFlags);
            }
            return (int)mh$.invokeExact(phProvider, pszProviderName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptEnumAlgorithms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptEnumAlgorithms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumAlgorithms(NCRYPT_PROV_HANDLE hProvider, DWORD dwAlgOperations, DWORD *pdwAlgCount, NCryptAlgorithmName **ppAlgList, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptEnumAlgorithms$descriptor() {
        return NCryptEnumAlgorithms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumAlgorithms(NCRYPT_PROV_HANDLE hProvider, DWORD dwAlgOperations, DWORD *pdwAlgCount, NCryptAlgorithmName **ppAlgList, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptEnumAlgorithms$handle() {
        return NCryptEnumAlgorithms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumAlgorithms(NCRYPT_PROV_HANDLE hProvider, DWORD dwAlgOperations, DWORD *pdwAlgCount, NCryptAlgorithmName **ppAlgList, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptEnumAlgorithms$address() {
        return NCryptEnumAlgorithms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumAlgorithms(NCRYPT_PROV_HANDLE hProvider, DWORD dwAlgOperations, DWORD *pdwAlgCount, NCryptAlgorithmName **ppAlgList, DWORD dwFlags)
     * }
     */
    public static int NCryptEnumAlgorithms(long hProvider, int dwAlgOperations, MemorySegment pdwAlgCount, MemorySegment ppAlgList, int dwFlags) {
        var mh$ = NCryptEnumAlgorithms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptEnumAlgorithms", hProvider, dwAlgOperations, pdwAlgCount, ppAlgList, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, dwAlgOperations, pdwAlgCount, ppAlgList, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptIsAlgSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptIsAlgSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptIsAlgSupported(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszAlgId, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptIsAlgSupported$descriptor() {
        return NCryptIsAlgSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptIsAlgSupported(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszAlgId, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptIsAlgSupported$handle() {
        return NCryptIsAlgSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptIsAlgSupported(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszAlgId, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptIsAlgSupported$address() {
        return NCryptIsAlgSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptIsAlgSupported(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszAlgId, DWORD dwFlags)
     * }
     */
    public static int NCryptIsAlgSupported(long hProvider, MemorySegment pszAlgId, int dwFlags) {
        var mh$ = NCryptIsAlgSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptIsAlgSupported", hProvider, pszAlgId, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, pszAlgId, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptEnumKeys {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptEnumKeys");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumKeys(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszScope, NCryptKeyName **ppKeyName, PVOID *ppEnumState, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptEnumKeys$descriptor() {
        return NCryptEnumKeys.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumKeys(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszScope, NCryptKeyName **ppKeyName, PVOID *ppEnumState, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptEnumKeys$handle() {
        return NCryptEnumKeys.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumKeys(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszScope, NCryptKeyName **ppKeyName, PVOID *ppEnumState, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptEnumKeys$address() {
        return NCryptEnumKeys.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumKeys(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszScope, NCryptKeyName **ppKeyName, PVOID *ppEnumState, DWORD dwFlags)
     * }
     */
    public static int NCryptEnumKeys(long hProvider, MemorySegment pszScope, MemorySegment ppKeyName, MemorySegment ppEnumState, int dwFlags) {
        var mh$ = NCryptEnumKeys.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptEnumKeys", hProvider, pszScope, ppKeyName, ppEnumState, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, pszScope, ppKeyName, ppEnumState, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptEnumStorageProviders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptEnumStorageProviders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumStorageProviders(DWORD *pdwProviderCount, NCryptProviderName **ppProviderList, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptEnumStorageProviders$descriptor() {
        return NCryptEnumStorageProviders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumStorageProviders(DWORD *pdwProviderCount, NCryptProviderName **ppProviderList, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptEnumStorageProviders$handle() {
        return NCryptEnumStorageProviders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumStorageProviders(DWORD *pdwProviderCount, NCryptProviderName **ppProviderList, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptEnumStorageProviders$address() {
        return NCryptEnumStorageProviders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumStorageProviders(DWORD *pdwProviderCount, NCryptProviderName **ppProviderList, DWORD dwFlags)
     * }
     */
    public static int NCryptEnumStorageProviders(MemorySegment pdwProviderCount, MemorySegment ppProviderList, int dwFlags) {
        var mh$ = NCryptEnumStorageProviders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptEnumStorageProviders", pdwProviderCount, ppProviderList, dwFlags);
            }
            return (int)mh$.invokeExact(pdwProviderCount, ppProviderList, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptFreeBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptFreeBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeBuffer(PVOID pvInput)
     * }
     */
    public static FunctionDescriptor NCryptFreeBuffer$descriptor() {
        return NCryptFreeBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeBuffer(PVOID pvInput)
     * }
     */
    public static MethodHandle NCryptFreeBuffer$handle() {
        return NCryptFreeBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeBuffer(PVOID pvInput)
     * }
     */
    public static MemorySegment NCryptFreeBuffer$address() {
        return NCryptFreeBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeBuffer(PVOID pvInput)
     * }
     */
    public static int NCryptFreeBuffer(MemorySegment pvInput) {
        var mh$ = NCryptFreeBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptFreeBuffer", pvInput);
            }
            return (int)mh$.invokeExact(pvInput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptOpenKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptOpenKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptOpenKey$descriptor() {
        return NCryptOpenKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptOpenKey$handle() {
        return NCryptOpenKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptOpenKey$address() {
        return NCryptOpenKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static int NCryptOpenKey(long hProvider, MemorySegment phKey, MemorySegment pszKeyName, int dwLegacyKeySpec, int dwFlags) {
        var mh$ = NCryptOpenKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptOpenKey", hProvider, phKey, pszKeyName, dwLegacyKeySpec, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, phKey, pszKeyName, dwLegacyKeySpec, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptCreatePersistedKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptCreatePersistedKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreatePersistedKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszAlgId, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptCreatePersistedKey$descriptor() {
        return NCryptCreatePersistedKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreatePersistedKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszAlgId, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptCreatePersistedKey$handle() {
        return NCryptCreatePersistedKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreatePersistedKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszAlgId, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptCreatePersistedKey$address() {
        return NCryptCreatePersistedKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreatePersistedKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszAlgId, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static int NCryptCreatePersistedKey(long hProvider, MemorySegment phKey, MemorySegment pszAlgId, MemorySegment pszKeyName, int dwLegacyKeySpec, int dwFlags) {
        var mh$ = NCryptCreatePersistedKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptCreatePersistedKey", hProvider, phKey, pszAlgId, pszKeyName, dwLegacyKeySpec, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, phKey, pszAlgId, pszKeyName, dwLegacyKeySpec, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptGetProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptGetProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptGetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptGetProperty$descriptor() {
        return NCryptGetProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptGetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptGetProperty$handle() {
        return NCryptGetProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptGetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptGetProperty$address() {
        return NCryptGetProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptGetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptGetProperty(long hObject, MemorySegment pszProperty, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptGetProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptGetProperty", hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptSetProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptSetProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbInput, DWORD cbInput, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptSetProperty$descriptor() {
        return NCryptSetProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbInput, DWORD cbInput, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptSetProperty$handle() {
        return NCryptSetProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbInput, DWORD cbInput, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptSetProperty$address() {
        return NCryptSetProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbInput, DWORD cbInput, DWORD dwFlags)
     * }
     */
    public static int NCryptSetProperty(long hObject, MemorySegment pszProperty, MemorySegment pbInput, int cbInput, int dwFlags) {
        var mh$ = NCryptSetProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptSetProperty", hObject, pszProperty, pbInput, cbInput, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, pszProperty, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptFinalizeKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptFinalizeKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFinalizeKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptFinalizeKey$descriptor() {
        return NCryptFinalizeKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFinalizeKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptFinalizeKey$handle() {
        return NCryptFinalizeKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFinalizeKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptFinalizeKey$address() {
        return NCryptFinalizeKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFinalizeKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static int NCryptFinalizeKey(long hKey, int dwFlags) {
        var mh$ = NCryptFinalizeKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptFinalizeKey", hKey, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptEncrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptEncrypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEncrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptEncrypt$descriptor() {
        return NCryptEncrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEncrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptEncrypt$handle() {
        return NCryptEncrypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEncrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptEncrypt$address() {
        return NCryptEncrypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEncrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptEncrypt(long hKey, MemorySegment pbInput, int cbInput, MemorySegment pPaddingInfo, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptEncrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptEncrypt", hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptDecrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptDecrypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDecrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptDecrypt$descriptor() {
        return NCryptDecrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDecrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptDecrypt$handle() {
        return NCryptDecrypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDecrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptDecrypt$address() {
        return NCryptDecrypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDecrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptDecrypt(long hKey, MemorySegment pbInput, int cbInput, MemorySegment pPaddingInfo, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptDecrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptDecrypt", hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_KEY_BLOB_HEADER {
     *     ULONG cbSize;
     *     ULONG dwMagic;
     *     ULONG cbAlgName;
     *     ULONG cbKeyData;
     * } *PNCRYPT_KEY_BLOB_HEADER
     * }
     */
    public static final AddressLayout PNCRYPT_KEY_BLOB_HEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER {
     *     DWORD magic;
     *     DWORD cbHeader;
     *     DWORD cbPublic;
     *     DWORD cbPrivate;
     *     DWORD cbName;
     * } *PNCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER
     * }
     */
    public static final AddressLayout PNCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = wgl_h.C_POINTER;

    private static class NCryptImportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptImportKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptImportKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, NCRYPT_KEY_HANDLE *phKey, PBYTE pbData, DWORD cbData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptImportKey$descriptor() {
        return NCryptImportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptImportKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, NCRYPT_KEY_HANDLE *phKey, PBYTE pbData, DWORD cbData, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptImportKey$handle() {
        return NCryptImportKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptImportKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, NCRYPT_KEY_HANDLE *phKey, PBYTE pbData, DWORD cbData, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptImportKey$address() {
        return NCryptImportKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptImportKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, NCRYPT_KEY_HANDLE *phKey, PBYTE pbData, DWORD cbData, DWORD dwFlags)
     * }
     */
    public static int NCryptImportKey(long hProvider, long hImportKey, MemorySegment pszBlobType, MemorySegment pParameterList, MemorySegment phKey, MemorySegment pbData, int cbData, int dwFlags) {
        var mh$ = NCryptImportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptImportKey", hProvider, hImportKey, pszBlobType, pParameterList, phKey, pbData, cbData, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, hImportKey, pszBlobType, pParameterList, phKey, pbData, cbData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptExportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptExportKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptExportKey(NCRYPT_KEY_HANDLE hKey, NCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptExportKey$descriptor() {
        return NCryptExportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptExportKey(NCRYPT_KEY_HANDLE hKey, NCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptExportKey$handle() {
        return NCryptExportKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptExportKey(NCRYPT_KEY_HANDLE hKey, NCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptExportKey$address() {
        return NCryptExportKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptExportKey(NCRYPT_KEY_HANDLE hKey, NCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptExportKey(long hKey, long hExportKey, MemorySegment pszBlobType, MemorySegment pParameterList, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptExportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptExportKey", hKey, hExportKey, pszBlobType, pParameterList, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, hExportKey, pszBlobType, pParameterList, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptSignHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptSignHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSignHash(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptSignHash$descriptor() {
        return NCryptSignHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSignHash(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptSignHash$handle() {
        return NCryptSignHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSignHash(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptSignHash$address() {
        return NCryptSignHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSignHash(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptSignHash(long hKey, MemorySegment pPaddingInfo, MemorySegment pbHashValue, int cbHashValue, MemorySegment pbSignature, int cbSignature, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptSignHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptSignHash", hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptVerifySignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptVerifySignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifySignature(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptVerifySignature$descriptor() {
        return NCryptVerifySignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifySignature(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptVerifySignature$handle() {
        return NCryptVerifySignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifySignature(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptVerifySignature$address() {
        return NCryptVerifySignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifySignature(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD dwFlags)
     * }
     */
    public static int NCryptVerifySignature(long hKey, MemorySegment pPaddingInfo, MemorySegment pbHashValue, int cbHashValue, MemorySegment pbSignature, int cbSignature, int dwFlags) {
        var mh$ = NCryptVerifySignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptVerifySignature", hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptDeleteKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptDeleteKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeleteKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptDeleteKey$descriptor() {
        return NCryptDeleteKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeleteKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptDeleteKey$handle() {
        return NCryptDeleteKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeleteKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptDeleteKey$address() {
        return NCryptDeleteKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeleteKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static int NCryptDeleteKey(long hKey, int dwFlags) {
        var mh$ = NCryptDeleteKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptDeleteKey", hKey, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptFreeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptFreeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeObject(NCRYPT_HANDLE hObject)
     * }
     */
    public static FunctionDescriptor NCryptFreeObject$descriptor() {
        return NCryptFreeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeObject(NCRYPT_HANDLE hObject)
     * }
     */
    public static MethodHandle NCryptFreeObject$handle() {
        return NCryptFreeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeObject(NCRYPT_HANDLE hObject)
     * }
     */
    public static MemorySegment NCryptFreeObject$address() {
        return NCryptFreeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeObject(NCRYPT_HANDLE hObject)
     * }
     */
    public static int NCryptFreeObject(long hObject) {
        var mh$ = NCryptFreeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptFreeObject", hObject);
            }
            return (int)mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptIsKeyHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptIsKeyHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NCryptIsKeyHandle(NCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static FunctionDescriptor NCryptIsKeyHandle$descriptor() {
        return NCryptIsKeyHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NCryptIsKeyHandle(NCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static MethodHandle NCryptIsKeyHandle$handle() {
        return NCryptIsKeyHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL NCryptIsKeyHandle(NCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static MemorySegment NCryptIsKeyHandle$address() {
        return NCryptIsKeyHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL NCryptIsKeyHandle(NCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static int NCryptIsKeyHandle(long hKey) {
        var mh$ = NCryptIsKeyHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptIsKeyHandle", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptTranslateHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptTranslateHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptTranslateHandle(NCRYPT_PROV_HANDLE *phProvider, NCRYPT_KEY_HANDLE *phKey, HCRYPTPROV hLegacyProv, HCRYPTKEY hLegacyKey, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptTranslateHandle$descriptor() {
        return NCryptTranslateHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptTranslateHandle(NCRYPT_PROV_HANDLE *phProvider, NCRYPT_KEY_HANDLE *phKey, HCRYPTPROV hLegacyProv, HCRYPTKEY hLegacyKey, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptTranslateHandle$handle() {
        return NCryptTranslateHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptTranslateHandle(NCRYPT_PROV_HANDLE *phProvider, NCRYPT_KEY_HANDLE *phKey, HCRYPTPROV hLegacyProv, HCRYPTKEY hLegacyKey, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptTranslateHandle$address() {
        return NCryptTranslateHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptTranslateHandle(NCRYPT_PROV_HANDLE *phProvider, NCRYPT_KEY_HANDLE *phKey, HCRYPTPROV hLegacyProv, HCRYPTKEY hLegacyKey, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static int NCryptTranslateHandle(MemorySegment phProvider, MemorySegment phKey, long hLegacyProv, long hLegacyKey, int dwLegacyKeySpec, int dwFlags) {
        var mh$ = NCryptTranslateHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptTranslateHandle", phProvider, phKey, hLegacyProv, hLegacyKey, dwLegacyKeySpec, dwFlags);
            }
            return (int)mh$.invokeExact(phProvider, phKey, hLegacyProv, hLegacyKey, dwLegacyKeySpec, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptNotifyChangeKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptNotifyChangeKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptNotifyChangeKey(NCRYPT_PROV_HANDLE hProvider, HANDLE *phEvent, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptNotifyChangeKey$descriptor() {
        return NCryptNotifyChangeKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptNotifyChangeKey(NCRYPT_PROV_HANDLE hProvider, HANDLE *phEvent, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptNotifyChangeKey$handle() {
        return NCryptNotifyChangeKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptNotifyChangeKey(NCRYPT_PROV_HANDLE hProvider, HANDLE *phEvent, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptNotifyChangeKey$address() {
        return NCryptNotifyChangeKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptNotifyChangeKey(NCRYPT_PROV_HANDLE hProvider, HANDLE *phEvent, DWORD dwFlags)
     * }
     */
    public static int NCryptNotifyChangeKey(long hProvider, MemorySegment phEvent, int dwFlags) {
        var mh$ = NCryptNotifyChangeKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptNotifyChangeKey", hProvider, phEvent, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, phEvent, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptSecretAgreement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptSecretAgreement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSecretAgreement(NCRYPT_KEY_HANDLE hPrivKey, NCRYPT_KEY_HANDLE hPubKey, NCRYPT_SECRET_HANDLE *phAgreedSecret, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptSecretAgreement$descriptor() {
        return NCryptSecretAgreement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSecretAgreement(NCRYPT_KEY_HANDLE hPrivKey, NCRYPT_KEY_HANDLE hPubKey, NCRYPT_SECRET_HANDLE *phAgreedSecret, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptSecretAgreement$handle() {
        return NCryptSecretAgreement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSecretAgreement(NCRYPT_KEY_HANDLE hPrivKey, NCRYPT_KEY_HANDLE hPubKey, NCRYPT_SECRET_HANDLE *phAgreedSecret, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptSecretAgreement$address() {
        return NCryptSecretAgreement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSecretAgreement(NCRYPT_KEY_HANDLE hPrivKey, NCRYPT_KEY_HANDLE hPubKey, NCRYPT_SECRET_HANDLE *phAgreedSecret, DWORD dwFlags)
     * }
     */
    public static int NCryptSecretAgreement(long hPrivKey, long hPubKey, MemorySegment phAgreedSecret, int dwFlags) {
        var mh$ = NCryptSecretAgreement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptSecretAgreement", hPrivKey, hPubKey, phAgreedSecret, dwFlags);
            }
            return (int)mh$.invokeExact(hPrivKey, hPubKey, phAgreedSecret, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptDeriveKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptDeriveKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeriveKey(NCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, NCryptBufferDesc *pParameterList, PBYTE pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptDeriveKey$descriptor() {
        return NCryptDeriveKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeriveKey(NCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, NCryptBufferDesc *pParameterList, PBYTE pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle NCryptDeriveKey$handle() {
        return NCryptDeriveKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeriveKey(NCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, NCryptBufferDesc *pParameterList, PBYTE pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static MemorySegment NCryptDeriveKey$address() {
        return NCryptDeriveKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeriveKey(NCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, NCryptBufferDesc *pParameterList, PBYTE pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static int NCryptDeriveKey(long hSharedSecret, MemorySegment pwszKDF, MemorySegment pParameterList, MemorySegment pbDerivedKey, int cbDerivedKey, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptDeriveKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptDeriveKey", hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptKeyDerivation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptKeyDerivation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptKeyDerivation(NCRYPT_KEY_HANDLE hKey, NCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptKeyDerivation$descriptor() {
        return NCryptKeyDerivation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptKeyDerivation(NCRYPT_KEY_HANDLE hKey, NCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle NCryptKeyDerivation$handle() {
        return NCryptKeyDerivation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptKeyDerivation(NCRYPT_KEY_HANDLE hKey, NCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static MemorySegment NCryptKeyDerivation$address() {
        return NCryptKeyDerivation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptKeyDerivation(NCRYPT_KEY_HANDLE hKey, NCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static int NCryptKeyDerivation(long hKey, MemorySegment pParameterList, MemorySegment pbDerivedKey, int cbDerivedKey, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptKeyDerivation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptKeyDerivation", hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptCreateClaim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptCreateClaim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreateClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptCreateClaim$descriptor() {
        return NCryptCreateClaim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreateClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptCreateClaim$handle() {
        return NCryptCreateClaim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreateClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptCreateClaim$address() {
        return NCryptCreateClaim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreateClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptCreateClaim(long hSubjectKey, long hAuthorityKey, int dwClaimType, MemorySegment pParameterList, MemorySegment pbClaimBlob, int cbClaimBlob, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptCreateClaim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptCreateClaim", hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptVerifyClaim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NCryptVerifyClaim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifyClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, NCryptBufferDesc *pOutput, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptVerifyClaim$descriptor() {
        return NCryptVerifyClaim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifyClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, NCryptBufferDesc *pOutput, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptVerifyClaim$handle() {
        return NCryptVerifyClaim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifyClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, NCryptBufferDesc *pOutput, DWORD dwFlags)
     * }
     */
    public static MemorySegment NCryptVerifyClaim$address() {
        return NCryptVerifyClaim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifyClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, NCryptBufferDesc *pOutput, DWORD dwFlags)
     * }
     */
    public static int NCryptVerifyClaim(long hSubjectKey, long hAuthorityKey, int dwClaimType, MemorySegment pParameterList, MemorySegment pbClaimBlob, int cbClaimBlob, MemorySegment pOutput, int dwFlags) {
        var mh$ = NCryptVerifyClaim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptVerifyClaim", hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pOutput, dwFlags);
            }
            return (int)mh$.invokeExact(hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pOutput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR HCRYPTPROV_OR_NCRYPT_KEY_HANDLE
     * }
     */
    public static final OfLong HCRYPTPROV_OR_NCRYPT_KEY_HANDLE = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR HCRYPTPROV_LEGACY
     * }
     */
    public static final OfLong HCRYPTPROV_LEGACY = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_BIT_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     *     DWORD cUnusedBits;
     * } *PCRYPT_BIT_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_BIT_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ALGORITHM_IDENTIFIER {
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Parameters;
     * } *PCRYPT_ALGORITHM_IDENTIFIER
     * }
     */
    public static final AddressLayout PCRYPT_ALGORITHM_IDENTIFIER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_OBJID_TABLE {
     *     DWORD dwAlgId;
     *     LPCSTR pszObjId;
     * } *PCRYPT_OBJID_TABLE
     * }
     */
    public static final AddressLayout PCRYPT_OBJID_TABLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_HASH_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_HASH_BLOB Hash;
     * } *PCRYPT_HASH_INFO
     * }
     */
    public static final AddressLayout PCRYPT_HASH_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_EXTENSION {
     *     LPSTR pszObjId;
     *     BOOL fCritical;
     *     CRYPT_OBJID_BLOB Value;
     * } *PCERT_EXTENSION
     * }
     */
    public static final AddressLayout PCERT_EXTENSION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_EXTENSION *PCCERT_EXTENSION
     * }
     */
    public static final AddressLayout PCCERT_EXTENSION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ATTRIBUTE_TYPE_VALUE {
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Value;
     * } *PCRYPT_ATTRIBUTE_TYPE_VALUE
     * }
     */
    public static final AddressLayout PCRYPT_ATTRIBUTE_TYPE_VALUE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ATTRIBUTE {
     *     LPSTR pszObjId;
     *     DWORD cValue;
     *     PCRYPT_ATTR_BLOB rgValue;
     * } *PCRYPT_ATTRIBUTE
     * }
     */
    public static final AddressLayout PCRYPT_ATTRIBUTE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ATTRIBUTES {
     *     DWORD cAttr;
     *     PCRYPT_ATTRIBUTE rgAttr;
     * } *PCRYPT_ATTRIBUTES
     * }
     */
    public static final AddressLayout PCRYPT_ATTRIBUTES = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_RDN_ATTR {
     *     LPSTR pszObjId;
     *     DWORD dwValueType;
     *     CERT_RDN_VALUE_BLOB Value;
     * } *PCERT_RDN_ATTR
     * }
     */
    public static final AddressLayout PCERT_RDN_ATTR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_RDN {
     *     DWORD cRDNAttr;
     *     PCERT_RDN_ATTR rgRDNAttr;
     * } *PCERT_RDN
     * }
     */
    public static final AddressLayout PCERT_RDN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_NAME_INFO {
     *     DWORD cRDN;
     *     PCERT_RDN rgRDN;
     * } *PCERT_NAME_INFO
     * }
     */
    public static final AddressLayout PCERT_NAME_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_NAME_VALUE {
     *     DWORD dwValueType;
     *     CERT_RDN_VALUE_BLOB Value;
     * } *PCERT_NAME_VALUE
     * }
     */
    public static final AddressLayout PCERT_NAME_VALUE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_PUBLIC_KEY_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER Algorithm;
     *     CRYPT_BIT_BLOB PublicKey;
     * } *PCERT_PUBLIC_KEY_INFO
     * }
     */
    public static final AddressLayout PCERT_PUBLIC_KEY_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ECC_PRIVATE_KEY_INFO {
     *     DWORD dwVersion;
     *     CRYPT_DER_BLOB PrivateKey;
     *     LPSTR szCurveOid;
     *     CRYPT_BIT_BLOB PublicKey;
     * } *PCRYPT_ECC_PRIVATE_KEY_INFO
     * }
     */
    public static final AddressLayout PCRYPT_ECC_PRIVATE_KEY_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PRIVATE_KEY_INFO {
     *     DWORD Version;
     *     CRYPT_ALGORITHM_IDENTIFIER Algorithm;
     *     CRYPT_DER_BLOB PrivateKey;
     *     PCRYPT_ATTRIBUTES pAttributes;
     * } *PCRYPT_PRIVATE_KEY_INFO
     * }
     */
    public static final AddressLayout PCRYPT_PRIVATE_KEY_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER EncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedPrivateKey;
     * } *PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO
     * }
     */
    public static final AddressLayout PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PKCS8_IMPORT_PARAMS {
     *     CRYPT_DIGEST_BLOB PrivateKey;
     *     PCRYPT_RESOLVE_HCRYPTPROV_FUNC pResolvehCryptProvFunc;
     *     LPVOID pVoidResolveFunc;
     *     PCRYPT_DECRYPT_PRIVATE_KEY_FUNC pDecryptPrivateKeyFunc;
     *     LPVOID pVoidDecryptFunc;
     * } *PCRYPT_PKCS8_IMPORT_PARAMS
     * }
     */
    public static final AddressLayout PCRYPT_PKCS8_IMPORT_PARAMS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PKCS8_IMPORT_PARAMS {
     *     CRYPT_DIGEST_BLOB PrivateKey;
     *     PCRYPT_RESOLVE_HCRYPTPROV_FUNC pResolvehCryptProvFunc;
     *     LPVOID pVoidResolveFunc;
     *     PCRYPT_DECRYPT_PRIVATE_KEY_FUNC pDecryptPrivateKeyFunc;
     *     LPVOID pVoidDecryptFunc;
     * } *PCRYPT_PRIVATE_KEY_BLOB_AND_PARAMS
     * }
     */
    public static final AddressLayout PCRYPT_PRIVATE_KEY_BLOB_AND_PARAMS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PKCS8_EXPORT_PARAMS {
     *     HCRYPTPROV hCryptProv;
     *     DWORD dwKeySpec;
     *     LPSTR pszPrivateKeyObjId;
     *     PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC pEncryptPrivateKeyFunc;
     *     LPVOID pVoidEncryptFunc;
     * } *PCRYPT_PKCS8_EXPORT_PARAMS
     * }
     */
    public static final AddressLayout PCRYPT_PKCS8_EXPORT_PARAMS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_INFO {
     *     DWORD dwVersion;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     *     CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
     *     CERT_NAME_BLOB Issuer;
     *     FILETIME NotBefore;
     *     FILETIME NotAfter;
     *     CERT_NAME_BLOB Subject;
     *     CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
     *     CRYPT_BIT_BLOB IssuerUniqueId;
     *     CRYPT_BIT_BLOB SubjectUniqueId;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCERT_INFO
     * }
     */
    public static final AddressLayout PCERT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_ENTRY {
     *     CRYPT_INTEGER_BLOB SerialNumber;
     *     FILETIME RevocationDate;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCRL_ENTRY
     * }
     */
    public static final AddressLayout PCRL_ENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_INFO {
     *     DWORD dwVersion;
     *     CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
     *     CERT_NAME_BLOB Issuer;
     *     FILETIME ThisUpdate;
     *     FILETIME NextUpdate;
     *     DWORD cCRLEntry;
     *     PCRL_ENTRY rgCRLEntry;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCRL_INFO
     * }
     */
    public static final AddressLayout PCRL_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_OR_CRL_BLOB {
     *     DWORD dwChoice;
     *     DWORD cbEncoded;
     *     BYTE *pbEncoded;
     * } *PCERT_OR_CRL_BLOB
     * }
     */
    public static final AddressLayout PCERT_OR_CRL_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_OR_CRL_BUNDLE {
     *     DWORD cItem;
     *     PCERT_OR_CRL_BLOB rgItem;
     * } *PCERT_OR_CRL_BUNDLE
     * }
     */
    public static final AddressLayout PCERT_OR_CRL_BUNDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REQUEST_INFO {
     *     DWORD dwVersion;
     *     CERT_NAME_BLOB Subject;
     *     CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
     *     DWORD cAttribute;
     *     PCRYPT_ATTRIBUTE rgAttribute;
     * } *PCERT_REQUEST_INFO
     * }
     */
    public static final AddressLayout PCERT_REQUEST_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_KEYGEN_REQUEST_INFO {
     *     DWORD dwVersion;
     *     CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
     *     LPWSTR pwszChallengeString;
     * } *PCERT_KEYGEN_REQUEST_INFO
     * }
     */
    public static final AddressLayout PCERT_KEYGEN_REQUEST_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SIGNED_CONTENT_INFO {
     *     CRYPT_DER_BLOB ToBeSigned;
     *     CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
     *     CRYPT_BIT_BLOB Signature;
     * } *PCERT_SIGNED_CONTENT_INFO
     * }
     */
    public static final AddressLayout PCERT_SIGNED_CONTENT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_USAGE {
     *     DWORD cUsageIdentifier;
     *     LPSTR *rgpszUsageIdentifier;
     * } *PCTL_USAGE
     * }
     */
    public static final AddressLayout PCTL_USAGE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_USAGE {
     *     DWORD cUsageIdentifier;
     *     LPSTR *rgpszUsageIdentifier;
     * } *PCERT_ENHKEY_USAGE
     * }
     */
    public static final AddressLayout PCERT_ENHKEY_USAGE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CTL_USAGE *PCCTL_USAGE
     * }
     */
    public static final AddressLayout PCCTL_USAGE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_ENHKEY_USAGE *PCCERT_ENHKEY_USAGE
     * }
     */
    public static final AddressLayout PCCERT_ENHKEY_USAGE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_ENTRY {
     *     CRYPT_DATA_BLOB SubjectIdentifier;
     *     DWORD cAttribute;
     *     PCRYPT_ATTRIBUTE rgAttribute;
     * } *PCTL_ENTRY
     * }
     */
    public static final AddressLayout PCTL_ENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_INFO {
     *     DWORD dwVersion;
     *     CTL_USAGE SubjectUsage;
     *     CRYPT_DATA_BLOB ListIdentifier;
     *     CRYPT_INTEGER_BLOB SequenceNumber;
     *     FILETIME ThisUpdate;
     *     FILETIME NextUpdate;
     *     CRYPT_ALGORITHM_IDENTIFIER SubjectAlgorithm;
     *     DWORD cCTLEntry;
     *     PCTL_ENTRY rgCTLEntry;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCTL_INFO
     * }
     */
    public static final AddressLayout PCTL_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIME_STAMP_REQUEST_INFO {
     *     LPSTR pszTimeStampAlgorithm;
     *     LPSTR pszContentType;
     *     CRYPT_OBJID_BLOB Content;
     *     DWORD cAttribute;
     *     PCRYPT_ATTRIBUTE rgAttribute;
     * } *PCRYPT_TIME_STAMP_REQUEST_INFO
     * }
     */
    public static final AddressLayout PCRYPT_TIME_STAMP_REQUEST_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ENROLLMENT_NAME_VALUE_PAIR {
     *     LPWSTR pwszName;
     *     LPWSTR pwszValue;
     * } *PCRYPT_ENROLLMENT_NAME_VALUE_PAIR
     * }
     */
    public static final AddressLayout PCRYPT_ENROLLMENT_NAME_VALUE_PAIR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CSP_PROVIDER {
     *     DWORD dwKeySpec;
     *     LPWSTR pwszProviderName;
     *     CRYPT_BIT_BLOB Signature;
     * } *PCRYPT_CSP_PROVIDER
     * }
     */
    public static final AddressLayout PCRYPT_CSP_PROVIDER = wgl_h.C_POINTER;

    private static class CryptFormatObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptFormatObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptFormatObject(DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType, void *pFormatStruct, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, void *pbFormat, DWORD *pcbFormat)
     * }
     */
    public static FunctionDescriptor CryptFormatObject$descriptor() {
        return CryptFormatObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptFormatObject(DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType, void *pFormatStruct, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, void *pbFormat, DWORD *pcbFormat)
     * }
     */
    public static MethodHandle CryptFormatObject$handle() {
        return CryptFormatObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptFormatObject(DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType, void *pFormatStruct, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, void *pbFormat, DWORD *pcbFormat)
     * }
     */
    public static MemorySegment CryptFormatObject$address() {
        return CryptFormatObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptFormatObject(DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType, void *pFormatStruct, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, void *pbFormat, DWORD *pcbFormat)
     * }
     */
    public static int CryptFormatObject(int dwCertEncodingType, int dwFormatType, int dwFormatStrType, MemorySegment pFormatStruct, MemorySegment lpszStructType, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbFormat, MemorySegment pcbFormat) {
        var mh$ = CryptFormatObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFormatObject", dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct, lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct, lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ENCODE_PARA {
     *     DWORD cbSize;
     *     PFN_CRYPT_ALLOC pfnAlloc;
     *     PFN_CRYPT_FREE pfnFree;
     * } *PCRYPT_ENCODE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_ENCODE_PARA = wgl_h.C_POINTER;

    private static class CryptEncodeObjectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptEncodeObjectEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void *pvEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptEncodeObjectEx$descriptor() {
        return CryptEncodeObjectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void *pvEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptEncodeObjectEx$handle() {
        return CryptEncodeObjectEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void *pvEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MemorySegment CryptEncodeObjectEx$address() {
        return CryptEncodeObjectEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEncodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void *pvEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptEncodeObjectEx(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pvStructInfo, int dwFlags, MemorySegment pEncodePara, MemorySegment pvEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptEncodeObjectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEncodeObjectEx", dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pvEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pvEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEncodeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptEncodeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptEncodeObject$descriptor() {
        return CryptEncodeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptEncodeObject$handle() {
        return CryptEncodeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MemorySegment CryptEncodeObject$address() {
        return CryptEncodeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptEncodeObject(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pvStructInfo, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptEncodeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEncodeObject", dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_DECODE_PARA {
     *     DWORD cbSize;
     *     PFN_CRYPT_ALLOC pfnAlloc;
     *     PFN_CRYPT_FREE pfnFree;
     * } *PCRYPT_DECODE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_DECODE_PARA = wgl_h.C_POINTER;

    private static class CryptDecodeObjectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptDecodeObjectEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static FunctionDescriptor CryptDecodeObjectEx$descriptor() {
        return CryptDecodeObjectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static MethodHandle CryptDecodeObjectEx$handle() {
        return CryptDecodeObjectEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static MemorySegment CryptDecodeObjectEx$address() {
        return CryptDecodeObjectEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static int CryptDecodeObjectEx(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pbEncoded, int cbEncoded, int dwFlags, MemorySegment pDecodePara, MemorySegment pvStructInfo, MemorySegment pcbStructInfo) {
        var mh$ = CryptDecodeObjectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecodeObjectEx", dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecodeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptDecodeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static FunctionDescriptor CryptDecodeObject$descriptor() {
        return CryptDecodeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static MethodHandle CryptDecodeObject$handle() {
        return CryptDecodeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static MemorySegment CryptDecodeObject$address() {
        return CryptDecodeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static int CryptDecodeObject(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pbEncoded, int cbEncoded, int dwFlags, MemorySegment pvStructInfo, MemorySegment pcbStructInfo) {
        var mh$ = CryptDecodeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecodeObject", dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_EXTENSIONS {
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCERT_EXTENSIONS
     * }
     */
    public static final AddressLayout PCERT_EXTENSIONS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_KEY_ID_INFO {
     *     CRYPT_DATA_BLOB KeyId;
     *     CERT_NAME_BLOB CertIssuer;
     *     CRYPT_INTEGER_BLOB CertSerialNumber;
     * } *PCERT_AUTHORITY_KEY_ID_INFO
     * }
     */
    public static final AddressLayout PCERT_AUTHORITY_KEY_ID_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_PRIVATE_KEY_VALIDITY {
     *     FILETIME NotBefore;
     *     FILETIME NotAfter;
     * } *PCERT_PRIVATE_KEY_VALIDITY
     * }
     */
    public static final AddressLayout PCERT_PRIVATE_KEY_VALIDITY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_KEY_ATTRIBUTES_INFO {
     *     CRYPT_DATA_BLOB KeyId;
     *     CRYPT_BIT_BLOB IntendedKeyUsage;
     *     PCERT_PRIVATE_KEY_VALIDITY pPrivateKeyUsagePeriod;
     * } *PCERT_KEY_ATTRIBUTES_INFO
     * }
     */
    public static final AddressLayout PCERT_KEY_ATTRIBUTES_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_ID {
     *     DWORD cCertPolicyElementId;
     *     LPSTR *rgpszCertPolicyElementId;
     * } *PCERT_POLICY_ID
     * }
     */
    public static final AddressLayout PCERT_POLICY_ID = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_KEY_USAGE_RESTRICTION_INFO {
     *     DWORD cCertPolicyId;
     *     PCERT_POLICY_ID rgCertPolicyId;
     *     CRYPT_BIT_BLOB RestrictedKeyUsage;
     * } *PCERT_KEY_USAGE_RESTRICTION_INFO
     * }
     */
    public static final AddressLayout PCERT_KEY_USAGE_RESTRICTION_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_OTHER_NAME {
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Value;
     * } *PCERT_OTHER_NAME
     * }
     */
    public static final AddressLayout PCERT_OTHER_NAME = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ALT_NAME_ENTRY {
     *     DWORD dwAltNameChoice;
     *     union {
     *         PCERT_OTHER_NAME pOtherName;
     *         LPWSTR pwszRfc822Name;
     *         LPWSTR pwszDNSName;
     *         CERT_NAME_BLOB DirectoryName;
     *         LPWSTR pwszURL;
     *         CRYPT_DATA_BLOB IPAddress;
     *         LPSTR pszRegisteredID;
     *     };
     * } *PCERT_ALT_NAME_ENTRY
     * }
     */
    public static final AddressLayout PCERT_ALT_NAME_ENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ALT_NAME_INFO {
     *     DWORD cAltEntry;
     *     PCERT_ALT_NAME_ENTRY rgAltEntry;
     * } *PCERT_ALT_NAME_INFO
     * }
     */
    public static final AddressLayout PCERT_ALT_NAME_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BASIC_CONSTRAINTS_INFO {
     *     CRYPT_BIT_BLOB SubjectType;
     *     BOOL fPathLenConstraint;
     *     DWORD dwPathLenConstraint;
     *     DWORD cSubtreesConstraint;
     *     CERT_NAME_BLOB *rgSubtreesConstraint;
     * } *PCERT_BASIC_CONSTRAINTS_INFO
     * }
     */
    public static final AddressLayout PCERT_BASIC_CONSTRAINTS_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BASIC_CONSTRAINTS2_INFO {
     *     BOOL fCA;
     *     BOOL fPathLenConstraint;
     *     DWORD dwPathLenConstraint;
     * } *PCERT_BASIC_CONSTRAINTS2_INFO
     * }
     */
    public static final AddressLayout PCERT_BASIC_CONSTRAINTS2_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_QUALIFIER_INFO {
     *     LPSTR pszPolicyQualifierId;
     *     CRYPT_OBJID_BLOB Qualifier;
     * } *PCERT_POLICY_QUALIFIER_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_QUALIFIER_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_INFO {
     *     LPSTR pszPolicyIdentifier;
     *     DWORD cPolicyQualifier;
     *     CERT_POLICY_QUALIFIER_INFO *rgPolicyQualifier;
     * } *PCERT_POLICY_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICIES_INFO {
     *     DWORD cPolicyInfo;
     *     CERT_POLICY_INFO *rgPolicyInfo;
     * } *PCERT_POLICIES_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICIES_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE {
     *     LPSTR pszOrganization;
     *     DWORD cNoticeNumbers;
     *     int *rgNoticeNumbers;
     * } *PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE
     * }
     */
    public static final AddressLayout PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_QUALIFIER_USER_NOTICE {
     *     CERT_POLICY_QUALIFIER_NOTICE_REFERENCE *pNoticeReference;
     *     LPWSTR pszDisplayText;
     * } *PCERT_POLICY_QUALIFIER_USER_NOTICE
     * }
     */
    public static final AddressLayout PCERT_POLICY_QUALIFIER_USER_NOTICE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CPS_URLS {
     *     LPWSTR pszURL;
     *     CRYPT_ALGORITHM_IDENTIFIER *pAlgorithm;
     *     CRYPT_DATA_BLOB *pDigest;
     * } *PCPS_URLS
     * }
     */
    public static final AddressLayout PCPS_URLS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY95_QUALIFIER1 {
     *     LPWSTR pszPracticesReference;
     *     LPSTR pszNoticeIdentifier;
     *     LPSTR pszNSINoticeIdentifier;
     *     DWORD cCPSURLs;
     *     CPS_URLS *rgCPSURLs;
     * } *PCERT_POLICY95_QUALIFIER1
     * }
     */
    public static final AddressLayout PCERT_POLICY95_QUALIFIER1 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_MAPPING {
     *     LPSTR pszIssuerDomainPolicy;
     *     LPSTR pszSubjectDomainPolicy;
     * } *PCERT_POLICY_MAPPING
     * }
     */
    public static final AddressLayout PCERT_POLICY_MAPPING = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_MAPPINGS_INFO {
     *     DWORD cPolicyMapping;
     *     PCERT_POLICY_MAPPING rgPolicyMapping;
     * } *PCERT_POLICY_MAPPINGS_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_MAPPINGS_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_CONSTRAINTS_INFO {
     *     BOOL fRequireExplicitPolicy;
     *     DWORD dwRequireExplicitPolicySkipCerts;
     *     BOOL fInhibitPolicyMapping;
     *     DWORD dwInhibitPolicyMappingSkipCerts;
     * } *PCERT_POLICY_CONSTRAINTS_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_CONSTRAINTS_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY {
     *     LPSTR pszObjId;
     *     DWORD cValue;
     *     PCRYPT_DER_BLOB rgValue;
     * } *PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY
     * }
     */
    public static final AddressLayout PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTENT_INFO {
     *     LPSTR pszObjId;
     *     CRYPT_DER_BLOB Content;
     * } *PCRYPT_CONTENT_INFO
     * }
     */
    public static final AddressLayout PCRYPT_CONTENT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SEQUENCE_OF_ANY {
     *     DWORD cValue;
     *     PCRYPT_DER_BLOB rgValue;
     * } *PCRYPT_SEQUENCE_OF_ANY
     * }
     */
    public static final AddressLayout PCRYPT_SEQUENCE_OF_ANY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_KEY_ID2_INFO {
     *     CRYPT_DATA_BLOB KeyId;
     *     CERT_ALT_NAME_INFO AuthorityCertIssuer;
     *     CRYPT_INTEGER_BLOB AuthorityCertSerialNumber;
     * } *PCERT_AUTHORITY_KEY_ID2_INFO
     * }
     */
    public static final AddressLayout PCERT_AUTHORITY_KEY_ID2_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ACCESS_DESCRIPTION {
     *     LPSTR pszAccessMethod;
     *     CERT_ALT_NAME_ENTRY AccessLocation;
     * } *PCERT_ACCESS_DESCRIPTION
     * }
     */
    public static final AddressLayout PCERT_ACCESS_DESCRIPTION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_INFO_ACCESS {
     *     DWORD cAccDescr;
     *     PCERT_ACCESS_DESCRIPTION rgAccDescr;
     * } *PCERT_AUTHORITY_INFO_ACCESS
     * }
     */
    public static final AddressLayout PCERT_AUTHORITY_INFO_ACCESS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_INFO_ACCESS {
     *     DWORD cAccDescr;
     *     PCERT_ACCESS_DESCRIPTION rgAccDescr;
     * } *PCERT_SUBJECT_INFO_ACCESS
     * }
     */
    public static final AddressLayout PCERT_SUBJECT_INFO_ACCESS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_DIST_POINT_NAME {
     *     DWORD dwDistPointNameChoice;
     *     union {
     *         CERT_ALT_NAME_INFO FullName;
     *     };
     * } *PCRL_DIST_POINT_NAME
     * }
     */
    public static final AddressLayout PCRL_DIST_POINT_NAME = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_DIST_POINT {
     *     CRL_DIST_POINT_NAME DistPointName;
     *     CRYPT_BIT_BLOB ReasonFlags;
     *     CERT_ALT_NAME_INFO CRLIssuer;
     * } *PCRL_DIST_POINT
     * }
     */
    public static final AddressLayout PCRL_DIST_POINT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_DIST_POINTS_INFO {
     *     DWORD cDistPoint;
     *     PCRL_DIST_POINT rgDistPoint;
     * } *PCRL_DIST_POINTS_INFO
     * }
     */
    public static final AddressLayout PCRL_DIST_POINTS_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CROSS_CERT_DIST_POINTS_INFO {
     *     DWORD dwSyncDeltaTime;
     *     DWORD cDistPoint;
     *     PCERT_ALT_NAME_INFO rgDistPoint;
     * } *PCROSS_CERT_DIST_POINTS_INFO
     * }
     */
    public static final AddressLayout PCROSS_CERT_DIST_POINTS_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_PAIR {
     *     CERT_BLOB Forward;
     *     CERT_BLOB Reverse;
     * } *PCERT_PAIR
     * }
     */
    public static final AddressLayout PCERT_PAIR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_ISSUING_DIST_POINT {
     *     CRL_DIST_POINT_NAME DistPointName;
     *     BOOL fOnlyContainsUserCerts;
     *     BOOL fOnlyContainsCACerts;
     *     CRYPT_BIT_BLOB OnlySomeReasonFlags;
     *     BOOL fIndirectCRL;
     * } *PCRL_ISSUING_DIST_POINT
     * }
     */
    public static final AddressLayout PCRL_ISSUING_DIST_POINT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_GENERAL_SUBTREE {
     *     CERT_ALT_NAME_ENTRY Base;
     *     DWORD dwMinimum;
     *     BOOL fMaximum;
     *     DWORD dwMaximum;
     * } *PCERT_GENERAL_SUBTREE
     * }
     */
    public static final AddressLayout PCERT_GENERAL_SUBTREE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_NAME_CONSTRAINTS_INFO {
     *     DWORD cPermittedSubtree;
     *     PCERT_GENERAL_SUBTREE rgPermittedSubtree;
     *     DWORD cExcludedSubtree;
     *     PCERT_GENERAL_SUBTREE rgExcludedSubtree;
     * } *PCERT_NAME_CONSTRAINTS_INFO
     * }
     */
    public static final AddressLayout PCERT_NAME_CONSTRAINTS_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_DSS_PARAMETERS {
     *     CRYPT_UINT_BLOB p;
     *     CRYPT_UINT_BLOB q;
     *     CRYPT_UINT_BLOB g;
     * } *PCERT_DSS_PARAMETERS
     * }
     */
    public static final AddressLayout PCERT_DSS_PARAMETERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_DH_PARAMETERS {
     *     CRYPT_UINT_BLOB p;
     *     CRYPT_UINT_BLOB g;
     * } *PCERT_DH_PARAMETERS
     * }
     */
    public static final AddressLayout PCERT_DH_PARAMETERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ECC_SIGNATURE {
     *     CRYPT_UINT_BLOB r;
     *     CRYPT_UINT_BLOB s;
     * } *PCERT_ECC_SIGNATURE
     * }
     */
    public static final AddressLayout PCERT_ECC_SIGNATURE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_X942_DH_VALIDATION_PARAMS {
     *     CRYPT_BIT_BLOB seed;
     *     DWORD pgenCounter;
     * } *PCERT_X942_DH_VALIDATION_PARAMS
     * }
     */
    public static final AddressLayout PCERT_X942_DH_VALIDATION_PARAMS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_X942_DH_PARAMETERS {
     *     CRYPT_UINT_BLOB p;
     *     CRYPT_UINT_BLOB g;
     *     CRYPT_UINT_BLOB q;
     *     CRYPT_UINT_BLOB j;
     *     PCERT_X942_DH_VALIDATION_PARAMS pValidationParams;
     * } *PCERT_X942_DH_PARAMETERS
     * }
     */
    public static final AddressLayout PCERT_X942_DH_PARAMETERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_X942_OTHER_INFO {
     *     LPSTR pszContentEncryptionObjId;
     *     BYTE rgbCounter[4];
     *     BYTE rgbKeyLength[4];
     *     CRYPT_DATA_BLOB PubInfo;
     * } *PCRYPT_X942_OTHER_INFO
     * }
     */
    public static final AddressLayout PCRYPT_X942_OTHER_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ECC_CMS_SHARED_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER Algorithm;
     *     CRYPT_DATA_BLOB EntityUInfo;
     *     BYTE rgbSuppPubInfo[4];
     * } *PCRYPT_ECC_CMS_SHARED_INFO
     * }
     */
    public static final AddressLayout PCRYPT_ECC_CMS_SHARED_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RC2_CBC_PARAMETERS {
     *     DWORD dwVersion;
     *     BOOL fIV;
     *     BYTE rgbIV[8];
     * } *PCRYPT_RC2_CBC_PARAMETERS
     * }
     */
    public static final AddressLayout PCRYPT_RC2_CBC_PARAMETERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SMIME_CAPABILITY {
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Parameters;
     * } *PCRYPT_SMIME_CAPABILITY
     * }
     */
    public static final AddressLayout PCRYPT_SMIME_CAPABILITY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SMIME_CAPABILITIES {
     *     DWORD cCapability;
     *     PCRYPT_SMIME_CAPABILITY rgCapability;
     * } *PCRYPT_SMIME_CAPABILITIES
     * }
     */
    public static final AddressLayout PCRYPT_SMIME_CAPABILITIES = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_QC_STATEMENT {
     *     LPSTR pszStatementId;
     *     CRYPT_OBJID_BLOB StatementInfo;
     * } *PCERT_QC_STATEMENT
     * }
     */
    public static final AddressLayout PCERT_QC_STATEMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_QC_STATEMENTS_EXT_INFO {
     *     DWORD cStatement;
     *     PCERT_QC_STATEMENT rgStatement;
     * } *PCERT_QC_STATEMENTS_EXT_INFO
     * }
     */
    public static final AddressLayout PCERT_QC_STATEMENTS_EXT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_MASK_GEN_ALGORITHM {
     *     LPSTR pszObjId;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     * } *PCRYPT_MASK_GEN_ALGORITHM
     * }
     */
    public static final AddressLayout PCRYPT_MASK_GEN_ALGORITHM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RSA_SSA_PSS_PARAMETERS {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_MASK_GEN_ALGORITHM MaskGenAlgorithm;
     *     DWORD dwSaltLength;
     *     DWORD dwTrailerField;
     * } *PCRYPT_RSA_SSA_PSS_PARAMETERS
     * }
     */
    public static final AddressLayout PCRYPT_RSA_SSA_PSS_PARAMETERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PSOURCE_ALGORITHM {
     *     LPSTR pszObjId;
     *     CRYPT_DATA_BLOB EncodingParameters;
     * } *PCRYPT_PSOURCE_ALGORITHM
     * }
     */
    public static final AddressLayout PCRYPT_PSOURCE_ALGORITHM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RSAES_OAEP_PARAMETERS {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_MASK_GEN_ALGORITHM MaskGenAlgorithm;
     *     CRYPT_PSOURCE_ALGORITHM PSourceAlgorithm;
     * } *PCRYPT_RSAES_OAEP_PARAMETERS
     * }
     */
    public static final AddressLayout PCRYPT_RSAES_OAEP_PARAMETERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_ATTRIBUTE {
     *     DWORD dwBodyPartID;
     *     CRYPT_ATTRIBUTE Attribute;
     * } *PCMC_TAGGED_ATTRIBUTE
     * }
     */
    public static final AddressLayout PCMC_TAGGED_ATTRIBUTE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_CERT_REQUEST {
     *     DWORD dwBodyPartID;
     *     CRYPT_DER_BLOB SignedCertRequest;
     * } *PCMC_TAGGED_CERT_REQUEST
     * }
     */
    public static final AddressLayout PCMC_TAGGED_CERT_REQUEST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_REQUEST {
     *     DWORD dwTaggedRequestChoice;
     *     union {
     *         PCMC_TAGGED_CERT_REQUEST pTaggedCertRequest;
     *     };
     * } *PCMC_TAGGED_REQUEST
     * }
     */
    public static final AddressLayout PCMC_TAGGED_REQUEST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_CONTENT_INFO {
     *     DWORD dwBodyPartID;
     *     CRYPT_DER_BLOB EncodedContentInfo;
     * } *PCMC_TAGGED_CONTENT_INFO
     * }
     */
    public static final AddressLayout PCMC_TAGGED_CONTENT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_OTHER_MSG {
     *     DWORD dwBodyPartID;
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Value;
     * } *PCMC_TAGGED_OTHER_MSG
     * }
     */
    public static final AddressLayout PCMC_TAGGED_OTHER_MSG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_DATA_INFO {
     *     DWORD cTaggedAttribute;
     *     PCMC_TAGGED_ATTRIBUTE rgTaggedAttribute;
     *     DWORD cTaggedRequest;
     *     PCMC_TAGGED_REQUEST rgTaggedRequest;
     *     DWORD cTaggedContentInfo;
     *     PCMC_TAGGED_CONTENT_INFO rgTaggedContentInfo;
     *     DWORD cTaggedOtherMsg;
     *     PCMC_TAGGED_OTHER_MSG rgTaggedOtherMsg;
     * } *PCMC_DATA_INFO
     * }
     */
    public static final AddressLayout PCMC_DATA_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_RESPONSE_INFO {
     *     DWORD cTaggedAttribute;
     *     PCMC_TAGGED_ATTRIBUTE rgTaggedAttribute;
     *     DWORD cTaggedContentInfo;
     *     PCMC_TAGGED_CONTENT_INFO rgTaggedContentInfo;
     *     DWORD cTaggedOtherMsg;
     *     PCMC_TAGGED_OTHER_MSG rgTaggedOtherMsg;
     * } *PCMC_RESPONSE_INFO
     * }
     */
    public static final AddressLayout PCMC_RESPONSE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_PEND_INFO {
     *     CRYPT_DATA_BLOB PendToken;
     *     FILETIME PendTime;
     * } *PCMC_PEND_INFO
     * }
     */
    public static final AddressLayout PCMC_PEND_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_STATUS_INFO {
     *     DWORD dwStatus;
     *     DWORD cBodyList;
     *     DWORD *rgdwBodyList;
     *     LPWSTR pwszStatusString;
     *     DWORD dwOtherInfoChoice;
     *     union {
     *         DWORD dwFailInfo;
     *         PCMC_PEND_INFO pPendInfo;
     *     };
     * } *PCMC_STATUS_INFO
     * }
     */
    public static final AddressLayout PCMC_STATUS_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_ADD_EXTENSIONS_INFO {
     *     DWORD dwCmcDataReference;
     *     DWORD cCertReference;
     *     DWORD *rgdwCertReference;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCMC_ADD_EXTENSIONS_INFO
     * }
     */
    public static final AddressLayout PCMC_ADD_EXTENSIONS_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_ADD_ATTRIBUTES_INFO {
     *     DWORD dwCmcDataReference;
     *     DWORD cCertReference;
     *     DWORD *rgdwCertReference;
     *     DWORD cAttribute;
     *     PCRYPT_ATTRIBUTE rgAttribute;
     * } *PCMC_ADD_ATTRIBUTES_INFO
     * }
     */
    public static final AddressLayout PCMC_ADD_ATTRIBUTES_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_TEMPLATE_EXT {
     *     LPSTR pszObjId;
     *     DWORD dwMajorVersion;
     *     BOOL fMinorVersion;
     *     DWORD dwMinorVersion;
     * } *PCERT_TEMPLATE_EXT
     * }
     */
    public static final AddressLayout PCERT_TEMPLATE_EXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_HASHED_URL {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_HASH_BLOB Hash;
     *     LPWSTR pwszUrl;
     * } *PCERT_HASHED_URL
     * }
     */
    public static final AddressLayout PCERT_HASHED_URL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_DETAILS {
     *     LPWSTR pwszMimeType;
     *     DWORD cHashedUrl;
     *     PCERT_HASHED_URL rgHashedUrl;
     * } *PCERT_LOGOTYPE_DETAILS
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_DETAILS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_REFERENCE {
     *     DWORD cHashedUrl;
     *     PCERT_HASHED_URL rgHashedUrl;
     * } *PCERT_LOGOTYPE_REFERENCE
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_REFERENCE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_IMAGE_INFO {
     *     DWORD dwLogotypeImageInfoChoice;
     *     DWORD dwFileSize;
     *     DWORD dwXSize;
     *     DWORD dwYSize;
     *     DWORD dwLogotypeImageResolutionChoice;
     *     union {
     *         DWORD dwNumBits;
     *         DWORD dwTableSize;
     *     };
     *     LPWSTR pwszLanguage;
     * } *PCERT_LOGOTYPE_IMAGE_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_IMAGE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_IMAGE {
     *     CERT_LOGOTYPE_DETAILS LogotypeDetails;
     *     PCERT_LOGOTYPE_IMAGE_INFO pLogotypeImageInfo;
     * } *PCERT_LOGOTYPE_IMAGE
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_IMAGE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_AUDIO_INFO {
     *     DWORD dwFileSize;
     *     DWORD dwPlayTime;
     *     DWORD dwChannels;
     *     DWORD dwSampleRate;
     *     LPWSTR pwszLanguage;
     * } *PCERT_LOGOTYPE_AUDIO_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_AUDIO_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_AUDIO {
     *     CERT_LOGOTYPE_DETAILS LogotypeDetails;
     *     PCERT_LOGOTYPE_AUDIO_INFO pLogotypeAudioInfo;
     * } *PCERT_LOGOTYPE_AUDIO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_AUDIO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_DATA {
     *     DWORD cLogotypeImage;
     *     PCERT_LOGOTYPE_IMAGE rgLogotypeImage;
     *     DWORD cLogotypeAudio;
     *     PCERT_LOGOTYPE_AUDIO rgLogotypeAudio;
     * } *PCERT_LOGOTYPE_DATA
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_DATA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_INFO {
     *     DWORD dwLogotypeInfoChoice;
     *     union {
     *         PCERT_LOGOTYPE_DATA pLogotypeDirectInfo;
     *         PCERT_LOGOTYPE_REFERENCE pLogotypeIndirectInfo;
     *     };
     * } *PCERT_LOGOTYPE_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_OTHER_LOGOTYPE_INFO {
     *     LPSTR pszObjId;
     *     CERT_LOGOTYPE_INFO LogotypeInfo;
     * } *PCERT_OTHER_LOGOTYPE_INFO
     * }
     */
    public static final AddressLayout PCERT_OTHER_LOGOTYPE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_EXT_INFO {
     *     DWORD cCommunityLogo;
     *     PCERT_LOGOTYPE_INFO rgCommunityLogo;
     *     PCERT_LOGOTYPE_INFO pIssuerLogo;
     *     PCERT_LOGOTYPE_INFO pSubjectLogo;
     *     DWORD cOtherLogo;
     *     PCERT_OTHER_LOGOTYPE_INFO rgOtherLogo;
     * } *PCERT_LOGOTYPE_EXT_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_EXT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BIOMETRIC_DATA {
     *     DWORD dwTypeOfBiometricDataChoice;
     *     union {
     *         DWORD dwPredefined;
     *         LPSTR pszObjId;
     *     };
     *     CERT_HASHED_URL HashedUrl;
     * } *PCERT_BIOMETRIC_DATA
     * }
     */
    public static final AddressLayout PCERT_BIOMETRIC_DATA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BIOMETRIC_EXT_INFO {
     *     DWORD cBiometricData;
     *     PCERT_BIOMETRIC_DATA rgBiometricData;
     * } *PCERT_BIOMETRIC_EXT_INFO
     * }
     */
    public static final AddressLayout PCERT_BIOMETRIC_EXT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_SIGNATURE_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
     *     CRYPT_BIT_BLOB Signature;
     *     DWORD cCertEncoded;
     *     PCERT_BLOB rgCertEncoded;
     * } *POCSP_SIGNATURE_INFO
     * }
     */
    public static final AddressLayout POCSP_SIGNATURE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_SIGNED_REQUEST_INFO {
     *     CRYPT_DER_BLOB ToBeSigned;
     *     POCSP_SIGNATURE_INFO pOptionalSignatureInfo;
     * } *POCSP_SIGNED_REQUEST_INFO
     * }
     */
    public static final AddressLayout POCSP_SIGNED_REQUEST_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_CERT_ID {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_HASH_BLOB IssuerNameHash;
     *     CRYPT_HASH_BLOB IssuerKeyHash;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     * } *POCSP_CERT_ID
     * }
     */
    public static final AddressLayout POCSP_CERT_ID = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_REQUEST_ENTRY {
     *     OCSP_CERT_ID CertId;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_REQUEST_ENTRY
     * }
     */
    public static final AddressLayout POCSP_REQUEST_ENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_REQUEST_INFO {
     *     DWORD dwVersion;
     *     PCERT_ALT_NAME_ENTRY pRequestorName;
     *     DWORD cRequestEntry;
     *     POCSP_REQUEST_ENTRY rgRequestEntry;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_REQUEST_INFO
     * }
     */
    public static final AddressLayout POCSP_REQUEST_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_RESPONSE_INFO {
     *     DWORD dwStatus;
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Value;
     * } *POCSP_RESPONSE_INFO
     * }
     */
    public static final AddressLayout POCSP_RESPONSE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_SIGNED_RESPONSE_INFO {
     *     CRYPT_DER_BLOB ToBeSigned;
     *     OCSP_SIGNATURE_INFO SignatureInfo;
     * } *POCSP_BASIC_SIGNED_RESPONSE_INFO
     * }
     */
    public static final AddressLayout POCSP_BASIC_SIGNED_RESPONSE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_REVOKED_INFO {
     *     FILETIME RevocationDate;
     *     DWORD dwCrlReasonCode;
     * } *POCSP_BASIC_REVOKED_INFO
     * }
     */
    public static final AddressLayout POCSP_BASIC_REVOKED_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_RESPONSE_ENTRY {
     *     OCSP_CERT_ID CertId;
     *     DWORD dwCertStatus;
     *     union {
     *         POCSP_BASIC_REVOKED_INFO pRevokedInfo;
     *     };
     *     FILETIME ThisUpdate;
     *     FILETIME NextUpdate;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_BASIC_RESPONSE_ENTRY
     * }
     */
    public static final AddressLayout POCSP_BASIC_RESPONSE_ENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_RESPONSE_INFO {
     *     DWORD dwVersion;
     *     DWORD dwResponderIdChoice;
     *     union {
     *         CERT_NAME_BLOB ByNameResponderId;
     *         CRYPT_HASH_BLOB ByKeyResponderId;
     *     };
     *     FILETIME ProducedAt;
     *     DWORD cResponseEntry;
     *     POCSP_BASIC_RESPONSE_ENTRY rgResponseEntry;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_BASIC_RESPONSE_INFO
     * }
     */
    public static final AddressLayout POCSP_BASIC_RESPONSE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SUPPORTED_ALGORITHM_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER Algorithm;
     *     CRYPT_BIT_BLOB IntendedKeyUsage;
     *     CERT_POLICIES_INFO IntendedCertPolicies;
     * } *PCERT_SUPPORTED_ALGORITHM_INFO
     * }
     */
    public static final AddressLayout PCERT_SUPPORTED_ALGORITHM_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_TPM_SPECIFICATION_INFO {
     *     LPWSTR pwszFamily;
     *     DWORD dwLevel;
     *     DWORD dwRevision;
     * } *PCERT_TPM_SPECIFICATION_INFO
     * }
     */
    public static final AddressLayout PCERT_TPM_SPECIFICATION_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTOIDFUNCSET
     * }
     */
    public static final AddressLayout HCRYPTOIDFUNCSET = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTOIDFUNCADDR
     * }
     */
    public static final AddressLayout HCRYPTOIDFUNCADDR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_OID_FUNC_ENTRY {
     *     LPCSTR pszOID;
     *     void *pvFuncAddr;
     * } *PCRYPT_OID_FUNC_ENTRY
     * }
     */
    public static final AddressLayout PCRYPT_OID_FUNC_ENTRY = wgl_h.C_POINTER;

    private static class CryptInstallOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptInstallOIDFunctionAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptInstallOIDFunctionAddress(HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptInstallOIDFunctionAddress$descriptor() {
        return CryptInstallOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptInstallOIDFunctionAddress(HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptInstallOIDFunctionAddress$handle() {
        return CryptInstallOIDFunctionAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptInstallOIDFunctionAddress(HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptInstallOIDFunctionAddress$address() {
        return CryptInstallOIDFunctionAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptInstallOIDFunctionAddress(HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags)
     * }
     */
    public static int CryptInstallOIDFunctionAddress(MemorySegment hModule, int dwEncodingType, MemorySegment pszFuncName, int cFuncEntry, MemorySegment rgFuncEntry, int dwFlags) {
        var mh$ = CryptInstallOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptInstallOIDFunctionAddress", hModule, dwEncodingType, pszFuncName, cFuncEntry, rgFuncEntry, dwFlags);
            }
            return (int)mh$.invokeExact(hModule, dwEncodingType, pszFuncName, cFuncEntry, rgFuncEntry, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptInitOIDFunctionSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptInitOIDFunctionSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTOIDFUNCSET CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptInitOIDFunctionSet$descriptor() {
        return CryptInitOIDFunctionSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTOIDFUNCSET CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptInitOIDFunctionSet$handle() {
        return CryptInitOIDFunctionSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCRYPTOIDFUNCSET CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptInitOIDFunctionSet$address() {
        return CryptInitOIDFunctionSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCRYPTOIDFUNCSET CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptInitOIDFunctionSet(MemorySegment pszFuncName, int dwFlags) {
        var mh$ = CryptInitOIDFunctionSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptInitOIDFunctionSet", pszFuncName, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(pszFuncName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetOIDFunctionAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static FunctionDescriptor CryptGetOIDFunctionAddress$descriptor() {
        return CryptGetOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static MethodHandle CryptGetOIDFunctionAddress$handle() {
        return CryptGetOIDFunctionAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static MemorySegment CryptGetOIDFunctionAddress$address() {
        return CryptGetOIDFunctionAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static int CryptGetOIDFunctionAddress(MemorySegment hFuncSet, int dwEncodingType, MemorySegment pszOID, int dwFlags, MemorySegment ppvFuncAddr, MemorySegment phFuncAddr) {
        var mh$ = CryptGetOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetOIDFunctionAddress", hFuncSet, dwEncodingType, pszOID, dwFlags, ppvFuncAddr, phFuncAddr);
            }
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pszOID, dwFlags, ppvFuncAddr, phFuncAddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetDefaultOIDDllList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetDefaultOIDDllList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR *pwszDllList, DWORD *pcchDllList)
     * }
     */
    public static FunctionDescriptor CryptGetDefaultOIDDllList$descriptor() {
        return CryptGetDefaultOIDDllList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR *pwszDllList, DWORD *pcchDllList)
     * }
     */
    public static MethodHandle CryptGetDefaultOIDDllList$handle() {
        return CryptGetDefaultOIDDllList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR *pwszDllList, DWORD *pcchDllList)
     * }
     */
    public static MemorySegment CryptGetDefaultOIDDllList$address() {
        return CryptGetDefaultOIDDllList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR *pwszDllList, DWORD *pcchDllList)
     * }
     */
    public static int CryptGetDefaultOIDDllList(MemorySegment hFuncSet, int dwEncodingType, MemorySegment pwszDllList, MemorySegment pcchDllList) {
        var mh$ = CryptGetDefaultOIDDllList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetDefaultOIDDllList", hFuncSet, dwEncodingType, pwszDllList, pcchDllList);
            }
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pwszDllList, pcchDllList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetDefaultOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetDefaultOIDFunctionAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static FunctionDescriptor CryptGetDefaultOIDFunctionAddress$descriptor() {
        return CryptGetDefaultOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static MethodHandle CryptGetDefaultOIDFunctionAddress$handle() {
        return CryptGetDefaultOIDFunctionAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static MemorySegment CryptGetDefaultOIDFunctionAddress$address() {
        return CryptGetDefaultOIDFunctionAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static int CryptGetDefaultOIDFunctionAddress(MemorySegment hFuncSet, int dwEncodingType, MemorySegment pwszDll, int dwFlags, MemorySegment ppvFuncAddr, MemorySegment phFuncAddr) {
        var mh$ = CryptGetDefaultOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetDefaultOIDFunctionAddress", hFuncSet, dwEncodingType, pwszDll, dwFlags, ppvFuncAddr, phFuncAddr);
            }
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pwszDll, dwFlags, ppvFuncAddr, phFuncAddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptFreeOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptFreeOIDFunctionAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptFreeOIDFunctionAddress$descriptor() {
        return CryptFreeOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptFreeOIDFunctionAddress$handle() {
        return CryptFreeOIDFunctionAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptFreeOIDFunctionAddress$address() {
        return CryptFreeOIDFunctionAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags)
     * }
     */
    public static int CryptFreeOIDFunctionAddress(MemorySegment hFuncAddr, int dwFlags) {
        var mh$ = CryptFreeOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFreeOIDFunctionAddress", hFuncAddr, dwFlags);
            }
            return (int)mh$.invokeExact(hFuncAddr, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptRegisterOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptRegisterOIDFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName)
     * }
     */
    public static FunctionDescriptor CryptRegisterOIDFunction$descriptor() {
        return CryptRegisterOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName)
     * }
     */
    public static MethodHandle CryptRegisterOIDFunction$handle() {
        return CryptRegisterOIDFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName)
     * }
     */
    public static MemorySegment CryptRegisterOIDFunction$address() {
        return CryptRegisterOIDFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName)
     * }
     */
    public static int CryptRegisterOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, MemorySegment pwszDll, MemorySegment pszOverrideFuncName) {
        var mh$ = CryptRegisterOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRegisterOIDFunction", dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnregisterOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptUnregisterOIDFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID)
     * }
     */
    public static FunctionDescriptor CryptUnregisterOIDFunction$descriptor() {
        return CryptUnregisterOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID)
     * }
     */
    public static MethodHandle CryptUnregisterOIDFunction$handle() {
        return CryptUnregisterOIDFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID)
     * }
     */
    public static MemorySegment CryptUnregisterOIDFunction$address() {
        return CryptUnregisterOIDFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID)
     * }
     */
    public static int CryptUnregisterOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID) {
        var mh$ = CryptUnregisterOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnregisterOIDFunction", dwEncodingType, pszFuncName, pszOID);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptRegisterDefaultOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptRegisterDefaultOIDFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll)
     * }
     */
    public static FunctionDescriptor CryptRegisterDefaultOIDFunction$descriptor() {
        return CryptRegisterDefaultOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll)
     * }
     */
    public static MethodHandle CryptRegisterDefaultOIDFunction$handle() {
        return CryptRegisterDefaultOIDFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll)
     * }
     */
    public static MemorySegment CryptRegisterDefaultOIDFunction$address() {
        return CryptRegisterDefaultOIDFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll)
     * }
     */
    public static int CryptRegisterDefaultOIDFunction(int dwEncodingType, MemorySegment pszFuncName, int dwIndex, MemorySegment pwszDll) {
        var mh$ = CryptRegisterDefaultOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRegisterDefaultOIDFunction", dwEncodingType, pszFuncName, dwIndex, pwszDll);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, dwIndex, pwszDll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnregisterDefaultOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptUnregisterDefaultOIDFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll)
     * }
     */
    public static FunctionDescriptor CryptUnregisterDefaultOIDFunction$descriptor() {
        return CryptUnregisterDefaultOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll)
     * }
     */
    public static MethodHandle CryptUnregisterDefaultOIDFunction$handle() {
        return CryptUnregisterDefaultOIDFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll)
     * }
     */
    public static MemorySegment CryptUnregisterDefaultOIDFunction$address() {
        return CryptUnregisterDefaultOIDFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll)
     * }
     */
    public static int CryptUnregisterDefaultOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pwszDll) {
        var mh$ = CryptUnregisterDefaultOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnregisterDefaultOIDFunction", dwEncodingType, pszFuncName, pwszDll);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pwszDll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetOIDFunctionValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSetOIDFunctionValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE *pbValueData, DWORD cbValueData)
     * }
     */
    public static FunctionDescriptor CryptSetOIDFunctionValue$descriptor() {
        return CryptSetOIDFunctionValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE *pbValueData, DWORD cbValueData)
     * }
     */
    public static MethodHandle CryptSetOIDFunctionValue$handle() {
        return CryptSetOIDFunctionValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE *pbValueData, DWORD cbValueData)
     * }
     */
    public static MemorySegment CryptSetOIDFunctionValue$address() {
        return CryptSetOIDFunctionValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE *pbValueData, DWORD cbValueData)
     * }
     */
    public static int CryptSetOIDFunctionValue(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, MemorySegment pwszValueName, int dwValueType, MemorySegment pbValueData, int cbValueData) {
        var mh$ = CryptSetOIDFunctionValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetOIDFunctionValue", dwEncodingType, pszFuncName, pszOID, pwszValueName, dwValueType, pbValueData, cbValueData);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszValueName, dwValueType, pbValueData, cbValueData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetOIDFunctionValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetOIDFunctionValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD *pdwValueType, BYTE *pbValueData, DWORD *pcbValueData)
     * }
     */
    public static FunctionDescriptor CryptGetOIDFunctionValue$descriptor() {
        return CryptGetOIDFunctionValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD *pdwValueType, BYTE *pbValueData, DWORD *pcbValueData)
     * }
     */
    public static MethodHandle CryptGetOIDFunctionValue$handle() {
        return CryptGetOIDFunctionValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD *pdwValueType, BYTE *pbValueData, DWORD *pcbValueData)
     * }
     */
    public static MemorySegment CryptGetOIDFunctionValue$address() {
        return CryptGetOIDFunctionValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD *pdwValueType, BYTE *pbValueData, DWORD *pcbValueData)
     * }
     */
    public static int CryptGetOIDFunctionValue(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, MemorySegment pwszValueName, MemorySegment pdwValueType, MemorySegment pbValueData, MemorySegment pcbValueData) {
        var mh$ = CryptGetOIDFunctionValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetOIDFunctionValue", dwEncodingType, pszFuncName, pszOID, pwszValueName, pdwValueType, pbValueData, pcbValueData);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszValueName, pdwValueType, pbValueData, pcbValueData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptEnumOIDFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc)
     * }
     */
    public static FunctionDescriptor CryptEnumOIDFunction$descriptor() {
        return CryptEnumOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc)
     * }
     */
    public static MethodHandle CryptEnumOIDFunction$handle() {
        return CryptEnumOIDFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc)
     * }
     */
    public static MemorySegment CryptEnumOIDFunction$address() {
        return CryptEnumOIDFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc)
     * }
     */
    public static int CryptEnumOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, int dwFlags, MemorySegment pvArg, MemorySegment pfnEnumOIDFunc) {
        var mh$ = CryptEnumOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumOIDFunction", dwEncodingType, pszFuncName, pszOID, dwFlags, pvArg, pfnEnumOIDFunc);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, dwFlags, pvArg, pfnEnumOIDFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_OID_INFO {
     *     DWORD cbSize;
     *     LPCSTR pszOID;
     *     LPCWSTR pwszName;
     *     DWORD dwGroupId;
     *     union {
     *         DWORD dwValue;
     *         ALG_ID Algid;
     *         DWORD dwLength;
     *     };
     *     CRYPT_DATA_BLOB ExtraInfo;
     * } *PCRYPT_OID_INFO
     * }
     */
    public static final AddressLayout PCRYPT_OID_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CRYPT_OID_INFO *PCCRYPT_OID_INFO
     * }
     */
    public static final AddressLayout PCCRYPT_OID_INFO = wgl_h.C_POINTER;

    private static class CryptFindOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptFindOIDInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRYPT_OID_INFO CryptFindOIDInfo(DWORD dwKeyType, void *pvKey, DWORD dwGroupId)
     * }
     */
    public static FunctionDescriptor CryptFindOIDInfo$descriptor() {
        return CryptFindOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRYPT_OID_INFO CryptFindOIDInfo(DWORD dwKeyType, void *pvKey, DWORD dwGroupId)
     * }
     */
    public static MethodHandle CryptFindOIDInfo$handle() {
        return CryptFindOIDInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRYPT_OID_INFO CryptFindOIDInfo(DWORD dwKeyType, void *pvKey, DWORD dwGroupId)
     * }
     */
    public static MemorySegment CryptFindOIDInfo$address() {
        return CryptFindOIDInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRYPT_OID_INFO CryptFindOIDInfo(DWORD dwKeyType, void *pvKey, DWORD dwGroupId)
     * }
     */
    public static MemorySegment CryptFindOIDInfo(int dwKeyType, MemorySegment pvKey, int dwGroupId) {
        var mh$ = CryptFindOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFindOIDInfo", dwKeyType, pvKey, dwGroupId);
            }
            return (MemorySegment)mh$.invokeExact(dwKeyType, pvKey, dwGroupId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptRegisterOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptRegisterOIDInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptRegisterOIDInfo$descriptor() {
        return CryptRegisterOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptRegisterOIDInfo$handle() {
        return CryptRegisterOIDInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptRegisterOIDInfo$address() {
        return CryptRegisterOIDInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags)
     * }
     */
    public static int CryptRegisterOIDInfo(MemorySegment pInfo, int dwFlags) {
        var mh$ = CryptRegisterOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRegisterOIDInfo", pInfo, dwFlags);
            }
            return (int)mh$.invokeExact(pInfo, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnregisterOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptUnregisterOIDInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo)
     * }
     */
    public static FunctionDescriptor CryptUnregisterOIDInfo$descriptor() {
        return CryptUnregisterOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo)
     * }
     */
    public static MethodHandle CryptUnregisterOIDInfo$handle() {
        return CryptUnregisterOIDInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo)
     * }
     */
    public static MemorySegment CryptUnregisterOIDInfo$address() {
        return CryptUnregisterOIDInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo)
     * }
     */
    public static int CryptUnregisterOIDInfo(MemorySegment pInfo) {
        var mh$ = CryptUnregisterOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnregisterOIDInfo", pInfo);
            }
            return (int)mh$.invokeExact(pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptEnumOIDInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo)
     * }
     */
    public static FunctionDescriptor CryptEnumOIDInfo$descriptor() {
        return CryptEnumOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo)
     * }
     */
    public static MethodHandle CryptEnumOIDInfo$handle() {
        return CryptEnumOIDInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo)
     * }
     */
    public static MemorySegment CryptEnumOIDInfo$address() {
        return CryptEnumOIDInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo)
     * }
     */
    public static int CryptEnumOIDInfo(int dwGroupId, int dwFlags, MemorySegment pvArg, MemorySegment pfnEnumOIDInfo) {
        var mh$ = CryptEnumOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumOIDInfo", dwGroupId, dwFlags, pvArg, pfnEnumOIDInfo);
            }
            return (int)mh$.invokeExact(dwGroupId, dwFlags, pvArg, pfnEnumOIDInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptFindLocalizedName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptFindLocalizedName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPCWSTR CryptFindLocalizedName(LPCWSTR pwszCryptName)
     * }
     */
    public static FunctionDescriptor CryptFindLocalizedName$descriptor() {
        return CryptFindLocalizedName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPCWSTR CryptFindLocalizedName(LPCWSTR pwszCryptName)
     * }
     */
    public static MethodHandle CryptFindLocalizedName$handle() {
        return CryptFindLocalizedName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPCWSTR CryptFindLocalizedName(LPCWSTR pwszCryptName)
     * }
     */
    public static MemorySegment CryptFindLocalizedName$address() {
        return CryptFindLocalizedName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPCWSTR CryptFindLocalizedName(LPCWSTR pwszCryptName)
     * }
     */
    public static MemorySegment CryptFindLocalizedName(MemorySegment pwszCryptName) {
        var mh$ = CryptFindLocalizedName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFindLocalizedName", pwszCryptName);
            }
            return (MemorySegment)mh$.invokeExact(pwszCryptName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STRONG_SIGN_SERIALIZED_INFO {
     *     DWORD dwFlags;
     *     LPWSTR pwszCNGSignHashAlgids;
     *     LPWSTR pwszCNGPubKeyMinBitLengths;
     * } *PCERT_STRONG_SIGN_SERIALIZED_INFO
     * }
     */
    public static final AddressLayout PCERT_STRONG_SIGN_SERIALIZED_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STRONG_SIGN_PARA {
     *     DWORD cbSize;
     *     DWORD dwInfoChoice;
     *     union {
     *         void *pvInfo;
     *         PCERT_STRONG_SIGN_SERIALIZED_INFO pSerializedInfo;
     *         LPSTR pszOID;
     *     };
     * } *PCERT_STRONG_SIGN_PARA
     * }
     */
    public static final AddressLayout PCERT_STRONG_SIGN_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_STRONG_SIGN_PARA *PCCERT_STRONG_SIGN_PARA
     * }
     */
    public static final AddressLayout PCCERT_STRONG_SIGN_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTMSG
     * }
     */
    public static final AddressLayout HCRYPTMSG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ISSUER_SERIAL_NUMBER {
     *     CERT_NAME_BLOB Issuer;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     * } *PCERT_ISSUER_SERIAL_NUMBER
     * }
     */
    public static final AddressLayout PCERT_ISSUER_SERIAL_NUMBER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ID {
     *     DWORD dwIdChoice;
     *     union {
     *         CERT_ISSUER_SERIAL_NUMBER IssuerSerialNumber;
     *         CRYPT_HASH_BLOB KeyId;
     *         CRYPT_HASH_BLOB HashId;
     *     };
     * } *PCERT_ID
     * }
     */
    public static final AddressLayout PCERT_ID = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNER_ENCODE_INFO {
     *     DWORD cbSize;
     *     PCERT_INFO pCertInfo;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     *     DWORD cAuthAttr;
     *     PCRYPT_ATTRIBUTE rgAuthAttr;
     *     DWORD cUnauthAttr;
     *     PCRYPT_ATTRIBUTE rgUnauthAttr;
     * } *PCMSG_SIGNER_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNER_ENCODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNED_ENCODE_INFO {
     *     DWORD cbSize;
     *     DWORD cSigners;
     *     PCMSG_SIGNER_ENCODE_INFO rgSigners;
     *     DWORD cCertEncoded;
     *     PCERT_BLOB rgCertEncoded;
     *     DWORD cCrlEncoded;
     *     PCRL_BLOB rgCrlEncoded;
     * } *PCMSG_SIGNED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNED_ENCODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RECIPIENT_ENCODE_INFO *PCMSG_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_RECIPIENT_ENCODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_ENVELOPED_ENCODE_INFO {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     *     DWORD cRecipients;
     *     PCERT_INFO *rgpRecipients;
     * } *PCMSG_ENVELOPED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_ENVELOPED_ENCODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     void *pvKeyEncryptionAuxInfo;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_BIT_BLOB RecipientPublicKey;
     *     CERT_ID RecipientId;
     * } *PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_BIT_BLOB RecipientPublicKey;
     *     CERT_ID RecipientId;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     void *pvKeyEncryptionAuxInfo;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyWrapAlgorithm;
     *     void *pvKeyWrapAuxInfo;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     DWORD dwKeySpec;
     *     DWORD dwKeyChoice;
     *     union {
     *         PCRYPT_ALGORITHM_IDENTIFIER pEphemeralAlgorithm;
     *         PCERT_ID pSenderId;
     *     };
     *     CRYPT_DATA_BLOB UserKeyingMaterial;
     *     DWORD cRecipientEncryptedKeys;
     *     PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *rgpRecipientEncryptedKeys;
     * } *PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     void *pvKeyEncryptionAuxInfo;
     *     HCRYPTPROV hCryptProv;
     *     DWORD dwKeyChoice;
     *     union {
     *         HCRYPTKEY hKeyEncryptionKey;
     *         void *pvKeyEncryptionKey;
     *     };
     *     CRYPT_DATA_BLOB KeyId;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RC2_AUX_INFO {
     *     DWORD cbSize;
     *     DWORD dwBitLen;
     * } *PCMSG_RC2_AUX_INFO
     * }
     */
    public static final AddressLayout PCMSG_RC2_AUX_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SP3_COMPATIBLE_AUX_INFO {
     *     DWORD cbSize;
     *     DWORD dwFlags;
     * } *PCMSG_SP3_COMPATIBLE_AUX_INFO
     * }
     */
    public static final AddressLayout PCMSG_SP3_COMPATIBLE_AUX_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RC4_AUX_INFO {
     *     DWORD cbSize;
     *     DWORD dwBitLen;
     * } *PCMSG_RC4_AUX_INFO
     * }
     */
    public static final AddressLayout PCMSG_RC4_AUX_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO {
     *     DWORD cbSize;
     *     CMSG_SIGNED_ENCODE_INFO SignedInfo;
     *     CMSG_ENVELOPED_ENCODE_INFO EnvelopedInfo;
     * } *PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_HASHED_ENCODE_INFO {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     * } *PCMSG_HASHED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_HASHED_ENCODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_ENCRYPTED_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     * } *PCMSG_ENCRYPTED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_ENCRYPTED_ENCODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_STREAM_INFO {
     *     DWORD cbContent;
     *     PFN_CMSG_STREAM_OUTPUT pfnStreamOutput;
     *     void *pvArg;
     * } *PCMSG_STREAM_INFO
     * }
     */
    public static final AddressLayout PCMSG_STREAM_INFO = wgl_h.C_POINTER;

    private static class CryptMsgOpenToEncode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgOpenToEncode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToEncode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static FunctionDescriptor CryptMsgOpenToEncode$descriptor() {
        return CryptMsgOpenToEncode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToEncode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MethodHandle CryptMsgOpenToEncode$handle() {
        return CryptMsgOpenToEncode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToEncode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MemorySegment CryptMsgOpenToEncode$address() {
        return CryptMsgOpenToEncode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToEncode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MemorySegment CryptMsgOpenToEncode(int dwMsgEncodingType, int dwFlags, int dwMsgType, MemorySegment pvMsgEncodeInfo, MemorySegment pszInnerContentObjID, MemorySegment pStreamInfo) {
        var mh$ = CryptMsgOpenToEncode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgOpenToEncode", dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgCalculateEncodedLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgCalculateEncodedLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CryptMsgCalculateEncodedLength(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData)
     * }
     */
    public static FunctionDescriptor CryptMsgCalculateEncodedLength$descriptor() {
        return CryptMsgCalculateEncodedLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CryptMsgCalculateEncodedLength(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData)
     * }
     */
    public static MethodHandle CryptMsgCalculateEncodedLength$handle() {
        return CryptMsgCalculateEncodedLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CryptMsgCalculateEncodedLength(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData)
     * }
     */
    public static MemorySegment CryptMsgCalculateEncodedLength$address() {
        return CryptMsgCalculateEncodedLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CryptMsgCalculateEncodedLength(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData)
     * }
     */
    public static int CryptMsgCalculateEncodedLength(int dwMsgEncodingType, int dwFlags, int dwMsgType, MemorySegment pvMsgEncodeInfo, MemorySegment pszInnerContentObjID, int cbData) {
        var mh$ = CryptMsgCalculateEncodedLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgCalculateEncodedLength", dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, cbData);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgOpenToDecode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgOpenToDecode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToDecode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV_LEGACY hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static FunctionDescriptor CryptMsgOpenToDecode$descriptor() {
        return CryptMsgOpenToDecode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToDecode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV_LEGACY hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MethodHandle CryptMsgOpenToDecode$handle() {
        return CryptMsgOpenToDecode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToDecode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV_LEGACY hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MemorySegment CryptMsgOpenToDecode$address() {
        return CryptMsgOpenToDecode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToDecode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV_LEGACY hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MemorySegment CryptMsgOpenToDecode(int dwMsgEncodingType, int dwFlags, int dwMsgType, long hCryptProv, MemorySegment pRecipientInfo, MemorySegment pStreamInfo) {
        var mh$ = CryptMsgOpenToDecode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgOpenToDecode", dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgDuplicate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgDuplicate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgDuplicate(HCRYPTMSG hCryptMsg)
     * }
     */
    public static FunctionDescriptor CryptMsgDuplicate$descriptor() {
        return CryptMsgDuplicate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgDuplicate(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MethodHandle CryptMsgDuplicate$handle() {
        return CryptMsgDuplicate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgDuplicate(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MemorySegment CryptMsgDuplicate$address() {
        return CryptMsgDuplicate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgDuplicate(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MemorySegment CryptMsgDuplicate(MemorySegment hCryptMsg) {
        var mh$ = CryptMsgDuplicate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgDuplicate", hCryptMsg);
            }
            return (MemorySegment)mh$.invokeExact(hCryptMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgClose(HCRYPTMSG hCryptMsg)
     * }
     */
    public static FunctionDescriptor CryptMsgClose$descriptor() {
        return CryptMsgClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgClose(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MethodHandle CryptMsgClose$handle() {
        return CryptMsgClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgClose(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MemorySegment CryptMsgClose$address() {
        return CryptMsgClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgClose(HCRYPTMSG hCryptMsg)
     * }
     */
    public static int CryptMsgClose(MemorySegment hCryptMsg) {
        var mh$ = CryptMsgClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgClose", hCryptMsg);
            }
            return (int)mh$.invokeExact(hCryptMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgUpdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgUpdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal)
     * }
     */
    public static FunctionDescriptor CryptMsgUpdate$descriptor() {
        return CryptMsgUpdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal)
     * }
     */
    public static MethodHandle CryptMsgUpdate$handle() {
        return CryptMsgUpdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal)
     * }
     */
    public static MemorySegment CryptMsgUpdate$address() {
        return CryptMsgUpdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal)
     * }
     */
    public static int CryptMsgUpdate(MemorySegment hCryptMsg, MemorySegment pbData, int cbData, int fFinal) {
        var mh$ = CryptMsgUpdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgUpdate", hCryptMsg, pbData, cbData, fFinal);
            }
            return (int)mh$.invokeExact(hCryptMsg, pbData, cbData, fFinal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgGetParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgGetParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CryptMsgGetParam$descriptor() {
        return CryptMsgGetParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CryptMsgGetParam$handle() {
        return CryptMsgGetParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CryptMsgGetParam$address() {
        return CryptMsgGetParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CryptMsgGetParam(MemorySegment hCryptMsg, int dwParamType, int dwIndex, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CryptMsgGetParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgGetParam", hCryptMsg, dwParamType, dwIndex, pvData, pcbData);
            }
            return (int)mh$.invokeExact(hCryptMsg, dwParamType, dwIndex, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNER_INFO {
     *     DWORD dwVersion;
     *     CERT_NAME_BLOB Issuer;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedHash;
     *     CRYPT_ATTRIBUTES AuthAttrs;
     *     CRYPT_ATTRIBUTES UnauthAttrs;
     * } *PCMSG_SIGNER_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNER_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CMS_SIGNER_INFO {
     *     DWORD dwVersion;
     *     CERT_ID SignerId;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedHash;
     *     CRYPT_ATTRIBUTES AuthAttrs;
     *     CRYPT_ATTRIBUTES UnauthAttrs;
     * } *PCMSG_CMS_SIGNER_INFO
     * }
     */
    public static final AddressLayout PCMSG_CMS_SIGNER_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CRYPT_ATTRIBUTES *PCMSG_ATTR
     * }
     */
    public static final AddressLayout PCMSG_ATTR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_TRANS_RECIPIENT_INFO {
     *     DWORD dwVersion;
     *     CERT_ID RecipientId;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     * } *PCMSG_KEY_TRANS_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_TRANS_RECIPIENT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO {
     *     CERT_ID RecipientId;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO
     * }
     */
    public static final AddressLayout PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_RECIPIENT_INFO {
     *     DWORD dwVersion;
     *     DWORD dwOriginatorChoice;
     *     union {
     *         CERT_ID OriginatorCertId;
     *         CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;
     *     };
     *     CRYPT_DATA_BLOB UserKeyingMaterial;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     DWORD cRecipientEncryptedKeys;
     *     PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO *rgpRecipientEncryptedKeys;
     * } *PCMSG_KEY_AGREE_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_RECIPIENT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_MAIL_LIST_RECIPIENT_INFO {
     *     DWORD dwVersion;
     *     CRYPT_DATA_BLOB KeyId;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_MAIL_LIST_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_MAIL_LIST_RECIPIENT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CMS_RECIPIENT_INFO {
     *     DWORD dwRecipientChoice;
     *     union {
     *         PCMSG_KEY_TRANS_RECIPIENT_INFO pKeyTrans;
     *         PCMSG_KEY_AGREE_RECIPIENT_INFO pKeyAgree;
     *         PCMSG_MAIL_LIST_RECIPIENT_INFO pMailList;
     *     };
     * } *PCMSG_CMS_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_CMS_RECIPIENT_INFO = wgl_h.C_POINTER;

    private static class CryptMsgControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static FunctionDescriptor CryptMsgControl$descriptor() {
        return CryptMsgControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static MethodHandle CryptMsgControl$handle() {
        return CryptMsgControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static MemorySegment CryptMsgControl$address() {
        return CryptMsgControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static int CryptMsgControl(MemorySegment hCryptMsg, int dwFlags, int dwCtrlType, MemorySegment pvCtrlPara) {
        var mh$ = CryptMsgControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgControl", hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara);
            }
            return (int)mh$.invokeExact(hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     DWORD dwSignerIndex;
     *     DWORD dwSignerType;
     *     void *pvSigner;
     * } *PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_DECRYPT_PARA {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     DWORD dwRecipientIndex;
     * } *PCMSG_CTRL_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_DECRYPT_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     PCMSG_KEY_TRANS_RECIPIENT_INFO pKeyTrans;
     *     DWORD dwRecipientIndex;
     * } *PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     PCMSG_KEY_AGREE_RECIPIENT_INFO pKeyAgree;
     *     DWORD dwRecipientIndex;
     *     DWORD dwRecipientEncryptedKeyIndex;
     *     CRYPT_BIT_BLOB OriginatorPublicKey;
     * } *PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA {
     *     DWORD cbSize;
     *     HCRYPTPROV hCryptProv;
     *     PCMSG_MAIL_LIST_RECIPIENT_INFO pMailList;
     *     DWORD dwRecipientIndex;
     *     DWORD dwKeyChoice;
     *     union {
     *         HCRYPTKEY hKeyEncryptionKey;
     *         void *pvKeyEncryptionKey;
     *     };
     * } *PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA {
     *     DWORD cbSize;
     *     DWORD dwSignerIndex;
     *     CRYPT_DATA_BLOB blob;
     * } *PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA {
     *     DWORD cbSize;
     *     DWORD dwSignerIndex;
     *     DWORD dwUnauthAttrIndex;
     * } *PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = wgl_h.C_POINTER;

    private static class CryptMsgVerifyCountersignatureEncoded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgVerifyCountersignatureEncoded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, PCERT_INFO pciCountersigner)
     * }
     */
    public static FunctionDescriptor CryptMsgVerifyCountersignatureEncoded$descriptor() {
        return CryptMsgVerifyCountersignatureEncoded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, PCERT_INFO pciCountersigner)
     * }
     */
    public static MethodHandle CryptMsgVerifyCountersignatureEncoded$handle() {
        return CryptMsgVerifyCountersignatureEncoded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, PCERT_INFO pciCountersigner)
     * }
     */
    public static MemorySegment CryptMsgVerifyCountersignatureEncoded$address() {
        return CryptMsgVerifyCountersignatureEncoded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, PCERT_INFO pciCountersigner)
     * }
     */
    public static int CryptMsgVerifyCountersignatureEncoded(long hCryptProv, int dwEncodingType, MemorySegment pbSignerInfo, int cbSignerInfo, MemorySegment pbSignerInfoCountersignature, int cbSignerInfoCountersignature, MemorySegment pciCountersigner) {
        var mh$ = CryptMsgVerifyCountersignatureEncoded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgVerifyCountersignatureEncoded", hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, pciCountersigner);
            }
            return (int)mh$.invokeExact(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, pciCountersigner);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgVerifyCountersignatureEncodedEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgVerifyCountersignatureEncodedEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, DWORD dwSignerType, void *pvSigner, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static FunctionDescriptor CryptMsgVerifyCountersignatureEncodedEx$descriptor() {
        return CryptMsgVerifyCountersignatureEncodedEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, DWORD dwSignerType, void *pvSigner, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static MethodHandle CryptMsgVerifyCountersignatureEncodedEx$handle() {
        return CryptMsgVerifyCountersignatureEncodedEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, DWORD dwSignerType, void *pvSigner, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static MemorySegment CryptMsgVerifyCountersignatureEncodedEx$address() {
        return CryptMsgVerifyCountersignatureEncodedEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, DWORD dwSignerType, void *pvSigner, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static int CryptMsgVerifyCountersignatureEncodedEx(long hCryptProv, int dwEncodingType, MemorySegment pbSignerInfo, int cbSignerInfo, MemorySegment pbSignerInfoCountersignature, int cbSignerInfoCountersignature, int dwSignerType, MemorySegment pvSigner, int dwFlags, MemorySegment pvExtra) {
        var mh$ = CryptMsgVerifyCountersignatureEncodedEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgVerifyCountersignatureEncodedEx", hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, dwSignerType, pvSigner, dwFlags, pvExtra);
            }
            return (int)mh$.invokeExact(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, dwSignerType, pvSigner, dwFlags, pvExtra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgCountersign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgCountersign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
     * }
     */
    public static FunctionDescriptor CryptMsgCountersign$descriptor() {
        return CryptMsgCountersign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
     * }
     */
    public static MethodHandle CryptMsgCountersign$handle() {
        return CryptMsgCountersign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
     * }
     */
    public static MemorySegment CryptMsgCountersign$address() {
        return CryptMsgCountersign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
     * }
     */
    public static int CryptMsgCountersign(MemorySegment hCryptMsg, int dwIndex, int cCountersigners, MemorySegment rgCountersigners) {
        var mh$ = CryptMsgCountersign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgCountersign", hCryptMsg, dwIndex, cCountersigners, rgCountersigners);
            }
            return (int)mh$.invokeExact(hCryptMsg, dwIndex, cCountersigners, rgCountersigners);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgCountersignEncoded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgCountersignEncoded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersignEncoded(DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners, PBYTE pbCountersignature, PDWORD pcbCountersignature)
     * }
     */
    public static FunctionDescriptor CryptMsgCountersignEncoded$descriptor() {
        return CryptMsgCountersignEncoded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersignEncoded(DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners, PBYTE pbCountersignature, PDWORD pcbCountersignature)
     * }
     */
    public static MethodHandle CryptMsgCountersignEncoded$handle() {
        return CryptMsgCountersignEncoded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersignEncoded(DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners, PBYTE pbCountersignature, PDWORD pcbCountersignature)
     * }
     */
    public static MemorySegment CryptMsgCountersignEncoded$address() {
        return CryptMsgCountersignEncoded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgCountersignEncoded(DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners, PBYTE pbCountersignature, PDWORD pcbCountersignature)
     * }
     */
    public static int CryptMsgCountersignEncoded(int dwEncodingType, MemorySegment pbSignerInfo, int cbSignerInfo, int cCountersigners, MemorySegment rgCountersigners, MemorySegment pbCountersignature, MemorySegment pcbCountersignature) {
        var mh$ = CryptMsgCountersignEncoded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgCountersignEncoded", dwEncodingType, pbSignerInfo, cbSignerInfo, cCountersigners, rgCountersigners, pbCountersignature, pcbCountersignature);
            }
            return (int)mh$.invokeExact(dwEncodingType, pbSignerInfo, cbSignerInfo, cCountersigners, rgCountersigners, pbCountersignature, pcbCountersignature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CONTENT_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     *     DWORD cRecipients;
     *     PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients;
     *     PFN_CMSG_ALLOC pfnAlloc;
     *     PFN_CMSG_FREE pfnFree;
     *     DWORD dwEncryptFlags;
     *     union {
     *         HCRYPTKEY hContentEncryptKey;
     *         BCRYPT_KEY_HANDLE hCNGContentEncryptKey;
     *     };
     *     DWORD dwFlags;
     *     BOOL fCNG;
     *     BYTE *pbCNGContentEncryptKeyObject;
     *     BYTE *pbContentEncryptKey;
     *     DWORD cbContentEncryptKey;
     * } *PCMSG_CONTENT_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_CONTENT_ENCRYPT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_TRANS_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     DWORD dwRecipientIndex;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     DWORD dwFlags;
     * } *PCMSG_KEY_TRANS_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_TRANS_ENCRYPT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     CRYPT_DATA_BLOB EncryptedKey;
     * } *PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     DWORD dwRecipientIndex;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB UserKeyingMaterial;
     *     DWORD dwOriginatorChoice;
     *     union {
     *         CERT_ID OriginatorCertId;
     *         CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;
     *     };
     *     DWORD cKeyAgreeKeyEncryptInfo;
     *     PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *rgpKeyAgreeKeyEncryptInfo;
     *     DWORD dwFlags;
     * } *PCMSG_KEY_AGREE_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_ENCRYPT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_MAIL_LIST_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     DWORD dwRecipientIndex;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     DWORD dwFlags;
     * } *PCMSG_MAIL_LIST_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_MAIL_LIST_ENCRYPT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CNG_CONTENT_DECRYPT_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     PFN_CMSG_ALLOC pfnAlloc;
     *     PFN_CMSG_FREE pfnFree;
     *     NCRYPT_KEY_HANDLE hNCryptKey;
     *     BYTE *pbContentEncryptKey;
     *     DWORD cbContentEncryptKey;
     *     BCRYPT_KEY_HANDLE hCNGContentEncryptKey;
     *     BYTE *pbCNGContentEncryptKeyObject;
     * } *PCMSG_CNG_CONTENT_DECRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_CNG_CONTENT_DECRYPT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCERTSTORE
     * }
     */
    public static final AddressLayout HCERTSTORE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CONTEXT {
     *     DWORD dwCertEncodingType;
     *     BYTE *pbCertEncoded;
     *     DWORD cbCertEncoded;
     *     PCERT_INFO pCertInfo;
     *     HCERTSTORE hCertStore;
     * } *PCERT_CONTEXT
     * }
     */
    public static final AddressLayout PCERT_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_CONTEXT *PCCERT_CONTEXT
     * }
     */
    public static final AddressLayout PCCERT_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_CONTEXT {
     *     DWORD dwCertEncodingType;
     *     BYTE *pbCrlEncoded;
     *     DWORD cbCrlEncoded;
     *     PCRL_INFO pCrlInfo;
     *     HCERTSTORE hCertStore;
     * } *PCRL_CONTEXT
     * }
     */
    public static final AddressLayout PCRL_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CRL_CONTEXT *PCCRL_CONTEXT
     * }
     */
    public static final AddressLayout PCCRL_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_CONTEXT {
     *     DWORD dwMsgAndCertEncodingType;
     *     BYTE *pbCtlEncoded;
     *     DWORD cbCtlEncoded;
     *     PCTL_INFO pCtlInfo;
     *     HCERTSTORE hCertStore;
     *     HCRYPTMSG hCryptMsg;
     *     BYTE *pbCtlContent;
     *     DWORD cbCtlContent;
     * } *PCTL_CONTEXT
     * }
     */
    public static final AddressLayout PCTL_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CTL_CONTEXT *PCCTL_CONTEXT
     * }
     */
    public static final AddressLayout PCCTL_CONTEXT = wgl_h.C_POINTER;
    private static final int KeyTypeOther = (int)0L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeOther = 0
     * }
     */
    public static int KeyTypeOther() {
        return KeyTypeOther;
    }
    private static final int KeyTypeVirtualSmartCard = (int)1L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeVirtualSmartCard = 1
     * }
     */
    public static int KeyTypeVirtualSmartCard() {
        return KeyTypeVirtualSmartCard;
    }
    private static final int KeyTypePhysicalSmartCard = (int)2L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePhysicalSmartCard = 2
     * }
     */
    public static int KeyTypePhysicalSmartCard() {
        return KeyTypePhysicalSmartCard;
    }
    private static final int KeyTypePassport = (int)3L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePassport = 3
     * }
     */
    public static int KeyTypePassport() {
        return KeyTypePassport;
    }
    private static final int KeyTypePassportRemote = (int)4L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePassportRemote = 4
     * }
     */
    public static int KeyTypePassportRemote() {
        return KeyTypePassportRemote;
    }
    private static final int KeyTypePassportSmartCard = (int)5L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePassportSmartCard = 5
     * }
     */
    public static int KeyTypePassportSmartCard() {
        return KeyTypePassportSmartCard;
    }
    private static final int KeyTypeHardware = (int)6L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeHardware = 6
     * }
     */
    public static int KeyTypeHardware() {
        return KeyTypeHardware;
    }
    private static final int KeyTypeSoftware = (int)7L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeSoftware = 7
     * }
     */
    public static int KeyTypeSoftware() {
        return KeyTypeSoftware;
    }
    private static final int KeyTypeSelfSigned = (int)8L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeSelfSigned = 8
     * }
     */
    public static int KeyTypeSelfSigned() {
        return KeyTypeSelfSigned;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_PROV_PARAM {
     *     DWORD dwParam;
     *     BYTE *pbData;
     *     DWORD cbData;
     *     DWORD dwFlags;
     * } *PCRYPT_KEY_PROV_PARAM
     * }
     */
    public static final AddressLayout PCRYPT_KEY_PROV_PARAM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_PROV_INFO {
     *     LPWSTR pwszContainerName;
     *     LPWSTR pwszProvName;
     *     DWORD dwProvType;
     *     DWORD dwFlags;
     *     DWORD cProvParam;
     *     PCRYPT_KEY_PROV_PARAM rgProvParam;
     *     DWORD dwKeySpec;
     * } *PCRYPT_KEY_PROV_INFO
     * }
     */
    public static final AddressLayout PCRYPT_KEY_PROV_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_KEY_CONTEXT {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     * } *PCERT_KEY_CONTEXT
     * }
     */
    public static final AddressLayout PCERT_KEY_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ROOT_INFO_LUID {
     *     DWORD LowPart;
     *     LONG HighPart;
     * } *PROOT_INFO_LUID
     * }
     */
    public static final AddressLayout PROOT_INFO_LUID = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SMART_CARD_ROOT_INFO {
     *     BYTE rgbCardID[16];
     *     ROOT_INFO_LUID luid;
     * } *PCRYPT_SMART_CARD_ROOT_INFO
     * }
     */
    public static final AddressLayout PCRYPT_SMART_CARD_ROOT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SYSTEM_STORE_RELOCATE_PARA {
     *     union {
     *         HKEY hKeyBase;
     *         void *pvBase;
     *     };
     *     union {
     *         void *pvSystemStore;
     *         LPCSTR pszSystemStore;
     *         LPCWSTR pwszSystemStore;
     *     };
     * } *PCERT_SYSTEM_STORE_RELOCATE_PARA
     * }
     */
    public static final AddressLayout PCERT_SYSTEM_STORE_RELOCATE_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REGISTRY_STORE_CLIENT_GPT_PARA {
     *     HKEY hKeyBase;
     *     LPWSTR pwszRegPath;
     * } *PCERT_REGISTRY_STORE_CLIENT_GPT_PARA
     * }
     */
    public static final AddressLayout PCERT_REGISTRY_STORE_CLIENT_GPT_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REGISTRY_STORE_ROAMING_PARA {
     *     HKEY hKey;
     *     LPWSTR pwszStoreDirectory;
     * } *PCERT_REGISTRY_STORE_ROAMING_PARA
     * }
     */
    public static final AddressLayout PCERT_REGISTRY_STORE_ROAMING_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LDAP_STORE_OPENED_PARA {
     *     void *pvLdapSessionHandle;
     *     LPCWSTR pwszLdapUrl;
     * } *PCERT_LDAP_STORE_OPENED_PARA
     * }
     */
    public static final AddressLayout PCERT_LDAP_STORE_OPENED_PARA = wgl_h.C_POINTER;

    private static class CertOpenStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertOpenStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara)
     * }
     */
    public static FunctionDescriptor CertOpenStore$descriptor() {
        return CertOpenStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara)
     * }
     */
    public static MethodHandle CertOpenStore$handle() {
        return CertOpenStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara)
     * }
     */
    public static MemorySegment CertOpenStore$address() {
        return CertOpenStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara)
     * }
     */
    public static MemorySegment CertOpenStore(MemorySegment lpszStoreProvider, int dwEncodingType, long hCryptProv, int dwFlags, MemorySegment pvPara) {
        var mh$ = CertOpenStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOpenStore", lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara);
            }
            return (MemorySegment)mh$.invokeExact(lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *HCERTSTOREPROV
     * }
     */
    public static final AddressLayout HCERTSTOREPROV = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STORE_PROV_INFO {
     *     DWORD cbSize;
     *     DWORD cStoreProvFunc;
     *     void **rgpvStoreProvFunc;
     *     HCERTSTOREPROV hStoreProv;
     *     DWORD dwStoreProvFlags;
     *     HCRYPTOIDFUNCADDR hStoreProvFuncAddr2;
     * } *PCERT_STORE_PROV_INFO
     * }
     */
    public static final AddressLayout PCERT_STORE_PROV_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STORE_PROV_FIND_INFO {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     DWORD dwFindFlags;
     *     DWORD dwFindType;
     *     const void *pvFindPara;
     * } *PCERT_STORE_PROV_FIND_INFO
     * }
     */
    public static final AddressLayout PCERT_STORE_PROV_FIND_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_STORE_PROV_FIND_INFO *PCCERT_STORE_PROV_FIND_INFO
     * }
     */
    public static final AddressLayout PCCERT_STORE_PROV_FIND_INFO = wgl_h.C_POINTER;

    private static class CertDuplicateStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertDuplicateStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertDuplicateStore(HCERTSTORE hCertStore)
     * }
     */
    public static FunctionDescriptor CertDuplicateStore$descriptor() {
        return CertDuplicateStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertDuplicateStore(HCERTSTORE hCertStore)
     * }
     */
    public static MethodHandle CertDuplicateStore$handle() {
        return CertDuplicateStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE CertDuplicateStore(HCERTSTORE hCertStore)
     * }
     */
    public static MemorySegment CertDuplicateStore$address() {
        return CertDuplicateStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE CertDuplicateStore(HCERTSTORE hCertStore)
     * }
     */
    public static MemorySegment CertDuplicateStore(MemorySegment hCertStore) {
        var mh$ = CertDuplicateStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateStore", hCertStore);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSaveStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertSaveStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void *pvSaveToPara, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertSaveStore$descriptor() {
        return CertSaveStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void *pvSaveToPara, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertSaveStore$handle() {
        return CertSaveStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void *pvSaveToPara, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertSaveStore$address() {
        return CertSaveStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void *pvSaveToPara, DWORD dwFlags)
     * }
     */
    public static int CertSaveStore(MemorySegment hCertStore, int dwEncodingType, int dwSaveAs, int dwSaveTo, MemorySegment pvSaveToPara, int dwFlags) {
        var mh$ = CertSaveStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSaveStore", hCertStore, dwEncodingType, dwSaveAs, dwSaveTo, pvSaveToPara, dwFlags);
            }
            return (int)mh$.invokeExact(hCertStore, dwEncodingType, dwSaveAs, dwSaveTo, pvSaveToPara, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCloseStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCloseStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertCloseStore$descriptor() {
        return CertCloseStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertCloseStore$handle() {
        return CertCloseStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertCloseStore$address() {
        return CertCloseStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags)
     * }
     */
    public static int CertCloseStore(MemorySegment hCertStore, int dwFlags) {
        var mh$ = CertCloseStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCloseStore", hCertStore, dwFlags);
            }
            return (int)mh$.invokeExact(hCertStore, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetSubjectCertificateFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetSubjectCertificateFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId)
     * }
     */
    public static FunctionDescriptor CertGetSubjectCertificateFromStore$descriptor() {
        return CertGetSubjectCertificateFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId)
     * }
     */
    public static MethodHandle CertGetSubjectCertificateFromStore$handle() {
        return CertGetSubjectCertificateFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId)
     * }
     */
    public static MemorySegment CertGetSubjectCertificateFromStore$address() {
        return CertGetSubjectCertificateFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId)
     * }
     */
    public static MemorySegment CertGetSubjectCertificateFromStore(MemorySegment hCertStore, int dwCertEncodingType, MemorySegment pCertId) {
        var mh$ = CertGetSubjectCertificateFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetSubjectCertificateFromStore", hCertStore, dwCertEncodingType, pCertId);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwCertEncodingType, pCertId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCertificatesInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertEnumCertificatesInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static FunctionDescriptor CertEnumCertificatesInStore$descriptor() {
        return CertEnumCertificatesInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MethodHandle CertEnumCertificatesInStore$handle() {
        return CertEnumCertificatesInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MemorySegment CertEnumCertificatesInStore$address() {
        return CertEnumCertificatesInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MemorySegment CertEnumCertificatesInStore(MemorySegment hCertStore, MemorySegment pPrevCertContext) {
        var mh$ = CertEnumCertificatesInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCertificatesInStore", hCertStore, pPrevCertContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pPrevCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindCertificateInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFindCertificateInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static FunctionDescriptor CertFindCertificateInStore$descriptor() {
        return CertFindCertificateInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MethodHandle CertFindCertificateInStore$handle() {
        return CertFindCertificateInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MemorySegment CertFindCertificateInStore$address() {
        return CertFindCertificateInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MemorySegment CertFindCertificateInStore(MemorySegment hCertStore, int dwCertEncodingType, int dwFindFlags, int dwFindType, MemorySegment pvFindPara, MemorySegment pPrevCertContext) {
        var mh$ = CertFindCertificateInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCertificateInStore", hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetIssuerCertificateFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetIssuerCertificateFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CertGetIssuerCertificateFromStore$descriptor() {
        return CertGetIssuerCertificateFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CertGetIssuerCertificateFromStore$handle() {
        return CertGetIssuerCertificateFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertGetIssuerCertificateFromStore$address() {
        return CertGetIssuerCertificateFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertGetIssuerCertificateFromStore(MemorySegment hCertStore, MemorySegment pSubjectContext, MemorySegment pPrevIssuerContext, MemorySegment pdwFlags) {
        var mh$ = CertGetIssuerCertificateFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetIssuerCertificateFromStore", hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifySubjectCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertVerifySubjectCertificateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CertVerifySubjectCertificateContext$descriptor() {
        return CertVerifySubjectCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CertVerifySubjectCertificateContext$handle() {
        return CertVerifySubjectCertificateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertVerifySubjectCertificateContext$address() {
        return CertVerifySubjectCertificateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags)
     * }
     */
    public static int CertVerifySubjectCertificateContext(MemorySegment pSubject, MemorySegment pIssuer, MemorySegment pdwFlags) {
        var mh$ = CertVerifySubjectCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifySubjectCertificateContext", pSubject, pIssuer, pdwFlags);
            }
            return (int)mh$.invokeExact(pSubject, pIssuer, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDuplicateCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertDuplicateCertificateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static FunctionDescriptor CertDuplicateCertificateContext$descriptor() {
        return CertDuplicateCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MethodHandle CertDuplicateCertificateContext$handle() {
        return CertDuplicateCertificateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MemorySegment CertDuplicateCertificateContext$address() {
        return CertDuplicateCertificateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MemorySegment CertDuplicateCertificateContext(MemorySegment pCertContext) {
        var mh$ = CertDuplicateCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateCertificateContext", pCertContext);
            }
            return (MemorySegment)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCreateCertificateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static FunctionDescriptor CertCreateCertificateContext$descriptor() {
        return CertCreateCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MethodHandle CertCreateCertificateContext$handle() {
        return CertCreateCertificateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MemorySegment CertCreateCertificateContext$address() {
        return CertCreateCertificateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MemorySegment CertCreateCertificateContext(int dwCertEncodingType, MemorySegment pbCertEncoded, int cbCertEncoded) {
        var mh$ = CertCreateCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCertificateContext", dwCertEncodingType, pbCertEncoded, cbCertEncoded);
            }
            return (MemorySegment)mh$.invokeExact(dwCertEncodingType, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFreeCertificateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFreeCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static FunctionDescriptor CertFreeCertificateContext$descriptor() {
        return CertFreeCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFreeCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MethodHandle CertFreeCertificateContext$handle() {
        return CertFreeCertificateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertFreeCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MemorySegment CertFreeCertificateContext$address() {
        return CertFreeCertificateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertFreeCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static int CertFreeCertificateContext(MemorySegment pCertContext) {
        var mh$ = CertFreeCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCertificateContext", pCertContext);
            }
            return (int)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCertificateContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertSetCertificateContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetCertificateContextProperty$descriptor() {
        return CertSetCertificateContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetCertificateContextProperty$handle() {
        return CertSetCertificateContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MemorySegment CertSetCertificateContextProperty$address() {
        return CertSetCertificateContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetCertificateContextProperty(MemorySegment pCertContext, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetCertificateContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCertificateContextProperty", pCertContext, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(pCertContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCertificateContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetCertificateContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetCertificateContextProperty$descriptor() {
        return CertGetCertificateContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetCertificateContextProperty$handle() {
        return CertGetCertificateContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CertGetCertificateContextProperty$address() {
        return CertGetCertificateContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetCertificateContextProperty(MemorySegment pCertContext, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetCertificateContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCertificateContextProperty", pCertContext, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(pCertContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCertificateContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertEnumCertificateContextProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId)
     * }
     */
    public static FunctionDescriptor CertEnumCertificateContextProperties$descriptor() {
        return CertEnumCertificateContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId)
     * }
     */
    public static MethodHandle CertEnumCertificateContextProperties$handle() {
        return CertEnumCertificateContextProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId)
     * }
     */
    public static MemorySegment CertEnumCertificateContextProperties$address() {
        return CertEnumCertificateContextProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId)
     * }
     */
    public static int CertEnumCertificateContextProperties(MemorySegment pCertContext, int dwPropId) {
        var mh$ = CertEnumCertificateContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCertificateContextProperties", pCertContext, dwPropId);
            }
            return (int)mh$.invokeExact(pCertContext, dwPropId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCTLEntryFromCertificateContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCreateCTLEntryFromCertificateContextProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD cOptAttr, PCRYPT_ATTRIBUTE rgOptAttr, DWORD dwFlags, void *pvReserved, PCTL_ENTRY pCtlEntry, DWORD *pcbCtlEntry)
     * }
     */
    public static FunctionDescriptor CertCreateCTLEntryFromCertificateContextProperties$descriptor() {
        return CertCreateCTLEntryFromCertificateContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD cOptAttr, PCRYPT_ATTRIBUTE rgOptAttr, DWORD dwFlags, void *pvReserved, PCTL_ENTRY pCtlEntry, DWORD *pcbCtlEntry)
     * }
     */
    public static MethodHandle CertCreateCTLEntryFromCertificateContextProperties$handle() {
        return CertCreateCTLEntryFromCertificateContextProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD cOptAttr, PCRYPT_ATTRIBUTE rgOptAttr, DWORD dwFlags, void *pvReserved, PCTL_ENTRY pCtlEntry, DWORD *pcbCtlEntry)
     * }
     */
    public static MemorySegment CertCreateCTLEntryFromCertificateContextProperties$address() {
        return CertCreateCTLEntryFromCertificateContextProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD cOptAttr, PCRYPT_ATTRIBUTE rgOptAttr, DWORD dwFlags, void *pvReserved, PCTL_ENTRY pCtlEntry, DWORD *pcbCtlEntry)
     * }
     */
    public static int CertCreateCTLEntryFromCertificateContextProperties(MemorySegment pCertContext, int cOptAttr, MemorySegment rgOptAttr, int dwFlags, MemorySegment pvReserved, MemorySegment pCtlEntry, MemorySegment pcbCtlEntry) {
        var mh$ = CertCreateCTLEntryFromCertificateContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCTLEntryFromCertificateContextProperties", pCertContext, cOptAttr, rgOptAttr, dwFlags, pvReserved, pCtlEntry, pcbCtlEntry);
            }
            return (int)mh$.invokeExact(pCertContext, cOptAttr, rgOptAttr, dwFlags, pvReserved, pCtlEntry, pcbCtlEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCertificateContextPropertiesFromCTLEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertSetCertificateContextPropertiesFromCTLEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertSetCertificateContextPropertiesFromCTLEntry$descriptor() {
        return CertSetCertificateContextPropertiesFromCTLEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertSetCertificateContextPropertiesFromCTLEntry$handle() {
        return CertSetCertificateContextPropertiesFromCTLEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertSetCertificateContextPropertiesFromCTLEntry$address() {
        return CertSetCertificateContextPropertiesFromCTLEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags)
     * }
     */
    public static int CertSetCertificateContextPropertiesFromCTLEntry(MemorySegment pCertContext, MemorySegment pCtlEntry, int dwFlags) {
        var mh$ = CertSetCertificateContextPropertiesFromCTLEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCertificateContextPropertiesFromCTLEntry", pCertContext, pCtlEntry, dwFlags);
            }
            return (int)mh$.invokeExact(pCertContext, pCtlEntry, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCRLFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetCRLFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CertGetCRLFromStore$descriptor() {
        return CertGetCRLFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CertGetCRLFromStore$handle() {
        return CertGetCRLFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertGetCRLFromStore$address() {
        return CertGetCRLFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertGetCRLFromStore(MemorySegment hCertStore, MemorySegment pIssuerContext, MemorySegment pPrevCrlContext, MemorySegment pdwFlags) {
        var mh$ = CertGetCRLFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCRLFromStore", hCertStore, pIssuerContext, pPrevCrlContext, pdwFlags);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pIssuerContext, pPrevCrlContext, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCRLsInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertEnumCRLsInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static FunctionDescriptor CertEnumCRLsInStore$descriptor() {
        return CertEnumCRLsInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MethodHandle CertEnumCRLsInStore$handle() {
        return CertEnumCRLsInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MemorySegment CertEnumCRLsInStore$address() {
        return CertEnumCRLsInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MemorySegment CertEnumCRLsInStore(MemorySegment hCertStore, MemorySegment pPrevCrlContext) {
        var mh$ = CertEnumCRLsInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCRLsInStore", hCertStore, pPrevCrlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pPrevCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindCRLInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFindCRLInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertFindCRLInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static FunctionDescriptor CertFindCRLInStore$descriptor() {
        return CertFindCRLInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertFindCRLInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MethodHandle CertFindCRLInStore$handle() {
        return CertFindCRLInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertFindCRLInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MemorySegment CertFindCRLInStore$address() {
        return CertFindCRLInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertFindCRLInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MemorySegment CertFindCRLInStore(MemorySegment hCertStore, int dwCertEncodingType, int dwFindFlags, int dwFindType, MemorySegment pvFindPara, MemorySegment pPrevCrlContext) {
        var mh$ = CertFindCRLInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCRLInStore", hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCrlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_FIND_ISSUED_FOR_PARA {
     *     PCCERT_CONTEXT pSubjectCert;
     *     PCCERT_CONTEXT pIssuerCert;
     * } *PCRL_FIND_ISSUED_FOR_PARA
     * }
     */
    public static final AddressLayout PCRL_FIND_ISSUED_FOR_PARA = wgl_h.C_POINTER;

    private static class CertDuplicateCRLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertDuplicateCRLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static FunctionDescriptor CertDuplicateCRLContext$descriptor() {
        return CertDuplicateCRLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MethodHandle CertDuplicateCRLContext$handle() {
        return CertDuplicateCRLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MemorySegment CertDuplicateCRLContext$address() {
        return CertDuplicateCRLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MemorySegment CertDuplicateCRLContext(MemorySegment pCrlContext) {
        var mh$ = CertDuplicateCRLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateCRLContext", pCrlContext);
            }
            return (MemorySegment)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCRLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCreateCRLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded)
     * }
     */
    public static FunctionDescriptor CertCreateCRLContext$descriptor() {
        return CertCreateCRLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded)
     * }
     */
    public static MethodHandle CertCreateCRLContext$handle() {
        return CertCreateCRLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded)
     * }
     */
    public static MemorySegment CertCreateCRLContext$address() {
        return CertCreateCRLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded)
     * }
     */
    public static MemorySegment CertCreateCRLContext(int dwCertEncodingType, MemorySegment pbCrlEncoded, int cbCrlEncoded) {
        var mh$ = CertCreateCRLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCRLContext", dwCertEncodingType, pbCrlEncoded, cbCrlEncoded);
            }
            return (MemorySegment)mh$.invokeExact(dwCertEncodingType, pbCrlEncoded, cbCrlEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCRLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFreeCRLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFreeCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static FunctionDescriptor CertFreeCRLContext$descriptor() {
        return CertFreeCRLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFreeCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MethodHandle CertFreeCRLContext$handle() {
        return CertFreeCRLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertFreeCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MemorySegment CertFreeCRLContext$address() {
        return CertFreeCRLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertFreeCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static int CertFreeCRLContext(MemorySegment pCrlContext) {
        var mh$ = CertFreeCRLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCRLContext", pCrlContext);
            }
            return (int)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCRLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertSetCRLContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetCRLContextProperty$descriptor() {
        return CertSetCRLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetCRLContextProperty$handle() {
        return CertSetCRLContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MemorySegment CertSetCRLContextProperty$address() {
        return CertSetCRLContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetCRLContextProperty(MemorySegment pCrlContext, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetCRLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCRLContextProperty", pCrlContext, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(pCrlContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCRLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetCRLContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetCRLContextProperty$descriptor() {
        return CertGetCRLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetCRLContextProperty$handle() {
        return CertGetCRLContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CertGetCRLContextProperty$address() {
        return CertGetCRLContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetCRLContextProperty(MemorySegment pCrlContext, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetCRLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCRLContextProperty", pCrlContext, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(pCrlContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCRLContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertEnumCRLContextProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId)
     * }
     */
    public static FunctionDescriptor CertEnumCRLContextProperties$descriptor() {
        return CertEnumCRLContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId)
     * }
     */
    public static MethodHandle CertEnumCRLContextProperties$handle() {
        return CertEnumCRLContextProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId)
     * }
     */
    public static MemorySegment CertEnumCRLContextProperties$address() {
        return CertEnumCRLContextProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId)
     * }
     */
    public static int CertEnumCRLContextProperties(MemorySegment pCrlContext, int dwPropId) {
        var mh$ = CertEnumCRLContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCRLContextProperties", pCrlContext, dwPropId);
            }
            return (int)mh$.invokeExact(pCrlContext, dwPropId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindCertificateInCRL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFindCertificateInCRL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void *pvReserved, PCRL_ENTRY *ppCrlEntry)
     * }
     */
    public static FunctionDescriptor CertFindCertificateInCRL$descriptor() {
        return CertFindCertificateInCRL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void *pvReserved, PCRL_ENTRY *ppCrlEntry)
     * }
     */
    public static MethodHandle CertFindCertificateInCRL$handle() {
        return CertFindCertificateInCRL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void *pvReserved, PCRL_ENTRY *ppCrlEntry)
     * }
     */
    public static MemorySegment CertFindCertificateInCRL$address() {
        return CertFindCertificateInCRL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void *pvReserved, PCRL_ENTRY *ppCrlEntry)
     * }
     */
    public static int CertFindCertificateInCRL(MemorySegment pCert, MemorySegment pCrlContext, int dwFlags, MemorySegment pvReserved, MemorySegment ppCrlEntry) {
        var mh$ = CertFindCertificateInCRL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCertificateInCRL", pCert, pCrlContext, dwFlags, pvReserved, ppCrlEntry);
            }
            return (int)mh$.invokeExact(pCert, pCrlContext, dwFlags, pvReserved, ppCrlEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertIsValidCRLForCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertIsValidCRLForCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CertIsValidCRLForCertificate$descriptor() {
        return CertIsValidCRLForCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CertIsValidCRLForCertificate$handle() {
        return CertIsValidCRLForCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MemorySegment CertIsValidCRLForCertificate$address() {
        return CertIsValidCRLForCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CertIsValidCRLForCertificate(MemorySegment pCert, MemorySegment pCrl, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CertIsValidCRLForCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertIsValidCRLForCertificate", pCert, pCrl, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pCert, pCrl, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCertificateToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddEncodedCertificateToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCertificateToStore$descriptor() {
        return CertAddEncodedCertificateToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext)
     * }
     */
    public static MethodHandle CertAddEncodedCertificateToStore$handle() {
        return CertAddEncodedCertificateToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext)
     * }
     */
    public static MemorySegment CertAddEncodedCertificateToStore$address() {
        return CertAddEncodedCertificateToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext)
     * }
     */
    public static int CertAddEncodedCertificateToStore(MemorySegment hCertStore, int dwCertEncodingType, MemorySegment pbCertEncoded, int cbCertEncoded, int dwAddDisposition, MemorySegment ppCertContext) {
        var mh$ = CertAddEncodedCertificateToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCertificateToStore", hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext);
            }
            return (int)mh$.invokeExact(hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCertificateContextToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddCertificateContextToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateContextToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCertificateContextToStore$descriptor() {
        return CertAddCertificateContextToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateContextToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCertificateContextToStore$handle() {
        return CertAddCertificateContextToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateContextToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCertificateContextToStore$address() {
        return CertAddCertificateContextToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCertificateContextToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCertificateContextToStore(MemorySegment hCertStore, MemorySegment pCertContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCertificateContextToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCertificateContextToStore", hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddSerializedElementToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddSerializedElementToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddSerializedElementToStore(HCERTSTORE hCertStore, const BYTE *pbElement, DWORD cbElement, DWORD dwAddDisposition, DWORD dwFlags, DWORD dwContextTypeFlags, DWORD *pdwContextType, const void **ppvContext)
     * }
     */
    public static FunctionDescriptor CertAddSerializedElementToStore$descriptor() {
        return CertAddSerializedElementToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddSerializedElementToStore(HCERTSTORE hCertStore, const BYTE *pbElement, DWORD cbElement, DWORD dwAddDisposition, DWORD dwFlags, DWORD dwContextTypeFlags, DWORD *pdwContextType, const void **ppvContext)
     * }
     */
    public static MethodHandle CertAddSerializedElementToStore$handle() {
        return CertAddSerializedElementToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddSerializedElementToStore(HCERTSTORE hCertStore, const BYTE *pbElement, DWORD cbElement, DWORD dwAddDisposition, DWORD dwFlags, DWORD dwContextTypeFlags, DWORD *pdwContextType, const void **ppvContext)
     * }
     */
    public static MemorySegment CertAddSerializedElementToStore$address() {
        return CertAddSerializedElementToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddSerializedElementToStore(HCERTSTORE hCertStore, const BYTE *pbElement, DWORD cbElement, DWORD dwAddDisposition, DWORD dwFlags, DWORD dwContextTypeFlags, DWORD *pdwContextType, const void **ppvContext)
     * }
     */
    public static int CertAddSerializedElementToStore(MemorySegment hCertStore, MemorySegment pbElement, int cbElement, int dwAddDisposition, int dwFlags, int dwContextTypeFlags, MemorySegment pdwContextType, MemorySegment ppvContext) {
        var mh$ = CertAddSerializedElementToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddSerializedElementToStore", hCertStore, pbElement, cbElement, dwAddDisposition, dwFlags, dwContextTypeFlags, pdwContextType, ppvContext);
            }
            return (int)mh$.invokeExact(hCertStore, pbElement, cbElement, dwAddDisposition, dwFlags, dwContextTypeFlags, pdwContextType, ppvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDeleteCertificateFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertDeleteCertificateFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static FunctionDescriptor CertDeleteCertificateFromStore$descriptor() {
        return CertDeleteCertificateFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MethodHandle CertDeleteCertificateFromStore$handle() {
        return CertDeleteCertificateFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MemorySegment CertDeleteCertificateFromStore$address() {
        return CertDeleteCertificateFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static int CertDeleteCertificateFromStore(MemorySegment pCertContext) {
        var mh$ = CertDeleteCertificateFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDeleteCertificateFromStore", pCertContext);
            }
            return (int)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCRLToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddEncodedCRLToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCRLToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCRLToStore$descriptor() {
        return CertAddEncodedCRLToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCRLToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext)
     * }
     */
    public static MethodHandle CertAddEncodedCRLToStore$handle() {
        return CertAddEncodedCRLToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCRLToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext)
     * }
     */
    public static MemorySegment CertAddEncodedCRLToStore$address() {
        return CertAddEncodedCRLToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCRLToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext)
     * }
     */
    public static int CertAddEncodedCRLToStore(MemorySegment hCertStore, int dwCertEncodingType, MemorySegment pbCrlEncoded, int cbCrlEncoded, int dwAddDisposition, MemorySegment ppCrlContext) {
        var mh$ = CertAddEncodedCRLToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCRLToStore", hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext);
            }
            return (int)mh$.invokeExact(hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCRLContextToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddCRLContextToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCRLContextToStore$descriptor() {
        return CertAddCRLContextToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCRLContextToStore$handle() {
        return CertAddCRLContextToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCRLContextToStore$address() {
        return CertAddCRLContextToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCRLContextToStore(MemorySegment hCertStore, MemorySegment pCrlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCRLContextToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCRLContextToStore", hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDeleteCRLFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertDeleteCRLFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static FunctionDescriptor CertDeleteCRLFromStore$descriptor() {
        return CertDeleteCRLFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MethodHandle CertDeleteCRLFromStore$handle() {
        return CertDeleteCRLFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MemorySegment CertDeleteCRLFromStore$address() {
        return CertDeleteCRLFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static int CertDeleteCRLFromStore(MemorySegment pCrlContext) {
        var mh$ = CertDeleteCRLFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDeleteCRLFromStore", pCrlContext);
            }
            return (int)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSerializeCertificateStoreElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertSerializeCertificateStoreElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static FunctionDescriptor CertSerializeCertificateStoreElement$descriptor() {
        return CertSerializeCertificateStoreElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MethodHandle CertSerializeCertificateStoreElement$handle() {
        return CertSerializeCertificateStoreElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MemorySegment CertSerializeCertificateStoreElement$address() {
        return CertSerializeCertificateStoreElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static int CertSerializeCertificateStoreElement(MemorySegment pCertContext, int dwFlags, MemorySegment pbElement, MemorySegment pcbElement) {
        var mh$ = CertSerializeCertificateStoreElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSerializeCertificateStoreElement", pCertContext, dwFlags, pbElement, pcbElement);
            }
            return (int)mh$.invokeExact(pCertContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSerializeCRLStoreElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertSerializeCRLStoreElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static FunctionDescriptor CertSerializeCRLStoreElement$descriptor() {
        return CertSerializeCRLStoreElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MethodHandle CertSerializeCRLStoreElement$handle() {
        return CertSerializeCRLStoreElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MemorySegment CertSerializeCRLStoreElement$address() {
        return CertSerializeCRLStoreElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static int CertSerializeCRLStoreElement(MemorySegment pCrlContext, int dwFlags, MemorySegment pbElement, MemorySegment pcbElement) {
        var mh$ = CertSerializeCRLStoreElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSerializeCRLStoreElement", pCrlContext, dwFlags, pbElement, pcbElement);
            }
            return (int)mh$.invokeExact(pCrlContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDuplicateCTLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertDuplicateCTLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static FunctionDescriptor CertDuplicateCTLContext$descriptor() {
        return CertDuplicateCTLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MethodHandle CertDuplicateCTLContext$handle() {
        return CertDuplicateCTLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MemorySegment CertDuplicateCTLContext$address() {
        return CertDuplicateCTLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MemorySegment CertDuplicateCTLContext(MemorySegment pCtlContext) {
        var mh$ = CertDuplicateCTLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateCTLContext", pCtlContext);
            }
            return (MemorySegment)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCTLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCreateCTLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded)
     * }
     */
    public static FunctionDescriptor CertCreateCTLContext$descriptor() {
        return CertCreateCTLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded)
     * }
     */
    public static MethodHandle CertCreateCTLContext$handle() {
        return CertCreateCTLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded)
     * }
     */
    public static MemorySegment CertCreateCTLContext$address() {
        return CertCreateCTLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded)
     * }
     */
    public static MemorySegment CertCreateCTLContext(int dwMsgAndCertEncodingType, MemorySegment pbCtlEncoded, int cbCtlEncoded) {
        var mh$ = CertCreateCTLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCTLContext", dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCTLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFreeCTLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFreeCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static FunctionDescriptor CertFreeCTLContext$descriptor() {
        return CertFreeCTLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFreeCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MethodHandle CertFreeCTLContext$handle() {
        return CertFreeCTLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertFreeCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MemorySegment CertFreeCTLContext$address() {
        return CertFreeCTLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertFreeCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static int CertFreeCTLContext(MemorySegment pCtlContext) {
        var mh$ = CertFreeCTLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCTLContext", pCtlContext);
            }
            return (int)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCTLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertSetCTLContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetCTLContextProperty$descriptor() {
        return CertSetCTLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetCTLContextProperty$handle() {
        return CertSetCTLContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MemorySegment CertSetCTLContextProperty$address() {
        return CertSetCTLContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetCTLContextProperty(MemorySegment pCtlContext, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetCTLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCTLContextProperty", pCtlContext, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(pCtlContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCTLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetCTLContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetCTLContextProperty$descriptor() {
        return CertGetCTLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetCTLContextProperty$handle() {
        return CertGetCTLContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CertGetCTLContextProperty$address() {
        return CertGetCTLContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetCTLContextProperty(MemorySegment pCtlContext, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetCTLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCTLContextProperty", pCtlContext, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(pCtlContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCTLContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertEnumCTLContextProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId)
     * }
     */
    public static FunctionDescriptor CertEnumCTLContextProperties$descriptor() {
        return CertEnumCTLContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId)
     * }
     */
    public static MethodHandle CertEnumCTLContextProperties$handle() {
        return CertEnumCTLContextProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId)
     * }
     */
    public static MemorySegment CertEnumCTLContextProperties$address() {
        return CertEnumCTLContextProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId)
     * }
     */
    public static int CertEnumCTLContextProperties(MemorySegment pCtlContext, int dwPropId) {
        var mh$ = CertEnumCTLContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCTLContextProperties", pCtlContext, dwPropId);
            }
            return (int)mh$.invokeExact(pCtlContext, dwPropId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCTLsInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertEnumCTLsInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static FunctionDescriptor CertEnumCTLsInStore$descriptor() {
        return CertEnumCTLsInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MethodHandle CertEnumCTLsInStore$handle() {
        return CertEnumCTLsInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MemorySegment CertEnumCTLsInStore$address() {
        return CertEnumCTLsInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MemorySegment CertEnumCTLsInStore(MemorySegment hCertStore, MemorySegment pPrevCtlContext) {
        var mh$ = CertEnumCTLsInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCTLsInStore", hCertStore, pPrevCtlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pPrevCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindSubjectInCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFindSubjectInCTL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCTL_ENTRY CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertFindSubjectInCTL$descriptor() {
        return CertFindSubjectInCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCTL_ENTRY CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertFindSubjectInCTL$handle() {
        return CertFindSubjectInCTL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCTL_ENTRY CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertFindSubjectInCTL$address() {
        return CertFindSubjectInCTL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCTL_ENTRY CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertFindSubjectInCTL(int dwEncodingType, int dwSubjectType, MemorySegment pvSubject, MemorySegment pCtlContext, int dwFlags) {
        var mh$ = CertFindSubjectInCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindSubjectInCTL", dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_ANY_SUBJECT_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER SubjectAlgorithm;
     *     CRYPT_DATA_BLOB SubjectIdentifier;
     * } *PCTL_ANY_SUBJECT_INFO
     * }
     */
    public static final AddressLayout PCTL_ANY_SUBJECT_INFO = wgl_h.C_POINTER;

    private static class CertFindCTLInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFindCTLInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertFindCTLInStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static FunctionDescriptor CertFindCTLInStore$descriptor() {
        return CertFindCTLInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertFindCTLInStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MethodHandle CertFindCTLInStore$handle() {
        return CertFindCTLInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertFindCTLInStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MemorySegment CertFindCTLInStore$address() {
        return CertFindCTLInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertFindCTLInStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MemorySegment CertFindCTLInStore(MemorySegment hCertStore, int dwMsgAndCertEncodingType, int dwFindFlags, int dwFindType, MemorySegment pvFindPara, MemorySegment pPrevCtlContext) {
        var mh$ = CertFindCTLInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCTLInStore", hCertStore, dwMsgAndCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCtlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwMsgAndCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_FIND_USAGE_PARA {
     *     DWORD cbSize;
     *     CTL_USAGE SubjectUsage;
     *     CRYPT_DATA_BLOB ListIdentifier;
     *     PCERT_INFO pSigner;
     * } *PCTL_FIND_USAGE_PARA
     * }
     */
    public static final AddressLayout PCTL_FIND_USAGE_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_FIND_SUBJECT_PARA {
     *     DWORD cbSize;
     *     PCTL_FIND_USAGE_PARA pUsagePara;
     *     DWORD dwSubjectType;
     *     void *pvSubject;
     * } *PCTL_FIND_SUBJECT_PARA
     * }
     */
    public static final AddressLayout PCTL_FIND_SUBJECT_PARA = wgl_h.C_POINTER;

    private static class CertAddEncodedCTLToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddEncodedCTLToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCTLToStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCTLToStore$descriptor() {
        return CertAddEncodedCTLToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCTLToStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
     * }
     */
    public static MethodHandle CertAddEncodedCTLToStore$handle() {
        return CertAddEncodedCTLToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCTLToStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
     * }
     */
    public static MemorySegment CertAddEncodedCTLToStore$address() {
        return CertAddEncodedCTLToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCTLToStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
     * }
     */
    public static int CertAddEncodedCTLToStore(MemorySegment hCertStore, int dwMsgAndCertEncodingType, MemorySegment pbCtlEncoded, int cbCtlEncoded, int dwAddDisposition, MemorySegment ppCtlContext) {
        var mh$ = CertAddEncodedCTLToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCTLToStore", hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded, dwAddDisposition, ppCtlContext);
            }
            return (int)mh$.invokeExact(hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded, dwAddDisposition, ppCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCTLContextToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddCTLContextToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCTLContextToStore$descriptor() {
        return CertAddCTLContextToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCTLContextToStore$handle() {
        return CertAddCTLContextToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCTLContextToStore$address() {
        return CertAddCTLContextToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCTLContextToStore(MemorySegment hCertStore, MemorySegment pCtlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCTLContextToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCTLContextToStore", hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSerializeCTLStoreElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertSerializeCTLStoreElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static FunctionDescriptor CertSerializeCTLStoreElement$descriptor() {
        return CertSerializeCTLStoreElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MethodHandle CertSerializeCTLStoreElement$handle() {
        return CertSerializeCTLStoreElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MemorySegment CertSerializeCTLStoreElement$address() {
        return CertSerializeCTLStoreElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static int CertSerializeCTLStoreElement(MemorySegment pCtlContext, int dwFlags, MemorySegment pbElement, MemorySegment pcbElement) {
        var mh$ = CertSerializeCTLStoreElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSerializeCTLStoreElement", pCtlContext, dwFlags, pbElement, pcbElement);
            }
            return (int)mh$.invokeExact(pCtlContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDeleteCTLFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertDeleteCTLFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static FunctionDescriptor CertDeleteCTLFromStore$descriptor() {
        return CertDeleteCTLFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MethodHandle CertDeleteCTLFromStore$handle() {
        return CertDeleteCTLFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MemorySegment CertDeleteCTLFromStore$address() {
        return CertDeleteCTLFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static int CertDeleteCTLFromStore(MemorySegment pCtlContext) {
        var mh$ = CertDeleteCTLFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDeleteCTLFromStore", pCtlContext);
            }
            return (int)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCertificateLinkToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddCertificateLinkToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateLinkToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCertificateLinkToStore$descriptor() {
        return CertAddCertificateLinkToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateLinkToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCertificateLinkToStore$handle() {
        return CertAddCertificateLinkToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateLinkToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCertificateLinkToStore$address() {
        return CertAddCertificateLinkToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCertificateLinkToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCertificateLinkToStore(MemorySegment hCertStore, MemorySegment pCertContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCertificateLinkToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCertificateLinkToStore", hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCRLLinkToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddCRLLinkToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCRLLinkToStore$descriptor() {
        return CertAddCRLLinkToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCRLLinkToStore$handle() {
        return CertAddCRLLinkToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCRLLinkToStore$address() {
        return CertAddCRLLinkToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCRLLinkToStore(MemorySegment hCertStore, MemorySegment pCrlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCRLLinkToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCRLLinkToStore", hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCTLLinkToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddCTLLinkToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCTLLinkToStore$descriptor() {
        return CertAddCTLLinkToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCTLLinkToStore$handle() {
        return CertAddCTLLinkToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCTLLinkToStore$address() {
        return CertAddCTLLinkToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCTLLinkToStore(MemorySegment hCertStore, MemorySegment pCtlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCTLLinkToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCTLLinkToStore", hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddStoreToCollection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddStoreToCollection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
     * }
     */
    public static FunctionDescriptor CertAddStoreToCollection$descriptor() {
        return CertAddStoreToCollection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
     * }
     */
    public static MethodHandle CertAddStoreToCollection$handle() {
        return CertAddStoreToCollection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
     * }
     */
    public static MemorySegment CertAddStoreToCollection$address() {
        return CertAddStoreToCollection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
     * }
     */
    public static int CertAddStoreToCollection(MemorySegment hCollectionStore, MemorySegment hSiblingStore, int dwUpdateFlags, int dwPriority) {
        var mh$ = CertAddStoreToCollection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddStoreToCollection", hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority);
            }
            return (int)mh$.invokeExact(hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRemoveStoreFromCollection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertRemoveStoreFromCollection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore)
     * }
     */
    public static FunctionDescriptor CertRemoveStoreFromCollection$descriptor() {
        return CertRemoveStoreFromCollection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore)
     * }
     */
    public static MethodHandle CertRemoveStoreFromCollection$handle() {
        return CertRemoveStoreFromCollection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore)
     * }
     */
    public static MemorySegment CertRemoveStoreFromCollection$address() {
        return CertRemoveStoreFromCollection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore)
     * }
     */
    public static void CertRemoveStoreFromCollection(MemorySegment hCollectionStore, MemorySegment hSiblingStore) {
        var mh$ = CertRemoveStoreFromCollection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRemoveStoreFromCollection", hCollectionStore, hSiblingStore);
            }
            mh$.invokeExact(hCollectionStore, hSiblingStore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertControlStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertControlStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static FunctionDescriptor CertControlStore$descriptor() {
        return CertControlStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static MethodHandle CertControlStore$handle() {
        return CertControlStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static MemorySegment CertControlStore$address() {
        return CertControlStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static int CertControlStore(MemorySegment hCertStore, int dwFlags, int dwCtrlType, MemorySegment pvCtrlPara) {
        var mh$ = CertControlStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertControlStore", hCertStore, dwFlags, dwCtrlType, pvCtrlPara);
            }
            return (int)mh$.invokeExact(hCertStore, dwFlags, dwCtrlType, pvCtrlPara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetStoreProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertSetStoreProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetStoreProperty$descriptor() {
        return CertSetStoreProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetStoreProperty$handle() {
        return CertSetStoreProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MemorySegment CertSetStoreProperty$address() {
        return CertSetStoreProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetStoreProperty(MemorySegment hCertStore, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetStoreProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetStoreProperty", hCertStore, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(hCertStore, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetStoreProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetStoreProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetStoreProperty$descriptor() {
        return CertGetStoreProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetStoreProperty$handle() {
        return CertGetStoreProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CertGetStoreProperty$address() {
        return CertGetStoreProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetStoreProperty(MemorySegment hCertStore, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetStoreProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetStoreProperty", hCertStore, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(hCertStore, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CREATE_CONTEXT_PARA {
     *     DWORD cbSize;
     *     PFN_CRYPT_FREE pfnFree;
     *     void *pvFree;
     *     PFN_CERT_CREATE_CONTEXT_SORT_FUNC pfnSort;
     *     void *pvSort;
     * } *PCERT_CREATE_CONTEXT_PARA
     * }
     */
    public static final AddressLayout PCERT_CREATE_CONTEXT_PARA = wgl_h.C_POINTER;

    private static class CertCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCreateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const void *CertCreateContext(DWORD dwContextType, DWORD dwEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCERT_CREATE_CONTEXT_PARA pCreatePara)
     * }
     */
    public static FunctionDescriptor CertCreateContext$descriptor() {
        return CertCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const void *CertCreateContext(DWORD dwContextType, DWORD dwEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCERT_CREATE_CONTEXT_PARA pCreatePara)
     * }
     */
    public static MethodHandle CertCreateContext$handle() {
        return CertCreateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const void *CertCreateContext(DWORD dwContextType, DWORD dwEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCERT_CREATE_CONTEXT_PARA pCreatePara)
     * }
     */
    public static MemorySegment CertCreateContext$address() {
        return CertCreateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const void *CertCreateContext(DWORD dwContextType, DWORD dwEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCERT_CREATE_CONTEXT_PARA pCreatePara)
     * }
     */
    public static MemorySegment CertCreateContext(int dwContextType, int dwEncodingType, MemorySegment pbEncoded, int cbEncoded, int dwFlags, MemorySegment pCreatePara) {
        var mh$ = CertCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateContext", dwContextType, dwEncodingType, pbEncoded, cbEncoded, dwFlags, pCreatePara);
            }
            return (MemorySegment)mh$.invokeExact(dwContextType, dwEncodingType, pbEncoded, cbEncoded, dwFlags, pCreatePara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SYSTEM_STORE_INFO {
     *     DWORD cbSize;
     * } *PCERT_SYSTEM_STORE_INFO
     * }
     */
    public static final AddressLayout PCERT_SYSTEM_STORE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_PHYSICAL_STORE_INFO {
     *     DWORD cbSize;
     *     LPSTR pszOpenStoreProvider;
     *     DWORD dwOpenEncodingType;
     *     DWORD dwOpenFlags;
     *     CRYPT_DATA_BLOB OpenParameters;
     *     DWORD dwFlags;
     *     DWORD dwPriority;
     * } *PCERT_PHYSICAL_STORE_INFO
     * }
     */
    public static final AddressLayout PCERT_PHYSICAL_STORE_INFO = wgl_h.C_POINTER;

    private static class CertRegisterSystemStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertRegisterSystemStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertRegisterSystemStore(const void *pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CertRegisterSystemStore$descriptor() {
        return CertRegisterSystemStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertRegisterSystemStore(const void *pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static MethodHandle CertRegisterSystemStore$handle() {
        return CertRegisterSystemStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertRegisterSystemStore(const void *pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static MemorySegment CertRegisterSystemStore$address() {
        return CertRegisterSystemStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertRegisterSystemStore(const void *pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static int CertRegisterSystemStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pStoreInfo, MemorySegment pvReserved) {
        var mh$ = CertRegisterSystemStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRegisterSystemStore", pvSystemStore, dwFlags, pStoreInfo, pvReserved);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pStoreInfo, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRegisterPhysicalStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertRegisterPhysicalStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertRegisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CertRegisterPhysicalStore$descriptor() {
        return CertRegisterPhysicalStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertRegisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static MethodHandle CertRegisterPhysicalStore$handle() {
        return CertRegisterPhysicalStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertRegisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static MemorySegment CertRegisterPhysicalStore$address() {
        return CertRegisterPhysicalStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertRegisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static int CertRegisterPhysicalStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pwszStoreName, MemorySegment pStoreInfo, MemorySegment pvReserved) {
        var mh$ = CertRegisterPhysicalStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRegisterPhysicalStore", pvSystemStore, dwFlags, pwszStoreName, pStoreInfo, pvReserved);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pwszStoreName, pStoreInfo, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertUnregisterSystemStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertUnregisterSystemStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertUnregisterSystemStore(const void *pvSystemStore, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertUnregisterSystemStore$descriptor() {
        return CertUnregisterSystemStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertUnregisterSystemStore(const void *pvSystemStore, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertUnregisterSystemStore$handle() {
        return CertUnregisterSystemStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertUnregisterSystemStore(const void *pvSystemStore, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertUnregisterSystemStore$address() {
        return CertUnregisterSystemStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertUnregisterSystemStore(const void *pvSystemStore, DWORD dwFlags)
     * }
     */
    public static int CertUnregisterSystemStore(MemorySegment pvSystemStore, int dwFlags) {
        var mh$ = CertUnregisterSystemStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertUnregisterSystemStore", pvSystemStore, dwFlags);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertUnregisterPhysicalStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertUnregisterPhysicalStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertUnregisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName)
     * }
     */
    public static FunctionDescriptor CertUnregisterPhysicalStore$descriptor() {
        return CertUnregisterPhysicalStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertUnregisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName)
     * }
     */
    public static MethodHandle CertUnregisterPhysicalStore$handle() {
        return CertUnregisterPhysicalStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertUnregisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName)
     * }
     */
    public static MemorySegment CertUnregisterPhysicalStore$address() {
        return CertUnregisterPhysicalStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertUnregisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName)
     * }
     */
    public static int CertUnregisterPhysicalStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pwszStoreName) {
        var mh$ = CertUnregisterPhysicalStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertUnregisterPhysicalStore", pvSystemStore, dwFlags, pwszStoreName);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pwszStoreName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumSystemStoreLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertEnumSystemStoreLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStoreLocation(DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum)
     * }
     */
    public static FunctionDescriptor CertEnumSystemStoreLocation$descriptor() {
        return CertEnumSystemStoreLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStoreLocation(DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum)
     * }
     */
    public static MethodHandle CertEnumSystemStoreLocation$handle() {
        return CertEnumSystemStoreLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStoreLocation(DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum)
     * }
     */
    public static MemorySegment CertEnumSystemStoreLocation$address() {
        return CertEnumSystemStoreLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertEnumSystemStoreLocation(DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum)
     * }
     */
    public static int CertEnumSystemStoreLocation(int dwFlags, MemorySegment pvArg, MemorySegment pfnEnum) {
        var mh$ = CertEnumSystemStoreLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumSystemStoreLocation", dwFlags, pvArg, pfnEnum);
            }
            return (int)mh$.invokeExact(dwFlags, pvArg, pfnEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumSystemStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertEnumSystemStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStore(DWORD dwFlags, void *pvSystemStoreLocationPara, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum)
     * }
     */
    public static FunctionDescriptor CertEnumSystemStore$descriptor() {
        return CertEnumSystemStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStore(DWORD dwFlags, void *pvSystemStoreLocationPara, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum)
     * }
     */
    public static MethodHandle CertEnumSystemStore$handle() {
        return CertEnumSystemStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStore(DWORD dwFlags, void *pvSystemStoreLocationPara, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum)
     * }
     */
    public static MemorySegment CertEnumSystemStore$address() {
        return CertEnumSystemStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertEnumSystemStore(DWORD dwFlags, void *pvSystemStoreLocationPara, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum)
     * }
     */
    public static int CertEnumSystemStore(int dwFlags, MemorySegment pvSystemStoreLocationPara, MemorySegment pvArg, MemorySegment pfnEnum) {
        var mh$ = CertEnumSystemStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumSystemStore", dwFlags, pvSystemStoreLocationPara, pvArg, pfnEnum);
            }
            return (int)mh$.invokeExact(dwFlags, pvSystemStoreLocationPara, pvArg, pfnEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumPhysicalStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertEnumPhysicalStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumPhysicalStore(const void *pvSystemStore, DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum)
     * }
     */
    public static FunctionDescriptor CertEnumPhysicalStore$descriptor() {
        return CertEnumPhysicalStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumPhysicalStore(const void *pvSystemStore, DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum)
     * }
     */
    public static MethodHandle CertEnumPhysicalStore$handle() {
        return CertEnumPhysicalStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertEnumPhysicalStore(const void *pvSystemStore, DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum)
     * }
     */
    public static MemorySegment CertEnumPhysicalStore$address() {
        return CertEnumPhysicalStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertEnumPhysicalStore(const void *pvSystemStore, DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum)
     * }
     */
    public static int CertEnumPhysicalStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pvArg, MemorySegment pfnEnum) {
        var mh$ = CertEnumPhysicalStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumPhysicalStore", pvSystemStore, dwFlags, pvArg, pfnEnum);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pvArg, pfnEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetEnhancedKeyUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetEnhancedKeyUsage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD *pcbUsage)
     * }
     */
    public static FunctionDescriptor CertGetEnhancedKeyUsage$descriptor() {
        return CertGetEnhancedKeyUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD *pcbUsage)
     * }
     */
    public static MethodHandle CertGetEnhancedKeyUsage$handle() {
        return CertGetEnhancedKeyUsage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD *pcbUsage)
     * }
     */
    public static MemorySegment CertGetEnhancedKeyUsage$address() {
        return CertGetEnhancedKeyUsage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD *pcbUsage)
     * }
     */
    public static int CertGetEnhancedKeyUsage(MemorySegment pCertContext, int dwFlags, MemorySegment pUsage, MemorySegment pcbUsage) {
        var mh$ = CertGetEnhancedKeyUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetEnhancedKeyUsage", pCertContext, dwFlags, pUsage, pcbUsage);
            }
            return (int)mh$.invokeExact(pCertContext, dwFlags, pUsage, pcbUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetEnhancedKeyUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertSetEnhancedKeyUsage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage)
     * }
     */
    public static FunctionDescriptor CertSetEnhancedKeyUsage$descriptor() {
        return CertSetEnhancedKeyUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage)
     * }
     */
    public static MethodHandle CertSetEnhancedKeyUsage$handle() {
        return CertSetEnhancedKeyUsage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage)
     * }
     */
    public static MemorySegment CertSetEnhancedKeyUsage$address() {
        return CertSetEnhancedKeyUsage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage)
     * }
     */
    public static int CertSetEnhancedKeyUsage(MemorySegment pCertContext, MemorySegment pUsage) {
        var mh$ = CertSetEnhancedKeyUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetEnhancedKeyUsage", pCertContext, pUsage);
            }
            return (int)mh$.invokeExact(pCertContext, pUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEnhancedKeyUsageIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddEnhancedKeyUsageIdentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static FunctionDescriptor CertAddEnhancedKeyUsageIdentifier$descriptor() {
        return CertAddEnhancedKeyUsageIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static MethodHandle CertAddEnhancedKeyUsageIdentifier$handle() {
        return CertAddEnhancedKeyUsageIdentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static MemorySegment CertAddEnhancedKeyUsageIdentifier$address() {
        return CertAddEnhancedKeyUsageIdentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static int CertAddEnhancedKeyUsageIdentifier(MemorySegment pCertContext, MemorySegment pszUsageIdentifier) {
        var mh$ = CertAddEnhancedKeyUsageIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEnhancedKeyUsageIdentifier", pCertContext, pszUsageIdentifier);
            }
            return (int)mh$.invokeExact(pCertContext, pszUsageIdentifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRemoveEnhancedKeyUsageIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertRemoveEnhancedKeyUsageIdentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static FunctionDescriptor CertRemoveEnhancedKeyUsageIdentifier$descriptor() {
        return CertRemoveEnhancedKeyUsageIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static MethodHandle CertRemoveEnhancedKeyUsageIdentifier$handle() {
        return CertRemoveEnhancedKeyUsageIdentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static MemorySegment CertRemoveEnhancedKeyUsageIdentifier$address() {
        return CertRemoveEnhancedKeyUsageIdentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static int CertRemoveEnhancedKeyUsageIdentifier(MemorySegment pCertContext, MemorySegment pszUsageIdentifier) {
        var mh$ = CertRemoveEnhancedKeyUsageIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRemoveEnhancedKeyUsageIdentifier", pCertContext, pszUsageIdentifier);
            }
            return (int)mh$.invokeExact(pCertContext, pszUsageIdentifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetValidUsages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetValidUsages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT *rghCerts, int *cNumOIDs, LPSTR *rghOIDs, DWORD *pcbOIDs)
     * }
     */
    public static FunctionDescriptor CertGetValidUsages$descriptor() {
        return CertGetValidUsages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT *rghCerts, int *cNumOIDs, LPSTR *rghOIDs, DWORD *pcbOIDs)
     * }
     */
    public static MethodHandle CertGetValidUsages$handle() {
        return CertGetValidUsages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT *rghCerts, int *cNumOIDs, LPSTR *rghOIDs, DWORD *pcbOIDs)
     * }
     */
    public static MemorySegment CertGetValidUsages$address() {
        return CertGetValidUsages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT *rghCerts, int *cNumOIDs, LPSTR *rghOIDs, DWORD *pcbOIDs)
     * }
     */
    public static int CertGetValidUsages(int cCerts, MemorySegment rghCerts, MemorySegment cNumOIDs, MemorySegment rghOIDs, MemorySegment pcbOIDs) {
        var mh$ = CertGetValidUsages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetValidUsages", cCerts, rghCerts, cNumOIDs, rghOIDs, pcbOIDs);
            }
            return (int)mh$.invokeExact(cCerts, rghCerts, cNumOIDs, rghOIDs, pcbOIDs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgGetAndVerifySigner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgGetAndVerifySigner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetAndVerifySigner(HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE *rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT *ppSigner, DWORD *pdwSignerIndex)
     * }
     */
    public static FunctionDescriptor CryptMsgGetAndVerifySigner$descriptor() {
        return CryptMsgGetAndVerifySigner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetAndVerifySigner(HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE *rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT *ppSigner, DWORD *pdwSignerIndex)
     * }
     */
    public static MethodHandle CryptMsgGetAndVerifySigner$handle() {
        return CryptMsgGetAndVerifySigner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetAndVerifySigner(HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE *rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT *ppSigner, DWORD *pdwSignerIndex)
     * }
     */
    public static MemorySegment CryptMsgGetAndVerifySigner$address() {
        return CryptMsgGetAndVerifySigner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgGetAndVerifySigner(HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE *rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT *ppSigner, DWORD *pdwSignerIndex)
     * }
     */
    public static int CryptMsgGetAndVerifySigner(MemorySegment hCryptMsg, int cSignerStore, MemorySegment rghSignerStore, int dwFlags, MemorySegment ppSigner, MemorySegment pdwSignerIndex) {
        var mh$ = CryptMsgGetAndVerifySigner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgGetAndVerifySigner", hCryptMsg, cSignerStore, rghSignerStore, dwFlags, ppSigner, pdwSignerIndex);
            }
            return (int)mh$.invokeExact(hCryptMsg, cSignerStore, rghSignerStore, dwFlags, ppSigner, pdwSignerIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgSignCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgSignCTL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgSignCTL(DWORD dwMsgEncodingType, BYTE *pbCtlContent, DWORD cbCtlContent, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptMsgSignCTL$descriptor() {
        return CryptMsgSignCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgSignCTL(DWORD dwMsgEncodingType, BYTE *pbCtlContent, DWORD cbCtlContent, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptMsgSignCTL$handle() {
        return CryptMsgSignCTL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgSignCTL(DWORD dwMsgEncodingType, BYTE *pbCtlContent, DWORD cbCtlContent, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MemorySegment CryptMsgSignCTL$address() {
        return CryptMsgSignCTL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgSignCTL(DWORD dwMsgEncodingType, BYTE *pbCtlContent, DWORD cbCtlContent, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptMsgSignCTL(int dwMsgEncodingType, MemorySegment pbCtlContent, int cbCtlContent, MemorySegment pSignInfo, int dwFlags, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptMsgSignCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgSignCTL", dwMsgEncodingType, pbCtlContent, cbCtlContent, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, pbCtlContent, cbCtlContent, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgEncodeAndSignCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMsgEncodeAndSignCTL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgEncodeAndSignCTL(DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptMsgEncodeAndSignCTL$descriptor() {
        return CryptMsgEncodeAndSignCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgEncodeAndSignCTL(DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptMsgEncodeAndSignCTL$handle() {
        return CryptMsgEncodeAndSignCTL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgEncodeAndSignCTL(DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MemorySegment CryptMsgEncodeAndSignCTL$address() {
        return CryptMsgEncodeAndSignCTL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgEncodeAndSignCTL(DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptMsgEncodeAndSignCTL(int dwMsgEncodingType, MemorySegment pCtlInfo, MemorySegment pSignInfo, int dwFlags, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptMsgEncodeAndSignCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgEncodeAndSignCTL", dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindSubjectInSortedCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFindSubjectInSortedCTL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier, PCCTL_CONTEXT pCtlContext, DWORD dwFlags, void *pvReserved, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static FunctionDescriptor CertFindSubjectInSortedCTL$descriptor() {
        return CertFindSubjectInSortedCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier, PCCTL_CONTEXT pCtlContext, DWORD dwFlags, void *pvReserved, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static MethodHandle CertFindSubjectInSortedCTL$handle() {
        return CertFindSubjectInSortedCTL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier, PCCTL_CONTEXT pCtlContext, DWORD dwFlags, void *pvReserved, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static MemorySegment CertFindSubjectInSortedCTL$address() {
        return CertFindSubjectInSortedCTL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier, PCCTL_CONTEXT pCtlContext, DWORD dwFlags, void *pvReserved, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static int CertFindSubjectInSortedCTL(MemorySegment pSubjectIdentifier, MemorySegment pCtlContext, int dwFlags, MemorySegment pvReserved, MemorySegment pEncodedAttributes) {
        var mh$ = CertFindSubjectInSortedCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindSubjectInSortedCTL", pSubjectIdentifier, pCtlContext, dwFlags, pvReserved, pEncodedAttributes);
            }
            return (int)mh$.invokeExact(pSubjectIdentifier, pCtlContext, dwFlags, pvReserved, pEncodedAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumSubjectInSortedCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertEnumSubjectInSortedCTL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext, void **ppvNextSubject, PCRYPT_DER_BLOB pSubjectIdentifier, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static FunctionDescriptor CertEnumSubjectInSortedCTL$descriptor() {
        return CertEnumSubjectInSortedCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext, void **ppvNextSubject, PCRYPT_DER_BLOB pSubjectIdentifier, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static MethodHandle CertEnumSubjectInSortedCTL$handle() {
        return CertEnumSubjectInSortedCTL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext, void **ppvNextSubject, PCRYPT_DER_BLOB pSubjectIdentifier, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static MemorySegment CertEnumSubjectInSortedCTL$address() {
        return CertEnumSubjectInSortedCTL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext, void **ppvNextSubject, PCRYPT_DER_BLOB pSubjectIdentifier, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static int CertEnumSubjectInSortedCTL(MemorySegment pCtlContext, MemorySegment ppvNextSubject, MemorySegment pSubjectIdentifier, MemorySegment pEncodedAttributes) {
        var mh$ = CertEnumSubjectInSortedCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumSubjectInSortedCTL", pCtlContext, ppvNextSubject, pSubjectIdentifier, pEncodedAttributes);
            }
            return (int)mh$.invokeExact(pCtlContext, ppvNextSubject, pSubjectIdentifier, pEncodedAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_VERIFY_USAGE_PARA {
     *     DWORD cbSize;
     *     CRYPT_DATA_BLOB ListIdentifier;
     *     DWORD cCtlStore;
     *     HCERTSTORE *rghCtlStore;
     *     DWORD cSignerStore;
     *     HCERTSTORE *rghSignerStore;
     * } *PCTL_VERIFY_USAGE_PARA
     * }
     */
    public static final AddressLayout PCTL_VERIFY_USAGE_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_VERIFY_USAGE_STATUS {
     *     DWORD cbSize;
     *     DWORD dwError;
     *     DWORD dwFlags;
     *     PCCTL_CONTEXT *ppCtl;
     *     DWORD dwCtlEntryIndex;
     *     PCCERT_CONTEXT *ppSigner;
     *     DWORD dwSignerIndex;
     * } *PCTL_VERIFY_USAGE_STATUS
     * }
     */
    public static final AddressLayout PCTL_VERIFY_USAGE_STATUS = wgl_h.C_POINTER;

    private static class CertVerifyCTLUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertVerifyCTLUsage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyCTLUsage(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCTL_USAGE pSubjectUsage, DWORD dwFlags, PCTL_VERIFY_USAGE_PARA pVerifyUsagePara, PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus)
     * }
     */
    public static FunctionDescriptor CertVerifyCTLUsage$descriptor() {
        return CertVerifyCTLUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyCTLUsage(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCTL_USAGE pSubjectUsage, DWORD dwFlags, PCTL_VERIFY_USAGE_PARA pVerifyUsagePara, PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus)
     * }
     */
    public static MethodHandle CertVerifyCTLUsage$handle() {
        return CertVerifyCTLUsage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifyCTLUsage(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCTL_USAGE pSubjectUsage, DWORD dwFlags, PCTL_VERIFY_USAGE_PARA pVerifyUsagePara, PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus)
     * }
     */
    public static MemorySegment CertVerifyCTLUsage$address() {
        return CertVerifyCTLUsage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifyCTLUsage(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCTL_USAGE pSubjectUsage, DWORD dwFlags, PCTL_VERIFY_USAGE_PARA pVerifyUsagePara, PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus)
     * }
     */
    public static int CertVerifyCTLUsage(int dwEncodingType, int dwSubjectType, MemorySegment pvSubject, MemorySegment pSubjectUsage, int dwFlags, MemorySegment pVerifyUsagePara, MemorySegment pVerifyUsageStatus) {
        var mh$ = CertVerifyCTLUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyCTLUsage", dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags, pVerifyUsagePara, pVerifyUsageStatus);
            }
            return (int)mh$.invokeExact(dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags, pVerifyUsagePara, pVerifyUsageStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_CRL_INFO {
     *     DWORD cbSize;
     *     PCCRL_CONTEXT pBaseCrlContext;
     *     PCCRL_CONTEXT pDeltaCrlContext;
     *     PCRL_ENTRY pCrlEntry;
     *     BOOL fDeltaCrlEntry;
     * } *PCERT_REVOCATION_CRL_INFO
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_CRL_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_CHAIN_PARA *PCERT_REVOCATION_CHAIN_PARA
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_CHAIN_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_PARA {
     *     DWORD cbSize;
     *     PCCERT_CONTEXT pIssuerCert;
     *     DWORD cCertStore;
     *     HCERTSTORE *rgCertStore;
     *     HCERTSTORE hCrlStore;
     *     LPFILETIME pftTimeToUse;
     * } *PCERT_REVOCATION_PARA
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_STATUS {
     *     DWORD cbSize;
     *     DWORD dwIndex;
     *     DWORD dwError;
     *     DWORD dwReason;
     *     BOOL fHasFreshnessTime;
     *     DWORD dwFreshnessTime;
     * } *PCERT_REVOCATION_STATUS
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_STATUS = wgl_h.C_POINTER;

    private static class CertVerifyRevocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertVerifyRevocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyRevocation(DWORD dwEncodingType, DWORD dwRevType, DWORD cContext, PVOID rgpvContext[], DWORD dwFlags, PCERT_REVOCATION_PARA pRevPara, PCERT_REVOCATION_STATUS pRevStatus)
     * }
     */
    public static FunctionDescriptor CertVerifyRevocation$descriptor() {
        return CertVerifyRevocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyRevocation(DWORD dwEncodingType, DWORD dwRevType, DWORD cContext, PVOID rgpvContext[], DWORD dwFlags, PCERT_REVOCATION_PARA pRevPara, PCERT_REVOCATION_STATUS pRevStatus)
     * }
     */
    public static MethodHandle CertVerifyRevocation$handle() {
        return CertVerifyRevocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifyRevocation(DWORD dwEncodingType, DWORD dwRevType, DWORD cContext, PVOID rgpvContext[], DWORD dwFlags, PCERT_REVOCATION_PARA pRevPara, PCERT_REVOCATION_STATUS pRevStatus)
     * }
     */
    public static MemorySegment CertVerifyRevocation$address() {
        return CertVerifyRevocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifyRevocation(DWORD dwEncodingType, DWORD dwRevType, DWORD cContext, PVOID rgpvContext[], DWORD dwFlags, PCERT_REVOCATION_PARA pRevPara, PCERT_REVOCATION_STATUS pRevStatus)
     * }
     */
    public static int CertVerifyRevocation(int dwEncodingType, int dwRevType, int cContext, MemorySegment rgpvContext, int dwFlags, MemorySegment pRevPara, MemorySegment pRevStatus) {
        var mh$ = CertVerifyRevocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyRevocation", dwEncodingType, dwRevType, cContext, rgpvContext, dwFlags, pRevPara, pRevStatus);
            }
            return (int)mh$.invokeExact(dwEncodingType, dwRevType, cContext, rgpvContext, dwFlags, pRevPara, pRevStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCompareIntegerBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCompareIntegerBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2)
     * }
     */
    public static FunctionDescriptor CertCompareIntegerBlob$descriptor() {
        return CertCompareIntegerBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2)
     * }
     */
    public static MethodHandle CertCompareIntegerBlob$handle() {
        return CertCompareIntegerBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2)
     * }
     */
    public static MemorySegment CertCompareIntegerBlob$address() {
        return CertCompareIntegerBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2)
     * }
     */
    public static int CertCompareIntegerBlob(MemorySegment pInt1, MemorySegment pInt2) {
        var mh$ = CertCompareIntegerBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCompareIntegerBlob", pInt1, pInt2);
            }
            return (int)mh$.invokeExact(pInt1, pInt2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCompareCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCompareCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2)
     * }
     */
    public static FunctionDescriptor CertCompareCertificate$descriptor() {
        return CertCompareCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2)
     * }
     */
    public static MethodHandle CertCompareCertificate$handle() {
        return CertCompareCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2)
     * }
     */
    public static MemorySegment CertCompareCertificate$address() {
        return CertCompareCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2)
     * }
     */
    public static int CertCompareCertificate(int dwCertEncodingType, MemorySegment pCertId1, MemorySegment pCertId2) {
        var mh$ = CertCompareCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCompareCertificate", dwCertEncodingType, pCertId1, pCertId2);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertId1, pCertId2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCompareCertificateName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCompareCertificateName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2)
     * }
     */
    public static FunctionDescriptor CertCompareCertificateName$descriptor() {
        return CertCompareCertificateName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2)
     * }
     */
    public static MethodHandle CertCompareCertificateName$handle() {
        return CertCompareCertificateName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2)
     * }
     */
    public static MemorySegment CertCompareCertificateName$address() {
        return CertCompareCertificateName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2)
     * }
     */
    public static int CertCompareCertificateName(int dwCertEncodingType, MemorySegment pCertName1, MemorySegment pCertName2) {
        var mh$ = CertCompareCertificateName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCompareCertificateName", dwCertEncodingType, pCertName1, pCertName2);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertName1, pCertName2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertIsRDNAttrsInCertificateName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertIsRDNAttrsInCertificateName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN)
     * }
     */
    public static FunctionDescriptor CertIsRDNAttrsInCertificateName$descriptor() {
        return CertIsRDNAttrsInCertificateName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN)
     * }
     */
    public static MethodHandle CertIsRDNAttrsInCertificateName$handle() {
        return CertIsRDNAttrsInCertificateName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN)
     * }
     */
    public static MemorySegment CertIsRDNAttrsInCertificateName$address() {
        return CertIsRDNAttrsInCertificateName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN)
     * }
     */
    public static int CertIsRDNAttrsInCertificateName(int dwCertEncodingType, int dwFlags, MemorySegment pCertName, MemorySegment pRDN) {
        var mh$ = CertIsRDNAttrsInCertificateName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertIsRDNAttrsInCertificateName", dwCertEncodingType, dwFlags, pCertName, pRDN);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, dwFlags, pCertName, pRDN);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertComparePublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertComparePublicKeyInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2)
     * }
     */
    public static FunctionDescriptor CertComparePublicKeyInfo$descriptor() {
        return CertComparePublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2)
     * }
     */
    public static MethodHandle CertComparePublicKeyInfo$handle() {
        return CertComparePublicKeyInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2)
     * }
     */
    public static MemorySegment CertComparePublicKeyInfo$address() {
        return CertComparePublicKeyInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2)
     * }
     */
    public static int CertComparePublicKeyInfo(int dwCertEncodingType, MemorySegment pPublicKey1, MemorySegment pPublicKey2) {
        var mh$ = CertComparePublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertComparePublicKeyInfo", dwCertEncodingType, pPublicKey1, pPublicKey2);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pPublicKey1, pPublicKey2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetPublicKeyLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetPublicKeyLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static FunctionDescriptor CertGetPublicKeyLength$descriptor() {
        return CertGetPublicKeyLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static MethodHandle CertGetPublicKeyLength$handle() {
        return CertGetPublicKeyLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static MemorySegment CertGetPublicKeyLength$address() {
        return CertGetPublicKeyLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static int CertGetPublicKeyLength(int dwCertEncodingType, MemorySegment pPublicKey) {
        var mh$ = CertGetPublicKeyLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetPublicKeyLength", dwCertEncodingType, pPublicKey);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pPublicKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyCertificateSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptVerifyCertificateSignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static FunctionDescriptor CryptVerifyCertificateSignature$descriptor() {
        return CryptVerifyCertificateSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static MethodHandle CryptVerifyCertificateSignature$handle() {
        return CryptVerifyCertificateSignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static MemorySegment CryptVerifyCertificateSignature$address() {
        return CryptVerifyCertificateSignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static int CryptVerifyCertificateSignature(long hCryptProv, int dwCertEncodingType, MemorySegment pbEncoded, int cbEncoded, MemorySegment pPublicKey) {
        var mh$ = CryptVerifyCertificateSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyCertificateSignature", hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pPublicKey);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pPublicKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyCertificateSignatureEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptVerifyCertificateSignatureEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, DWORD dwSubjectType, void *pvSubject, DWORD dwIssuerType, void *pvIssuer, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static FunctionDescriptor CryptVerifyCertificateSignatureEx$descriptor() {
        return CryptVerifyCertificateSignatureEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, DWORD dwSubjectType, void *pvSubject, DWORD dwIssuerType, void *pvIssuer, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static MethodHandle CryptVerifyCertificateSignatureEx$handle() {
        return CryptVerifyCertificateSignatureEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, DWORD dwSubjectType, void *pvSubject, DWORD dwIssuerType, void *pvIssuer, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static MemorySegment CryptVerifyCertificateSignatureEx$address() {
        return CryptVerifyCertificateSignatureEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, DWORD dwSubjectType, void *pvSubject, DWORD dwIssuerType, void *pvIssuer, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static int CryptVerifyCertificateSignatureEx(long hCryptProv, int dwCertEncodingType, int dwSubjectType, MemorySegment pvSubject, int dwIssuerType, MemorySegment pvIssuer, int dwFlags, MemorySegment pvExtra) {
        var mh$ = CryptVerifyCertificateSignatureEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyCertificateSignatureEx", hCryptProv, dwCertEncodingType, dwSubjectType, pvSubject, dwIssuerType, pvIssuer, dwFlags, pvExtra);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, dwSubjectType, pvSubject, dwIssuerType, pvIssuer, dwFlags, pvExtra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO {
     *     CRYPT_DATA_BLOB CertSignHashCNGAlgPropData;
     *     CRYPT_DATA_BLOB CertIssuerPubKeyBitLengthPropData;
     * } *PCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO
     * }
     */
    public static final AddressLayout PCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO {
     *     DWORD cCNGHashAlgid;
     *     PCWSTR *rgpwszCNGHashAlgid;
     *     DWORD dwWeakIndex;
     * } *PCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO
     * }
     */
    public static final AddressLayout PCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = wgl_h.C_POINTER;

    private static class CertIsStrongHashToSign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertIsStrongHashToSign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert)
     * }
     */
    public static FunctionDescriptor CertIsStrongHashToSign$descriptor() {
        return CertIsStrongHashToSign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert)
     * }
     */
    public static MethodHandle CertIsStrongHashToSign$handle() {
        return CertIsStrongHashToSign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert)
     * }
     */
    public static MemorySegment CertIsStrongHashToSign$address() {
        return CertIsStrongHashToSign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert)
     * }
     */
    public static int CertIsStrongHashToSign(MemorySegment pStrongSignPara, MemorySegment pwszCNGHashAlgid, MemorySegment pSigningCert) {
        var mh$ = CertIsStrongHashToSign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertIsStrongHashToSign", pStrongSignPara, pwszCNGHashAlgid, pSigningCert);
            }
            return (int)mh$.invokeExact(pStrongSignPara, pwszCNGHashAlgid, pSigningCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashToBeSigned {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptHashToBeSigned");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashToBeSigned$descriptor() {
        return CryptHashToBeSigned.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashToBeSigned$handle() {
        return CryptHashToBeSigned.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptHashToBeSigned$address() {
        return CryptHashToBeSigned.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashToBeSigned(long hCryptProv, int dwCertEncodingType, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashToBeSigned.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashToBeSigned", hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptHashCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashCertificate$descriptor() {
        return CryptHashCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashCertificate$handle() {
        return CryptHashCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptHashCertificate$address() {
        return CryptHashCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashCertificate(long hCryptProv, int Algid, int dwFlags, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashCertificate", hCryptProv, Algid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(hCryptProv, Algid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashCertificate2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptHashCertificate2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid, DWORD dwFlags, void *pvReserved, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashCertificate2$descriptor() {
        return CryptHashCertificate2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid, DWORD dwFlags, void *pvReserved, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashCertificate2$handle() {
        return CryptHashCertificate2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid, DWORD dwFlags, void *pvReserved, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptHashCertificate2$address() {
        return CryptHashCertificate2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid, DWORD dwFlags, void *pvReserved, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashCertificate2(MemorySegment pwszCNGHashAlgid, int dwFlags, MemorySegment pvReserved, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashCertificate2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashCertificate2", pwszCNGHashAlgid, dwFlags, pvReserved, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pwszCNGHashAlgid, dwFlags, pvReserved, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSignCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, const BYTE *pbEncodedToBeSigned, DWORD cbEncodedToBeSigned, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbSignature, DWORD *pcbSignature)
     * }
     */
    public static FunctionDescriptor CryptSignCertificate$descriptor() {
        return CryptSignCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, const BYTE *pbEncodedToBeSigned, DWORD cbEncodedToBeSigned, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbSignature, DWORD *pcbSignature)
     * }
     */
    public static MethodHandle CryptSignCertificate$handle() {
        return CryptSignCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, const BYTE *pbEncodedToBeSigned, DWORD cbEncodedToBeSigned, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbSignature, DWORD *pcbSignature)
     * }
     */
    public static MemorySegment CryptSignCertificate$address() {
        return CryptSignCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, const BYTE *pbEncodedToBeSigned, DWORD cbEncodedToBeSigned, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbSignature, DWORD *pcbSignature)
     * }
     */
    public static int CryptSignCertificate(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment pbEncodedToBeSigned, int cbEncodedToBeSigned, MemorySegment pSignatureAlgorithm, MemorySegment pvHashAuxInfo, MemorySegment pbSignature, MemorySegment pcbSignature) {
        var mh$ = CryptSignCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignCertificate", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, pSignatureAlgorithm, pvHashAuxInfo, pbSignature, pcbSignature);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, pSignatureAlgorithm, pvHashAuxInfo, pbSignature, pcbSignature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignAndEncodeCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSignAndEncodeCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncodeCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptSignAndEncodeCertificate$descriptor() {
        return CryptSignAndEncodeCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncodeCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptSignAndEncodeCertificate$handle() {
        return CryptSignAndEncodeCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncodeCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MemorySegment CryptSignAndEncodeCertificate$address() {
        return CryptSignAndEncodeCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignAndEncodeCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptSignAndEncodeCertificate(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pvStructInfo, MemorySegment pSignatureAlgorithm, MemorySegment pvHashAuxInfo, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptSignAndEncodeCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignAndEncodeCertificate", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, lpszStructType, pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, lpszStructType, pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyTimeValidity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertVerifyTimeValidity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo)
     * }
     */
    public static FunctionDescriptor CertVerifyTimeValidity$descriptor() {
        return CertVerifyTimeValidity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo)
     * }
     */
    public static MethodHandle CertVerifyTimeValidity$handle() {
        return CertVerifyTimeValidity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo)
     * }
     */
    public static MemorySegment CertVerifyTimeValidity$address() {
        return CertVerifyTimeValidity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo)
     * }
     */
    public static int CertVerifyTimeValidity(MemorySegment pTimeToVerify, MemorySegment pCertInfo) {
        var mh$ = CertVerifyTimeValidity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyTimeValidity", pTimeToVerify, pCertInfo);
            }
            return (int)mh$.invokeExact(pTimeToVerify, pCertInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyCRLTimeValidity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertVerifyCRLTimeValidity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo)
     * }
     */
    public static FunctionDescriptor CertVerifyCRLTimeValidity$descriptor() {
        return CertVerifyCRLTimeValidity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo)
     * }
     */
    public static MethodHandle CertVerifyCRLTimeValidity$handle() {
        return CertVerifyCRLTimeValidity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo)
     * }
     */
    public static MemorySegment CertVerifyCRLTimeValidity$address() {
        return CertVerifyCRLTimeValidity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo)
     * }
     */
    public static int CertVerifyCRLTimeValidity(MemorySegment pTimeToVerify, MemorySegment pCrlInfo) {
        var mh$ = CertVerifyCRLTimeValidity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyCRLTimeValidity", pTimeToVerify, pCrlInfo);
            }
            return (int)mh$.invokeExact(pTimeToVerify, pCrlInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyValidityNesting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertVerifyValidityNesting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo)
     * }
     */
    public static FunctionDescriptor CertVerifyValidityNesting$descriptor() {
        return CertVerifyValidityNesting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo)
     * }
     */
    public static MethodHandle CertVerifyValidityNesting$handle() {
        return CertVerifyValidityNesting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo)
     * }
     */
    public static MemorySegment CertVerifyValidityNesting$address() {
        return CertVerifyValidityNesting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo)
     * }
     */
    public static int CertVerifyValidityNesting(MemorySegment pSubjectInfo, MemorySegment pIssuerInfo) {
        var mh$ = CertVerifyValidityNesting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyValidityNesting", pSubjectInfo, pIssuerInfo);
            }
            return (int)mh$.invokeExact(pSubjectInfo, pIssuerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyCRLRevocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertVerifyCRLRevocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyCRLRevocation(DWORD dwCertEncodingType, PCERT_INFO pCertId, DWORD cCrlInfo, PCRL_INFO rgpCrlInfo[])
     * }
     */
    public static FunctionDescriptor CertVerifyCRLRevocation$descriptor() {
        return CertVerifyCRLRevocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyCRLRevocation(DWORD dwCertEncodingType, PCERT_INFO pCertId, DWORD cCrlInfo, PCRL_INFO rgpCrlInfo[])
     * }
     */
    public static MethodHandle CertVerifyCRLRevocation$handle() {
        return CertVerifyCRLRevocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifyCRLRevocation(DWORD dwCertEncodingType, PCERT_INFO pCertId, DWORD cCrlInfo, PCRL_INFO rgpCrlInfo[])
     * }
     */
    public static MemorySegment CertVerifyCRLRevocation$address() {
        return CertVerifyCRLRevocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifyCRLRevocation(DWORD dwCertEncodingType, PCERT_INFO pCertId, DWORD cCrlInfo, PCRL_INFO rgpCrlInfo[])
     * }
     */
    public static int CertVerifyCRLRevocation(int dwCertEncodingType, MemorySegment pCertId, int cCrlInfo, MemorySegment rgpCrlInfo) {
        var mh$ = CertVerifyCRLRevocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyCRLRevocation", dwCertEncodingType, pCertId, cCrlInfo, rgpCrlInfo);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertId, cCrlInfo, rgpCrlInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAlgIdToOID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAlgIdToOID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPCSTR CertAlgIdToOID(DWORD dwAlgId)
     * }
     */
    public static FunctionDescriptor CertAlgIdToOID$descriptor() {
        return CertAlgIdToOID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPCSTR CertAlgIdToOID(DWORD dwAlgId)
     * }
     */
    public static MethodHandle CertAlgIdToOID$handle() {
        return CertAlgIdToOID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPCSTR CertAlgIdToOID(DWORD dwAlgId)
     * }
     */
    public static MemorySegment CertAlgIdToOID$address() {
        return CertAlgIdToOID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPCSTR CertAlgIdToOID(DWORD dwAlgId)
     * }
     */
    public static MemorySegment CertAlgIdToOID(int dwAlgId) {
        var mh$ = CertAlgIdToOID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAlgIdToOID", dwAlgId);
            }
            return (MemorySegment)mh$.invokeExact(dwAlgId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertOIDToAlgId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertOIDToAlgId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertOIDToAlgId(LPCSTR pszObjId)
     * }
     */
    public static FunctionDescriptor CertOIDToAlgId$descriptor() {
        return CertOIDToAlgId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertOIDToAlgId(LPCSTR pszObjId)
     * }
     */
    public static MethodHandle CertOIDToAlgId$handle() {
        return CertOIDToAlgId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertOIDToAlgId(LPCSTR pszObjId)
     * }
     */
    public static MemorySegment CertOIDToAlgId$address() {
        return CertOIDToAlgId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertOIDToAlgId(LPCSTR pszObjId)
     * }
     */
    public static int CertOIDToAlgId(MemorySegment pszObjId) {
        var mh$ = CertOIDToAlgId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOIDToAlgId", pszObjId);
            }
            return (int)mh$.invokeExact(pszObjId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindExtension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFindExtension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCERT_EXTENSION CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[])
     * }
     */
    public static FunctionDescriptor CertFindExtension$descriptor() {
        return CertFindExtension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCERT_EXTENSION CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[])
     * }
     */
    public static MethodHandle CertFindExtension$handle() {
        return CertFindExtension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCERT_EXTENSION CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[])
     * }
     */
    public static MemorySegment CertFindExtension$address() {
        return CertFindExtension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCERT_EXTENSION CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[])
     * }
     */
    public static MemorySegment CertFindExtension(MemorySegment pszObjId, int cExtensions, MemorySegment rgExtensions) {
        var mh$ = CertFindExtension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindExtension", pszObjId, cExtensions, rgExtensions);
            }
            return (MemorySegment)mh$.invokeExact(pszObjId, cExtensions, rgExtensions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFindAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCRYPT_ATTRIBUTE CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[])
     * }
     */
    public static FunctionDescriptor CertFindAttribute$descriptor() {
        return CertFindAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCRYPT_ATTRIBUTE CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[])
     * }
     */
    public static MethodHandle CertFindAttribute$handle() {
        return CertFindAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCRYPT_ATTRIBUTE CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[])
     * }
     */
    public static MemorySegment CertFindAttribute$address() {
        return CertFindAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCRYPT_ATTRIBUTE CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[])
     * }
     */
    public static MemorySegment CertFindAttribute(MemorySegment pszObjId, int cAttr, MemorySegment rgAttr) {
        var mh$ = CertFindAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindAttribute", pszObjId, cAttr, rgAttr);
            }
            return (MemorySegment)mh$.invokeExact(pszObjId, cAttr, rgAttr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindRDNAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFindRDNAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCERT_RDN_ATTR CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName)
     * }
     */
    public static FunctionDescriptor CertFindRDNAttr$descriptor() {
        return CertFindRDNAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCERT_RDN_ATTR CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName)
     * }
     */
    public static MethodHandle CertFindRDNAttr$handle() {
        return CertFindRDNAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCERT_RDN_ATTR CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName)
     * }
     */
    public static MemorySegment CertFindRDNAttr$address() {
        return CertFindRDNAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCERT_RDN_ATTR CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName)
     * }
     */
    public static MemorySegment CertFindRDNAttr(MemorySegment pszObjId, MemorySegment pName) {
        var mh$ = CertFindRDNAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindRDNAttr", pszObjId, pName);
            }
            return (MemorySegment)mh$.invokeExact(pszObjId, pName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetIntendedKeyUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetIntendedKeyUsage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE *pbKeyUsage, DWORD cbKeyUsage)
     * }
     */
    public static FunctionDescriptor CertGetIntendedKeyUsage$descriptor() {
        return CertGetIntendedKeyUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE *pbKeyUsage, DWORD cbKeyUsage)
     * }
     */
    public static MethodHandle CertGetIntendedKeyUsage$handle() {
        return CertGetIntendedKeyUsage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE *pbKeyUsage, DWORD cbKeyUsage)
     * }
     */
    public static MemorySegment CertGetIntendedKeyUsage$address() {
        return CertGetIntendedKeyUsage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE *pbKeyUsage, DWORD cbKeyUsage)
     * }
     */
    public static int CertGetIntendedKeyUsage(int dwCertEncodingType, MemorySegment pCertInfo, MemorySegment pbKeyUsage, int cbKeyUsage) {
        var mh$ = CertGetIntendedKeyUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetIntendedKeyUsage", dwCertEncodingType, pCertInfo, pbKeyUsage, cbKeyUsage);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertInfo, pbKeyUsage, cbKeyUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTDEFAULTCONTEXT
     * }
     */
    public static final AddressLayout HCRYPTDEFAULTCONTEXT = wgl_h.C_POINTER;

    private static class CryptInstallDefaultContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptInstallDefaultContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptInstallDefaultContext(HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara, DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext)
     * }
     */
    public static FunctionDescriptor CryptInstallDefaultContext$descriptor() {
        return CryptInstallDefaultContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptInstallDefaultContext(HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara, DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext)
     * }
     */
    public static MethodHandle CryptInstallDefaultContext$handle() {
        return CryptInstallDefaultContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptInstallDefaultContext(HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara, DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext)
     * }
     */
    public static MemorySegment CryptInstallDefaultContext$address() {
        return CryptInstallDefaultContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptInstallDefaultContext(HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara, DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext)
     * }
     */
    public static int CryptInstallDefaultContext(long hCryptProv, int dwDefaultType, MemorySegment pvDefaultPara, int dwFlags, MemorySegment pvReserved, MemorySegment phDefaultContext) {
        var mh$ = CryptInstallDefaultContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptInstallDefaultContext", hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, pvReserved, phDefaultContext);
            }
            return (int)mh$.invokeExact(hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, pvReserved, phDefaultContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA {
     *     DWORD cOID;
     *     LPSTR *rgpszOID;
     * } *PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA
     * }
     */
    public static final AddressLayout PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = wgl_h.C_POINTER;

    private static class CryptUninstallDefaultContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptUninstallDefaultContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CryptUninstallDefaultContext$descriptor() {
        return CryptUninstallDefaultContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CryptUninstallDefaultContext$handle() {
        return CryptUninstallDefaultContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MemorySegment CryptUninstallDefaultContext$address() {
        return CryptUninstallDefaultContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CryptUninstallDefaultContext(MemorySegment hDefaultContext, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptUninstallDefaultContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUninstallDefaultContext", hDefaultContext, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(hDefaultContext, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptExportPublicKeyInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static FunctionDescriptor CryptExportPublicKeyInfo$descriptor() {
        return CryptExportPublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MethodHandle CryptExportPublicKeyInfo$handle() {
        return CryptExportPublicKeyInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MemorySegment CryptExportPublicKeyInfo$address() {
        return CryptExportPublicKeyInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static int CryptExportPublicKeyInfo(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment pInfo, MemorySegment pcbInfo) {
        var mh$ = CryptExportPublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPublicKeyInfo", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPublicKeyInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptExportPublicKeyInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static FunctionDescriptor CryptExportPublicKeyInfoEx$descriptor() {
        return CryptExportPublicKeyInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MethodHandle CryptExportPublicKeyInfoEx$handle() {
        return CryptExportPublicKeyInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MemorySegment CryptExportPublicKeyInfoEx$address() {
        return CryptExportPublicKeyInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static int CryptExportPublicKeyInfoEx(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment pszPublicKeyObjId, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pInfo, MemorySegment pcbInfo) {
        var mh$ = CryptExportPublicKeyInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPublicKeyInfoEx", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPublicKeyInfoFromBCryptKeyHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptExportPublicKeyInfoFromBCryptKeyHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static FunctionDescriptor CryptExportPublicKeyInfoFromBCryptKeyHandle$descriptor() {
        return CryptExportPublicKeyInfoFromBCryptKeyHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MethodHandle CryptExportPublicKeyInfoFromBCryptKeyHandle$handle() {
        return CryptExportPublicKeyInfoFromBCryptKeyHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MemorySegment CryptExportPublicKeyInfoFromBCryptKeyHandle$address() {
        return CryptExportPublicKeyInfoFromBCryptKeyHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static int CryptExportPublicKeyInfoFromBCryptKeyHandle(MemorySegment hBCryptKey, int dwCertEncodingType, MemorySegment pszPublicKeyObjId, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pInfo, MemorySegment pcbInfo) {
        var mh$ = CryptExportPublicKeyInfoFromBCryptKeyHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPublicKeyInfoFromBCryptKeyHandle", hBCryptKey, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
            }
            return (int)mh$.invokeExact(hBCryptKey, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptImportPublicKeyInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptImportPublicKeyInfo$descriptor() {
        return CryptImportPublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptImportPublicKeyInfo$handle() {
        return CryptImportPublicKeyInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
     * }
     */
    public static MemorySegment CryptImportPublicKeyInfo$address() {
        return CryptImportPublicKeyInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptImportPublicKeyInfo(long hCryptProv, int dwCertEncodingType, MemorySegment pInfo, MemorySegment phKey) {
        var mh$ = CryptImportPublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPublicKeyInfo", hCryptProv, dwCertEncodingType, pInfo, phKey);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pInfo, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPublicKeyInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptImportPublicKeyInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID aiKeyAlg, DWORD dwFlags, void *pvAuxInfo, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptImportPublicKeyInfoEx$descriptor() {
        return CryptImportPublicKeyInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID aiKeyAlg, DWORD dwFlags, void *pvAuxInfo, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptImportPublicKeyInfoEx$handle() {
        return CryptImportPublicKeyInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID aiKeyAlg, DWORD dwFlags, void *pvAuxInfo, HCRYPTKEY *phKey)
     * }
     */
    public static MemorySegment CryptImportPublicKeyInfoEx$address() {
        return CryptImportPublicKeyInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID aiKeyAlg, DWORD dwFlags, void *pvAuxInfo, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptImportPublicKeyInfoEx(long hCryptProv, int dwCertEncodingType, MemorySegment pInfo, int aiKeyAlg, int dwFlags, MemorySegment pvAuxInfo, MemorySegment phKey) {
        var mh$ = CryptImportPublicKeyInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPublicKeyInfoEx", hCryptProv, dwCertEncodingType, pInfo, aiKeyAlg, dwFlags, pvAuxInfo, phKey);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pInfo, aiKeyAlg, dwFlags, pvAuxInfo, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPublicKeyInfoEx2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptImportPublicKeyInfoEx2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx2(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void *pvAuxInfo, BCRYPT_KEY_HANDLE *phKey)
     * }
     */
    public static FunctionDescriptor CryptImportPublicKeyInfoEx2$descriptor() {
        return CryptImportPublicKeyInfoEx2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx2(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void *pvAuxInfo, BCRYPT_KEY_HANDLE *phKey)
     * }
     */
    public static MethodHandle CryptImportPublicKeyInfoEx2$handle() {
        return CryptImportPublicKeyInfoEx2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx2(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void *pvAuxInfo, BCRYPT_KEY_HANDLE *phKey)
     * }
     */
    public static MemorySegment CryptImportPublicKeyInfoEx2$address() {
        return CryptImportPublicKeyInfoEx2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx2(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void *pvAuxInfo, BCRYPT_KEY_HANDLE *phKey)
     * }
     */
    public static int CryptImportPublicKeyInfoEx2(int dwCertEncodingType, MemorySegment pInfo, int dwFlags, MemorySegment pvAuxInfo, MemorySegment phKey) {
        var mh$ = CryptImportPublicKeyInfoEx2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPublicKeyInfoEx2", dwCertEncodingType, pInfo, dwFlags, pvAuxInfo, phKey);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pInfo, dwFlags, pvAuxInfo, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptAcquireCertificatePrivateKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptAcquireCertificatePrivateKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvParameters, HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey, DWORD *pdwKeySpec, BOOL *pfCallerFreeProvOrNCryptKey)
     * }
     */
    public static FunctionDescriptor CryptAcquireCertificatePrivateKey$descriptor() {
        return CryptAcquireCertificatePrivateKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvParameters, HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey, DWORD *pdwKeySpec, BOOL *pfCallerFreeProvOrNCryptKey)
     * }
     */
    public static MethodHandle CryptAcquireCertificatePrivateKey$handle() {
        return CryptAcquireCertificatePrivateKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvParameters, HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey, DWORD *pdwKeySpec, BOOL *pfCallerFreeProvOrNCryptKey)
     * }
     */
    public static MemorySegment CryptAcquireCertificatePrivateKey$address() {
        return CryptAcquireCertificatePrivateKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvParameters, HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey, DWORD *pdwKeySpec, BOOL *pfCallerFreeProvOrNCryptKey)
     * }
     */
    public static int CryptAcquireCertificatePrivateKey(MemorySegment pCert, int dwFlags, MemorySegment pvParameters, MemorySegment phCryptProvOrNCryptKey, MemorySegment pdwKeySpec, MemorySegment pfCallerFreeProvOrNCryptKey) {
        var mh$ = CryptAcquireCertificatePrivateKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptAcquireCertificatePrivateKey", pCert, dwFlags, pvParameters, phCryptProvOrNCryptKey, pdwKeySpec, pfCallerFreeProvOrNCryptKey);
            }
            return (int)mh$.invokeExact(pCert, dwFlags, pvParameters, phCryptProvOrNCryptKey, pdwKeySpec, pfCallerFreeProvOrNCryptKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptFindCertificateKeyProvInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptFindCertificateKeyProvInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CryptFindCertificateKeyProvInfo$descriptor() {
        return CryptFindCertificateKeyProvInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CryptFindCertificateKeyProvInfo$handle() {
        return CryptFindCertificateKeyProvInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MemorySegment CryptFindCertificateKeyProvInfo$address() {
        return CryptFindCertificateKeyProvInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CryptFindCertificateKeyProvInfo(MemorySegment pCert, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptFindCertificateKeyProvInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFindCertificateKeyProvInfo", pCert, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pCert, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPKCS8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            _CRYPT_PKCS8_IMPORT_PARAMS.layout(),
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptImportPKCS8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV *phCryptProv, void *pvAuxInfo)
     * }
     */
    public static FunctionDescriptor CryptImportPKCS8$descriptor() {
        return CryptImportPKCS8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV *phCryptProv, void *pvAuxInfo)
     * }
     */
    public static MethodHandle CryptImportPKCS8$handle() {
        return CryptImportPKCS8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV *phCryptProv, void *pvAuxInfo)
     * }
     */
    public static MemorySegment CryptImportPKCS8$address() {
        return CryptImportPKCS8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV *phCryptProv, void *pvAuxInfo)
     * }
     */
    public static int CryptImportPKCS8(MemorySegment sPrivateKeyAndParams, int dwFlags, MemorySegment phCryptProv, MemorySegment pvAuxInfo) {
        var mh$ = CryptImportPKCS8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPKCS8", sPrivateKeyAndParams, dwFlags, phCryptProv, pvAuxInfo);
            }
            return (int)mh$.invokeExact(sPrivateKeyAndParams, dwFlags, phCryptProv, pvAuxInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPKCS8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptExportPKCS8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8(HCRYPTPROV hCryptProv, DWORD dwKeySpec, LPSTR pszPrivateKeyObjId, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static FunctionDescriptor CryptExportPKCS8$descriptor() {
        return CryptExportPKCS8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8(HCRYPTPROV hCryptProv, DWORD dwKeySpec, LPSTR pszPrivateKeyObjId, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static MethodHandle CryptExportPKCS8$handle() {
        return CryptExportPKCS8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8(HCRYPTPROV hCryptProv, DWORD dwKeySpec, LPSTR pszPrivateKeyObjId, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static MemorySegment CryptExportPKCS8$address() {
        return CryptExportPKCS8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8(HCRYPTPROV hCryptProv, DWORD dwKeySpec, LPSTR pszPrivateKeyObjId, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static int CryptExportPKCS8(long hCryptProv, int dwKeySpec, MemorySegment pszPrivateKeyObjId, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pbPrivateKeyBlob, MemorySegment pcbPrivateKeyBlob) {
        var mh$ = CryptExportPKCS8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPKCS8", hCryptProv, dwKeySpec, pszPrivateKeyObjId, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
            }
            return (int)mh$.invokeExact(hCryptProv, dwKeySpec, pszPrivateKeyObjId, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPKCS8Ex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptExportPKCS8Ex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8Ex(CRYPT_PKCS8_EXPORT_PARAMS *psExportParams, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static FunctionDescriptor CryptExportPKCS8Ex$descriptor() {
        return CryptExportPKCS8Ex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8Ex(CRYPT_PKCS8_EXPORT_PARAMS *psExportParams, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static MethodHandle CryptExportPKCS8Ex$handle() {
        return CryptExportPKCS8Ex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8Ex(CRYPT_PKCS8_EXPORT_PARAMS *psExportParams, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static MemorySegment CryptExportPKCS8Ex$address() {
        return CryptExportPKCS8Ex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8Ex(CRYPT_PKCS8_EXPORT_PARAMS *psExportParams, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static int CryptExportPKCS8Ex(MemorySegment psExportParams, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pbPrivateKeyBlob, MemorySegment pcbPrivateKeyBlob) {
        var mh$ = CryptExportPKCS8Ex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPKCS8Ex", psExportParams, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
            }
            return (int)mh$.invokeExact(psExportParams, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashPublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptHashPublicKeyInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashPublicKeyInfo$descriptor() {
        return CryptHashPublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashPublicKeyInfo$handle() {
        return CryptHashPublicKeyInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptHashPublicKeyInfo$address() {
        return CryptHashPublicKeyInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashPublicKeyInfo(long hCryptProv, int Algid, int dwFlags, int dwCertEncodingType, MemorySegment pInfo, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashPublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashPublicKeyInfo", hCryptProv, Algid, dwFlags, dwCertEncodingType, pInfo, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(hCryptProv, Algid, dwFlags, dwCertEncodingType, pInfo, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRDNValueToStrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertRDNValueToStrA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertRDNValueToStrA$descriptor() {
        return CertRDNValueToStrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertRDNValueToStrA$handle() {
        return CertRDNValueToStrA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
     * }
     */
    public static MemorySegment CertRDNValueToStrA$address() {
        return CertRDNValueToStrA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
     * }
     */
    public static int CertRDNValueToStrA(int dwValueType, MemorySegment pValue, MemorySegment psz, int csz) {
        var mh$ = CertRDNValueToStrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRDNValueToStrA", dwValueType, pValue, psz, csz);
            }
            return (int)mh$.invokeExact(dwValueType, pValue, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRDNValueToStrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertRDNValueToStrW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertRDNValueToStrW$descriptor() {
        return CertRDNValueToStrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertRDNValueToStrW$handle() {
        return CertRDNValueToStrW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
     * }
     */
    public static MemorySegment CertRDNValueToStrW$address() {
        return CertRDNValueToStrW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
     * }
     */
    public static int CertRDNValueToStrW(int dwValueType, MemorySegment pValue, MemorySegment psz, int csz) {
        var mh$ = CertRDNValueToStrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRDNValueToStrW", dwValueType, pValue, psz, csz);
            }
            return (int)mh$.invokeExact(dwValueType, pValue, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertNameToStrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertNameToStrA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertNameToStrA$descriptor() {
        return CertNameToStrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertNameToStrA$handle() {
        return CertNameToStrA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz)
     * }
     */
    public static MemorySegment CertNameToStrA$address() {
        return CertNameToStrA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz)
     * }
     */
    public static int CertNameToStrA(int dwCertEncodingType, MemorySegment pName, int dwStrType, MemorySegment psz, int csz) {
        var mh$ = CertNameToStrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertNameToStrA", dwCertEncodingType, pName, dwStrType, psz, csz);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pName, dwStrType, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertNameToStrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertNameToStrW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertNameToStrW$descriptor() {
        return CertNameToStrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertNameToStrW$handle() {
        return CertNameToStrW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz)
     * }
     */
    public static MemorySegment CertNameToStrW$address() {
        return CertNameToStrW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz)
     * }
     */
    public static int CertNameToStrW(int dwCertEncodingType, MemorySegment pName, int dwStrType, MemorySegment psz, int csz) {
        var mh$ = CertNameToStrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertNameToStrW", dwCertEncodingType, pName, dwStrType, psz, csz);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pName, dwStrType, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertStrToNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertStrToNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertStrToNameA(DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError)
     * }
     */
    public static FunctionDescriptor CertStrToNameA$descriptor() {
        return CertStrToNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertStrToNameA(DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError)
     * }
     */
    public static MethodHandle CertStrToNameA$handle() {
        return CertStrToNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertStrToNameA(DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError)
     * }
     */
    public static MemorySegment CertStrToNameA$address() {
        return CertStrToNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertStrToNameA(DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError)
     * }
     */
    public static int CertStrToNameA(int dwCertEncodingType, MemorySegment pszX500, int dwStrType, MemorySegment pvReserved, MemorySegment pbEncoded, MemorySegment pcbEncoded, MemorySegment ppszError) {
        var mh$ = CertStrToNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertStrToNameA", dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertStrToNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertStrToNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError)
     * }
     */
    public static FunctionDescriptor CertStrToNameW$descriptor() {
        return CertStrToNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError)
     * }
     */
    public static MethodHandle CertStrToNameW$handle() {
        return CertStrToNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError)
     * }
     */
    public static MemorySegment CertStrToNameW$address() {
        return CertStrToNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError)
     * }
     */
    public static int CertStrToNameW(int dwCertEncodingType, MemorySegment pszX500, int dwStrType, MemorySegment pvReserved, MemorySegment pbEncoded, MemorySegment pcbEncoded, MemorySegment ppszError) {
        var mh$ = CertStrToNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertStrToNameW", dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetNameStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetNameStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static FunctionDescriptor CertGetNameStringA$descriptor() {
        return CertGetNameStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static MethodHandle CertGetNameStringA$handle() {
        return CertGetNameStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static MemorySegment CertGetNameStringA$address() {
        return CertGetNameStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static int CertGetNameStringA(MemorySegment pCertContext, int dwType, int dwFlags, MemorySegment pvTypePara, MemorySegment pszNameString, int cchNameString) {
        var mh$ = CertGetNameStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetNameStringA", pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
            }
            return (int)mh$.invokeExact(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetNameStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetNameStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static FunctionDescriptor CertGetNameStringW$descriptor() {
        return CertGetNameStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static MethodHandle CertGetNameStringW$handle() {
        return CertGetNameStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static MemorySegment CertGetNameStringW$address() {
        return CertGetNameStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static int CertGetNameStringW(MemorySegment pCertContext, int dwType, int dwFlags, MemorySegment pvTypePara, MemorySegment pszNameString, int cchNameString) {
        var mh$ = CertGetNameStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetNameStringW", pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
            }
            return (int)mh$.invokeExact(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SIGN_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     PCCERT_CONTEXT pSigningCert;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     *     DWORD cMsgCert;
     *     PCCERT_CONTEXT *rgpMsgCert;
     *     DWORD cMsgCrl;
     *     PCCRL_CONTEXT *rgpMsgCrl;
     *     DWORD cAuthAttr;
     *     PCRYPT_ATTRIBUTE rgAuthAttr;
     *     DWORD cUnauthAttr;
     *     PCRYPT_ATTRIBUTE rgUnauthAttr;
     *     DWORD dwFlags;
     *     DWORD dwInnerContentType;
     * } *PCRYPT_SIGN_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_SIGN_MESSAGE_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_VERIFY_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     PFN_CRYPT_GET_SIGNER_CERTIFICATE pfnGetSignerCertificate;
     *     void *pvGetArg;
     * } *PCRYPT_VERIFY_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_VERIFY_MESSAGE_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ENCRYPT_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     *     DWORD dwFlags;
     *     DWORD dwInnerContentType;
     * } *PCRYPT_ENCRYPT_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_ENCRYPT_MESSAGE_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_DECRYPT_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     DWORD cCertStore;
     *     HCERTSTORE *rghCertStore;
     * } *PCRYPT_DECRYPT_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_DECRYPT_MESSAGE_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_HASH_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     * } *PCRYPT_HASH_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_HASH_MESSAGE_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_SIGN_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     *     CRYPT_ALGORITHM_IDENTIFIER PubKeyAlgorithm;
     * } *PCRYPT_KEY_SIGN_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_KEY_SIGN_MESSAGE_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_VERIFY_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     * } *PCRYPT_KEY_VERIFY_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_KEY_VERIFY_MESSAGE_PARA = wgl_h.C_POINTER;

    private static class CryptSignMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSignMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, BOOL fDetachedSignature, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptSignMessage$descriptor() {
        return CryptSignMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, BOOL fDetachedSignature, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static MethodHandle CryptSignMessage$handle() {
        return CryptSignMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, BOOL fDetachedSignature, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static MemorySegment CryptSignMessage$address() {
        return CryptSignMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, BOOL fDetachedSignature, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static int CryptSignMessage(MemorySegment pSignPara, int fDetachedSignature, int cToBeSigned, MemorySegment rgpbToBeSigned, MemorySegment rgcbToBeSigned, MemorySegment pbSignedBlob, MemorySegment pcbSignedBlob) {
        var mh$ = CryptSignMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignMessage", pSignPara, fDetachedSignature, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, pbSignedBlob, pcbSignedBlob);
            }
            return (int)mh$.invokeExact(pSignPara, fDetachedSignature, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, pbSignedBlob, pcbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyMessageSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptVerifyMessageSignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptVerifyMessageSignature$descriptor() {
        return CryptVerifyMessageSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptVerifyMessageSignature$handle() {
        return CryptVerifyMessageSignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MemorySegment CryptVerifyMessageSignature$address() {
        return CryptVerifyMessageSignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptVerifyMessageSignature(MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbSignedBlob, int cbSignedBlob, MemorySegment pbDecoded, MemorySegment pcbDecoded, MemorySegment ppSignerCert) {
        var mh$ = CryptVerifyMessageSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyMessageSignature", pVerifyPara, dwSignerIndex, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded, ppSignerCert);
            }
            return (int)mh$.invokeExact(pVerifyPara, dwSignerIndex, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetMessageSignerCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetMessageSignerCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptGetMessageSignerCount$descriptor() {
        return CryptGetMessageSignerCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MethodHandle CryptGetMessageSignerCount$handle() {
        return CryptGetMessageSignerCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MemorySegment CryptGetMessageSignerCount$address() {
        return CryptGetMessageSignerCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static int CryptGetMessageSignerCount(int dwMsgEncodingType, MemorySegment pbSignedBlob, int cbSignedBlob) {
        var mh$ = CryptGetMessageSignerCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetMessageSignerCount", dwMsgEncodingType, pbSignedBlob, cbSignedBlob);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, pbSignedBlob, cbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetMessageCertificates {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetMessageCertificates");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CryptGetMessageCertificates(DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptGetMessageCertificates$descriptor() {
        return CryptGetMessageCertificates.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CryptGetMessageCertificates(DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MethodHandle CryptGetMessageCertificates$handle() {
        return CryptGetMessageCertificates.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE CryptGetMessageCertificates(DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MemorySegment CryptGetMessageCertificates$address() {
        return CryptGetMessageCertificates.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE CryptGetMessageCertificates(DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MemorySegment CryptGetMessageCertificates(int dwMsgAndCertEncodingType, long hCryptProv, int dwFlags, MemorySegment pbSignedBlob, int cbSignedBlob) {
        var mh$ = CryptGetMessageCertificates.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetMessageCertificates", dwMsgAndCertEncodingType, hCryptProv, dwFlags, pbSignedBlob, cbSignedBlob);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgAndCertEncodingType, hCryptProv, dwFlags, pbSignedBlob, cbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyDetachedMessageSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptVerifyDetachedMessageSignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbDetachedSignBlob, DWORD cbDetachedSignBlob, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptVerifyDetachedMessageSignature$descriptor() {
        return CryptVerifyDetachedMessageSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbDetachedSignBlob, DWORD cbDetachedSignBlob, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptVerifyDetachedMessageSignature$handle() {
        return CryptVerifyDetachedMessageSignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbDetachedSignBlob, DWORD cbDetachedSignBlob, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MemorySegment CryptVerifyDetachedMessageSignature$address() {
        return CryptVerifyDetachedMessageSignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbDetachedSignBlob, DWORD cbDetachedSignBlob, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptVerifyDetachedMessageSignature(MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbDetachedSignBlob, int cbDetachedSignBlob, int cToBeSigned, MemorySegment rgpbToBeSigned, MemorySegment rgcbToBeSigned, MemorySegment ppSignerCert) {
        var mh$ = CryptVerifyDetachedMessageSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyDetachedMessageSignature", pVerifyPara, dwSignerIndex, pbDetachedSignBlob, cbDetachedSignBlob, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, ppSignerCert);
            }
            return (int)mh$.invokeExact(pVerifyPara, dwSignerIndex, pbDetachedSignBlob, cbDetachedSignBlob, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEncryptMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptEncryptMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeEncrypted, DWORD cbToBeEncrypted, BYTE *pbEncryptedBlob, DWORD *pcbEncryptedBlob)
     * }
     */
    public static FunctionDescriptor CryptEncryptMessage$descriptor() {
        return CryptEncryptMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeEncrypted, DWORD cbToBeEncrypted, BYTE *pbEncryptedBlob, DWORD *pcbEncryptedBlob)
     * }
     */
    public static MethodHandle CryptEncryptMessage$handle() {
        return CryptEncryptMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeEncrypted, DWORD cbToBeEncrypted, BYTE *pbEncryptedBlob, DWORD *pcbEncryptedBlob)
     * }
     */
    public static MemorySegment CryptEncryptMessage$address() {
        return CryptEncryptMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeEncrypted, DWORD cbToBeEncrypted, BYTE *pbEncryptedBlob, DWORD *pcbEncryptedBlob)
     * }
     */
    public static int CryptEncryptMessage(MemorySegment pEncryptPara, int cRecipientCert, MemorySegment rgpRecipientCert, MemorySegment pbToBeEncrypted, int cbToBeEncrypted, MemorySegment pbEncryptedBlob, MemorySegment pcbEncryptedBlob) {
        var mh$ = CryptEncryptMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEncryptMessage", pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeEncrypted, cbToBeEncrypted, pbEncryptedBlob, pcbEncryptedBlob);
            }
            return (int)mh$.invokeExact(pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeEncrypted, cbToBeEncrypted, pbEncryptedBlob, pcbEncryptedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecryptMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptDecryptMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert)
     * }
     */
    public static FunctionDescriptor CryptDecryptMessage$descriptor() {
        return CryptDecryptMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert)
     * }
     */
    public static MethodHandle CryptDecryptMessage$handle() {
        return CryptDecryptMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert)
     * }
     */
    public static MemorySegment CryptDecryptMessage$address() {
        return CryptDecryptMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert)
     * }
     */
    public static int CryptDecryptMessage(MemorySegment pDecryptPara, MemorySegment pbEncryptedBlob, int cbEncryptedBlob, MemorySegment pbDecrypted, MemorySegment pcbDecrypted, MemorySegment ppXchgCert) {
        var mh$ = CryptDecryptMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecryptMessage", pDecryptPara, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert);
            }
            return (int)mh$.invokeExact(pDecryptPara, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignAndEncryptMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSignAndEncryptMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeSignedAndEncrypted, DWORD cbToBeSignedAndEncrypted, BYTE *pbSignedAndEncryptedBlob, DWORD *pcbSignedAndEncryptedBlob)
     * }
     */
    public static FunctionDescriptor CryptSignAndEncryptMessage$descriptor() {
        return CryptSignAndEncryptMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeSignedAndEncrypted, DWORD cbToBeSignedAndEncrypted, BYTE *pbSignedAndEncryptedBlob, DWORD *pcbSignedAndEncryptedBlob)
     * }
     */
    public static MethodHandle CryptSignAndEncryptMessage$handle() {
        return CryptSignAndEncryptMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeSignedAndEncrypted, DWORD cbToBeSignedAndEncrypted, BYTE *pbSignedAndEncryptedBlob, DWORD *pcbSignedAndEncryptedBlob)
     * }
     */
    public static MemorySegment CryptSignAndEncryptMessage$address() {
        return CryptSignAndEncryptMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeSignedAndEncrypted, DWORD cbToBeSignedAndEncrypted, BYTE *pbSignedAndEncryptedBlob, DWORD *pcbSignedAndEncryptedBlob)
     * }
     */
    public static int CryptSignAndEncryptMessage(MemorySegment pSignPara, MemorySegment pEncryptPara, int cRecipientCert, MemorySegment rgpRecipientCert, MemorySegment pbToBeSignedAndEncrypted, int cbToBeSignedAndEncrypted, MemorySegment pbSignedAndEncryptedBlob, MemorySegment pcbSignedAndEncryptedBlob) {
        var mh$ = CryptSignAndEncryptMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignAndEncryptMessage", pSignPara, pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, pbSignedAndEncryptedBlob, pcbSignedAndEncryptedBlob);
            }
            return (int)mh$.invokeExact(pSignPara, pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, pbSignedAndEncryptedBlob, pcbSignedAndEncryptedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecryptAndVerifyMessageSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptDecryptAndVerifyMessageSignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptDecryptAndVerifyMessageSignature$descriptor() {
        return CryptDecryptAndVerifyMessageSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptDecryptAndVerifyMessageSignature$handle() {
        return CryptDecryptAndVerifyMessageSignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MemorySegment CryptDecryptAndVerifyMessageSignature$address() {
        return CryptDecryptAndVerifyMessageSignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptDecryptAndVerifyMessageSignature(MemorySegment pDecryptPara, MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbEncryptedBlob, int cbEncryptedBlob, MemorySegment pbDecrypted, MemorySegment pcbDecrypted, MemorySegment ppXchgCert, MemorySegment ppSignerCert) {
        var mh$ = CryptDecryptAndVerifyMessageSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecryptAndVerifyMessageSignature", pDecryptPara, pVerifyPara, dwSignerIndex, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert, ppSignerCert);
            }
            return (int)mh$.invokeExact(pDecryptPara, pVerifyPara, dwSignerIndex, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecodeMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptDecodeMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecodeMessage(DWORD dwMsgTypeFlags, PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncodedBlob, DWORD cbEncodedBlob, DWORD dwPrevInnerContentType, DWORD *pdwMsgType, DWORD *pdwInnerContentType, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptDecodeMessage$descriptor() {
        return CryptDecodeMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecodeMessage(DWORD dwMsgTypeFlags, PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncodedBlob, DWORD cbEncodedBlob, DWORD dwPrevInnerContentType, DWORD *pdwMsgType, DWORD *pdwInnerContentType, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptDecodeMessage$handle() {
        return CryptDecodeMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDecodeMessage(DWORD dwMsgTypeFlags, PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncodedBlob, DWORD cbEncodedBlob, DWORD dwPrevInnerContentType, DWORD *pdwMsgType, DWORD *pdwInnerContentType, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MemorySegment CryptDecodeMessage$address() {
        return CryptDecodeMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDecodeMessage(DWORD dwMsgTypeFlags, PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncodedBlob, DWORD cbEncodedBlob, DWORD dwPrevInnerContentType, DWORD *pdwMsgType, DWORD *pdwInnerContentType, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptDecodeMessage(int dwMsgTypeFlags, MemorySegment pDecryptPara, MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbEncodedBlob, int cbEncodedBlob, int dwPrevInnerContentType, MemorySegment pdwMsgType, MemorySegment pdwInnerContentType, MemorySegment pbDecoded, MemorySegment pcbDecoded, MemorySegment ppXchgCert, MemorySegment ppSignerCert) {
        var mh$ = CryptDecodeMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecodeMessage", dwMsgTypeFlags, pDecryptPara, pVerifyPara, dwSignerIndex, pbEncodedBlob, cbEncodedBlob, dwPrevInnerContentType, pdwMsgType, pdwInnerContentType, pbDecoded, pcbDecoded, ppXchgCert, ppSignerCert);
            }
            return (int)mh$.invokeExact(dwMsgTypeFlags, pDecryptPara, pVerifyPara, dwSignerIndex, pbEncodedBlob, cbEncodedBlob, dwPrevInnerContentType, pdwMsgType, pdwInnerContentType, pbDecoded, pcbDecoded, ppXchgCert, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptHashMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara, BOOL fDetachedHash, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbHashedBlob, DWORD *pcbHashedBlob, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashMessage$descriptor() {
        return CryptHashMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara, BOOL fDetachedHash, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbHashedBlob, DWORD *pcbHashedBlob, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashMessage$handle() {
        return CryptHashMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara, BOOL fDetachedHash, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbHashedBlob, DWORD *pcbHashedBlob, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptHashMessage$address() {
        return CryptHashMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara, BOOL fDetachedHash, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbHashedBlob, DWORD *pcbHashedBlob, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashMessage(MemorySegment pHashPara, int fDetachedHash, int cToBeHashed, MemorySegment rgpbToBeHashed, MemorySegment rgcbToBeHashed, MemorySegment pbHashedBlob, MemorySegment pcbHashedBlob, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashMessage", pHashPara, fDetachedHash, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbHashedBlob, pcbHashedBlob, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pHashPara, fDetachedHash, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbHashedBlob, pcbHashedBlob, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyMessageHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptVerifyMessageHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbHashedBlob, DWORD cbHashedBlob, BYTE *pbToBeHashed, DWORD *pcbToBeHashed, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptVerifyMessageHash$descriptor() {
        return CryptVerifyMessageHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbHashedBlob, DWORD cbHashedBlob, BYTE *pbToBeHashed, DWORD *pcbToBeHashed, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptVerifyMessageHash$handle() {
        return CryptVerifyMessageHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbHashedBlob, DWORD cbHashedBlob, BYTE *pbToBeHashed, DWORD *pcbToBeHashed, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptVerifyMessageHash$address() {
        return CryptVerifyMessageHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbHashedBlob, DWORD cbHashedBlob, BYTE *pbToBeHashed, DWORD *pcbToBeHashed, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptVerifyMessageHash(MemorySegment pHashPara, MemorySegment pbHashedBlob, int cbHashedBlob, MemorySegment pbToBeHashed, MemorySegment pcbToBeHashed, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptVerifyMessageHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyMessageHash", pHashPara, pbHashedBlob, cbHashedBlob, pbToBeHashed, pcbToBeHashed, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pHashPara, pbHashedBlob, cbHashedBlob, pbToBeHashed, pcbToBeHashed, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyDetachedMessageHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptVerifyDetachedMessageHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbDetachedHashBlob, DWORD cbDetachedHashBlob, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptVerifyDetachedMessageHash$descriptor() {
        return CryptVerifyDetachedMessageHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbDetachedHashBlob, DWORD cbDetachedHashBlob, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptVerifyDetachedMessageHash$handle() {
        return CryptVerifyDetachedMessageHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbDetachedHashBlob, DWORD cbDetachedHashBlob, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptVerifyDetachedMessageHash$address() {
        return CryptVerifyDetachedMessageHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbDetachedHashBlob, DWORD cbDetachedHashBlob, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptVerifyDetachedMessageHash(MemorySegment pHashPara, MemorySegment pbDetachedHashBlob, int cbDetachedHashBlob, int cToBeHashed, MemorySegment rgpbToBeHashed, MemorySegment rgcbToBeHashed, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptVerifyDetachedMessageHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyDetachedMessageHash", pHashPara, pbDetachedHashBlob, cbDetachedHashBlob, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pHashPara, pbDetachedHashBlob, cbDetachedHashBlob, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignMessageWithKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSignMessageWithKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara, const BYTE *pbToBeSigned, DWORD cbToBeSigned, BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptSignMessageWithKey$descriptor() {
        return CryptSignMessageWithKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara, const BYTE *pbToBeSigned, DWORD cbToBeSigned, BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static MethodHandle CryptSignMessageWithKey$handle() {
        return CryptSignMessageWithKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara, const BYTE *pbToBeSigned, DWORD cbToBeSigned, BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static MemorySegment CryptSignMessageWithKey$address() {
        return CryptSignMessageWithKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara, const BYTE *pbToBeSigned, DWORD cbToBeSigned, BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static int CryptSignMessageWithKey(MemorySegment pSignPara, MemorySegment pbToBeSigned, int cbToBeSigned, MemorySegment pbSignedBlob, MemorySegment pcbSignedBlob) {
        var mh$ = CryptSignMessageWithKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignMessageWithKey", pSignPara, pbToBeSigned, cbToBeSigned, pbSignedBlob, pcbSignedBlob);
            }
            return (int)mh$.invokeExact(pSignPara, pbToBeSigned, cbToBeSigned, pbSignedBlob, pcbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyMessageSignatureWithKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptVerifyMessageSignatureWithKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded)
     * }
     */
    public static FunctionDescriptor CryptVerifyMessageSignatureWithKey$descriptor() {
        return CryptVerifyMessageSignatureWithKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded)
     * }
     */
    public static MethodHandle CryptVerifyMessageSignatureWithKey$handle() {
        return CryptVerifyMessageSignatureWithKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded)
     * }
     */
    public static MemorySegment CryptVerifyMessageSignatureWithKey$address() {
        return CryptVerifyMessageSignatureWithKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded)
     * }
     */
    public static int CryptVerifyMessageSignatureWithKey(MemorySegment pVerifyPara, MemorySegment pPublicKeyInfo, MemorySegment pbSignedBlob, int cbSignedBlob, MemorySegment pbDecoded, MemorySegment pcbDecoded) {
        var mh$ = CryptVerifyMessageSignatureWithKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyMessageSignatureWithKey", pVerifyPara, pPublicKeyInfo, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded);
            }
            return (int)mh$.invokeExact(pVerifyPara, pPublicKeyInfo, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertOpenSystemStoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertOpenSystemStoreA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol)
     * }
     */
    public static FunctionDescriptor CertOpenSystemStoreA$descriptor() {
        return CertOpenSystemStoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol)
     * }
     */
    public static MethodHandle CertOpenSystemStoreA$handle() {
        return CertOpenSystemStoreA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol)
     * }
     */
    public static MemorySegment CertOpenSystemStoreA$address() {
        return CertOpenSystemStoreA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol)
     * }
     */
    public static MemorySegment CertOpenSystemStoreA(long hProv, MemorySegment szSubsystemProtocol) {
        var mh$ = CertOpenSystemStoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOpenSystemStoreA", hProv, szSubsystemProtocol);
            }
            return (MemorySegment)mh$.invokeExact(hProv, szSubsystemProtocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertOpenSystemStoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertOpenSystemStoreW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol)
     * }
     */
    public static FunctionDescriptor CertOpenSystemStoreW$descriptor() {
        return CertOpenSystemStoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol)
     * }
     */
    public static MethodHandle CertOpenSystemStoreW$handle() {
        return CertOpenSystemStoreW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol)
     * }
     */
    public static MemorySegment CertOpenSystemStoreW$address() {
        return CertOpenSystemStoreW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol)
     * }
     */
    public static MemorySegment CertOpenSystemStoreW(long hProv, MemorySegment szSubsystemProtocol) {
        var mh$ = CertOpenSystemStoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOpenSystemStoreW", hProv, szSubsystemProtocol);
            }
            return (MemorySegment)mh$.invokeExact(hProv, szSubsystemProtocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCertificateToSystemStoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddEncodedCertificateToSystemStoreA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCertificateToSystemStoreA$descriptor() {
        return CertAddEncodedCertificateToSystemStoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MethodHandle CertAddEncodedCertificateToSystemStoreA$handle() {
        return CertAddEncodedCertificateToSystemStoreA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MemorySegment CertAddEncodedCertificateToSystemStoreA$address() {
        return CertAddEncodedCertificateToSystemStoreA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static int CertAddEncodedCertificateToSystemStoreA(MemorySegment szCertStoreName, MemorySegment pbCertEncoded, int cbCertEncoded) {
        var mh$ = CertAddEncodedCertificateToSystemStoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCertificateToSystemStoreA", szCertStoreName, pbCertEncoded, cbCertEncoded);
            }
            return (int)mh$.invokeExact(szCertStoreName, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCertificateToSystemStoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddEncodedCertificateToSystemStoreW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCertificateToSystemStoreW$descriptor() {
        return CertAddEncodedCertificateToSystemStoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MethodHandle CertAddEncodedCertificateToSystemStoreW$handle() {
        return CertAddEncodedCertificateToSystemStoreW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MemorySegment CertAddEncodedCertificateToSystemStoreW$address() {
        return CertAddEncodedCertificateToSystemStoreW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static int CertAddEncodedCertificateToSystemStoreW(MemorySegment szCertStoreName, MemorySegment pbCertEncoded, int cbCertEncoded) {
        var mh$ = CertAddEncodedCertificateToSystemStoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCertificateToSystemStoreW", szCertStoreName, pbCertEncoded, cbCertEncoded);
            }
            return (int)mh$.invokeExact(szCertStoreName, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN {
     *     DWORD cCerts;
     *     PCERT_BLOB certs;
     *     CRYPT_KEY_PROV_INFO keyLocatorInfo;
     * } *PCERT_CHAIN
     * }
     */
    public static final AddressLayout PCERT_CHAIN = wgl_h.C_POINTER;

    private static class FindCertsByIssuer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindCertsByIssuer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains, DWORD *pcCertChains, BYTE *pbEncodedIssuerName, DWORD cbEncodedIssuerName, LPCWSTR pwszPurpose, DWORD dwKeySpec)
     * }
     */
    public static FunctionDescriptor FindCertsByIssuer$descriptor() {
        return FindCertsByIssuer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains, DWORD *pcCertChains, BYTE *pbEncodedIssuerName, DWORD cbEncodedIssuerName, LPCWSTR pwszPurpose, DWORD dwKeySpec)
     * }
     */
    public static MethodHandle FindCertsByIssuer$handle() {
        return FindCertsByIssuer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains, DWORD *pcCertChains, BYTE *pbEncodedIssuerName, DWORD cbEncodedIssuerName, LPCWSTR pwszPurpose, DWORD dwKeySpec)
     * }
     */
    public static MemorySegment FindCertsByIssuer$address() {
        return FindCertsByIssuer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains, DWORD *pcCertChains, BYTE *pbEncodedIssuerName, DWORD cbEncodedIssuerName, LPCWSTR pwszPurpose, DWORD dwKeySpec)
     * }
     */
    public static int FindCertsByIssuer(MemorySegment pCertChains, MemorySegment pcbCertChains, MemorySegment pcCertChains, MemorySegment pbEncodedIssuerName, int cbEncodedIssuerName, MemorySegment pwszPurpose, int dwKeySpec) {
        var mh$ = FindCertsByIssuer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindCertsByIssuer", pCertChains, pcbCertChains, pcCertChains, pbEncodedIssuerName, cbEncodedIssuerName, pwszPurpose, dwKeySpec);
            }
            return (int)mh$.invokeExact(pCertChains, pcbCertChains, pcCertChains, pbEncodedIssuerName, cbEncodedIssuerName, pwszPurpose, dwKeySpec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptQueryObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptQueryObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptQueryObject(DWORD dwObjectType, const void *pvObject, DWORD dwExpectedContentTypeFlags, DWORD dwExpectedFormatTypeFlags, DWORD dwFlags, DWORD *pdwMsgAndCertEncodingType, DWORD *pdwContentType, DWORD *pdwFormatType, HCERTSTORE *phCertStore, HCRYPTMSG *phMsg, const void **ppvContext)
     * }
     */
    public static FunctionDescriptor CryptQueryObject$descriptor() {
        return CryptQueryObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptQueryObject(DWORD dwObjectType, const void *pvObject, DWORD dwExpectedContentTypeFlags, DWORD dwExpectedFormatTypeFlags, DWORD dwFlags, DWORD *pdwMsgAndCertEncodingType, DWORD *pdwContentType, DWORD *pdwFormatType, HCERTSTORE *phCertStore, HCRYPTMSG *phMsg, const void **ppvContext)
     * }
     */
    public static MethodHandle CryptQueryObject$handle() {
        return CryptQueryObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptQueryObject(DWORD dwObjectType, const void *pvObject, DWORD dwExpectedContentTypeFlags, DWORD dwExpectedFormatTypeFlags, DWORD dwFlags, DWORD *pdwMsgAndCertEncodingType, DWORD *pdwContentType, DWORD *pdwFormatType, HCERTSTORE *phCertStore, HCRYPTMSG *phMsg, const void **ppvContext)
     * }
     */
    public static MemorySegment CryptQueryObject$address() {
        return CryptQueryObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptQueryObject(DWORD dwObjectType, const void *pvObject, DWORD dwExpectedContentTypeFlags, DWORD dwExpectedFormatTypeFlags, DWORD dwFlags, DWORD *pdwMsgAndCertEncodingType, DWORD *pdwContentType, DWORD *pdwFormatType, HCERTSTORE *phCertStore, HCRYPTMSG *phMsg, const void **ppvContext)
     * }
     */
    public static int CryptQueryObject(int dwObjectType, MemorySegment pvObject, int dwExpectedContentTypeFlags, int dwExpectedFormatTypeFlags, int dwFlags, MemorySegment pdwMsgAndCertEncodingType, MemorySegment pdwContentType, MemorySegment pdwFormatType, MemorySegment phCertStore, MemorySegment phMsg, MemorySegment ppvContext) {
        var mh$ = CryptQueryObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptQueryObject", dwObjectType, pvObject, dwExpectedContentTypeFlags, dwExpectedFormatTypeFlags, dwFlags, pdwMsgAndCertEncodingType, pdwContentType, pdwFormatType, phCertStore, phMsg, ppvContext);
            }
            return (int)mh$.invokeExact(dwObjectType, pvObject, dwExpectedContentTypeFlags, dwExpectedFormatTypeFlags, dwFlags, pdwMsgAndCertEncodingType, pdwContentType, pdwFormatType, phCertStore, phMsg, ppvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMemAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMemAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CryptMemAlloc(ULONG cbSize)
     * }
     */
    public static FunctionDescriptor CryptMemAlloc$descriptor() {
        return CryptMemAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CryptMemAlloc(ULONG cbSize)
     * }
     */
    public static MethodHandle CryptMemAlloc$handle() {
        return CryptMemAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID CryptMemAlloc(ULONG cbSize)
     * }
     */
    public static MemorySegment CryptMemAlloc$address() {
        return CryptMemAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID CryptMemAlloc(ULONG cbSize)
     * }
     */
    public static MemorySegment CryptMemAlloc(int cbSize) {
        var mh$ = CryptMemAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMemAlloc", cbSize);
            }
            return (MemorySegment)mh$.invokeExact(cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMemRealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMemRealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CryptMemRealloc(LPVOID pv, ULONG cbSize)
     * }
     */
    public static FunctionDescriptor CryptMemRealloc$descriptor() {
        return CryptMemRealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CryptMemRealloc(LPVOID pv, ULONG cbSize)
     * }
     */
    public static MethodHandle CryptMemRealloc$handle() {
        return CryptMemRealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID CryptMemRealloc(LPVOID pv, ULONG cbSize)
     * }
     */
    public static MemorySegment CryptMemRealloc$address() {
        return CryptMemRealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID CryptMemRealloc(LPVOID pv, ULONG cbSize)
     * }
     */
    public static MemorySegment CryptMemRealloc(MemorySegment pv, int cbSize) {
        var mh$ = CryptMemRealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMemRealloc", pv, cbSize);
            }
            return (MemorySegment)mh$.invokeExact(pv, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMemFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptMemFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CryptMemFree(LPVOID pv)
     * }
     */
    public static FunctionDescriptor CryptMemFree$descriptor() {
        return CryptMemFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CryptMemFree(LPVOID pv)
     * }
     */
    public static MethodHandle CryptMemFree$handle() {
        return CryptMemFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CryptMemFree(LPVOID pv)
     * }
     */
    public static MemorySegment CryptMemFree$address() {
        return CryptMemFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CryptMemFree(LPVOID pv)
     * }
     */
    public static void CryptMemFree(MemorySegment pv) {
        var mh$ = CryptMemFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMemFree", pv);
            }
            mh$.invokeExact(pv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef HANDLE HCRYPTASYNC
     * }
     */
    public static final AddressLayout HCRYPTASYNC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE *PHCRYPTASYNC
     * }
     */
    public static final AddressLayout PHCRYPTASYNC = wgl_h.C_POINTER;

    private static class CryptCreateAsyncHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptCreateAsyncHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptCreateAsyncHandle(DWORD dwFlags, PHCRYPTASYNC phAsync)
     * }
     */
    public static FunctionDescriptor CryptCreateAsyncHandle$descriptor() {
        return CryptCreateAsyncHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptCreateAsyncHandle(DWORD dwFlags, PHCRYPTASYNC phAsync)
     * }
     */
    public static MethodHandle CryptCreateAsyncHandle$handle() {
        return CryptCreateAsyncHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptCreateAsyncHandle(DWORD dwFlags, PHCRYPTASYNC phAsync)
     * }
     */
    public static MemorySegment CryptCreateAsyncHandle$address() {
        return CryptCreateAsyncHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptCreateAsyncHandle(DWORD dwFlags, PHCRYPTASYNC phAsync)
     * }
     */
    public static int CryptCreateAsyncHandle(int dwFlags, MemorySegment phAsync) {
        var mh$ = CryptCreateAsyncHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptCreateAsyncHandle", dwFlags, phAsync);
            }
            return (int)mh$.invokeExact(dwFlags, phAsync);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetAsyncParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSetAsyncParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID pvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree)
     * }
     */
    public static FunctionDescriptor CryptSetAsyncParam$descriptor() {
        return CryptSetAsyncParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID pvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree)
     * }
     */
    public static MethodHandle CryptSetAsyncParam$handle() {
        return CryptSetAsyncParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID pvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree)
     * }
     */
    public static MemorySegment CryptSetAsyncParam$address() {
        return CryptSetAsyncParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID pvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree)
     * }
     */
    public static int CryptSetAsyncParam(MemorySegment hAsync, MemorySegment pszParamOid, MemorySegment pvParam, MemorySegment pfnFree) {
        var mh$ = CryptSetAsyncParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetAsyncParam", hAsync, pszParamOid, pvParam, pfnFree);
            }
            return (int)mh$.invokeExact(hAsync, pszParamOid, pvParam, pfnFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetAsyncParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetAsyncParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID *ppvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC *ppfnFree)
     * }
     */
    public static FunctionDescriptor CryptGetAsyncParam$descriptor() {
        return CryptGetAsyncParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID *ppvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC *ppfnFree)
     * }
     */
    public static MethodHandle CryptGetAsyncParam$handle() {
        return CryptGetAsyncParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID *ppvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC *ppfnFree)
     * }
     */
    public static MemorySegment CryptGetAsyncParam$address() {
        return CryptGetAsyncParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID *ppvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC *ppfnFree)
     * }
     */
    public static int CryptGetAsyncParam(MemorySegment hAsync, MemorySegment pszParamOid, MemorySegment ppvParam, MemorySegment ppfnFree) {
        var mh$ = CryptGetAsyncParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetAsyncParam", hAsync, pszParamOid, ppvParam, ppfnFree);
            }
            return (int)mh$.invokeExact(hAsync, pszParamOid, ppvParam, ppfnFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptCloseAsyncHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptCloseAsyncHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptCloseAsyncHandle(HCRYPTASYNC hAsync)
     * }
     */
    public static FunctionDescriptor CryptCloseAsyncHandle$descriptor() {
        return CryptCloseAsyncHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptCloseAsyncHandle(HCRYPTASYNC hAsync)
     * }
     */
    public static MethodHandle CryptCloseAsyncHandle$handle() {
        return CryptCloseAsyncHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptCloseAsyncHandle(HCRYPTASYNC hAsync)
     * }
     */
    public static MemorySegment CryptCloseAsyncHandle$address() {
        return CryptCloseAsyncHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptCloseAsyncHandle(HCRYPTASYNC hAsync)
     * }
     */
    public static int CryptCloseAsyncHandle(MemorySegment hAsync) {
        var mh$ = CryptCloseAsyncHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptCloseAsyncHandle", hAsync);
            }
            return (int)mh$.invokeExact(hAsync);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_BLOB_ARRAY {
     *     DWORD cBlob;
     *     PCRYPT_DATA_BLOB rgBlob;
     * } *PCRYPT_BLOB_ARRAY
     * }
     */
    public static final AddressLayout PCRYPT_BLOB_ARRAY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CREDENTIALS {
     *     DWORD cbSize;
     *     LPCSTR pszCredentialsOid;
     *     LPVOID pvCredentials;
     * } *PCRYPT_CREDENTIALS
     * }
     */
    public static final AddressLayout PCRYPT_CREDENTIALS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PASSWORD_CREDENTIALSA {
     *     DWORD cbSize;
     *     LPSTR pszUsername;
     *     LPSTR pszPassword;
     * } *PCRYPT_PASSWORD_CREDENTIALSA
     * }
     */
    public static final AddressLayout PCRYPT_PASSWORD_CREDENTIALSA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PASSWORD_CREDENTIALSW {
     *     DWORD cbSize;
     *     LPWSTR pszUsername;
     *     LPWSTR pszPassword;
     * } *PCRYPT_PASSWORD_CREDENTIALSW
     * }
     */
    public static final AddressLayout PCRYPT_PASSWORD_CREDENTIALSW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCRYPT_PASSWORD_CREDENTIALSA PCRYPT_PASSWORD_CREDENTIALS
     * }
     */
    public static final AddressLayout PCRYPT_PASSWORD_CREDENTIALS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTNET_URL_CACHE_PRE_FETCH_INFO {
     *     DWORD cbSize;
     *     DWORD dwObjectType;
     *     DWORD dwError;
     *     DWORD dwReserved;
     *     FILETIME ThisUpdateTime;
     *     FILETIME NextUpdateTime;
     *     FILETIME PublishTime;
     * } *PCRYPTNET_URL_CACHE_PRE_FETCH_INFO
     * }
     */
    public static final AddressLayout PCRYPTNET_URL_CACHE_PRE_FETCH_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTNET_URL_CACHE_FLUSH_INFO {
     *     DWORD cbSize;
     *     DWORD dwExemptSeconds;
     *     FILETIME ExpireTime;
     * } *PCRYPTNET_URL_CACHE_FLUSH_INFO
     * }
     */
    public static final AddressLayout PCRYPTNET_URL_CACHE_FLUSH_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTNET_URL_CACHE_RESPONSE_INFO {
     *     DWORD cbSize;
     *     WORD wResponseType;
     *     WORD wResponseFlags;
     *     FILETIME LastModifiedTime;
     *     DWORD dwMaxAge;
     *     LPCWSTR pwszETag;
     *     DWORD dwProxyId;
     * } *PCRYPTNET_URL_CACHE_RESPONSE_INFO
     * }
     */
    public static final AddressLayout PCRYPTNET_URL_CACHE_RESPONSE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RETRIEVE_AUX_INFO {
     *     DWORD cbSize;
     *     FILETIME *pLastSyncTime;
     *     DWORD dwMaxUrlRetrievalByteCount;
     *     PCRYPTNET_URL_CACHE_PRE_FETCH_INFO pPreFetchInfo;
     *     PCRYPTNET_URL_CACHE_FLUSH_INFO pFlushInfo;
     *     PCRYPTNET_URL_CACHE_RESPONSE_INFO *ppResponseInfo;
     *     LPWSTR pwszCacheFileNamePrefix;
     *     LPFILETIME pftCacheResync;
     *     BOOL fProxyCacheRetrieval;
     *     DWORD dwHttpStatusCode;
     *     LPWSTR *ppwszErrorResponseHeaders;
     *     PCRYPT_DATA_BLOB *ppErrorContentBlob;
     * } *PCRYPT_RETRIEVE_AUX_INFO
     * }
     */
    public static final AddressLayout PCRYPT_RETRIEVE_AUX_INFO = wgl_h.C_POINTER;

    private static class CryptRetrieveObjectByUrlA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptRetrieveObjectByUrlA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlA(LPCSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static FunctionDescriptor CryptRetrieveObjectByUrlA$descriptor() {
        return CryptRetrieveObjectByUrlA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlA(LPCSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static MethodHandle CryptRetrieveObjectByUrlA$handle() {
        return CryptRetrieveObjectByUrlA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlA(LPCSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static MemorySegment CryptRetrieveObjectByUrlA$address() {
        return CryptRetrieveObjectByUrlA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlA(LPCSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static int CryptRetrieveObjectByUrlA(MemorySegment pszUrl, MemorySegment pszObjectOid, int dwRetrievalFlags, int dwTimeout, MemorySegment ppvObject, MemorySegment hAsyncRetrieve, MemorySegment pCredentials, MemorySegment pvVerify, MemorySegment pAuxInfo) {
        var mh$ = CryptRetrieveObjectByUrlA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRetrieveObjectByUrlA", pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
            }
            return (int)mh$.invokeExact(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptRetrieveObjectByUrlW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptRetrieveObjectByUrlW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlW(LPCWSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static FunctionDescriptor CryptRetrieveObjectByUrlW$descriptor() {
        return CryptRetrieveObjectByUrlW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlW(LPCWSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static MethodHandle CryptRetrieveObjectByUrlW$handle() {
        return CryptRetrieveObjectByUrlW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlW(LPCWSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static MemorySegment CryptRetrieveObjectByUrlW$address() {
        return CryptRetrieveObjectByUrlW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlW(LPCWSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static int CryptRetrieveObjectByUrlW(MemorySegment pszUrl, MemorySegment pszObjectOid, int dwRetrievalFlags, int dwTimeout, MemorySegment ppvObject, MemorySegment hAsyncRetrieve, MemorySegment pCredentials, MemorySegment pvVerify, MemorySegment pAuxInfo) {
        var mh$ = CryptRetrieveObjectByUrlW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRetrieveObjectByUrlW", pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
            }
            return (int)mh$.invokeExact(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptInstallCancelRetrieval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptInstallCancelRetrieval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptInstallCancelRetrieval(PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel, const void *pvArg, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CryptInstallCancelRetrieval$descriptor() {
        return CryptInstallCancelRetrieval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptInstallCancelRetrieval(PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel, const void *pvArg, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CryptInstallCancelRetrieval$handle() {
        return CryptInstallCancelRetrieval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptInstallCancelRetrieval(PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel, const void *pvArg, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MemorySegment CryptInstallCancelRetrieval$address() {
        return CryptInstallCancelRetrieval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptInstallCancelRetrieval(PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel, const void *pvArg, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CryptInstallCancelRetrieval(MemorySegment pfnCancel, MemorySegment pvArg, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptInstallCancelRetrieval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptInstallCancelRetrieval", pfnCancel, pvArg, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pfnCancel, pvArg, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUninstallCancelRetrieval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptUninstallCancelRetrieval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUninstallCancelRetrieval(DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CryptUninstallCancelRetrieval$descriptor() {
        return CryptUninstallCancelRetrieval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUninstallCancelRetrieval(DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CryptUninstallCancelRetrieval$handle() {
        return CryptUninstallCancelRetrieval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUninstallCancelRetrieval(DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MemorySegment CryptUninstallCancelRetrieval$address() {
        return CryptUninstallCancelRetrieval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUninstallCancelRetrieval(DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CryptUninstallCancelRetrieval(int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptUninstallCancelRetrieval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUninstallCancelRetrieval", dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptCancelAsyncRetrieval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptCancelAsyncRetrieval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptCancelAsyncRetrieval(HCRYPTASYNC hAsyncRetrieval)
     * }
     */
    public static FunctionDescriptor CryptCancelAsyncRetrieval$descriptor() {
        return CryptCancelAsyncRetrieval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptCancelAsyncRetrieval(HCRYPTASYNC hAsyncRetrieval)
     * }
     */
    public static MethodHandle CryptCancelAsyncRetrieval$handle() {
        return CryptCancelAsyncRetrieval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptCancelAsyncRetrieval(HCRYPTASYNC hAsyncRetrieval)
     * }
     */
    public static MemorySegment CryptCancelAsyncRetrieval$address() {
        return CryptCancelAsyncRetrieval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptCancelAsyncRetrieval(HCRYPTASYNC hAsyncRetrieval)
     * }
     */
    public static int CryptCancelAsyncRetrieval(MemorySegment hAsyncRetrieval) {
        var mh$ = CryptCancelAsyncRetrieval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptCancelAsyncRetrieval", hAsyncRetrieval);
            }
            return (int)mh$.invokeExact(hAsyncRetrieval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ASYNC_RETRIEVAL_COMPLETION {
     *     PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC pfnCompletion;
     *     LPVOID pvCompletion;
     * } *PCRYPT_ASYNC_RETRIEVAL_COMPLETION
     * }
     */
    public static final AddressLayout PCRYPT_ASYNC_RETRIEVAL_COMPLETION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_URL_ARRAY {
     *     DWORD cUrl;
     *     LPWSTR *rgwszUrl;
     * } *PCRYPT_URL_ARRAY
     * }
     */
    public static final AddressLayout PCRYPT_URL_ARRAY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_URL_INFO {
     *     DWORD cbSize;
     *     DWORD dwSyncDeltaTime;
     *     DWORD cGroup;
     *     DWORD *rgcGroupEntry;
     * } *PCRYPT_URL_INFO
     * }
     */
    public static final AddressLayout PCRYPT_URL_INFO = wgl_h.C_POINTER;

    private static class CryptGetObjectUrl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetObjectUrl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetObjectUrl(LPCSTR pszUrlOid, LPVOID pvPara, DWORD dwFlags, PCRYPT_URL_ARRAY pUrlArray, DWORD *pcbUrlArray, PCRYPT_URL_INFO pUrlInfo, DWORD *pcbUrlInfo, LPVOID pvReserved)
     * }
     */
    public static FunctionDescriptor CryptGetObjectUrl$descriptor() {
        return CryptGetObjectUrl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetObjectUrl(LPCSTR pszUrlOid, LPVOID pvPara, DWORD dwFlags, PCRYPT_URL_ARRAY pUrlArray, DWORD *pcbUrlArray, PCRYPT_URL_INFO pUrlInfo, DWORD *pcbUrlInfo, LPVOID pvReserved)
     * }
     */
    public static MethodHandle CryptGetObjectUrl$handle() {
        return CryptGetObjectUrl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetObjectUrl(LPCSTR pszUrlOid, LPVOID pvPara, DWORD dwFlags, PCRYPT_URL_ARRAY pUrlArray, DWORD *pcbUrlArray, PCRYPT_URL_INFO pUrlInfo, DWORD *pcbUrlInfo, LPVOID pvReserved)
     * }
     */
    public static MemorySegment CryptGetObjectUrl$address() {
        return CryptGetObjectUrl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetObjectUrl(LPCSTR pszUrlOid, LPVOID pvPara, DWORD dwFlags, PCRYPT_URL_ARRAY pUrlArray, DWORD *pcbUrlArray, PCRYPT_URL_INFO pUrlInfo, DWORD *pcbUrlInfo, LPVOID pvReserved)
     * }
     */
    public static int CryptGetObjectUrl(MemorySegment pszUrlOid, MemorySegment pvPara, int dwFlags, MemorySegment pUrlArray, MemorySegment pcbUrlArray, MemorySegment pUrlInfo, MemorySegment pcbUrlInfo, MemorySegment pvReserved) {
        var mh$ = CryptGetObjectUrl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetObjectUrl", pszUrlOid, pvPara, dwFlags, pUrlArray, pcbUrlArray, pUrlInfo, pcbUrlInfo, pvReserved);
            }
            return (int)mh$.invokeExact(pszUrlOid, pvPara, dwFlags, pUrlArray, pcbUrlArray, pUrlInfo, pcbUrlInfo, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CRL_CONTEXT_PAIR {
     *     PCCERT_CONTEXT pCertContext;
     *     PCCRL_CONTEXT pCrlContext;
     * } *PCERT_CRL_CONTEXT_PAIR
     * }
     */
    public static final AddressLayout PCERT_CRL_CONTEXT_PAIR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_CRL_CONTEXT_PAIR *PCCERT_CRL_CONTEXT_PAIR
     * }
     */
    public static final AddressLayout PCCERT_CRL_CONTEXT_PAIR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO {
     *     DWORD cbSize;
     *     int iDeltaCrlIndicator;
     *     LPFILETIME pftCacheResync;
     *     LPFILETIME pLastSyncTime;
     *     LPFILETIME pMaxAgeTime;
     *     PCERT_REVOCATION_CHAIN_PARA pChainPara;
     *     PCRYPT_INTEGER_BLOB pDeltaCrlIndicator;
     * } *PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO
     * }
     */
    public static final AddressLayout PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = wgl_h.C_POINTER;

    private static class CryptGetTimeValidObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetTimeValidObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetTimeValidObject(LPCSTR pszTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, LPFILETIME pftValidFor, DWORD dwFlags, DWORD dwTimeout, LPVOID *ppvObject, PCRYPT_CREDENTIALS pCredentials, PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO pExtraInfo)
     * }
     */
    public static FunctionDescriptor CryptGetTimeValidObject$descriptor() {
        return CryptGetTimeValidObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetTimeValidObject(LPCSTR pszTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, LPFILETIME pftValidFor, DWORD dwFlags, DWORD dwTimeout, LPVOID *ppvObject, PCRYPT_CREDENTIALS pCredentials, PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO pExtraInfo)
     * }
     */
    public static MethodHandle CryptGetTimeValidObject$handle() {
        return CryptGetTimeValidObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetTimeValidObject(LPCSTR pszTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, LPFILETIME pftValidFor, DWORD dwFlags, DWORD dwTimeout, LPVOID *ppvObject, PCRYPT_CREDENTIALS pCredentials, PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO pExtraInfo)
     * }
     */
    public static MemorySegment CryptGetTimeValidObject$address() {
        return CryptGetTimeValidObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetTimeValidObject(LPCSTR pszTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, LPFILETIME pftValidFor, DWORD dwFlags, DWORD dwTimeout, LPVOID *ppvObject, PCRYPT_CREDENTIALS pCredentials, PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO pExtraInfo)
     * }
     */
    public static int CryptGetTimeValidObject(MemorySegment pszTimeValidOid, MemorySegment pvPara, MemorySegment pIssuer, MemorySegment pftValidFor, int dwFlags, int dwTimeout, MemorySegment ppvObject, MemorySegment pCredentials, MemorySegment pExtraInfo) {
        var mh$ = CryptGetTimeValidObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetTimeValidObject", pszTimeValidOid, pvPara, pIssuer, pftValidFor, dwFlags, dwTimeout, ppvObject, pCredentials, pExtraInfo);
            }
            return (int)mh$.invokeExact(pszTimeValidOid, pvPara, pIssuer, pftValidFor, dwFlags, dwTimeout, ppvObject, pCredentials, pExtraInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptFlushTimeValidObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptFlushTimeValidObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptFlushTimeValidObject(LPCSTR pszFlushTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static FunctionDescriptor CryptFlushTimeValidObject$descriptor() {
        return CryptFlushTimeValidObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptFlushTimeValidObject(LPCSTR pszFlushTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MethodHandle CryptFlushTimeValidObject$handle() {
        return CryptFlushTimeValidObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptFlushTimeValidObject(LPCSTR pszFlushTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MemorySegment CryptFlushTimeValidObject$address() {
        return CryptFlushTimeValidObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptFlushTimeValidObject(LPCSTR pszFlushTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static int CryptFlushTimeValidObject(MemorySegment pszFlushTimeValidOid, MemorySegment pvPara, MemorySegment pIssuer, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptFlushTimeValidObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFlushTimeValidObject", pszFlushTimeValidOid, pvPara, pIssuer, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pszFlushTimeValidOid, pvPara, pIssuer, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateSelfSignCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCreateSelfSignCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateSelfSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, PCERT_NAME_BLOB pSubjectIssuerBlob, DWORD dwFlags, PCRYPT_KEY_PROV_INFO pKeyProvInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, PSYSTEMTIME pStartTime, PSYSTEMTIME pEndTime, PCERT_EXTENSIONS pExtensions)
     * }
     */
    public static FunctionDescriptor CertCreateSelfSignCertificate$descriptor() {
        return CertCreateSelfSignCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateSelfSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, PCERT_NAME_BLOB pSubjectIssuerBlob, DWORD dwFlags, PCRYPT_KEY_PROV_INFO pKeyProvInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, PSYSTEMTIME pStartTime, PSYSTEMTIME pEndTime, PCERT_EXTENSIONS pExtensions)
     * }
     */
    public static MethodHandle CertCreateSelfSignCertificate$handle() {
        return CertCreateSelfSignCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateSelfSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, PCERT_NAME_BLOB pSubjectIssuerBlob, DWORD dwFlags, PCRYPT_KEY_PROV_INFO pKeyProvInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, PSYSTEMTIME pStartTime, PSYSTEMTIME pEndTime, PCERT_EXTENSIONS pExtensions)
     * }
     */
    public static MemorySegment CertCreateSelfSignCertificate$address() {
        return CertCreateSelfSignCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateSelfSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, PCERT_NAME_BLOB pSubjectIssuerBlob, DWORD dwFlags, PCRYPT_KEY_PROV_INFO pKeyProvInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, PSYSTEMTIME pStartTime, PSYSTEMTIME pEndTime, PCERT_EXTENSIONS pExtensions)
     * }
     */
    public static MemorySegment CertCreateSelfSignCertificate(long hCryptProvOrNCryptKey, MemorySegment pSubjectIssuerBlob, int dwFlags, MemorySegment pKeyProvInfo, MemorySegment pSignatureAlgorithm, MemorySegment pStartTime, MemorySegment pEndTime, MemorySegment pExtensions) {
        var mh$ = CertCreateSelfSignCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateSelfSignCertificate", hCryptProvOrNCryptKey, pSubjectIssuerBlob, dwFlags, pKeyProvInfo, pSignatureAlgorithm, pStartTime, pEndTime, pExtensions);
            }
            return (MemorySegment)mh$.invokeExact(hCryptProvOrNCryptKey, pSubjectIssuerBlob, dwFlags, pKeyProvInfo, pSignatureAlgorithm, pStartTime, pEndTime, pExtensions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetKeyIdentifierProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptGetKeyIdentifierProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CryptGetKeyIdentifierProperty$descriptor() {
        return CryptGetKeyIdentifierProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CryptGetKeyIdentifierProperty$handle() {
        return CryptGetKeyIdentifierProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CryptGetKeyIdentifierProperty$address() {
        return CryptGetKeyIdentifierProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CryptGetKeyIdentifierProperty(MemorySegment pKeyIdentifier, int dwPropId, int dwFlags, MemorySegment pwszComputerName, MemorySegment pvReserved, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CryptGetKeyIdentifierProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetKeyIdentifierProperty", pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData, pcbData);
            }
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetKeyIdentifierProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptSetKeyIdentifierProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, const void *pvData)
     * }
     */
    public static FunctionDescriptor CryptSetKeyIdentifierProperty$descriptor() {
        return CryptSetKeyIdentifierProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, const void *pvData)
     * }
     */
    public static MethodHandle CryptSetKeyIdentifierProperty$handle() {
        return CryptSetKeyIdentifierProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, const void *pvData)
     * }
     */
    public static MemorySegment CryptSetKeyIdentifierProperty$address() {
        return CryptSetKeyIdentifierProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, const void *pvData)
     * }
     */
    public static int CryptSetKeyIdentifierProperty(MemorySegment pKeyIdentifier, int dwPropId, int dwFlags, MemorySegment pwszComputerName, MemorySegment pvReserved, MemorySegment pvData) {
        var mh$ = CryptSetKeyIdentifierProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetKeyIdentifierProperty", pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData);
            }
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumKeyIdentifierProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptEnumKeyIdentifierProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumKeyIdentifierProperties(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvArg, PFN_CRYPT_ENUM_KEYID_PROP pfnEnum)
     * }
     */
    public static FunctionDescriptor CryptEnumKeyIdentifierProperties$descriptor() {
        return CryptEnumKeyIdentifierProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumKeyIdentifierProperties(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvArg, PFN_CRYPT_ENUM_KEYID_PROP pfnEnum)
     * }
     */
    public static MethodHandle CryptEnumKeyIdentifierProperties$handle() {
        return CryptEnumKeyIdentifierProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEnumKeyIdentifierProperties(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvArg, PFN_CRYPT_ENUM_KEYID_PROP pfnEnum)
     * }
     */
    public static MemorySegment CryptEnumKeyIdentifierProperties$address() {
        return CryptEnumKeyIdentifierProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEnumKeyIdentifierProperties(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvArg, PFN_CRYPT_ENUM_KEYID_PROP pfnEnum)
     * }
     */
    public static int CryptEnumKeyIdentifierProperties(MemorySegment pKeyIdentifier, int dwPropId, int dwFlags, MemorySegment pwszComputerName, MemorySegment pvReserved, MemorySegment pvArg, MemorySegment pfnEnum) {
        var mh$ = CryptEnumKeyIdentifierProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumKeyIdentifierProperties", pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvArg, pfnEnum);
            }
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvArg, pfnEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptCreateKeyIdentifierFromCSP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptCreateKeyIdentifierFromCSP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptCreateKeyIdentifierFromCSP(DWORD dwCertEncodingType, LPCSTR pszPubKeyOID, const PUBLICKEYSTRUC *pPubKeyStruc, DWORD cbPubKeyStruc, DWORD dwFlags, void *pvReserved, BYTE *pbHash, DWORD *pcbHash)
     * }
     */
    public static FunctionDescriptor CryptCreateKeyIdentifierFromCSP$descriptor() {
        return CryptCreateKeyIdentifierFromCSP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptCreateKeyIdentifierFromCSP(DWORD dwCertEncodingType, LPCSTR pszPubKeyOID, const PUBLICKEYSTRUC *pPubKeyStruc, DWORD cbPubKeyStruc, DWORD dwFlags, void *pvReserved, BYTE *pbHash, DWORD *pcbHash)
     * }
     */
    public static MethodHandle CryptCreateKeyIdentifierFromCSP$handle() {
        return CryptCreateKeyIdentifierFromCSP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptCreateKeyIdentifierFromCSP(DWORD dwCertEncodingType, LPCSTR pszPubKeyOID, const PUBLICKEYSTRUC *pPubKeyStruc, DWORD cbPubKeyStruc, DWORD dwFlags, void *pvReserved, BYTE *pbHash, DWORD *pcbHash)
     * }
     */
    public static MemorySegment CryptCreateKeyIdentifierFromCSP$address() {
        return CryptCreateKeyIdentifierFromCSP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptCreateKeyIdentifierFromCSP(DWORD dwCertEncodingType, LPCSTR pszPubKeyOID, const PUBLICKEYSTRUC *pPubKeyStruc, DWORD cbPubKeyStruc, DWORD dwFlags, void *pvReserved, BYTE *pbHash, DWORD *pcbHash)
     * }
     */
    public static int CryptCreateKeyIdentifierFromCSP(int dwCertEncodingType, MemorySegment pszPubKeyOID, MemorySegment pPubKeyStruc, int cbPubKeyStruc, int dwFlags, MemorySegment pvReserved, MemorySegment pbHash, MemorySegment pcbHash) {
        var mh$ = CryptCreateKeyIdentifierFromCSP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptCreateKeyIdentifierFromCSP", dwCertEncodingType, pszPubKeyOID, pPubKeyStruc, cbPubKeyStruc, dwFlags, pvReserved, pbHash, pcbHash);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pszPubKeyOID, pPubKeyStruc, cbPubKeyStruc, dwFlags, pvReserved, pbHash, pcbHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef HANDLE HCERTCHAINENGINE
     * }
     */
    public static final AddressLayout HCERTCHAINENGINE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_ENGINE_CONFIG {
     *     DWORD cbSize;
     *     HCERTSTORE hRestrictedRoot;
     *     HCERTSTORE hRestrictedTrust;
     *     HCERTSTORE hRestrictedOther;
     *     DWORD cAdditionalStore;
     *     HCERTSTORE *rghAdditionalStore;
     *     DWORD dwFlags;
     *     DWORD dwUrlRetrievalTimeout;
     *     DWORD MaximumCachedCertificates;
     *     DWORD CycleDetectionModulus;
     *     HCERTSTORE hExclusiveRoot;
     *     HCERTSTORE hExclusiveTrustedPeople;
     *     DWORD dwExclusiveFlags;
     * } *PCERT_CHAIN_ENGINE_CONFIG
     * }
     */
    public static final AddressLayout PCERT_CHAIN_ENGINE_CONFIG = wgl_h.C_POINTER;

    private static class CertCreateCertificateChainEngine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCreateCertificateChainEngine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCreateCertificateChainEngine(PCERT_CHAIN_ENGINE_CONFIG pConfig, HCERTCHAINENGINE *phChainEngine)
     * }
     */
    public static FunctionDescriptor CertCreateCertificateChainEngine$descriptor() {
        return CertCreateCertificateChainEngine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCreateCertificateChainEngine(PCERT_CHAIN_ENGINE_CONFIG pConfig, HCERTCHAINENGINE *phChainEngine)
     * }
     */
    public static MethodHandle CertCreateCertificateChainEngine$handle() {
        return CertCreateCertificateChainEngine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCreateCertificateChainEngine(PCERT_CHAIN_ENGINE_CONFIG pConfig, HCERTCHAINENGINE *phChainEngine)
     * }
     */
    public static MemorySegment CertCreateCertificateChainEngine$address() {
        return CertCreateCertificateChainEngine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCreateCertificateChainEngine(PCERT_CHAIN_ENGINE_CONFIG pConfig, HCERTCHAINENGINE *phChainEngine)
     * }
     */
    public static int CertCreateCertificateChainEngine(MemorySegment pConfig, MemorySegment phChainEngine) {
        var mh$ = CertCreateCertificateChainEngine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCertificateChainEngine", pConfig, phChainEngine);
            }
            return (int)mh$.invokeExact(pConfig, phChainEngine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCertificateChainEngine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFreeCertificateChainEngine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static FunctionDescriptor CertFreeCertificateChainEngine$descriptor() {
        return CertFreeCertificateChainEngine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static MethodHandle CertFreeCertificateChainEngine$handle() {
        return CertFreeCertificateChainEngine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static MemorySegment CertFreeCertificateChainEngine$address() {
        return CertFreeCertificateChainEngine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertFreeCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static void CertFreeCertificateChainEngine(MemorySegment hChainEngine) {
        var mh$ = CertFreeCertificateChainEngine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCertificateChainEngine", hChainEngine);
            }
            mh$.invokeExact(hChainEngine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertResyncCertificateChainEngine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertResyncCertificateChainEngine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertResyncCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static FunctionDescriptor CertResyncCertificateChainEngine$descriptor() {
        return CertResyncCertificateChainEngine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertResyncCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static MethodHandle CertResyncCertificateChainEngine$handle() {
        return CertResyncCertificateChainEngine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertResyncCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static MemorySegment CertResyncCertificateChainEngine$address() {
        return CertResyncCertificateChainEngine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertResyncCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static int CertResyncCertificateChainEngine(MemorySegment hChainEngine) {
        var mh$ = CertResyncCertificateChainEngine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertResyncCertificateChainEngine", hChainEngine);
            }
            return (int)mh$.invokeExact(hChainEngine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_TRUST_STATUS {
     *     DWORD dwErrorStatus;
     *     DWORD dwInfoStatus;
     * } *PCERT_TRUST_STATUS
     * }
     */
    public static final AddressLayout PCERT_TRUST_STATUS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_INFO {
     *     DWORD cbSize;
     *     DWORD dwRevocationResult;
     *     LPCSTR pszRevocationOid;
     *     LPVOID pvOidSpecificInfo;
     *     BOOL fHasFreshnessTime;
     *     DWORD dwFreshnessTime;
     *     PCERT_REVOCATION_CRL_INFO pCrlInfo;
     * } *PCERT_REVOCATION_INFO
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_TRUST_LIST_INFO {
     *     DWORD cbSize;
     *     PCTL_ENTRY pCtlEntry;
     *     PCCTL_CONTEXT pCtlContext;
     * } *PCERT_TRUST_LIST_INFO
     * }
     */
    public static final AddressLayout PCERT_TRUST_LIST_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_ELEMENT {
     *     DWORD cbSize;
     *     PCCERT_CONTEXT pCertContext;
     *     CERT_TRUST_STATUS TrustStatus;
     *     PCERT_REVOCATION_INFO pRevocationInfo;
     *     PCERT_ENHKEY_USAGE pIssuanceUsage;
     *     PCERT_ENHKEY_USAGE pApplicationUsage;
     *     LPCWSTR pwszExtendedErrorInfo;
     * } *PCERT_CHAIN_ELEMENT
     * }
     */
    public static final AddressLayout PCERT_CHAIN_ELEMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_CHAIN_ELEMENT *PCCERT_CHAIN_ELEMENT
     * }
     */
    public static final AddressLayout PCCERT_CHAIN_ELEMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SIMPLE_CHAIN {
     *     DWORD cbSize;
     *     CERT_TRUST_STATUS TrustStatus;
     *     DWORD cElement;
     *     PCERT_CHAIN_ELEMENT *rgpElement;
     *     PCERT_TRUST_LIST_INFO pTrustListInfo;
     *     BOOL fHasRevocationFreshnessTime;
     *     DWORD dwRevocationFreshnessTime;
     * } *PCERT_SIMPLE_CHAIN
     * }
     */
    public static final AddressLayout PCERT_SIMPLE_CHAIN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_SIMPLE_CHAIN *PCCERT_SIMPLE_CHAIN
     * }
     */
    public static final AddressLayout PCCERT_SIMPLE_CHAIN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_CONTEXT *PCERT_CHAIN_CONTEXT
     * }
     */
    public static final AddressLayout PCERT_CHAIN_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_CHAIN_CONTEXT *PCCERT_CHAIN_CONTEXT
     * }
     */
    public static final AddressLayout PCCERT_CHAIN_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_USAGE_MATCH {
     *     DWORD dwType;
     *     CERT_ENHKEY_USAGE Usage;
     * } *PCERT_USAGE_MATCH
     * }
     */
    public static final AddressLayout PCERT_USAGE_MATCH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_USAGE_MATCH {
     *     DWORD dwType;
     *     CTL_USAGE Usage;
     * } *PCTL_USAGE_MATCH
     * }
     */
    public static final AddressLayout PCTL_USAGE_MATCH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_PARA {
     *     DWORD cbSize;
     *     CERT_USAGE_MATCH RequestedUsage;
     * } *PCERT_CHAIN_PARA
     * }
     */
    public static final AddressLayout PCERT_CHAIN_PARA = wgl_h.C_POINTER;

    private static class CertGetCertificateChain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetCertificateChain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateChain(HCERTCHAINENGINE hChainEngine, PCCERT_CONTEXT pCertContext, LPFILETIME pTime, HCERTSTORE hAdditionalStore, PCERT_CHAIN_PARA pChainPara, DWORD dwFlags, LPVOID pvReserved, PCCERT_CHAIN_CONTEXT *ppChainContext)
     * }
     */
    public static FunctionDescriptor CertGetCertificateChain$descriptor() {
        return CertGetCertificateChain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateChain(HCERTCHAINENGINE hChainEngine, PCCERT_CONTEXT pCertContext, LPFILETIME pTime, HCERTSTORE hAdditionalStore, PCERT_CHAIN_PARA pChainPara, DWORD dwFlags, LPVOID pvReserved, PCCERT_CHAIN_CONTEXT *ppChainContext)
     * }
     */
    public static MethodHandle CertGetCertificateChain$handle() {
        return CertGetCertificateChain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateChain(HCERTCHAINENGINE hChainEngine, PCCERT_CONTEXT pCertContext, LPFILETIME pTime, HCERTSTORE hAdditionalStore, PCERT_CHAIN_PARA pChainPara, DWORD dwFlags, LPVOID pvReserved, PCCERT_CHAIN_CONTEXT *ppChainContext)
     * }
     */
    public static MemorySegment CertGetCertificateChain$address() {
        return CertGetCertificateChain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetCertificateChain(HCERTCHAINENGINE hChainEngine, PCCERT_CONTEXT pCertContext, LPFILETIME pTime, HCERTSTORE hAdditionalStore, PCERT_CHAIN_PARA pChainPara, DWORD dwFlags, LPVOID pvReserved, PCCERT_CHAIN_CONTEXT *ppChainContext)
     * }
     */
    public static int CertGetCertificateChain(MemorySegment hChainEngine, MemorySegment pCertContext, MemorySegment pTime, MemorySegment hAdditionalStore, MemorySegment pChainPara, int dwFlags, MemorySegment pvReserved, MemorySegment ppChainContext) {
        var mh$ = CertGetCertificateChain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCertificateChain", hChainEngine, pCertContext, pTime, hAdditionalStore, pChainPara, dwFlags, pvReserved, ppChainContext);
            }
            return (int)mh$.invokeExact(hChainEngine, pCertContext, pTime, hAdditionalStore, pChainPara, dwFlags, pvReserved, ppChainContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCertificateChain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFreeCertificateChain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertFreeCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static FunctionDescriptor CertFreeCertificateChain$descriptor() {
        return CertFreeCertificateChain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertFreeCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static MethodHandle CertFreeCertificateChain$handle() {
        return CertFreeCertificateChain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertFreeCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static MemorySegment CertFreeCertificateChain$address() {
        return CertFreeCertificateChain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertFreeCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static void CertFreeCertificateChain(MemorySegment pChainContext) {
        var mh$ = CertFreeCertificateChain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCertificateChain", pChainContext);
            }
            mh$.invokeExact(pChainContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDuplicateCertificateChain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertDuplicateCertificateChain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertDuplicateCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static FunctionDescriptor CertDuplicateCertificateChain$descriptor() {
        return CertDuplicateCertificateChain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertDuplicateCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static MethodHandle CertDuplicateCertificateChain$handle() {
        return CertDuplicateCertificateChain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertDuplicateCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static MemorySegment CertDuplicateCertificateChain$address() {
        return CertDuplicateCertificateChain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertDuplicateCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static MemorySegment CertDuplicateCertificateChain(MemorySegment pChainContext) {
        var mh$ = CertDuplicateCertificateChain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateCertificateChain", pChainContext);
            }
            return (MemorySegment)mh$.invokeExact(pChainContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_REVOCATION_INFO {
     *     PCRL_ENTRY pCrlEntry;
     *     PCCRL_CONTEXT pCrlContext;
     *     PCCERT_CHAIN_CONTEXT pCrlIssuerChain;
     * } *PCRL_REVOCATION_INFO
     * }
     */
    public static final AddressLayout PCRL_REVOCATION_INFO = wgl_h.C_POINTER;

    private static class CertFindChainInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFindChainInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertFindChainInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CHAIN_CONTEXT pPrevChainContext)
     * }
     */
    public static FunctionDescriptor CertFindChainInStore$descriptor() {
        return CertFindChainInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertFindChainInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CHAIN_CONTEXT pPrevChainContext)
     * }
     */
    public static MethodHandle CertFindChainInStore$handle() {
        return CertFindChainInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertFindChainInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CHAIN_CONTEXT pPrevChainContext)
     * }
     */
    public static MemorySegment CertFindChainInStore$address() {
        return CertFindChainInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertFindChainInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CHAIN_CONTEXT pPrevChainContext)
     * }
     */
    public static MemorySegment CertFindChainInStore(MemorySegment hCertStore, int dwCertEncodingType, int dwFindFlags, int dwFindType, MemorySegment pvFindPara, MemorySegment pPrevChainContext) {
        var mh$ = CertFindChainInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindChainInStore", hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevChainContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevChainContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_FIND_BY_ISSUER_PARA {
     *     DWORD cbSize;
     *     LPCSTR pszUsageIdentifier;
     *     DWORD dwKeySpec;
     *     DWORD dwAcquirePrivateKeyFlags;
     *     DWORD cIssuer;
     *     CERT_NAME_BLOB *rgIssuer;
     *     PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK pfnFindCallback;
     *     void *pvFindArg;
     * } *PCERT_CHAIN_FIND_ISSUER_PARA
     * }
     */
    public static final AddressLayout PCERT_CHAIN_FIND_ISSUER_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_FIND_BY_ISSUER_PARA {
     *     DWORD cbSize;
     *     LPCSTR pszUsageIdentifier;
     *     DWORD dwKeySpec;
     *     DWORD dwAcquirePrivateKeyFlags;
     *     DWORD cIssuer;
     *     CERT_NAME_BLOB *rgIssuer;
     *     PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK pfnFindCallback;
     *     void *pvFindArg;
     * } *PCERT_CHAIN_FIND_BY_ISSUER_PARA
     * }
     */
    public static final AddressLayout PCERT_CHAIN_FIND_BY_ISSUER_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwFlags;
     *     void *pvExtraPolicyPara;
     * } *PCERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PCERT_CHAIN_POLICY_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_POLICY_STATUS {
     *     DWORD cbSize;
     *     DWORD dwError;
     *     LONG lChainIndex;
     *     LONG lElementIndex;
     *     void *pvExtraPolicyStatus;
     * } *PCERT_CHAIN_POLICY_STATUS
     * }
     */
    public static final AddressLayout PCERT_CHAIN_POLICY_STATUS = wgl_h.C_POINTER;

    private static class CertVerifyCertificateChainPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertVerifyCertificateChainPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyCertificateChainPolicy(LPCSTR pszPolicyOID, PCCERT_CHAIN_CONTEXT pChainContext, PCERT_CHAIN_POLICY_PARA pPolicyPara, PCERT_CHAIN_POLICY_STATUS pPolicyStatus)
     * }
     */
    public static FunctionDescriptor CertVerifyCertificateChainPolicy$descriptor() {
        return CertVerifyCertificateChainPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyCertificateChainPolicy(LPCSTR pszPolicyOID, PCCERT_CHAIN_CONTEXT pChainContext, PCERT_CHAIN_POLICY_PARA pPolicyPara, PCERT_CHAIN_POLICY_STATUS pPolicyStatus)
     * }
     */
    public static MethodHandle CertVerifyCertificateChainPolicy$handle() {
        return CertVerifyCertificateChainPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifyCertificateChainPolicy(LPCSTR pszPolicyOID, PCCERT_CHAIN_CONTEXT pChainContext, PCERT_CHAIN_POLICY_PARA pPolicyPara, PCERT_CHAIN_POLICY_STATUS pPolicyStatus)
     * }
     */
    public static MemorySegment CertVerifyCertificateChainPolicy$address() {
        return CertVerifyCertificateChainPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifyCertificateChainPolicy(LPCSTR pszPolicyOID, PCCERT_CHAIN_CONTEXT pChainContext, PCERT_CHAIN_POLICY_PARA pPolicyPara, PCERT_CHAIN_POLICY_STATUS pPolicyStatus)
     * }
     */
    public static int CertVerifyCertificateChainPolicy(MemorySegment pszPolicyOID, MemorySegment pChainContext, MemorySegment pPolicyPara, MemorySegment pPolicyStatus) {
        var mh$ = CertVerifyCertificateChainPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyCertificateChainPolicy", pszPolicyOID, pChainContext, pPolicyPara, pPolicyStatus);
            }
            return (int)mh$.invokeExact(pszPolicyOID, pChainContext, pPolicyPara, pPolicyStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwRegPolicySettings;
     *     PCMSG_SIGNER_INFO pSignerInfo;
     * } *PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS {
     *     DWORD cbSize;
     *     BOOL fCommercial;
     * } *PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS
     * }
     */
    public static final AddressLayout PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwRegPolicySettings;
     *     BOOL fCommercial;
     * } *PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _HTTPSPolicyCallbackData {
     *     union {
     *         DWORD cbStruct;
     *         DWORD cbSize;
     *     };
     *     DWORD dwAuthType;
     *     DWORD fdwChecks;
     *     WCHAR *pwszServerName;
     * } *PHTTPSPolicyCallbackData
     * }
     */
    public static final AddressLayout PHTTPSPolicyCallbackData = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _HTTPSPolicyCallbackData {
     *     union {
     *         DWORD cbStruct;
     *         DWORD cbSize;
     *     };
     *     DWORD dwAuthType;
     *     DWORD fdwChecks;
     *     WCHAR *pwszServerName;
     * } *PSSL_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PSSL_EXTRA_CERT_CHAIN_POLICY_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EV_EXTRA_CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwRootProgramQualifierFlags;
     * } *PEV_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PEV_EXTRA_CERT_CHAIN_POLICY_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EV_EXTRA_CERT_CHAIN_POLICY_STATUS {
     *     DWORD cbSize;
     *     DWORD dwQualifiers;
     *     DWORD dwIssuanceUsageIndex;
     * } *PEV_EXTRA_CERT_CHAIN_POLICY_STATUS
     * }
     */
    public static final AddressLayout PEV_EXTRA_CERT_CHAIN_POLICY_STATUS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS {
     *     DWORD cbSize;
     *     DWORD dwErrorLevel;
     *     DWORD dwErrorCategory;
     *     DWORD dwReserved;
     *     WCHAR wszErrorText[256];
     * } *PSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS
     * }
     */
    public static final AddressLayout PSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwReserved;
     *     LPWSTR pwszServerName;
     *     LPSTR rgpszHpkpValue[2];
     * } *PSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwReserved;
     *     PCWSTR pwszServerName;
     * } *PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS {
     *     DWORD cbSize;
     *     LONG lError;
     *     WCHAR wszErrorText[512];
     * } *PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS
     * }
     */
    public static final AddressLayout PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = wgl_h.C_POINTER;

    private static class CryptStringToBinaryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptStringToBinaryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryA(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CryptStringToBinaryA$descriptor() {
        return CryptStringToBinaryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryA(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CryptStringToBinaryA$handle() {
        return CryptStringToBinaryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryA(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CryptStringToBinaryA$address() {
        return CryptStringToBinaryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryA(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static int CryptStringToBinaryA(MemorySegment pszString, int cchString, int dwFlags, MemorySegment pbBinary, MemorySegment pcbBinary, MemorySegment pdwSkip, MemorySegment pdwFlags) {
        var mh$ = CryptStringToBinaryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptStringToBinaryA", pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
            }
            return (int)mh$.invokeExact(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptStringToBinaryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptStringToBinaryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryW(LPCWSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CryptStringToBinaryW$descriptor() {
        return CryptStringToBinaryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryW(LPCWSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CryptStringToBinaryW$handle() {
        return CryptStringToBinaryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryW(LPCWSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CryptStringToBinaryW$address() {
        return CryptStringToBinaryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryW(LPCWSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static int CryptStringToBinaryW(MemorySegment pszString, int cchString, int dwFlags, MemorySegment pbBinary, MemorySegment pcbBinary, MemorySegment pdwSkip, MemorySegment pdwFlags) {
        var mh$ = CryptStringToBinaryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptStringToBinaryW", pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
            }
            return (int)mh$.invokeExact(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptBinaryToStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptBinaryToStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringA(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString)
     * }
     */
    public static FunctionDescriptor CryptBinaryToStringA$descriptor() {
        return CryptBinaryToStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringA(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString)
     * }
     */
    public static MethodHandle CryptBinaryToStringA$handle() {
        return CryptBinaryToStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringA(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString)
     * }
     */
    public static MemorySegment CryptBinaryToStringA$address() {
        return CryptBinaryToStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringA(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString)
     * }
     */
    public static int CryptBinaryToStringA(MemorySegment pbBinary, int cbBinary, int dwFlags, MemorySegment pszString, MemorySegment pcchString) {
        var mh$ = CryptBinaryToStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptBinaryToStringA", pbBinary, cbBinary, dwFlags, pszString, pcchString);
            }
            return (int)mh$.invokeExact(pbBinary, cbBinary, dwFlags, pszString, pcchString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptBinaryToStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptBinaryToStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringW(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPWSTR pszString, DWORD *pcchString)
     * }
     */
    public static FunctionDescriptor CryptBinaryToStringW$descriptor() {
        return CryptBinaryToStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringW(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPWSTR pszString, DWORD *pcchString)
     * }
     */
    public static MethodHandle CryptBinaryToStringW$handle() {
        return CryptBinaryToStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringW(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPWSTR pszString, DWORD *pcchString)
     * }
     */
    public static MemorySegment CryptBinaryToStringW$address() {
        return CryptBinaryToStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringW(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPWSTR pszString, DWORD *pcchString)
     * }
     */
    public static int CryptBinaryToStringW(MemorySegment pbBinary, int cbBinary, int dwFlags, MemorySegment pszString, MemorySegment pcchString) {
        var mh$ = CryptBinaryToStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptBinaryToStringW", pbBinary, cbBinary, dwFlags, pszString, pcchString);
            }
            return (int)mh$.invokeExact(pbBinary, cbBinary, dwFlags, pszString, pcchString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PFXImportCertStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PFXImportCertStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE PFXImportCertStore(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor PFXImportCertStore$descriptor() {
        return PFXImportCertStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE PFXImportCertStore(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MethodHandle PFXImportCertStore$handle() {
        return PFXImportCertStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE PFXImportCertStore(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MemorySegment PFXImportCertStore$address() {
        return PFXImportCertStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE PFXImportCertStore(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MemorySegment PFXImportCertStore(MemorySegment pPFX, MemorySegment szPassword, int dwFlags) {
        var mh$ = PFXImportCertStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PFXImportCertStore", pPFX, szPassword, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PFXIsPFXBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PFXIsPFXBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PFXIsPFXBlob(CRYPT_DATA_BLOB *pPFX)
     * }
     */
    public static FunctionDescriptor PFXIsPFXBlob$descriptor() {
        return PFXIsPFXBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PFXIsPFXBlob(CRYPT_DATA_BLOB *pPFX)
     * }
     */
    public static MethodHandle PFXIsPFXBlob$handle() {
        return PFXIsPFXBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PFXIsPFXBlob(CRYPT_DATA_BLOB *pPFX)
     * }
     */
    public static MemorySegment PFXIsPFXBlob$address() {
        return PFXIsPFXBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PFXIsPFXBlob(CRYPT_DATA_BLOB *pPFX)
     * }
     */
    public static int PFXIsPFXBlob(MemorySegment pPFX) {
        var mh$ = PFXIsPFXBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PFXIsPFXBlob", pPFX);
            }
            return (int)mh$.invokeExact(pPFX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PFXVerifyPassword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PFXVerifyPassword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PFXVerifyPassword(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor PFXVerifyPassword$descriptor() {
        return PFXVerifyPassword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PFXVerifyPassword(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MethodHandle PFXVerifyPassword$handle() {
        return PFXVerifyPassword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PFXVerifyPassword(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MemorySegment PFXVerifyPassword$address() {
        return PFXVerifyPassword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PFXVerifyPassword(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static int PFXVerifyPassword(MemorySegment pPFX, MemorySegment szPassword, int dwFlags) {
        var mh$ = PFXVerifyPassword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PFXVerifyPassword", pPFX, szPassword, dwFlags);
            }
            return (int)mh$.invokeExact(pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PFXExportCertStoreEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PFXExportCertStoreEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStoreEx(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, void *pvPara, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor PFXExportCertStoreEx$descriptor() {
        return PFXExportCertStoreEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStoreEx(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, void *pvPara, DWORD dwFlags)
     * }
     */
    public static MethodHandle PFXExportCertStoreEx$handle() {
        return PFXExportCertStoreEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStoreEx(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, void *pvPara, DWORD dwFlags)
     * }
     */
    public static MemorySegment PFXExportCertStoreEx$address() {
        return PFXExportCertStoreEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PFXExportCertStoreEx(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, void *pvPara, DWORD dwFlags)
     * }
     */
    public static int PFXExportCertStoreEx(MemorySegment hStore, MemorySegment pPFX, MemorySegment szPassword, MemorySegment pvPara, int dwFlags) {
        var mh$ = PFXExportCertStoreEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PFXExportCertStoreEx", hStore, pPFX, szPassword, pvPara, dwFlags);
            }
            return (int)mh$.invokeExact(hStore, pPFX, szPassword, pvPara, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _PKCS12_PBES2_EXPORT_PARAMS {
     *     DWORD dwSize;
     *     PVOID hNcryptDescriptor;
     *     LPWSTR pwszPbes2Alg;
     * } *PPKCS12_PBES2_EXPORT_PARAMS
     * }
     */
    public static final AddressLayout PPKCS12_PBES2_EXPORT_PARAMS = wgl_h.C_POINTER;

    private static class PFXExportCertStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PFXExportCertStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStore(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor PFXExportCertStore$descriptor() {
        return PFXExportCertStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStore(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MethodHandle PFXExportCertStore$handle() {
        return PFXExportCertStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStore(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MemorySegment PFXExportCertStore$address() {
        return PFXExportCertStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PFXExportCertStore(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static int PFXExportCertStore(MemorySegment hStore, MemorySegment pPFX, MemorySegment szPassword, int dwFlags) {
        var mh$ = PFXExportCertStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PFXExportCertStore", hStore, pPFX, szPassword, dwFlags);
            }
            return (int)mh$.invokeExact(hStore, pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *HCERT_SERVER_OCSP_RESPONSE
     * }
     */
    public static final AddressLayout HCERT_SERVER_OCSP_RESPONSE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SERVER_OCSP_RESPONSE_CONTEXT *PCERT_SERVER_OCSP_RESPONSE_CONTEXT
     * }
     */
    public static final AddressLayout PCERT_SERVER_OCSP_RESPONSE_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_SERVER_OCSP_RESPONSE_CONTEXT *PCCERT_SERVER_OCSP_RESPONSE_CONTEXT
     * }
     */
    public static final AddressLayout PCCERT_SERVER_OCSP_RESPONSE_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SERVER_OCSP_RESPONSE_OPEN_PARA {
     *     DWORD cbSize;
     *     DWORD dwFlags;
     *     DWORD *pcbUsedSize;
     *     PWSTR pwszOcspDirectory;
     *     PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK pfnUpdateCallback;
     *     PVOID pvUpdateCallbackArg;
     * } *PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA
     * }
     */
    public static final AddressLayout PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA = wgl_h.C_POINTER;

    private static class CertOpenServerOcspResponse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertOpenServerOcspResponse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERT_SERVER_OCSP_RESPONSE CertOpenServerOcspResponse(PCCERT_CHAIN_CONTEXT pChainContext, DWORD dwFlags, PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA pOpenPara)
     * }
     */
    public static FunctionDescriptor CertOpenServerOcspResponse$descriptor() {
        return CertOpenServerOcspResponse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERT_SERVER_OCSP_RESPONSE CertOpenServerOcspResponse(PCCERT_CHAIN_CONTEXT pChainContext, DWORD dwFlags, PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA pOpenPara)
     * }
     */
    public static MethodHandle CertOpenServerOcspResponse$handle() {
        return CertOpenServerOcspResponse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERT_SERVER_OCSP_RESPONSE CertOpenServerOcspResponse(PCCERT_CHAIN_CONTEXT pChainContext, DWORD dwFlags, PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA pOpenPara)
     * }
     */
    public static MemorySegment CertOpenServerOcspResponse$address() {
        return CertOpenServerOcspResponse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERT_SERVER_OCSP_RESPONSE CertOpenServerOcspResponse(PCCERT_CHAIN_CONTEXT pChainContext, DWORD dwFlags, PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA pOpenPara)
     * }
     */
    public static MemorySegment CertOpenServerOcspResponse(MemorySegment pChainContext, int dwFlags, MemorySegment pOpenPara) {
        var mh$ = CertOpenServerOcspResponse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOpenServerOcspResponse", pChainContext, dwFlags, pOpenPara);
            }
            return (MemorySegment)mh$.invokeExact(pChainContext, dwFlags, pOpenPara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddRefServerOcspResponse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddRefServerOcspResponse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse)
     * }
     */
    public static FunctionDescriptor CertAddRefServerOcspResponse$descriptor() {
        return CertAddRefServerOcspResponse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse)
     * }
     */
    public static MethodHandle CertAddRefServerOcspResponse$handle() {
        return CertAddRefServerOcspResponse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse)
     * }
     */
    public static MemorySegment CertAddRefServerOcspResponse$address() {
        return CertAddRefServerOcspResponse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse)
     * }
     */
    public static void CertAddRefServerOcspResponse(MemorySegment hServerOcspResponse) {
        var mh$ = CertAddRefServerOcspResponse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddRefServerOcspResponse", hServerOcspResponse);
            }
            mh$.invokeExact(hServerOcspResponse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCloseServerOcspResponse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertCloseServerOcspResponse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertCloseServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertCloseServerOcspResponse$descriptor() {
        return CertCloseServerOcspResponse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertCloseServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertCloseServerOcspResponse$handle() {
        return CertCloseServerOcspResponse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertCloseServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertCloseServerOcspResponse$address() {
        return CertCloseServerOcspResponse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertCloseServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags)
     * }
     */
    public static void CertCloseServerOcspResponse(MemorySegment hServerOcspResponse, int dwFlags) {
        var mh$ = CertCloseServerOcspResponse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCloseServerOcspResponse", hServerOcspResponse, dwFlags);
            }
            mh$.invokeExact(hServerOcspResponse, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetServerOcspResponseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertGetServerOcspResponseContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_SERVER_OCSP_RESPONSE_CONTEXT CertGetServerOcspResponseContext(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static FunctionDescriptor CertGetServerOcspResponseContext$descriptor() {
        return CertGetServerOcspResponseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_SERVER_OCSP_RESPONSE_CONTEXT CertGetServerOcspResponseContext(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MethodHandle CertGetServerOcspResponseContext$handle() {
        return CertGetServerOcspResponseContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_SERVER_OCSP_RESPONSE_CONTEXT CertGetServerOcspResponseContext(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MemorySegment CertGetServerOcspResponseContext$address() {
        return CertGetServerOcspResponseContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_SERVER_OCSP_RESPONSE_CONTEXT CertGetServerOcspResponseContext(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MemorySegment CertGetServerOcspResponseContext(MemorySegment hServerOcspResponse, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CertGetServerOcspResponseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetServerOcspResponseContext", hServerOcspResponse, dwFlags, pvReserved);
            }
            return (MemorySegment)mh$.invokeExact(hServerOcspResponse, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddRefServerOcspResponseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertAddRefServerOcspResponseContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static FunctionDescriptor CertAddRefServerOcspResponseContext$descriptor() {
        return CertAddRefServerOcspResponseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static MethodHandle CertAddRefServerOcspResponseContext$handle() {
        return CertAddRefServerOcspResponseContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static MemorySegment CertAddRefServerOcspResponseContext$address() {
        return CertAddRefServerOcspResponseContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static void CertAddRefServerOcspResponseContext(MemorySegment pServerOcspResponseContext) {
        var mh$ = CertAddRefServerOcspResponseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddRefServerOcspResponseContext", pServerOcspResponseContext);
            }
            mh$.invokeExact(pServerOcspResponseContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeServerOcspResponseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFreeServerOcspResponseContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertFreeServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static FunctionDescriptor CertFreeServerOcspResponseContext$descriptor() {
        return CertFreeServerOcspResponseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertFreeServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static MethodHandle CertFreeServerOcspResponseContext$handle() {
        return CertFreeServerOcspResponseContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertFreeServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static MemorySegment CertFreeServerOcspResponseContext$address() {
        return CertFreeServerOcspResponseContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertFreeServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static void CertFreeServerOcspResponseContext(MemorySegment pServerOcspResponseContext) {
        var mh$ = CertFreeServerOcspResponseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeServerOcspResponseContext", pServerOcspResponseContext);
            }
            mh$.invokeExact(pServerOcspResponseContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRetrieveLogoOrBiometricInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertRetrieveLogoOrBiometricInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertRetrieveLogoOrBiometricInfo(PCCERT_CONTEXT pCertContext, LPCSTR lpszLogoOrBiometricType, DWORD dwRetrievalFlags, DWORD dwTimeout, DWORD dwFlags, void *pvReserved, BYTE **ppbData, DWORD *pcbData, LPWSTR *ppwszMimeType)
     * }
     */
    public static FunctionDescriptor CertRetrieveLogoOrBiometricInfo$descriptor() {
        return CertRetrieveLogoOrBiometricInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertRetrieveLogoOrBiometricInfo(PCCERT_CONTEXT pCertContext, LPCSTR lpszLogoOrBiometricType, DWORD dwRetrievalFlags, DWORD dwTimeout, DWORD dwFlags, void *pvReserved, BYTE **ppbData, DWORD *pcbData, LPWSTR *ppwszMimeType)
     * }
     */
    public static MethodHandle CertRetrieveLogoOrBiometricInfo$handle() {
        return CertRetrieveLogoOrBiometricInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertRetrieveLogoOrBiometricInfo(PCCERT_CONTEXT pCertContext, LPCSTR lpszLogoOrBiometricType, DWORD dwRetrievalFlags, DWORD dwTimeout, DWORD dwFlags, void *pvReserved, BYTE **ppbData, DWORD *pcbData, LPWSTR *ppwszMimeType)
     * }
     */
    public static MemorySegment CertRetrieveLogoOrBiometricInfo$address() {
        return CertRetrieveLogoOrBiometricInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertRetrieveLogoOrBiometricInfo(PCCERT_CONTEXT pCertContext, LPCSTR lpszLogoOrBiometricType, DWORD dwRetrievalFlags, DWORD dwTimeout, DWORD dwFlags, void *pvReserved, BYTE **ppbData, DWORD *pcbData, LPWSTR *ppwszMimeType)
     * }
     */
    public static int CertRetrieveLogoOrBiometricInfo(MemorySegment pCertContext, MemorySegment lpszLogoOrBiometricType, int dwRetrievalFlags, int dwTimeout, int dwFlags, MemorySegment pvReserved, MemorySegment ppbData, MemorySegment pcbData, MemorySegment ppwszMimeType) {
        var mh$ = CertRetrieveLogoOrBiometricInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRetrieveLogoOrBiometricInfo", pCertContext, lpszLogoOrBiometricType, dwRetrievalFlags, dwTimeout, dwFlags, pvReserved, ppbData, pcbData, ppwszMimeType);
            }
            return (int)mh$.invokeExact(pCertContext, lpszLogoOrBiometricType, dwRetrievalFlags, dwTimeout, dwFlags, pvReserved, ppbData, pcbData, ppwszMimeType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SELECT_CHAIN_PARA {
     *     HCERTCHAINENGINE hChainEngine;
     *     PFILETIME pTime;
     *     HCERTSTORE hAdditionalStore;
     *     PCERT_CHAIN_PARA pChainPara;
     *     DWORD dwFlags;
     * } *PCERT_SELECT_CHAIN_PARA
     * }
     */
    public static final AddressLayout PCERT_SELECT_CHAIN_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_SELECT_CHAIN_PARA *PCCERT_SELECT_CHAIN_PARA
     * }
     */
    public static final AddressLayout PCCERT_SELECT_CHAIN_PARA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SELECT_CRITERIA {
     *     DWORD dwType;
     *     DWORD cPara;
     *     void **ppPara;
     * } *PCERT_SELECT_CRITERIA
     * }
     */
    public static final AddressLayout PCERT_SELECT_CRITERIA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_SELECT_CRITERIA *PCCERT_SELECT_CRITERIA
     * }
     */
    public static final AddressLayout PCCERT_SELECT_CRITERIA = wgl_h.C_POINTER;

    private static class CertSelectCertificateChains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertSelectCertificateChains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSelectCertificateChains(LPCGUID pSelectionContext, DWORD dwFlags, PCCERT_SELECT_CHAIN_PARA pChainParameters, DWORD cCriteria, PCCERT_SELECT_CRITERIA rgpCriteria, HCERTSTORE hStore, PDWORD pcSelection, PCCERT_CHAIN_CONTEXT **pprgpSelection)
     * }
     */
    public static FunctionDescriptor CertSelectCertificateChains$descriptor() {
        return CertSelectCertificateChains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSelectCertificateChains(LPCGUID pSelectionContext, DWORD dwFlags, PCCERT_SELECT_CHAIN_PARA pChainParameters, DWORD cCriteria, PCCERT_SELECT_CRITERIA rgpCriteria, HCERTSTORE hStore, PDWORD pcSelection, PCCERT_CHAIN_CONTEXT **pprgpSelection)
     * }
     */
    public static MethodHandle CertSelectCertificateChains$handle() {
        return CertSelectCertificateChains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSelectCertificateChains(LPCGUID pSelectionContext, DWORD dwFlags, PCCERT_SELECT_CHAIN_PARA pChainParameters, DWORD cCriteria, PCCERT_SELECT_CRITERIA rgpCriteria, HCERTSTORE hStore, PDWORD pcSelection, PCCERT_CHAIN_CONTEXT **pprgpSelection)
     * }
     */
    public static MemorySegment CertSelectCertificateChains$address() {
        return CertSelectCertificateChains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSelectCertificateChains(LPCGUID pSelectionContext, DWORD dwFlags, PCCERT_SELECT_CHAIN_PARA pChainParameters, DWORD cCriteria, PCCERT_SELECT_CRITERIA rgpCriteria, HCERTSTORE hStore, PDWORD pcSelection, PCCERT_CHAIN_CONTEXT **pprgpSelection)
     * }
     */
    public static int CertSelectCertificateChains(MemorySegment pSelectionContext, int dwFlags, MemorySegment pChainParameters, int cCriteria, MemorySegment rgpCriteria, MemorySegment hStore, MemorySegment pcSelection, MemorySegment pprgpSelection) {
        var mh$ = CertSelectCertificateChains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSelectCertificateChains", pSelectionContext, dwFlags, pChainParameters, cCriteria, rgpCriteria, hStore, pcSelection, pprgpSelection);
            }
            return (int)mh$.invokeExact(pSelectionContext, dwFlags, pChainParameters, cCriteria, rgpCriteria, hStore, pcSelection, pprgpSelection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCertificateChainList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertFreeCertificateChainList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainList(PCCERT_CHAIN_CONTEXT *prgpSelection)
     * }
     */
    public static FunctionDescriptor CertFreeCertificateChainList$descriptor() {
        return CertFreeCertificateChainList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainList(PCCERT_CHAIN_CONTEXT *prgpSelection)
     * }
     */
    public static MethodHandle CertFreeCertificateChainList$handle() {
        return CertFreeCertificateChainList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainList(PCCERT_CHAIN_CONTEXT *prgpSelection)
     * }
     */
    public static MemorySegment CertFreeCertificateChainList$address() {
        return CertFreeCertificateChainList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertFreeCertificateChainList(PCCERT_CHAIN_CONTEXT *prgpSelection)
     * }
     */
    public static void CertFreeCertificateChainList(MemorySegment prgpSelection) {
        var mh$ = CertFreeCertificateChainList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCertificateChainList", prgpSelection);
            }
            mh$.invokeExact(prgpSelection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_REQUEST {
     *     DWORD dwVersion;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_DER_BLOB HashedMessage;
     *     LPSTR pszTSAPolicyId;
     *     CRYPT_INTEGER_BLOB Nonce;
     *     BOOL fCertReq;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCRYPT_TIMESTAMP_REQUEST
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_REQUEST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_RESPONSE {
     *     DWORD dwStatus;
     *     DWORD cFreeText;
     *     LPWSTR *rgFreeText;
     *     CRYPT_BIT_BLOB FailureInfo;
     *     CRYPT_DER_BLOB ContentInfo;
     * } *PCRYPT_TIMESTAMP_RESPONSE
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_RESPONSE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_ACCURACY {
     *     DWORD dwSeconds;
     *     DWORD dwMillis;
     *     DWORD dwMicros;
     * } *PCRYPT_TIMESTAMP_ACCURACY
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_ACCURACY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_INFO {
     *     DWORD dwVersion;
     *     LPSTR pszTSAPolicyId;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_DER_BLOB HashedMessage;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     *     FILETIME ftTime;
     *     PCRYPT_TIMESTAMP_ACCURACY pvAccuracy;
     *     BOOL fOrdering;
     *     CRYPT_DER_BLOB Nonce;
     *     CRYPT_DER_BLOB Tsa;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCRYPT_TIMESTAMP_INFO
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_CONTEXT {
     *     DWORD cbEncoded;
     *     BYTE *pbEncoded;
     *     PCRYPT_TIMESTAMP_INFO pTimeStamp;
     * } *PCRYPT_TIMESTAMP_CONTEXT
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_PARA {
     *     LPCSTR pszTSAPolicyId;
     *     BOOL fRequestCerts;
     *     CRYPT_INTEGER_BLOB Nonce;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCRYPT_TIMESTAMP_PARA
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_PARA = wgl_h.C_POINTER;

    private static class CryptRetrieveTimeStamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptRetrieveTimeStamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveTimeStamp(LPCWSTR wszUrl, DWORD dwRetrievalFlags, DWORD dwTimeout, LPCSTR pszHashId, const CRYPT_TIMESTAMP_PARA *pPara, const BYTE *pbData, DWORD cbData, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static FunctionDescriptor CryptRetrieveTimeStamp$descriptor() {
        return CryptRetrieveTimeStamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveTimeStamp(LPCWSTR wszUrl, DWORD dwRetrievalFlags, DWORD dwTimeout, LPCSTR pszHashId, const CRYPT_TIMESTAMP_PARA *pPara, const BYTE *pbData, DWORD cbData, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static MethodHandle CryptRetrieveTimeStamp$handle() {
        return CryptRetrieveTimeStamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveTimeStamp(LPCWSTR wszUrl, DWORD dwRetrievalFlags, DWORD dwTimeout, LPCSTR pszHashId, const CRYPT_TIMESTAMP_PARA *pPara, const BYTE *pbData, DWORD cbData, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static MemorySegment CryptRetrieveTimeStamp$address() {
        return CryptRetrieveTimeStamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRetrieveTimeStamp(LPCWSTR wszUrl, DWORD dwRetrievalFlags, DWORD dwTimeout, LPCSTR pszHashId, const CRYPT_TIMESTAMP_PARA *pPara, const BYTE *pbData, DWORD cbData, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static int CryptRetrieveTimeStamp(MemorySegment wszUrl, int dwRetrievalFlags, int dwTimeout, MemorySegment pszHashId, MemorySegment pPara, MemorySegment pbData, int cbData, MemorySegment ppTsContext, MemorySegment ppTsSigner, MemorySegment phStore) {
        var mh$ = CryptRetrieveTimeStamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRetrieveTimeStamp", wszUrl, dwRetrievalFlags, dwTimeout, pszHashId, pPara, pbData, cbData, ppTsContext, ppTsSigner, phStore);
            }
            return (int)mh$.invokeExact(wszUrl, dwRetrievalFlags, dwTimeout, pszHashId, pPara, pbData, cbData, ppTsContext, ppTsSigner, phStore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyTimeStampSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptVerifyTimeStampSignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyTimeStampSignature(const BYTE *pbTSContentInfo, DWORD cbTSContentInfo, const BYTE *pbData, DWORD cbData, HCERTSTORE hAdditionalStore, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static FunctionDescriptor CryptVerifyTimeStampSignature$descriptor() {
        return CryptVerifyTimeStampSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyTimeStampSignature(const BYTE *pbTSContentInfo, DWORD cbTSContentInfo, const BYTE *pbData, DWORD cbData, HCERTSTORE hAdditionalStore, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static MethodHandle CryptVerifyTimeStampSignature$handle() {
        return CryptVerifyTimeStampSignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyTimeStampSignature(const BYTE *pbTSContentInfo, DWORD cbTSContentInfo, const BYTE *pbData, DWORD cbData, HCERTSTORE hAdditionalStore, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static MemorySegment CryptVerifyTimeStampSignature$address() {
        return CryptVerifyTimeStampSignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyTimeStampSignature(const BYTE *pbTSContentInfo, DWORD cbTSContentInfo, const BYTE *pbData, DWORD cbData, HCERTSTORE hAdditionalStore, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static int CryptVerifyTimeStampSignature(MemorySegment pbTSContentInfo, int cbTSContentInfo, MemorySegment pbData, int cbData, MemorySegment hAdditionalStore, MemorySegment ppTsContext, MemorySegment ppTsSigner, MemorySegment phStore) {
        var mh$ = CryptVerifyTimeStampSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyTimeStampSignature", pbTSContentInfo, cbTSContentInfo, pbData, cbData, hAdditionalStore, ppTsContext, ppTsSigner, phStore);
            }
            return (int)mh$.invokeExact(pbTSContentInfo, cbTSContentInfo, pbData, cbData, hAdditionalStore, ppTsContext, ppTsSigner, phStore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE {
     *     DWORD cbSize;
     *     PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET pfnGet;
     *     PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE pfnRelease;
     *     PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD pfnFreePassword;
     *     PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE pfnFree;
     *     PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER pfnFreeIdentifier;
     * } *PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE
     * }
     */
    public static final AddressLayout PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = wgl_h.C_POINTER;

    private static class CertIsWeakHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CertIsWeakHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertIsWeakHash(DWORD dwHashUseType, LPCWSTR pwszCNGHashAlgid, DWORD dwChainFlags, PCCERT_CHAIN_CONTEXT pSignerChainContext, LPFILETIME pTimeStamp, LPCWSTR pwszFileName)
     * }
     */
    public static FunctionDescriptor CertIsWeakHash$descriptor() {
        return CertIsWeakHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertIsWeakHash(DWORD dwHashUseType, LPCWSTR pwszCNGHashAlgid, DWORD dwChainFlags, PCCERT_CHAIN_CONTEXT pSignerChainContext, LPFILETIME pTimeStamp, LPCWSTR pwszFileName)
     * }
     */
    public static MethodHandle CertIsWeakHash$handle() {
        return CertIsWeakHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertIsWeakHash(DWORD dwHashUseType, LPCWSTR pwszCNGHashAlgid, DWORD dwChainFlags, PCCERT_CHAIN_CONTEXT pSignerChainContext, LPFILETIME pTimeStamp, LPCWSTR pwszFileName)
     * }
     */
    public static MemorySegment CertIsWeakHash$address() {
        return CertIsWeakHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertIsWeakHash(DWORD dwHashUseType, LPCWSTR pwszCNGHashAlgid, DWORD dwChainFlags, PCCERT_CHAIN_CONTEXT pSignerChainContext, LPFILETIME pTimeStamp, LPCWSTR pwszFileName)
     * }
     */
    public static int CertIsWeakHash(int dwHashUseType, MemorySegment pwszCNGHashAlgid, int dwChainFlags, MemorySegment pSignerChainContext, MemorySegment pTimeStamp, MemorySegment pwszFileName) {
        var mh$ = CertIsWeakHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertIsWeakHash", dwHashUseType, pwszCNGHashAlgid, dwChainFlags, pSignerChainContext, pTimeStamp, pwszFileName);
            }
            return (int)mh$.invokeExact(dwHashUseType, pwszCNGHashAlgid, dwChainFlags, pSignerChainContext, pTimeStamp, pwszFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTPROTECT_PROMPTSTRUCT {
     *     DWORD cbSize;
     *     DWORD dwPromptFlags;
     *     HWND hwndApp;
     *     LPCWSTR szPrompt;
     * } *PCRYPTPROTECT_PROMPTSTRUCT
     * }
     */
    public static final AddressLayout PCRYPTPROTECT_PROMPTSTRUCT = wgl_h.C_POINTER;

    private static class CryptProtectData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptProtectData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptProtectData(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static FunctionDescriptor CryptProtectData$descriptor() {
        return CryptProtectData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptProtectData(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static MethodHandle CryptProtectData$handle() {
        return CryptProtectData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptProtectData(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static MemorySegment CryptProtectData$address() {
        return CryptProtectData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptProtectData(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static int CryptProtectData(MemorySegment pDataIn, MemorySegment szDataDescr, MemorySegment pOptionalEntropy, MemorySegment pvReserved, MemorySegment pPromptStruct, int dwFlags, MemorySegment pDataOut) {
        var mh$ = CryptProtectData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptProtectData", pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
            }
            return (int)mh$.invokeExact(pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnprotectData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptUnprotectData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectData(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static FunctionDescriptor CryptUnprotectData$descriptor() {
        return CryptUnprotectData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectData(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static MethodHandle CryptUnprotectData$handle() {
        return CryptUnprotectData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectData(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static MemorySegment CryptUnprotectData$address() {
        return CryptUnprotectData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnprotectData(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static int CryptUnprotectData(MemorySegment pDataIn, MemorySegment ppszDataDescr, MemorySegment pOptionalEntropy, MemorySegment pvReserved, MemorySegment pPromptStruct, int dwFlags, MemorySegment pDataOut) {
        var mh$ = CryptUnprotectData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnprotectData", pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
            }
            return (int)mh$.invokeExact(pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptProtectDataNoUI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptProtectDataNoUI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptProtectDataNoUI(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static FunctionDescriptor CryptProtectDataNoUI$descriptor() {
        return CryptProtectDataNoUI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptProtectDataNoUI(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static MethodHandle CryptProtectDataNoUI$handle() {
        return CryptProtectDataNoUI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptProtectDataNoUI(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static MemorySegment CryptProtectDataNoUI$address() {
        return CryptProtectDataNoUI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptProtectDataNoUI(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static int CryptProtectDataNoUI(MemorySegment pDataIn, MemorySegment szDataDescr, MemorySegment pOptionalEntropy, MemorySegment pvReserved, MemorySegment pPromptStruct, int dwFlags, MemorySegment pbOptionalPassword, int cbOptionalPassword, MemorySegment pDataOut) {
        var mh$ = CryptProtectDataNoUI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptProtectDataNoUI", pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
            }
            return (int)mh$.invokeExact(pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnprotectDataNoUI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptUnprotectDataNoUI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectDataNoUI(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static FunctionDescriptor CryptUnprotectDataNoUI$descriptor() {
        return CryptUnprotectDataNoUI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectDataNoUI(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static MethodHandle CryptUnprotectDataNoUI$handle() {
        return CryptUnprotectDataNoUI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectDataNoUI(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static MemorySegment CryptUnprotectDataNoUI$address() {
        return CryptUnprotectDataNoUI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnprotectDataNoUI(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static int CryptUnprotectDataNoUI(MemorySegment pDataIn, MemorySegment ppszDataDescr, MemorySegment pOptionalEntropy, MemorySegment pvReserved, MemorySegment pPromptStruct, int dwFlags, MemorySegment pbOptionalPassword, int cbOptionalPassword, MemorySegment pDataOut) {
        var mh$ = CryptUnprotectDataNoUI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnprotectDataNoUI", pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
            }
            return (int)mh$.invokeExact(pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUpdateProtectedState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptUpdateProtectedState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUpdateProtectedState(PSID pOldSid, LPCWSTR pwszOldPassword, DWORD dwFlags, DWORD *pdwSuccessCount, DWORD *pdwFailureCount)
     * }
     */
    public static FunctionDescriptor CryptUpdateProtectedState$descriptor() {
        return CryptUpdateProtectedState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUpdateProtectedState(PSID pOldSid, LPCWSTR pwszOldPassword, DWORD dwFlags, DWORD *pdwSuccessCount, DWORD *pdwFailureCount)
     * }
     */
    public static MethodHandle CryptUpdateProtectedState$handle() {
        return CryptUpdateProtectedState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUpdateProtectedState(PSID pOldSid, LPCWSTR pwszOldPassword, DWORD dwFlags, DWORD *pdwSuccessCount, DWORD *pdwFailureCount)
     * }
     */
    public static MemorySegment CryptUpdateProtectedState$address() {
        return CryptUpdateProtectedState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUpdateProtectedState(PSID pOldSid, LPCWSTR pwszOldPassword, DWORD dwFlags, DWORD *pdwSuccessCount, DWORD *pdwFailureCount)
     * }
     */
    public static int CryptUpdateProtectedState(MemorySegment pOldSid, MemorySegment pwszOldPassword, int dwFlags, MemorySegment pdwSuccessCount, MemorySegment pdwFailureCount) {
        var mh$ = CryptUpdateProtectedState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUpdateProtectedState", pOldSid, pwszOldPassword, dwFlags, pdwSuccessCount, pdwFailureCount);
            }
            return (int)mh$.invokeExact(pOldSid, pwszOldPassword, dwFlags, pdwSuccessCount, pdwFailureCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptProtectMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptProtectMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptProtectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptProtectMemory$descriptor() {
        return CryptProtectMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptProtectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptProtectMemory$handle() {
        return CryptProtectMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptProtectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptProtectMemory$address() {
        return CryptProtectMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptProtectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static int CryptProtectMemory(MemorySegment pDataIn, int cbDataIn, int dwFlags) {
        var mh$ = CryptProtectMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptProtectMemory", pDataIn, cbDataIn, dwFlags);
            }
            return (int)mh$.invokeExact(pDataIn, cbDataIn, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnprotectMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CryptUnprotectMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptUnprotectMemory$descriptor() {
        return CryptUnprotectMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptUnprotectMemory$handle() {
        return CryptUnprotectMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptUnprotectMemory$address() {
        return CryptUnprotectMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnprotectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static int CryptUnprotectMemory(MemorySegment pDataIn, int cbDataIn, int dwFlags) {
        var mh$ = CryptUnprotectMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnprotectMemory", pDataIn, cbDataIn, dwFlags);
            }
            return (int)mh$.invokeExact(pDataIn, cbDataIn, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERTIFICATE_BLOB {
     *     DWORD dwCertEncodingType;
     *     DWORD cbData;
     *     PBYTE pbData;
     * } *PEFS_CERTIFICATE_BLOB
     * }
     */
    public static final AddressLayout PEFS_CERTIFICATE_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_HASH_BLOB {
     *     DWORD cbData;
     *     PBYTE pbData;
     * } *PEFS_HASH_BLOB
     * }
     */
    public static final AddressLayout PEFS_HASH_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_RPC_BLOB {
     *     DWORD cbData;
     *     PBYTE pbData;
     * } *PEFS_RPC_BLOB
     * }
     */
    public static final AddressLayout PEFS_RPC_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_PIN_BLOB {
     *     DWORD cbPadding;
     *     DWORD cbData;
     *     PBYTE pbData;
     * } *PEFS_PIN_BLOB
     * }
     */
    public static final AddressLayout PEFS_PIN_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_KEY_INFO {
     *     DWORD dwVersion;
     *     ULONG Entropy;
     *     ALG_ID Algorithm;
     *     ULONG KeyLength;
     * } *PEFS_KEY_INFO
     * }
     */
    public static final AddressLayout PEFS_KEY_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_COMPATIBILITY_INFO {
     *     DWORD EfsVersion;
     * } *PEFS_COMPATIBILITY_INFO
     * }
     */
    public static final AddressLayout PEFS_COMPATIBILITY_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_VERSION_INFO {
     *     DWORD EfsVersion;
     *     DWORD SubVersion;
     * } *PEFS_VERSION_INFO
     * }
     */
    public static final AddressLayout PEFS_VERSION_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_DECRYPTION_STATUS_INFO {
     *     DWORD dwDecryptionError;
     *     DWORD dwHashOffset;
     *     DWORD cbHash;
     * } *PEFS_DECRYPTION_STATUS_INFO
     * }
     */
    public static final AddressLayout PEFS_DECRYPTION_STATUS_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_ENCRYPTION_STATUS_INFO {
     *     BOOL bHasCurrentKey;
     *     DWORD dwEncryptionError;
     * } *PEFS_ENCRYPTION_STATUS_INFO
     * }
     */
    public static final AddressLayout PEFS_ENCRYPTION_STATUS_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_CERTIFICATE {
     *     DWORD cbTotalLength;
     *     SID *pUserSid;
     *     PEFS_CERTIFICATE_BLOB pCertBlob;
     * } *PENCRYPTION_CERTIFICATE
     * }
     */
    public static final AddressLayout PENCRYPTION_CERTIFICATE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_CERTIFICATE_HASH {
     *     DWORD cbTotalLength;
     *     SID *pUserSid;
     *     PEFS_HASH_BLOB pHash;
     *     LPWSTR lpDisplayInformation;
     * } *PENCRYPTION_CERTIFICATE_HASH
     * }
     */
    public static final AddressLayout PENCRYPTION_CERTIFICATE_HASH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_CERTIFICATE_HASH_LIST {
     *     DWORD nCert_Hash;
     *     PENCRYPTION_CERTIFICATE_HASH *pUsers;
     * } *PENCRYPTION_CERTIFICATE_HASH_LIST
     * }
     */
    public static final AddressLayout PENCRYPTION_CERTIFICATE_HASH_LIST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_CERTIFICATE_LIST {
     *     DWORD nUsers;
     *     PENCRYPTION_CERTIFICATE *pUsers;
     * } *PENCRYPTION_CERTIFICATE_LIST
     * }
     */
    public static final AddressLayout PENCRYPTION_CERTIFICATE_LIST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTED_FILE_METADATA_SIGNATURE {
     *     DWORD dwEfsAccessType;
     *     PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded;
     *     PENCRYPTION_CERTIFICATE pEncryptionCertificate;
     *     PEFS_RPC_BLOB pEfsStreamSignature;
     * } *PENCRYPTED_FILE_METADATA_SIGNATURE
     * }
     */
    public static final AddressLayout PENCRYPTED_FILE_METADATA_SIGNATURE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_PROTECTOR {
     *     DWORD cbTotalLength;
     *     SID *pUserSid;
     *     LPWSTR lpProtectorDescriptor;
     * } *PENCRYPTION_PROTECTOR
     * }
     */
    public static final AddressLayout PENCRYPTION_PROTECTOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_PROTECTOR_LIST {
     *     DWORD nProtectors;
     *     PENCRYPTION_PROTECTOR *pProtectors;
     * } *PENCRYPTION_PROTECTOR_LIST
     * }
     */
    public static final AddressLayout PENCRYPTION_PROTECTOR_LIST = wgl_h.C_POINTER;

    private static class QueryUsersOnEncryptedFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryUsersOnEncryptedFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryUsersOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pUsers)
     * }
     */
    public static FunctionDescriptor QueryUsersOnEncryptedFile$descriptor() {
        return QueryUsersOnEncryptedFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryUsersOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pUsers)
     * }
     */
    public static MethodHandle QueryUsersOnEncryptedFile$handle() {
        return QueryUsersOnEncryptedFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryUsersOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pUsers)
     * }
     */
    public static MemorySegment QueryUsersOnEncryptedFile$address() {
        return QueryUsersOnEncryptedFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryUsersOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pUsers)
     * }
     */
    public static int QueryUsersOnEncryptedFile(MemorySegment lpFileName, MemorySegment pUsers) {
        var mh$ = QueryUsersOnEncryptedFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryUsersOnEncryptedFile", lpFileName, pUsers);
            }
            return (int)mh$.invokeExact(lpFileName, pUsers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryRecoveryAgentsOnEncryptedFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryRecoveryAgentsOnEncryptedFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryRecoveryAgentsOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pRecoveryAgents)
     * }
     */
    public static FunctionDescriptor QueryRecoveryAgentsOnEncryptedFile$descriptor() {
        return QueryRecoveryAgentsOnEncryptedFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryRecoveryAgentsOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pRecoveryAgents)
     * }
     */
    public static MethodHandle QueryRecoveryAgentsOnEncryptedFile$handle() {
        return QueryRecoveryAgentsOnEncryptedFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryRecoveryAgentsOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pRecoveryAgents)
     * }
     */
    public static MemorySegment QueryRecoveryAgentsOnEncryptedFile$address() {
        return QueryRecoveryAgentsOnEncryptedFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryRecoveryAgentsOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pRecoveryAgents)
     * }
     */
    public static int QueryRecoveryAgentsOnEncryptedFile(MemorySegment lpFileName, MemorySegment pRecoveryAgents) {
        var mh$ = QueryRecoveryAgentsOnEncryptedFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryRecoveryAgentsOnEncryptedFile", lpFileName, pRecoveryAgents);
            }
            return (int)mh$.invokeExact(lpFileName, pRecoveryAgents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveUsersFromEncryptedFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveUsersFromEncryptedFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RemoveUsersFromEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST pHashes)
     * }
     */
    public static FunctionDescriptor RemoveUsersFromEncryptedFile$descriptor() {
        return RemoveUsersFromEncryptedFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RemoveUsersFromEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST pHashes)
     * }
     */
    public static MethodHandle RemoveUsersFromEncryptedFile$handle() {
        return RemoveUsersFromEncryptedFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RemoveUsersFromEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST pHashes)
     * }
     */
    public static MemorySegment RemoveUsersFromEncryptedFile$address() {
        return RemoveUsersFromEncryptedFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RemoveUsersFromEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST pHashes)
     * }
     */
    public static int RemoveUsersFromEncryptedFile(MemorySegment lpFileName, MemorySegment pHashes) {
        var mh$ = RemoveUsersFromEncryptedFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveUsersFromEncryptedFile", lpFileName, pHashes);
            }
            return (int)mh$.invokeExact(lpFileName, pHashes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddUsersToEncryptedFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddUsersToEncryptedFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD AddUsersToEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates)
     * }
     */
    public static FunctionDescriptor AddUsersToEncryptedFile$descriptor() {
        return AddUsersToEncryptedFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD AddUsersToEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates)
     * }
     */
    public static MethodHandle AddUsersToEncryptedFile$handle() {
        return AddUsersToEncryptedFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD AddUsersToEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates)
     * }
     */
    public static MemorySegment AddUsersToEncryptedFile$address() {
        return AddUsersToEncryptedFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD AddUsersToEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates)
     * }
     */
    public static int AddUsersToEncryptedFile(MemorySegment lpFileName, MemorySegment pEncryptionCertificates) {
        var mh$ = AddUsersToEncryptedFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddUsersToEncryptedFile", lpFileName, pEncryptionCertificates);
            }
            return (int)mh$.invokeExact(lpFileName, pEncryptionCertificates);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserFileEncryptionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetUserFileEncryptionKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKey(PENCRYPTION_CERTIFICATE pEncryptionCertificate)
     * }
     */
    public static FunctionDescriptor SetUserFileEncryptionKey$descriptor() {
        return SetUserFileEncryptionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKey(PENCRYPTION_CERTIFICATE pEncryptionCertificate)
     * }
     */
    public static MethodHandle SetUserFileEncryptionKey$handle() {
        return SetUserFileEncryptionKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKey(PENCRYPTION_CERTIFICATE pEncryptionCertificate)
     * }
     */
    public static MemorySegment SetUserFileEncryptionKey$address() {
        return SetUserFileEncryptionKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKey(PENCRYPTION_CERTIFICATE pEncryptionCertificate)
     * }
     */
    public static int SetUserFileEncryptionKey(MemorySegment pEncryptionCertificate) {
        var mh$ = SetUserFileEncryptionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserFileEncryptionKey", pEncryptionCertificate);
            }
            return (int)mh$.invokeExact(pEncryptionCertificate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserFileEncryptionKeyEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetUserFileEncryptionKeyEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKeyEx(PENCRYPTION_CERTIFICATE pEncryptionCertificate, DWORD dwCapabilities, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static FunctionDescriptor SetUserFileEncryptionKeyEx$descriptor() {
        return SetUserFileEncryptionKeyEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKeyEx(PENCRYPTION_CERTIFICATE pEncryptionCertificate, DWORD dwCapabilities, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MethodHandle SetUserFileEncryptionKeyEx$handle() {
        return SetUserFileEncryptionKeyEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKeyEx(PENCRYPTION_CERTIFICATE pEncryptionCertificate, DWORD dwCapabilities, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MemorySegment SetUserFileEncryptionKeyEx$address() {
        return SetUserFileEncryptionKeyEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKeyEx(PENCRYPTION_CERTIFICATE pEncryptionCertificate, DWORD dwCapabilities, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static int SetUserFileEncryptionKeyEx(MemorySegment pEncryptionCertificate, int dwCapabilities, int dwFlags, MemorySegment pvReserved) {
        var mh$ = SetUserFileEncryptionKeyEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserFileEncryptionKeyEx", pEncryptionCertificate, dwCapabilities, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pEncryptionCertificate, dwCapabilities, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeEncryptionCertificateHashList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FreeEncryptionCertificateHashList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeEncryptionCertificateHashList(PENCRYPTION_CERTIFICATE_HASH_LIST pUsers)
     * }
     */
    public static FunctionDescriptor FreeEncryptionCertificateHashList$descriptor() {
        return FreeEncryptionCertificateHashList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeEncryptionCertificateHashList(PENCRYPTION_CERTIFICATE_HASH_LIST pUsers)
     * }
     */
    public static MethodHandle FreeEncryptionCertificateHashList$handle() {
        return FreeEncryptionCertificateHashList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FreeEncryptionCertificateHashList(PENCRYPTION_CERTIFICATE_HASH_LIST pUsers)
     * }
     */
    public static MemorySegment FreeEncryptionCertificateHashList$address() {
        return FreeEncryptionCertificateHashList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FreeEncryptionCertificateHashList(PENCRYPTION_CERTIFICATE_HASH_LIST pUsers)
     * }
     */
    public static void FreeEncryptionCertificateHashList(MemorySegment pUsers) {
        var mh$ = FreeEncryptionCertificateHashList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeEncryptionCertificateHashList", pUsers);
            }
            mh$.invokeExact(pUsers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncryptionDisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EncryptionDisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EncryptionDisable(LPCWSTR DirPath, BOOL Disable)
     * }
     */
    public static FunctionDescriptor EncryptionDisable$descriptor() {
        return EncryptionDisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EncryptionDisable(LPCWSTR DirPath, BOOL Disable)
     * }
     */
    public static MethodHandle EncryptionDisable$handle() {
        return EncryptionDisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EncryptionDisable(LPCWSTR DirPath, BOOL Disable)
     * }
     */
    public static MemorySegment EncryptionDisable$address() {
        return EncryptionDisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EncryptionDisable(LPCWSTR DirPath, BOOL Disable)
     * }
     */
    public static int EncryptionDisable(MemorySegment DirPath, int Disable) {
        var mh$ = EncryptionDisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncryptionDisable", DirPath, Disable);
            }
            return (int)mh$.invokeExact(DirPath, Disable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateEncryptionInfoFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DuplicateEncryptionInfoFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DuplicateEncryptionInfoFile(LPCWSTR SrcFileName, LPCWSTR DstFileName, DWORD dwCreationDistribution, DWORD dwAttributes, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor DuplicateEncryptionInfoFile$descriptor() {
        return DuplicateEncryptionInfoFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DuplicateEncryptionInfoFile(LPCWSTR SrcFileName, LPCWSTR DstFileName, DWORD dwCreationDistribution, DWORD dwAttributes, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle DuplicateEncryptionInfoFile$handle() {
        return DuplicateEncryptionInfoFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DuplicateEncryptionInfoFile(LPCWSTR SrcFileName, LPCWSTR DstFileName, DWORD dwCreationDistribution, DWORD dwAttributes, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment DuplicateEncryptionInfoFile$address() {
        return DuplicateEncryptionInfoFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DuplicateEncryptionInfoFile(LPCWSTR SrcFileName, LPCWSTR DstFileName, DWORD dwCreationDistribution, DWORD dwAttributes, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int DuplicateEncryptionInfoFile(MemorySegment SrcFileName, MemorySegment DstFileName, int dwCreationDistribution, int dwAttributes, MemorySegment lpSecurityAttributes) {
        var mh$ = DuplicateEncryptionInfoFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateEncryptionInfoFile", SrcFileName, DstFileName, dwCreationDistribution, dwAttributes, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(SrcFileName, DstFileName, dwCreationDistribution, dwAttributes, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEncryptedFileMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEncryptedFileMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetEncryptedFileMetadata(LPCWSTR lpFileName, PDWORD pcbMetadata, PBYTE *ppbMetadata)
     * }
     */
    public static FunctionDescriptor GetEncryptedFileMetadata$descriptor() {
        return GetEncryptedFileMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetEncryptedFileMetadata(LPCWSTR lpFileName, PDWORD pcbMetadata, PBYTE *ppbMetadata)
     * }
     */
    public static MethodHandle GetEncryptedFileMetadata$handle() {
        return GetEncryptedFileMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetEncryptedFileMetadata(LPCWSTR lpFileName, PDWORD pcbMetadata, PBYTE *ppbMetadata)
     * }
     */
    public static MemorySegment GetEncryptedFileMetadata$address() {
        return GetEncryptedFileMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetEncryptedFileMetadata(LPCWSTR lpFileName, PDWORD pcbMetadata, PBYTE *ppbMetadata)
     * }
     */
    public static int GetEncryptedFileMetadata(MemorySegment lpFileName, MemorySegment pcbMetadata, MemorySegment ppbMetadata) {
        var mh$ = GetEncryptedFileMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEncryptedFileMetadata", lpFileName, pcbMetadata, ppbMetadata);
            }
            return (int)mh$.invokeExact(lpFileName, pcbMetadata, ppbMetadata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEncryptedFileMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetEncryptedFileMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetEncryptedFileMetadata(LPCWSTR lpFileName, PBYTE pbOldMetadata, PBYTE pbNewMetadata, PENCRYPTION_CERTIFICATE_HASH pOwnerHash, DWORD dwOperation, PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded)
     * }
     */
    public static FunctionDescriptor SetEncryptedFileMetadata$descriptor() {
        return SetEncryptedFileMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetEncryptedFileMetadata(LPCWSTR lpFileName, PBYTE pbOldMetadata, PBYTE pbNewMetadata, PENCRYPTION_CERTIFICATE_HASH pOwnerHash, DWORD dwOperation, PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded)
     * }
     */
    public static MethodHandle SetEncryptedFileMetadata$handle() {
        return SetEncryptedFileMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetEncryptedFileMetadata(LPCWSTR lpFileName, PBYTE pbOldMetadata, PBYTE pbNewMetadata, PENCRYPTION_CERTIFICATE_HASH pOwnerHash, DWORD dwOperation, PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded)
     * }
     */
    public static MemorySegment SetEncryptedFileMetadata$address() {
        return SetEncryptedFileMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetEncryptedFileMetadata(LPCWSTR lpFileName, PBYTE pbOldMetadata, PBYTE pbNewMetadata, PENCRYPTION_CERTIFICATE_HASH pOwnerHash, DWORD dwOperation, PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded)
     * }
     */
    public static int SetEncryptedFileMetadata(MemorySegment lpFileName, MemorySegment pbOldMetadata, MemorySegment pbNewMetadata, MemorySegment pOwnerHash, int dwOperation, MemorySegment pCertificatesAdded) {
        var mh$ = SetEncryptedFileMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEncryptedFileMetadata", lpFileName, pbOldMetadata, pbNewMetadata, pOwnerHash, dwOperation, pCertificatesAdded);
            }
            return (int)mh$.invokeExact(lpFileName, pbOldMetadata, pbNewMetadata, pOwnerHash, dwOperation, pCertificatesAdded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeEncryptedFileMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FreeEncryptedFileMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeEncryptedFileMetadata(PBYTE pbMetadata)
     * }
     */
    public static FunctionDescriptor FreeEncryptedFileMetadata$descriptor() {
        return FreeEncryptedFileMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeEncryptedFileMetadata(PBYTE pbMetadata)
     * }
     */
    public static MethodHandle FreeEncryptedFileMetadata$handle() {
        return FreeEncryptedFileMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FreeEncryptedFileMetadata(PBYTE pbMetadata)
     * }
     */
    public static MemorySegment FreeEncryptedFileMetadata$address() {
        return FreeEncryptedFileMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FreeEncryptedFileMetadata(PBYTE pbMetadata)
     * }
     */
    public static void FreeEncryptedFileMetadata(MemorySegment pbMetadata) {
        var mh$ = FreeEncryptedFileMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeEncryptedFileMetadata", pbMetadata);
            }
            mh$.invokeExact(pbMetadata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     RPC_NS_HANDLE LookupContext;
     *     RPC_BINDING_HANDLE ProposedHandle;
     *     RPC_BINDING_VECTOR *Bindings;
     * } *PRPC_IMPORT_CONTEXT_P
     * }
     */
    public static final AddressLayout PRPC_IMPORT_CONTEXT_P = wgl_h.C_POINTER;

    private static class I_RpcNsGetBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("I_RpcNsGetBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsGetBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static FunctionDescriptor I_RpcNsGetBuffer$descriptor() {
        return I_RpcNsGetBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsGetBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static MethodHandle I_RpcNsGetBuffer$handle() {
        return I_RpcNsGetBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsGetBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static MemorySegment I_RpcNsGetBuffer$address() {
        return I_RpcNsGetBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsGetBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static int I_RpcNsGetBuffer(MemorySegment Message) {
        var mh$ = I_RpcNsGetBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcNsGetBuffer", Message);
            }
            return (int)mh$.invokeExact(Message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcNsSendReceive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("I_RpcNsSendReceive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsSendReceive(PRPC_MESSAGE Message, RPC_BINDING_HANDLE *Handle)
     * }
     */
    public static FunctionDescriptor I_RpcNsSendReceive$descriptor() {
        return I_RpcNsSendReceive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsSendReceive(PRPC_MESSAGE Message, RPC_BINDING_HANDLE *Handle)
     * }
     */
    public static MethodHandle I_RpcNsSendReceive$handle() {
        return I_RpcNsSendReceive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsSendReceive(PRPC_MESSAGE Message, RPC_BINDING_HANDLE *Handle)
     * }
     */
    public static MemorySegment I_RpcNsSendReceive$address() {
        return I_RpcNsSendReceive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsSendReceive(PRPC_MESSAGE Message, RPC_BINDING_HANDLE *Handle)
     * }
     */
    public static int I_RpcNsSendReceive(MemorySegment Message, MemorySegment Handle) {
        var mh$ = I_RpcNsSendReceive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcNsSendReceive", Message, Handle);
            }
            return (int)mh$.invokeExact(Message, Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcNsRaiseException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("I_RpcNsRaiseException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void I_RpcNsRaiseException(PRPC_MESSAGE Message, RPC_STATUS Status)
     * }
     */
    public static FunctionDescriptor I_RpcNsRaiseException$descriptor() {
        return I_RpcNsRaiseException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void I_RpcNsRaiseException(PRPC_MESSAGE Message, RPC_STATUS Status)
     * }
     */
    public static MethodHandle I_RpcNsRaiseException$handle() {
        return I_RpcNsRaiseException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void I_RpcNsRaiseException(PRPC_MESSAGE Message, RPC_STATUS Status)
     * }
     */
    public static MemorySegment I_RpcNsRaiseException$address() {
        return I_RpcNsRaiseException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void I_RpcNsRaiseException(PRPC_MESSAGE Message, RPC_STATUS Status)
     * }
     */
    public static void I_RpcNsRaiseException(MemorySegment Message, int Status) {
        var mh$ = I_RpcNsRaiseException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcNsRaiseException", Message, Status);
            }
            mh$.invokeExact(Message, Status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcReBindBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("I_RpcReBindBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcReBindBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static FunctionDescriptor I_RpcReBindBuffer$descriptor() {
        return I_RpcReBindBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcReBindBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static MethodHandle I_RpcReBindBuffer$handle() {
        return I_RpcReBindBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcReBindBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static MemorySegment I_RpcReBindBuffer$address() {
        return I_RpcReBindBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS I_RpcReBindBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static int I_RpcReBindBuffer(MemorySegment Message) {
        var mh$ = I_RpcReBindBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcReBindBuffer", Message);
            }
            return (int)mh$.invokeExact(Message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_NsServerBindSearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("I_NsServerBindSearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsServerBindSearch()
     * }
     */
    public static FunctionDescriptor I_NsServerBindSearch$descriptor() {
        return I_NsServerBindSearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsServerBindSearch()
     * }
     */
    public static MethodHandle I_NsServerBindSearch$handle() {
        return I_NsServerBindSearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsServerBindSearch()
     * }
     */
    public static MemorySegment I_NsServerBindSearch$address() {
        return I_NsServerBindSearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS I_NsServerBindSearch()
     * }
     */
    public static int I_NsServerBindSearch() {
        var mh$ = I_NsServerBindSearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_NsServerBindSearch");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_NsClientBindSearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("I_NsClientBindSearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsClientBindSearch()
     * }
     */
    public static FunctionDescriptor I_NsClientBindSearch$descriptor() {
        return I_NsClientBindSearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsClientBindSearch()
     * }
     */
    public static MethodHandle I_NsClientBindSearch$handle() {
        return I_NsClientBindSearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsClientBindSearch()
     * }
     */
    public static MemorySegment I_NsClientBindSearch$address() {
        return I_NsClientBindSearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS I_NsClientBindSearch()
     * }
     */
    public static int I_NsClientBindSearch() {
        var mh$ = I_NsClientBindSearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_NsClientBindSearch");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_NsClientBindDone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("I_NsClientBindDone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void I_NsClientBindDone()
     * }
     */
    public static FunctionDescriptor I_NsClientBindDone$descriptor() {
        return I_NsClientBindDone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void I_NsClientBindDone()
     * }
     */
    public static MethodHandle I_NsClientBindDone$handle() {
        return I_NsClientBindDone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void I_NsClientBindDone()
     * }
     */
    public static MemorySegment I_NsClientBindDone$address() {
        return I_NsClientBindDone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void I_NsClientBindDone()
     * }
     */
    public static void I_NsClientBindDone() {
        var mh$ = I_NsClientBindDone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_NsClientBindDone");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char byte
     * }
     */
    public static final OfByte byte_ = wgl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef byte cs_byte
     * }
     */
    public static final OfByte cs_byte = wgl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char boolean
     * }
     */
    public static final OfByte boolean_ = wgl_h.C_CHAR;

    private static class MIDL_user_allocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MIDL_user_allocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *MIDL_user_allocate(size_t size)
     * }
     */
    public static FunctionDescriptor MIDL_user_allocate$descriptor() {
        return MIDL_user_allocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *MIDL_user_allocate(size_t size)
     * }
     */
    public static MethodHandle MIDL_user_allocate$handle() {
        return MIDL_user_allocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *MIDL_user_allocate(size_t size)
     * }
     */
    public static MemorySegment MIDL_user_allocate$address() {
        return MIDL_user_allocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *MIDL_user_allocate(size_t size)
     * }
     */
    public static MemorySegment MIDL_user_allocate(long size) {
        var mh$ = MIDL_user_allocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MIDL_user_allocate", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MIDL_user_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MIDL_user_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void MIDL_user_free(void *)
     * }
     */
    public static FunctionDescriptor MIDL_user_free$descriptor() {
        return MIDL_user_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void MIDL_user_free(void *)
     * }
     */
    public static MethodHandle MIDL_user_free$handle() {
        return MIDL_user_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void MIDL_user_free(void *)
     * }
     */
    public static MemorySegment MIDL_user_free$address() {
        return MIDL_user_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void MIDL_user_free(void *)
     * }
     */
    public static void MIDL_user_free(MemorySegment x0) {
        var mh$ = MIDL_user_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MIDL_user_free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcDefaultAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("I_RpcDefaultAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *I_RpcDefaultAllocate(handle_t bh, size_t size, void *(*RealAlloc)(size_t))
     * }
     */
    public static FunctionDescriptor I_RpcDefaultAllocate$descriptor() {
        return I_RpcDefaultAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *I_RpcDefaultAllocate(handle_t bh, size_t size, void *(*RealAlloc)(size_t))
     * }
     */
    public static MethodHandle I_RpcDefaultAllocate$handle() {
        return I_RpcDefaultAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *I_RpcDefaultAllocate(handle_t bh, size_t size, void *(*RealAlloc)(size_t))
     * }
     */
    public static MemorySegment I_RpcDefaultAllocate$address() {
        return I_RpcDefaultAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *I_RpcDefaultAllocate(handle_t bh, size_t size, void *(*RealAlloc)(size_t))
     * }
     */
    public static MemorySegment I_RpcDefaultAllocate(MemorySegment bh, long size, MemorySegment RealAlloc) {
        var mh$ = I_RpcDefaultAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcDefaultAllocate", bh, size, RealAlloc);
            }
            return (MemorySegment)mh$.invokeExact(bh, size, RealAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcDefaultFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("I_RpcDefaultFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void I_RpcDefaultFree(handle_t bh, void *, void (*RealFree)(void *))
     * }
     */
    public static FunctionDescriptor I_RpcDefaultFree$descriptor() {
        return I_RpcDefaultFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void I_RpcDefaultFree(handle_t bh, void *, void (*RealFree)(void *))
     * }
     */
    public static MethodHandle I_RpcDefaultFree$handle() {
        return I_RpcDefaultFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void I_RpcDefaultFree(handle_t bh, void *, void (*RealFree)(void *))
     * }
     */
    public static MemorySegment I_RpcDefaultFree$address() {
        return I_RpcDefaultFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void I_RpcDefaultFree(handle_t bh, void *, void (*RealFree)(void *))
     * }
     */
    public static void I_RpcDefaultFree(MemorySegment bh, MemorySegment x1, MemorySegment RealFree) {
        var mh$ = I_RpcDefaultFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcDefaultFree", bh, x1, RealFree);
            }
            mh$.invokeExact(bh, x1, RealFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *NDR_CCONTEXT
     * }
     */
    public static final AddressLayout NDR_CCONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     void *pad[2];
     *     void *userContext;
     * } *NDR_SCONTEXT
     * }
     */
    public static final AddressLayout NDR_SCONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SCONTEXT_QUEUE {
     *     unsigned long NumberOfObjects;
     *     NDR_SCONTEXT *ArrayOfObjects;
     * } *PSCONTEXT_QUEUE
     * }
     */
    public static final AddressLayout PSCONTEXT_QUEUE = wgl_h.C_POINTER;

    private static class NDRCContextBinding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NDRCContextBinding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_BINDING_HANDLE NDRCContextBinding(NDR_CCONTEXT CContext)
     * }
     */
    public static FunctionDescriptor NDRCContextBinding$descriptor() {
        return NDRCContextBinding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_BINDING_HANDLE NDRCContextBinding(NDR_CCONTEXT CContext)
     * }
     */
    public static MethodHandle NDRCContextBinding$handle() {
        return NDRCContextBinding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_BINDING_HANDLE NDRCContextBinding(NDR_CCONTEXT CContext)
     * }
     */
    public static MemorySegment NDRCContextBinding$address() {
        return NDRCContextBinding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_BINDING_HANDLE NDRCContextBinding(NDR_CCONTEXT CContext)
     * }
     */
    public static MemorySegment NDRCContextBinding(MemorySegment CContext) {
        var mh$ = NDRCContextBinding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRCContextBinding", CContext);
            }
            return (MemorySegment)mh$.invokeExact(CContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRCContextMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NDRCContextMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRCContextMarshall(NDR_CCONTEXT CContext, void *pBuff)
     * }
     */
    public static FunctionDescriptor NDRCContextMarshall$descriptor() {
        return NDRCContextMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRCContextMarshall(NDR_CCONTEXT CContext, void *pBuff)
     * }
     */
    public static MethodHandle NDRCContextMarshall$handle() {
        return NDRCContextMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRCContextMarshall(NDR_CCONTEXT CContext, void *pBuff)
     * }
     */
    public static MemorySegment NDRCContextMarshall$address() {
        return NDRCContextMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRCContextMarshall(NDR_CCONTEXT CContext, void *pBuff)
     * }
     */
    public static void NDRCContextMarshall(MemorySegment CContext, MemorySegment pBuff) {
        var mh$ = NDRCContextMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRCContextMarshall", CContext, pBuff);
            }
            mh$.invokeExact(CContext, pBuff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRCContextUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NDRCContextUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static FunctionDescriptor NDRCContextUnmarshall$descriptor() {
        return NDRCContextUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MethodHandle NDRCContextUnmarshall$handle() {
        return NDRCContextUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRCContextUnmarshall$address() {
        return NDRCContextUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRCContextUnmarshall(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static void NDRCContextUnmarshall(MemorySegment pCContext, MemorySegment hBinding, MemorySegment pBuff, int DataRepresentation) {
        var mh$ = NDRCContextUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRCContextUnmarshall", pCContext, hBinding, pBuff, DataRepresentation);
            }
            mh$.invokeExact(pCContext, hBinding, pBuff, DataRepresentation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRCContextUnmarshall2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NDRCContextUnmarshall2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall2(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static FunctionDescriptor NDRCContextUnmarshall2$descriptor() {
        return NDRCContextUnmarshall2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall2(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MethodHandle NDRCContextUnmarshall2$handle() {
        return NDRCContextUnmarshall2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall2(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRCContextUnmarshall2$address() {
        return NDRCContextUnmarshall2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRCContextUnmarshall2(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static void NDRCContextUnmarshall2(MemorySegment pCContext, MemorySegment hBinding, MemorySegment pBuff, int DataRepresentation) {
        var mh$ = NDRCContextUnmarshall2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRCContextUnmarshall2", pCContext, hBinding, pBuff, DataRepresentation);
            }
            mh$.invokeExact(pCContext, hBinding, pBuff, DataRepresentation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NDRSContextMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRSContextMarshall(NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static FunctionDescriptor NDRSContextMarshall$descriptor() {
        return NDRSContextMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRSContextMarshall(NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static MethodHandle NDRSContextMarshall$handle() {
        return NDRSContextMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRSContextMarshall(NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static MemorySegment NDRSContextMarshall$address() {
        return NDRSContextMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRSContextMarshall(NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static void NDRSContextMarshall(MemorySegment CContext, MemorySegment pBuff, MemorySegment userRunDownIn) {
        var mh$ = NDRSContextMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextMarshall", CContext, pBuff, userRunDownIn);
            }
            mh$.invokeExact(CContext, pBuff, userRunDownIn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NDRSContextUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall(void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static FunctionDescriptor NDRSContextUnmarshall$descriptor() {
        return NDRSContextUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall(void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MethodHandle NDRSContextUnmarshall$handle() {
        return NDRSContextUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall(void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRSContextUnmarshall$address() {
        return NDRSContextUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall(void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRSContextUnmarshall(MemorySegment pBuff, int DataRepresentation) {
        var mh$ = NDRSContextUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextUnmarshall", pBuff, DataRepresentation);
            }
            return (MemorySegment)mh$.invokeExact(pBuff, DataRepresentation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextMarshallEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NDRSContextMarshallEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRSContextMarshallEx(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static FunctionDescriptor NDRSContextMarshallEx$descriptor() {
        return NDRSContextMarshallEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRSContextMarshallEx(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static MethodHandle NDRSContextMarshallEx$handle() {
        return NDRSContextMarshallEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRSContextMarshallEx(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static MemorySegment NDRSContextMarshallEx$address() {
        return NDRSContextMarshallEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRSContextMarshallEx(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static void NDRSContextMarshallEx(MemorySegment BindingHandle, MemorySegment CContext, MemorySegment pBuff, MemorySegment userRunDownIn) {
        var mh$ = NDRSContextMarshallEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextMarshallEx", BindingHandle, CContext, pBuff, userRunDownIn);
            }
            mh$.invokeExact(BindingHandle, CContext, pBuff, userRunDownIn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextMarshall2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NDRSContextMarshall2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRSContextMarshall2(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static FunctionDescriptor NDRSContextMarshall2$descriptor() {
        return NDRSContextMarshall2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRSContextMarshall2(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static MethodHandle NDRSContextMarshall2$handle() {
        return NDRSContextMarshall2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRSContextMarshall2(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static MemorySegment NDRSContextMarshall2$address() {
        return NDRSContextMarshall2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRSContextMarshall2(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static void NDRSContextMarshall2(MemorySegment BindingHandle, MemorySegment CContext, MemorySegment pBuff, MemorySegment userRunDownIn, MemorySegment CtxGuard, int Flags) {
        var mh$ = NDRSContextMarshall2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextMarshall2", BindingHandle, CContext, pBuff, userRunDownIn, CtxGuard, Flags);
            }
            mh$.invokeExact(BindingHandle, CContext, pBuff, userRunDownIn, CtxGuard, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextUnmarshallEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NDRSContextUnmarshallEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshallEx(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static FunctionDescriptor NDRSContextUnmarshallEx$descriptor() {
        return NDRSContextUnmarshallEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshallEx(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MethodHandle NDRSContextUnmarshallEx$handle() {
        return NDRSContextUnmarshallEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshallEx(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRSContextUnmarshallEx$address() {
        return NDRSContextUnmarshallEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshallEx(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRSContextUnmarshallEx(MemorySegment BindingHandle, MemorySegment pBuff, int DataRepresentation) {
        var mh$ = NDRSContextUnmarshallEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextUnmarshallEx", BindingHandle, pBuff, DataRepresentation);
            }
            return (MemorySegment)mh$.invokeExact(BindingHandle, pBuff, DataRepresentation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextUnmarshall2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NDRSContextUnmarshall2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall2(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static FunctionDescriptor NDRSContextUnmarshall2$descriptor() {
        return NDRSContextUnmarshall2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall2(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static MethodHandle NDRSContextUnmarshall2$handle() {
        return NDRSContextUnmarshall2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall2(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static MemorySegment NDRSContextUnmarshall2$address() {
        return NDRSContextUnmarshall2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall2(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static MemorySegment NDRSContextUnmarshall2(MemorySegment BindingHandle, MemorySegment pBuff, int DataRepresentation, MemorySegment CtxGuard, int Flags) {
        var mh$ = NDRSContextUnmarshall2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextUnmarshall2", BindingHandle, pBuff, DataRepresentation, CtxGuard, Flags);
            }
            return (MemorySegment)mh$.invokeExact(BindingHandle, pBuff, DataRepresentation, CtxGuard, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSsDestroyClientContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RpcSsDestroyClientContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RpcSsDestroyClientContext(void **ContextHandle)
     * }
     */
    public static FunctionDescriptor RpcSsDestroyClientContext$descriptor() {
        return RpcSsDestroyClientContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RpcSsDestroyClientContext(void **ContextHandle)
     * }
     */
    public static MethodHandle RpcSsDestroyClientContext$handle() {
        return RpcSsDestroyClientContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RpcSsDestroyClientContext(void **ContextHandle)
     * }
     */
    public static MemorySegment RpcSsDestroyClientContext$address() {
        return RpcSsDestroyClientContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RpcSsDestroyClientContext(void **ContextHandle)
     * }
     */
    public static void RpcSsDestroyClientContext(MemorySegment ContextHandle) {
        var mh$ = RpcSsDestroyClientContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsDestroyClientContext", ContextHandle);
            }
            mh$.invokeExact(ContextHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long error_status_t
     * }
     */
    public static final OfInt error_status_t = wgl_h.C_LONG;
}

