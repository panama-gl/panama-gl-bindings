// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _FILE_LAYOUT_INFO_ENTRY {
 *     struct {
 *         LARGE_INTEGER CreationTime;
 *         LARGE_INTEGER LastAccessTime;
 *         LARGE_INTEGER LastWriteTime;
 *         LARGE_INTEGER ChangeTime;
 *         DWORD FileAttributes;
 *     } BasicInformation;
 *     DWORD OwnerId;
 *     DWORD SecurityId;
 *     USN Usn;
 *     STORAGE_RESERVE_ID StorageReserveId;
 * }
 * }
 */
public class _FILE_LAYOUT_INFO_ENTRY {

    _FILE_LAYOUT_INFO_ENTRY() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _FILE_LAYOUT_INFO_ENTRY.BasicInformation.layout().withName("BasicInformation"),
        wgl_h.C_LONG.withName("OwnerId"),
        wgl_h.C_LONG.withName("SecurityId"),
        wgl_h.C_LONG_LONG.withName("Usn"),
        wgl_h.C_INT.withName("StorageReserveId"),
        MemoryLayout.paddingLayout(4)
    ).withName("_FILE_LAYOUT_INFO_ENTRY");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     DWORD FileAttributes;
     * }
     * }
     */
    public static class BasicInformation {

        BasicInformation() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            _LARGE_INTEGER.layout().withName("CreationTime"),
            _LARGE_INTEGER.layout().withName("LastAccessTime"),
            _LARGE_INTEGER.layout().withName("LastWriteTime"),
            _LARGE_INTEGER.layout().withName("ChangeTime"),
            wgl_h.C_LONG.withName("FileAttributes"),
            MemoryLayout.paddingLayout(4)
        ).withName("$anon$14576:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout CreationTime$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("CreationTime"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * LARGE_INTEGER CreationTime
         * }
         */
        public static final GroupLayout CreationTime$layout() {
            return CreationTime$LAYOUT;
        }

        private static final long CreationTime$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * LARGE_INTEGER CreationTime
         * }
         */
        public static final long CreationTime$offset() {
            return CreationTime$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * LARGE_INTEGER CreationTime
         * }
         */
        public static MemorySegment CreationTime(MemorySegment struct) {
            return struct.asSlice(CreationTime$OFFSET, CreationTime$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * LARGE_INTEGER CreationTime
         * }
         */
        public static void CreationTime(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, CreationTime$OFFSET, CreationTime$LAYOUT.byteSize());
        }

        private static final GroupLayout LastAccessTime$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("LastAccessTime"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * LARGE_INTEGER LastAccessTime
         * }
         */
        public static final GroupLayout LastAccessTime$layout() {
            return LastAccessTime$LAYOUT;
        }

        private static final long LastAccessTime$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * LARGE_INTEGER LastAccessTime
         * }
         */
        public static final long LastAccessTime$offset() {
            return LastAccessTime$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * LARGE_INTEGER LastAccessTime
         * }
         */
        public static MemorySegment LastAccessTime(MemorySegment struct) {
            return struct.asSlice(LastAccessTime$OFFSET, LastAccessTime$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * LARGE_INTEGER LastAccessTime
         * }
         */
        public static void LastAccessTime(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, LastAccessTime$OFFSET, LastAccessTime$LAYOUT.byteSize());
        }

        private static final GroupLayout LastWriteTime$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("LastWriteTime"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * LARGE_INTEGER LastWriteTime
         * }
         */
        public static final GroupLayout LastWriteTime$layout() {
            return LastWriteTime$LAYOUT;
        }

        private static final long LastWriteTime$OFFSET = 16;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * LARGE_INTEGER LastWriteTime
         * }
         */
        public static final long LastWriteTime$offset() {
            return LastWriteTime$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * LARGE_INTEGER LastWriteTime
         * }
         */
        public static MemorySegment LastWriteTime(MemorySegment struct) {
            return struct.asSlice(LastWriteTime$OFFSET, LastWriteTime$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * LARGE_INTEGER LastWriteTime
         * }
         */
        public static void LastWriteTime(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, LastWriteTime$OFFSET, LastWriteTime$LAYOUT.byteSize());
        }

        private static final GroupLayout ChangeTime$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("ChangeTime"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * LARGE_INTEGER ChangeTime
         * }
         */
        public static final GroupLayout ChangeTime$layout() {
            return ChangeTime$LAYOUT;
        }

        private static final long ChangeTime$OFFSET = 24;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * LARGE_INTEGER ChangeTime
         * }
         */
        public static final long ChangeTime$offset() {
            return ChangeTime$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * LARGE_INTEGER ChangeTime
         * }
         */
        public static MemorySegment ChangeTime(MemorySegment struct) {
            return struct.asSlice(ChangeTime$OFFSET, ChangeTime$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * LARGE_INTEGER ChangeTime
         * }
         */
        public static void ChangeTime(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, ChangeTime$OFFSET, ChangeTime$LAYOUT.byteSize());
        }

        private static final OfInt FileAttributes$LAYOUT = (OfInt)$LAYOUT.select(groupElement("FileAttributes"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * DWORD FileAttributes
         * }
         */
        public static final OfInt FileAttributes$layout() {
            return FileAttributes$LAYOUT;
        }

        private static final long FileAttributes$OFFSET = 32;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * DWORD FileAttributes
         * }
         */
        public static final long FileAttributes$offset() {
            return FileAttributes$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * DWORD FileAttributes
         * }
         */
        public static int FileAttributes(MemorySegment struct) {
            return struct.get(FileAttributes$LAYOUT, FileAttributes$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * DWORD FileAttributes
         * }
         */
        public static void FileAttributes(MemorySegment struct, int fieldValue) {
            struct.set(FileAttributes$LAYOUT, FileAttributes$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout BasicInformation$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("BasicInformation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     DWORD FileAttributes;
     * } BasicInformation
     * }
     */
    public static final GroupLayout BasicInformation$layout() {
        return BasicInformation$LAYOUT;
    }

    private static final long BasicInformation$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     DWORD FileAttributes;
     * } BasicInformation
     * }
     */
    public static final long BasicInformation$offset() {
        return BasicInformation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     DWORD FileAttributes;
     * } BasicInformation
     * }
     */
    public static MemorySegment BasicInformation(MemorySegment struct) {
        return struct.asSlice(BasicInformation$OFFSET, BasicInformation$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     DWORD FileAttributes;
     * } BasicInformation
     * }
     */
    public static void BasicInformation(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, BasicInformation$OFFSET, BasicInformation$LAYOUT.byteSize());
    }

    private static final OfInt OwnerId$LAYOUT = (OfInt)$LAYOUT.select(groupElement("OwnerId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * DWORD OwnerId
     * }
     */
    public static final OfInt OwnerId$layout() {
        return OwnerId$LAYOUT;
    }

    private static final long OwnerId$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * DWORD OwnerId
     * }
     */
    public static final long OwnerId$offset() {
        return OwnerId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * DWORD OwnerId
     * }
     */
    public static int OwnerId(MemorySegment struct) {
        return struct.get(OwnerId$LAYOUT, OwnerId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * DWORD OwnerId
     * }
     */
    public static void OwnerId(MemorySegment struct, int fieldValue) {
        struct.set(OwnerId$LAYOUT, OwnerId$OFFSET, fieldValue);
    }

    private static final OfInt SecurityId$LAYOUT = (OfInt)$LAYOUT.select(groupElement("SecurityId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * DWORD SecurityId
     * }
     */
    public static final OfInt SecurityId$layout() {
        return SecurityId$LAYOUT;
    }

    private static final long SecurityId$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * DWORD SecurityId
     * }
     */
    public static final long SecurityId$offset() {
        return SecurityId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * DWORD SecurityId
     * }
     */
    public static int SecurityId(MemorySegment struct) {
        return struct.get(SecurityId$LAYOUT, SecurityId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * DWORD SecurityId
     * }
     */
    public static void SecurityId(MemorySegment struct, int fieldValue) {
        struct.set(SecurityId$LAYOUT, SecurityId$OFFSET, fieldValue);
    }

    private static final OfLong Usn$LAYOUT = (OfLong)$LAYOUT.select(groupElement("Usn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * USN Usn
     * }
     */
    public static final OfLong Usn$layout() {
        return Usn$LAYOUT;
    }

    private static final long Usn$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * USN Usn
     * }
     */
    public static final long Usn$offset() {
        return Usn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * USN Usn
     * }
     */
    public static long Usn(MemorySegment struct) {
        return struct.get(Usn$LAYOUT, Usn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * USN Usn
     * }
     */
    public static void Usn(MemorySegment struct, long fieldValue) {
        struct.set(Usn$LAYOUT, Usn$OFFSET, fieldValue);
    }

    private static final OfInt StorageReserveId$LAYOUT = (OfInt)$LAYOUT.select(groupElement("StorageReserveId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * STORAGE_RESERVE_ID StorageReserveId
     * }
     */
    public static final OfInt StorageReserveId$layout() {
        return StorageReserveId$LAYOUT;
    }

    private static final long StorageReserveId$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * STORAGE_RESERVE_ID StorageReserveId
     * }
     */
    public static final long StorageReserveId$offset() {
        return StorageReserveId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * STORAGE_RESERVE_ID StorageReserveId
     * }
     */
    public static int StorageReserveId(MemorySegment struct) {
        return struct.get(StorageReserveId$LAYOUT, StorageReserveId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * STORAGE_RESERVE_ID StorageReserveId
     * }
     */
    public static void StorageReserveId(MemorySegment struct, int fieldValue) {
        struct.set(StorageReserveId$LAYOUT, StorageReserveId$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

