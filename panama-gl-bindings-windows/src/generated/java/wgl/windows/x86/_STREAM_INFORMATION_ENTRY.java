// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _STREAM_INFORMATION_ENTRY {
 *     DWORD Version;
 *     DWORD Flags;
 *     union _StreamInformation {
 *         struct _DesiredStorageClass {
 *             FILE_STORAGE_TIER_CLASS Class;
 *             DWORD Flags;
 *         } DesiredStorageClass;
 *         struct _DataStream {
 *             WORD Length;
 *             WORD Flags;
 *             DWORD Reserved;
 *             DWORDLONG Vdl;
 *         } DataStream;
 *         struct _Reparse {
 *             WORD Length;
 *             WORD Flags;
 *             DWORD ReparseDataSize;
 *             DWORD ReparseDataOffset;
 *         } Reparse;
 *         struct _Ea {
 *             WORD Length;
 *             WORD Flags;
 *             DWORD EaSize;
 *             DWORD EaInformationOffset;
 *         } Ea;
 *     } StreamInformation;
 * }
 * }
 */
public class _STREAM_INFORMATION_ENTRY {

    _STREAM_INFORMATION_ENTRY() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        wgl_h.C_LONG.withName("Version"),
        wgl_h.C_LONG.withName("Flags"),
        _STREAM_INFORMATION_ENTRY._StreamInformation.layout().withName("StreamInformation")
    ).withName("_STREAM_INFORMATION_ENTRY");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt Version$LAYOUT = (OfInt)$LAYOUT.select(groupElement("Version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * DWORD Version
     * }
     */
    public static final OfInt Version$layout() {
        return Version$LAYOUT;
    }

    private static final long Version$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * DWORD Version
     * }
     */
    public static final long Version$offset() {
        return Version$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * DWORD Version
     * }
     */
    public static int Version(MemorySegment struct) {
        return struct.get(Version$LAYOUT, Version$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * DWORD Version
     * }
     */
    public static void Version(MemorySegment struct, int fieldValue) {
        struct.set(Version$LAYOUT, Version$OFFSET, fieldValue);
    }

    private static final OfInt Flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("Flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * DWORD Flags
     * }
     */
    public static final OfInt Flags$layout() {
        return Flags$LAYOUT;
    }

    private static final long Flags$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * DWORD Flags
     * }
     */
    public static final long Flags$offset() {
        return Flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * DWORD Flags
     * }
     */
    public static int Flags(MemorySegment struct) {
        return struct.get(Flags$LAYOUT, Flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * DWORD Flags
     * }
     */
    public static void Flags(MemorySegment struct, int fieldValue) {
        struct.set(Flags$LAYOUT, Flags$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * union _StreamInformation {
     *     struct _DesiredStorageClass {
     *         FILE_STORAGE_TIER_CLASS Class;
     *         DWORD Flags;
     *     } DesiredStorageClass;
     *     struct _DataStream {
     *         WORD Length;
     *         WORD Flags;
     *         DWORD Reserved;
     *         DWORDLONG Vdl;
     *     } DataStream;
     *     struct _Reparse {
     *         WORD Length;
     *         WORD Flags;
     *         DWORD ReparseDataSize;
     *         DWORD ReparseDataOffset;
     *     } Reparse;
     *     struct _Ea {
     *         WORD Length;
     *         WORD Flags;
     *         DWORD EaSize;
     *         DWORD EaInformationOffset;
     *     } Ea;
     * }
     * }
     */
    public static class _StreamInformation {

        _StreamInformation() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
            _STREAM_INFORMATION_ENTRY._StreamInformation._DesiredStorageClass.layout().withName("DesiredStorageClass"),
            _STREAM_INFORMATION_ENTRY._StreamInformation._DataStream.layout().withName("DataStream"),
            _STREAM_INFORMATION_ENTRY._StreamInformation._Reparse.layout().withName("Reparse"),
            _STREAM_INFORMATION_ENTRY._StreamInformation._Ea.layout().withName("Ea")
        ).withName("_StreamInformation");

        /**
         * The layout of this union
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        /**
         * {@snippet lang=c :
         * struct _DesiredStorageClass {
         *     FILE_STORAGE_TIER_CLASS Class;
         *     DWORD Flags;
         * }
         * }
         */
        public static class _DesiredStorageClass {

            _DesiredStorageClass() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                wgl_h.C_INT.withName("Class"),
                wgl_h.C_LONG.withName("Flags")
            ).withName("_DesiredStorageClass");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfInt Class$LAYOUT = (OfInt)$LAYOUT.select(groupElement("Class"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * FILE_STORAGE_TIER_CLASS Class
             * }
             */
            public static final OfInt Class$layout() {
                return Class$LAYOUT;
            }

            private static final long Class$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * FILE_STORAGE_TIER_CLASS Class
             * }
             */
            public static final long Class$offset() {
                return Class$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * FILE_STORAGE_TIER_CLASS Class
             * }
             */
            public static int Class(MemorySegment struct) {
                return struct.get(Class$LAYOUT, Class$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * FILE_STORAGE_TIER_CLASS Class
             * }
             */
            public static void Class(MemorySegment struct, int fieldValue) {
                struct.set(Class$LAYOUT, Class$OFFSET, fieldValue);
            }

            private static final OfInt Flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("Flags"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD Flags
             * }
             */
            public static final OfInt Flags$layout() {
                return Flags$LAYOUT;
            }

            private static final long Flags$OFFSET = 4;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD Flags
             * }
             */
            public static final long Flags$offset() {
                return Flags$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD Flags
             * }
             */
            public static int Flags(MemorySegment struct) {
                return struct.get(Flags$LAYOUT, Flags$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD Flags
             * }
             */
            public static void Flags(MemorySegment struct, int fieldValue) {
                struct.set(Flags$LAYOUT, Flags$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout DesiredStorageClass$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("DesiredStorageClass"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct _DesiredStorageClass DesiredStorageClass
         * }
         */
        public static final GroupLayout DesiredStorageClass$layout() {
            return DesiredStorageClass$LAYOUT;
        }

        private static final long DesiredStorageClass$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct _DesiredStorageClass DesiredStorageClass
         * }
         */
        public static final long DesiredStorageClass$offset() {
            return DesiredStorageClass$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct _DesiredStorageClass DesiredStorageClass
         * }
         */
        public static MemorySegment DesiredStorageClass(MemorySegment union) {
            return union.asSlice(DesiredStorageClass$OFFSET, DesiredStorageClass$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct _DesiredStorageClass DesiredStorageClass
         * }
         */
        public static void DesiredStorageClass(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, DesiredStorageClass$OFFSET, DesiredStorageClass$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct _DataStream {
         *     WORD Length;
         *     WORD Flags;
         *     DWORD Reserved;
         *     DWORDLONG Vdl;
         * }
         * }
         */
        public static class _DataStream {

            _DataStream() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                wgl_h.C_SHORT.withName("Length"),
                wgl_h.C_SHORT.withName("Flags"),
                wgl_h.C_LONG.withName("Reserved"),
                wgl_h.C_LONG_LONG.withName("Vdl")
            ).withName("_DataStream");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfShort Length$LAYOUT = (OfShort)$LAYOUT.select(groupElement("Length"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static final OfShort Length$layout() {
                return Length$LAYOUT;
            }

            private static final long Length$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static final long Length$offset() {
                return Length$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static short Length(MemorySegment struct) {
                return struct.get(Length$LAYOUT, Length$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static void Length(MemorySegment struct, short fieldValue) {
                struct.set(Length$LAYOUT, Length$OFFSET, fieldValue);
            }

            private static final OfShort Flags$LAYOUT = (OfShort)$LAYOUT.select(groupElement("Flags"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static final OfShort Flags$layout() {
                return Flags$LAYOUT;
            }

            private static final long Flags$OFFSET = 2;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static final long Flags$offset() {
                return Flags$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static short Flags(MemorySegment struct) {
                return struct.get(Flags$LAYOUT, Flags$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static void Flags(MemorySegment struct, short fieldValue) {
                struct.set(Flags$LAYOUT, Flags$OFFSET, fieldValue);
            }

            private static final OfInt Reserved$LAYOUT = (OfInt)$LAYOUT.select(groupElement("Reserved"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD Reserved
             * }
             */
            public static final OfInt Reserved$layout() {
                return Reserved$LAYOUT;
            }

            private static final long Reserved$OFFSET = 4;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD Reserved
             * }
             */
            public static final long Reserved$offset() {
                return Reserved$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD Reserved
             * }
             */
            public static int Reserved(MemorySegment struct) {
                return struct.get(Reserved$LAYOUT, Reserved$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD Reserved
             * }
             */
            public static void Reserved(MemorySegment struct, int fieldValue) {
                struct.set(Reserved$LAYOUT, Reserved$OFFSET, fieldValue);
            }

            private static final OfLong Vdl$LAYOUT = (OfLong)$LAYOUT.select(groupElement("Vdl"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORDLONG Vdl
             * }
             */
            public static final OfLong Vdl$layout() {
                return Vdl$LAYOUT;
            }

            private static final long Vdl$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORDLONG Vdl
             * }
             */
            public static final long Vdl$offset() {
                return Vdl$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORDLONG Vdl
             * }
             */
            public static long Vdl(MemorySegment struct) {
                return struct.get(Vdl$LAYOUT, Vdl$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORDLONG Vdl
             * }
             */
            public static void Vdl(MemorySegment struct, long fieldValue) {
                struct.set(Vdl$LAYOUT, Vdl$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout DataStream$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("DataStream"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct _DataStream DataStream
         * }
         */
        public static final GroupLayout DataStream$layout() {
            return DataStream$LAYOUT;
        }

        private static final long DataStream$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct _DataStream DataStream
         * }
         */
        public static final long DataStream$offset() {
            return DataStream$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct _DataStream DataStream
         * }
         */
        public static MemorySegment DataStream(MemorySegment union) {
            return union.asSlice(DataStream$OFFSET, DataStream$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct _DataStream DataStream
         * }
         */
        public static void DataStream(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, DataStream$OFFSET, DataStream$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct _Reparse {
         *     WORD Length;
         *     WORD Flags;
         *     DWORD ReparseDataSize;
         *     DWORD ReparseDataOffset;
         * }
         * }
         */
        public static class _Reparse {

            _Reparse() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                wgl_h.C_SHORT.withName("Length"),
                wgl_h.C_SHORT.withName("Flags"),
                wgl_h.C_LONG.withName("ReparseDataSize"),
                wgl_h.C_LONG.withName("ReparseDataOffset")
            ).withName("_Reparse");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfShort Length$LAYOUT = (OfShort)$LAYOUT.select(groupElement("Length"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static final OfShort Length$layout() {
                return Length$LAYOUT;
            }

            private static final long Length$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static final long Length$offset() {
                return Length$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static short Length(MemorySegment struct) {
                return struct.get(Length$LAYOUT, Length$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static void Length(MemorySegment struct, short fieldValue) {
                struct.set(Length$LAYOUT, Length$OFFSET, fieldValue);
            }

            private static final OfShort Flags$LAYOUT = (OfShort)$LAYOUT.select(groupElement("Flags"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static final OfShort Flags$layout() {
                return Flags$LAYOUT;
            }

            private static final long Flags$OFFSET = 2;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static final long Flags$offset() {
                return Flags$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static short Flags(MemorySegment struct) {
                return struct.get(Flags$LAYOUT, Flags$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static void Flags(MemorySegment struct, short fieldValue) {
                struct.set(Flags$LAYOUT, Flags$OFFSET, fieldValue);
            }

            private static final OfInt ReparseDataSize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ReparseDataSize"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD ReparseDataSize
             * }
             */
            public static final OfInt ReparseDataSize$layout() {
                return ReparseDataSize$LAYOUT;
            }

            private static final long ReparseDataSize$OFFSET = 4;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD ReparseDataSize
             * }
             */
            public static final long ReparseDataSize$offset() {
                return ReparseDataSize$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD ReparseDataSize
             * }
             */
            public static int ReparseDataSize(MemorySegment struct) {
                return struct.get(ReparseDataSize$LAYOUT, ReparseDataSize$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD ReparseDataSize
             * }
             */
            public static void ReparseDataSize(MemorySegment struct, int fieldValue) {
                struct.set(ReparseDataSize$LAYOUT, ReparseDataSize$OFFSET, fieldValue);
            }

            private static final OfInt ReparseDataOffset$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ReparseDataOffset"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD ReparseDataOffset
             * }
             */
            public static final OfInt ReparseDataOffset$layout() {
                return ReparseDataOffset$LAYOUT;
            }

            private static final long ReparseDataOffset$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD ReparseDataOffset
             * }
             */
            public static final long ReparseDataOffset$offset() {
                return ReparseDataOffset$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD ReparseDataOffset
             * }
             */
            public static int ReparseDataOffset(MemorySegment struct) {
                return struct.get(ReparseDataOffset$LAYOUT, ReparseDataOffset$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD ReparseDataOffset
             * }
             */
            public static void ReparseDataOffset(MemorySegment struct, int fieldValue) {
                struct.set(ReparseDataOffset$LAYOUT, ReparseDataOffset$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout Reparse$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Reparse"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct _Reparse Reparse
         * }
         */
        public static final GroupLayout Reparse$layout() {
            return Reparse$LAYOUT;
        }

        private static final long Reparse$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct _Reparse Reparse
         * }
         */
        public static final long Reparse$offset() {
            return Reparse$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct _Reparse Reparse
         * }
         */
        public static MemorySegment Reparse(MemorySegment union) {
            return union.asSlice(Reparse$OFFSET, Reparse$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct _Reparse Reparse
         * }
         */
        public static void Reparse(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, Reparse$OFFSET, Reparse$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct _Ea {
         *     WORD Length;
         *     WORD Flags;
         *     DWORD EaSize;
         *     DWORD EaInformationOffset;
         * }
         * }
         */
        public static class _Ea {

            _Ea() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                wgl_h.C_SHORT.withName("Length"),
                wgl_h.C_SHORT.withName("Flags"),
                wgl_h.C_LONG.withName("EaSize"),
                wgl_h.C_LONG.withName("EaInformationOffset")
            ).withName("_Ea");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfShort Length$LAYOUT = (OfShort)$LAYOUT.select(groupElement("Length"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static final OfShort Length$layout() {
                return Length$LAYOUT;
            }

            private static final long Length$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static final long Length$offset() {
                return Length$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static short Length(MemorySegment struct) {
                return struct.get(Length$LAYOUT, Length$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * WORD Length
             * }
             */
            public static void Length(MemorySegment struct, short fieldValue) {
                struct.set(Length$LAYOUT, Length$OFFSET, fieldValue);
            }

            private static final OfShort Flags$LAYOUT = (OfShort)$LAYOUT.select(groupElement("Flags"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static final OfShort Flags$layout() {
                return Flags$LAYOUT;
            }

            private static final long Flags$OFFSET = 2;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static final long Flags$offset() {
                return Flags$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static short Flags(MemorySegment struct) {
                return struct.get(Flags$LAYOUT, Flags$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * WORD Flags
             * }
             */
            public static void Flags(MemorySegment struct, short fieldValue) {
                struct.set(Flags$LAYOUT, Flags$OFFSET, fieldValue);
            }

            private static final OfInt EaSize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("EaSize"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD EaSize
             * }
             */
            public static final OfInt EaSize$layout() {
                return EaSize$LAYOUT;
            }

            private static final long EaSize$OFFSET = 4;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD EaSize
             * }
             */
            public static final long EaSize$offset() {
                return EaSize$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD EaSize
             * }
             */
            public static int EaSize(MemorySegment struct) {
                return struct.get(EaSize$LAYOUT, EaSize$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD EaSize
             * }
             */
            public static void EaSize(MemorySegment struct, int fieldValue) {
                struct.set(EaSize$LAYOUT, EaSize$OFFSET, fieldValue);
            }

            private static final OfInt EaInformationOffset$LAYOUT = (OfInt)$LAYOUT.select(groupElement("EaInformationOffset"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * DWORD EaInformationOffset
             * }
             */
            public static final OfInt EaInformationOffset$layout() {
                return EaInformationOffset$LAYOUT;
            }

            private static final long EaInformationOffset$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * DWORD EaInformationOffset
             * }
             */
            public static final long EaInformationOffset$offset() {
                return EaInformationOffset$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * DWORD EaInformationOffset
             * }
             */
            public static int EaInformationOffset(MemorySegment struct) {
                return struct.get(EaInformationOffset$LAYOUT, EaInformationOffset$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * DWORD EaInformationOffset
             * }
             */
            public static void EaInformationOffset(MemorySegment struct, int fieldValue) {
                struct.set(EaInformationOffset$LAYOUT, EaInformationOffset$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout Ea$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Ea"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct _Ea Ea
         * }
         */
        public static final GroupLayout Ea$layout() {
            return Ea$LAYOUT;
        }

        private static final long Ea$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct _Ea Ea
         * }
         */
        public static final long Ea$offset() {
            return Ea$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct _Ea Ea
         * }
         */
        public static MemorySegment Ea(MemorySegment union) {
            return union.asSlice(Ea$OFFSET, Ea$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct _Ea Ea
         * }
         */
        public static void Ea(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, Ea$OFFSET, Ea$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this union
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout StreamInformation$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("StreamInformation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * union _StreamInformation StreamInformation
     * }
     */
    public static final GroupLayout StreamInformation$layout() {
        return StreamInformation$LAYOUT;
    }

    private static final long StreamInformation$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * union _StreamInformation StreamInformation
     * }
     */
    public static final long StreamInformation$offset() {
        return StreamInformation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * union _StreamInformation StreamInformation
     * }
     */
    public static MemorySegment StreamInformation(MemorySegment struct) {
        return struct.asSlice(StreamInformation$OFFSET, StreamInformation$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * union _StreamInformation StreamInformation
     * }
     */
    public static void StreamInformation(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, StreamInformation$OFFSET, StreamInformation$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

