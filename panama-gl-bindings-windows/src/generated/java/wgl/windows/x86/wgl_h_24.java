// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class wgl_h_24 extends wgl_h_25 {

    wgl_h_24() {
        // Should not be called directly
    }

    private static class QueryAuxiliaryCounterFrequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryAuxiliaryCounterFrequency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency)
     * }
     */
    public static FunctionDescriptor QueryAuxiliaryCounterFrequency$descriptor() {
        return QueryAuxiliaryCounterFrequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency)
     * }
     */
    public static MethodHandle QueryAuxiliaryCounterFrequency$handle() {
        return QueryAuxiliaryCounterFrequency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency)
     * }
     */
    public static MemorySegment QueryAuxiliaryCounterFrequency$address() {
        return QueryAuxiliaryCounterFrequency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency)
     * }
     */
    public static int QueryAuxiliaryCounterFrequency(MemorySegment lpAuxiliaryCounterFrequency) {
        var mh$ = QueryAuxiliaryCounterFrequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryAuxiliaryCounterFrequency", lpAuxiliaryCounterFrequency);
            }
            return (int)mh$.invokeExact(lpAuxiliaryCounterFrequency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertAuxiliaryCounterToPerformanceCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ConvertAuxiliaryCounterToPerformanceCounter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue, PULONGLONG lpPerformanceCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static FunctionDescriptor ConvertAuxiliaryCounterToPerformanceCounter$descriptor() {
        return ConvertAuxiliaryCounterToPerformanceCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue, PULONGLONG lpPerformanceCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static MethodHandle ConvertAuxiliaryCounterToPerformanceCounter$handle() {
        return ConvertAuxiliaryCounterToPerformanceCounter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue, PULONGLONG lpPerformanceCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static MemorySegment ConvertAuxiliaryCounterToPerformanceCounter$address() {
        return ConvertAuxiliaryCounterToPerformanceCounter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue, PULONGLONG lpPerformanceCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static int ConvertAuxiliaryCounterToPerformanceCounter(long ullAuxiliaryCounterValue, MemorySegment lpPerformanceCounterValue, MemorySegment lpConversionError) {
        var mh$ = ConvertAuxiliaryCounterToPerformanceCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertAuxiliaryCounterToPerformanceCounter", ullAuxiliaryCounterValue, lpPerformanceCounterValue, lpConversionError);
            }
            return (int)mh$.invokeExact(ullAuxiliaryCounterValue, lpPerformanceCounterValue, lpConversionError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertPerformanceCounterToAuxiliaryCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ConvertPerformanceCounterToAuxiliaryCounter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue, PULONGLONG lpAuxiliaryCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static FunctionDescriptor ConvertPerformanceCounterToAuxiliaryCounter$descriptor() {
        return ConvertPerformanceCounterToAuxiliaryCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue, PULONGLONG lpAuxiliaryCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static MethodHandle ConvertPerformanceCounterToAuxiliaryCounter$handle() {
        return ConvertPerformanceCounterToAuxiliaryCounter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue, PULONGLONG lpAuxiliaryCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static MemorySegment ConvertPerformanceCounterToAuxiliaryCounter$address() {
        return ConvertPerformanceCounterToAuxiliaryCounter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue, PULONGLONG lpAuxiliaryCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static int ConvertPerformanceCounterToAuxiliaryCounter(long ullPerformanceCounterValue, MemorySegment lpAuxiliaryCounterValue, MemorySegment lpConversionError) {
        var mh$ = ConvertPerformanceCounterToAuxiliaryCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertPerformanceCounterToAuxiliaryCounter", ullPerformanceCounterValue, lpAuxiliaryCounterValue, lpConversionError);
            }
            return (int)mh$.invokeExact(ullPerformanceCounterValue, lpAuxiliaryCounterValue, lpConversionError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef LPVOID LPLDT_ENTRY
     * }
     */
    public static final AddressLayout LPLDT_ENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMMPROP {
     *     WORD wPacketLength;
     *     WORD wPacketVersion;
     *     DWORD dwServiceMask;
     *     DWORD dwReserved1;
     *     DWORD dwMaxTxQueue;
     *     DWORD dwMaxRxQueue;
     *     DWORD dwMaxBaud;
     *     DWORD dwProvSubType;
     *     DWORD dwProvCapabilities;
     *     DWORD dwSettableParams;
     *     DWORD dwSettableBaud;
     *     WORD wSettableData;
     *     WORD wSettableStopParity;
     *     DWORD dwCurrentTxQueue;
     *     DWORD dwCurrentRxQueue;
     *     DWORD dwProvSpec1;
     *     DWORD dwProvSpec2;
     *     WCHAR wcProvChar[1];
     * } *LPCOMMPROP
     * }
     */
    public static final AddressLayout LPCOMMPROP = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMSTAT {
     *     DWORD fCtsHold : 1;
     *     DWORD fDsrHold : 1;
     *     DWORD fRlsdHold : 1;
     *     DWORD fXoffHold : 1;
     *     DWORD fXoffSent : 1;
     *     DWORD fEof : 1;
     *     DWORD fTxim : 1;
     *     DWORD fReserved : 25;
     *     DWORD cbInQue;
     *     DWORD cbOutQue;
     * } *LPCOMSTAT
     * }
     */
    public static final AddressLayout LPCOMSTAT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DCB {
     *     DWORD DCBlength;
     *     DWORD BaudRate;
     *     DWORD fBinary : 1;
     *     DWORD fParity : 1;
     *     DWORD fOutxCtsFlow : 1;
     *     DWORD fOutxDsrFlow : 1;
     *     DWORD fDtrControl : 2;
     *     DWORD fDsrSensitivity : 1;
     *     DWORD fTXContinueOnXoff : 1;
     *     DWORD fOutX : 1;
     *     DWORD fInX : 1;
     *     DWORD fErrorChar : 1;
     *     DWORD fNull : 1;
     *     DWORD fRtsControl : 2;
     *     DWORD fAbortOnError : 1;
     *     DWORD fDummy2 : 17;
     *     WORD wReserved;
     *     WORD XonLim;
     *     WORD XoffLim;
     *     BYTE ByteSize;
     *     BYTE Parity;
     *     BYTE StopBits;
     *     char XonChar;
     *     char XoffChar;
     *     char ErrorChar;
     *     char EofChar;
     *     char EvtChar;
     *     WORD wReserved1;
     * } *LPDCB
     * }
     */
    public static final AddressLayout LPDCB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMMTIMEOUTS {
     *     DWORD ReadIntervalTimeout;
     *     DWORD ReadTotalTimeoutMultiplier;
     *     DWORD ReadTotalTimeoutConstant;
     *     DWORD WriteTotalTimeoutMultiplier;
     *     DWORD WriteTotalTimeoutConstant;
     * } *LPCOMMTIMEOUTS
     * }
     */
    public static final AddressLayout LPCOMMTIMEOUTS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMMCONFIG {
     *     DWORD dwSize;
     *     WORD wVersion;
     *     WORD wReserved;
     *     DCB dcb;
     *     DWORD dwProviderSubType;
     *     DWORD dwProviderOffset;
     *     DWORD dwProviderSize;
     *     WCHAR wcProviderData[1];
     * } *LPCOMMCONFIG
     * }
     */
    public static final AddressLayout LPCOMMCONFIG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORYSTATUS {
     *     DWORD dwLength;
     *     DWORD dwMemoryLoad;
     *     SIZE_T dwTotalPhys;
     *     SIZE_T dwAvailPhys;
     *     SIZE_T dwTotalPageFile;
     *     SIZE_T dwAvailPageFile;
     *     SIZE_T dwTotalVirtual;
     *     SIZE_T dwAvailVirtual;
     * } *LPMEMORYSTATUS
     * }
     */
    public static final AddressLayout LPMEMORYSTATUS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JIT_DEBUG_INFO {
     *     DWORD dwSize;
     *     DWORD dwProcessorArchitecture;
     *     DWORD dwThreadID;
     *     DWORD dwReserved0;
     *     ULONG64 lpExceptionAddress;
     *     ULONG64 lpExceptionRecord;
     *     ULONG64 lpContextRecord;
     * } *LPJIT_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPJIT_DEBUG_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef JIT_DEBUG_INFO *LPJIT_DEBUG_INFO32
     * }
     */
    public static final AddressLayout LPJIT_DEBUG_INFO32 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef JIT_DEBUG_INFO *LPJIT_DEBUG_INFO64
     * }
     */
    public static final AddressLayout LPJIT_DEBUG_INFO64 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD
     * }
     */
    public static final AddressLayout LPEXCEPTION_RECORD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS
     * }
     */
    public static final AddressLayout LPEXCEPTION_POINTERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OFSTRUCT {
     *     BYTE cBytes;
     *     BYTE fFixedDisk;
     *     WORD nErrCode;
     *     WORD Reserved1;
     *     WORD Reserved2;
     *     CHAR szPathName[128];
     * } *LPOFSTRUCT
     * }
     */
    public static final AddressLayout LPOFSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OFSTRUCT {
     *     BYTE cBytes;
     *     BYTE fFixedDisk;
     *     WORD nErrCode;
     *     WORD Reserved1;
     *     WORD Reserved2;
     *     CHAR szPathName[128];
     * } *POFSTRUCT
     * }
     */
    public static final AddressLayout POFSTRUCT = wgl_h.C_POINTER;

    private static class WinMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WinMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static FunctionDescriptor WinMain$descriptor() {
        return WinMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static MethodHandle WinMain$handle() {
        return WinMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static MemorySegment WinMain$address() {
        return WinMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static int WinMain(MemorySegment hInstance, MemorySegment hPrevInstance, MemorySegment lpCmdLine, int nShowCmd) {
        var mh$ = WinMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WinMain", hInstance, hPrevInstance, lpCmdLine, nShowCmd);
            }
            return (int)mh$.invokeExact(hInstance, hPrevInstance, lpCmdLine, nShowCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wWinMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wWinMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static FunctionDescriptor wWinMain$descriptor() {
        return wWinMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static MethodHandle wWinMain$handle() {
        return wWinMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static MemorySegment wWinMain$address() {
        return wWinMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static int wWinMain(MemorySegment hInstance, MemorySegment hPrevInstance, MemorySegment lpCmdLine, int nShowCmd) {
        var mh$ = wWinMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wWinMain", hInstance, hPrevInstance, lpCmdLine, nShowCmd);
            }
            return (int)mh$.invokeExact(hInstance, hPrevInstance, lpCmdLine, nShowCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
     * }
     */
    public static FunctionDescriptor GlobalAlloc$descriptor() {
        return GlobalAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
     * }
     */
    public static MethodHandle GlobalAlloc$handle() {
        return GlobalAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment GlobalAlloc$address() {
        return GlobalAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment GlobalAlloc(int uFlags, long dwBytes) {
        var mh$ = GlobalAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAlloc", uFlags, dwBytes);
            }
            return (MemorySegment)mh$.invokeExact(uFlags, dwBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalReAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalReAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
     * }
     */
    public static FunctionDescriptor GlobalReAlloc$descriptor() {
        return GlobalReAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
     * }
     */
    public static MethodHandle GlobalReAlloc$handle() {
        return GlobalReAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLOBAL GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
     * }
     */
    public static MemorySegment GlobalReAlloc$address() {
        return GlobalReAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
     * }
     */
    public static MemorySegment GlobalReAlloc(MemorySegment hMem, long dwBytes, int uFlags) {
        var mh$ = GlobalReAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalReAlloc", hMem, dwBytes, uFlags);
            }
            return (MemorySegment)mh$.invokeExact(hMem, dwBytes, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T GlobalSize(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalSize$descriptor() {
        return GlobalSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T GlobalSize(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalSize$handle() {
        return GlobalSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T GlobalSize(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalSize$address() {
        return GlobalSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T GlobalSize(HGLOBAL hMem)
     * }
     */
    public static long GlobalSize(MemorySegment hMem) {
        var mh$ = GlobalSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalSize", hMem);
            }
            return (long)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GlobalUnlock(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalUnlock$descriptor() {
        return GlobalUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GlobalUnlock(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalUnlock$handle() {
        return GlobalUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GlobalUnlock(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalUnlock$address() {
        return GlobalUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GlobalUnlock(HGLOBAL hMem)
     * }
     */
    public static int GlobalUnlock(MemorySegment hMem) {
        var mh$ = GlobalUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalUnlock", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID GlobalLock(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalLock$descriptor() {
        return GlobalLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID GlobalLock(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalLock$handle() {
        return GlobalLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID GlobalLock(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalLock$address() {
        return GlobalLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID GlobalLock(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalLock(MemorySegment hMem) {
        var mh$ = GlobalLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalLock", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GlobalFlags(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalFlags$descriptor() {
        return GlobalFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GlobalFlags(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalFlags$handle() {
        return GlobalFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GlobalFlags(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalFlags$address() {
        return GlobalFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GlobalFlags(HGLOBAL hMem)
     * }
     */
    public static int GlobalFlags(MemorySegment hMem) {
        var mh$ = GlobalFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFlags", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalHandle(LPCVOID pMem)
     * }
     */
    public static FunctionDescriptor GlobalHandle$descriptor() {
        return GlobalHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalHandle(LPCVOID pMem)
     * }
     */
    public static MethodHandle GlobalHandle$handle() {
        return GlobalHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLOBAL GlobalHandle(LPCVOID pMem)
     * }
     */
    public static MemorySegment GlobalHandle$address() {
        return GlobalHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalHandle(LPCVOID pMem)
     * }
     */
    public static MemorySegment GlobalHandle(MemorySegment pMem) {
        var mh$ = GlobalHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalHandle", pMem);
            }
            return (MemorySegment)mh$.invokeExact(pMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalFree(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalFree$descriptor() {
        return GlobalFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalFree(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalFree$handle() {
        return GlobalFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLOBAL GlobalFree(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalFree$address() {
        return GlobalFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalFree(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalFree(MemorySegment hMem) {
        var mh$ = GlobalFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFree", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalCompact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalCompact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T GlobalCompact(DWORD dwMinFree)
     * }
     */
    public static FunctionDescriptor GlobalCompact$descriptor() {
        return GlobalCompact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T GlobalCompact(DWORD dwMinFree)
     * }
     */
    public static MethodHandle GlobalCompact$handle() {
        return GlobalCompact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T GlobalCompact(DWORD dwMinFree)
     * }
     */
    public static MemorySegment GlobalCompact$address() {
        return GlobalCompact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T GlobalCompact(DWORD dwMinFree)
     * }
     */
    public static long GlobalCompact(int dwMinFree) {
        var mh$ = GlobalCompact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalCompact", dwMinFree);
            }
            return (long)mh$.invokeExact(dwMinFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalFix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GlobalFix(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalFix$descriptor() {
        return GlobalFix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GlobalFix(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalFix$handle() {
        return GlobalFix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GlobalFix(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalFix$address() {
        return GlobalFix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GlobalFix(HGLOBAL hMem)
     * }
     */
    public static void GlobalFix(MemorySegment hMem) {
        var mh$ = GlobalFix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFix", hMem);
            }
            mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalUnfix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalUnfix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GlobalUnfix(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalUnfix$descriptor() {
        return GlobalUnfix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GlobalUnfix(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalUnfix$handle() {
        return GlobalUnfix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GlobalUnfix(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalUnfix$address() {
        return GlobalUnfix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GlobalUnfix(HGLOBAL hMem)
     * }
     */
    public static void GlobalUnfix(MemorySegment hMem) {
        var mh$ = GlobalUnfix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalUnfix", hMem);
            }
            mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalWire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalWire");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID GlobalWire(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalWire$descriptor() {
        return GlobalWire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID GlobalWire(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalWire$handle() {
        return GlobalWire.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID GlobalWire(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalWire$address() {
        return GlobalWire.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID GlobalWire(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalWire(MemorySegment hMem) {
        var mh$ = GlobalWire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalWire", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalUnWire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalUnWire");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GlobalUnWire(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalUnWire$descriptor() {
        return GlobalUnWire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GlobalUnWire(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalUnWire$handle() {
        return GlobalUnWire.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GlobalUnWire(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalUnWire$address() {
        return GlobalUnWire.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GlobalUnWire(HGLOBAL hMem)
     * }
     */
    public static int GlobalUnWire(MemorySegment hMem) {
        var mh$ = GlobalUnWire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalUnWire", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalMemoryStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalMemoryStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
     * }
     */
    public static FunctionDescriptor GlobalMemoryStatus$descriptor() {
        return GlobalMemoryStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
     * }
     */
    public static MethodHandle GlobalMemoryStatus$handle() {
        return GlobalMemoryStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
     * }
     */
    public static MemorySegment GlobalMemoryStatus$address() {
        return GlobalMemoryStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
     * }
     */
    public static void GlobalMemoryStatus(MemorySegment lpBuffer) {
        var mh$ = GlobalMemoryStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalMemoryStatus", lpBuffer);
            }
            mh$.invokeExact(lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalAlloc(UINT uFlags, SIZE_T uBytes)
     * }
     */
    public static FunctionDescriptor LocalAlloc$descriptor() {
        return LocalAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalAlloc(UINT uFlags, SIZE_T uBytes)
     * }
     */
    public static MethodHandle LocalAlloc$handle() {
        return LocalAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HLOCAL LocalAlloc(UINT uFlags, SIZE_T uBytes)
     * }
     */
    public static MemorySegment LocalAlloc$address() {
        return LocalAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HLOCAL LocalAlloc(UINT uFlags, SIZE_T uBytes)
     * }
     */
    public static MemorySegment LocalAlloc(int uFlags, long uBytes) {
        var mh$ = LocalAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalAlloc", uFlags, uBytes);
            }
            return (MemorySegment)mh$.invokeExact(uFlags, uBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalReAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalReAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
     * }
     */
    public static FunctionDescriptor LocalReAlloc$descriptor() {
        return LocalReAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
     * }
     */
    public static MethodHandle LocalReAlloc$handle() {
        return LocalReAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HLOCAL LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
     * }
     */
    public static MemorySegment LocalReAlloc$address() {
        return LocalReAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HLOCAL LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
     * }
     */
    public static MemorySegment LocalReAlloc(MemorySegment hMem, long uBytes, int uFlags) {
        var mh$ = LocalReAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalReAlloc", hMem, uBytes, uFlags);
            }
            return (MemorySegment)mh$.invokeExact(hMem, uBytes, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID LocalLock(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalLock$descriptor() {
        return LocalLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID LocalLock(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalLock$handle() {
        return LocalLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID LocalLock(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalLock$address() {
        return LocalLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID LocalLock(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalLock(MemorySegment hMem) {
        var mh$ = LocalLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalLock", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalHandle(LPCVOID pMem)
     * }
     */
    public static FunctionDescriptor LocalHandle$descriptor() {
        return LocalHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalHandle(LPCVOID pMem)
     * }
     */
    public static MethodHandle LocalHandle$handle() {
        return LocalHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HLOCAL LocalHandle(LPCVOID pMem)
     * }
     */
    public static MemorySegment LocalHandle$address() {
        return LocalHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HLOCAL LocalHandle(LPCVOID pMem)
     * }
     */
    public static MemorySegment LocalHandle(MemorySegment pMem) {
        var mh$ = LocalHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalHandle", pMem);
            }
            return (MemorySegment)mh$.invokeExact(pMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalUnlock(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalUnlock$descriptor() {
        return LocalUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalUnlock(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalUnlock$handle() {
        return LocalUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LocalUnlock(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalUnlock$address() {
        return LocalUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LocalUnlock(HLOCAL hMem)
     * }
     */
    public static int LocalUnlock(MemorySegment hMem) {
        var mh$ = LocalUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalUnlock", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T LocalSize(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalSize$descriptor() {
        return LocalSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T LocalSize(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalSize$handle() {
        return LocalSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T LocalSize(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalSize$address() {
        return LocalSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T LocalSize(HLOCAL hMem)
     * }
     */
    public static long LocalSize(MemorySegment hMem) {
        var mh$ = LocalSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalSize", hMem);
            }
            return (long)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT LocalFlags(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalFlags$descriptor() {
        return LocalFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT LocalFlags(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalFlags$handle() {
        return LocalFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT LocalFlags(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalFlags$address() {
        return LocalFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT LocalFlags(HLOCAL hMem)
     * }
     */
    public static int LocalFlags(MemorySegment hMem) {
        var mh$ = LocalFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFlags", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalFree(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalFree$descriptor() {
        return LocalFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalFree(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalFree$handle() {
        return LocalFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HLOCAL LocalFree(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalFree$address() {
        return LocalFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HLOCAL LocalFree(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalFree(MemorySegment hMem) {
        var mh$ = LocalFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFree", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalShrink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalShrink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T LocalShrink(HLOCAL hMem, UINT cbNewSize)
     * }
     */
    public static FunctionDescriptor LocalShrink$descriptor() {
        return LocalShrink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T LocalShrink(HLOCAL hMem, UINT cbNewSize)
     * }
     */
    public static MethodHandle LocalShrink$handle() {
        return LocalShrink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T LocalShrink(HLOCAL hMem, UINT cbNewSize)
     * }
     */
    public static MemorySegment LocalShrink$address() {
        return LocalShrink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T LocalShrink(HLOCAL hMem, UINT cbNewSize)
     * }
     */
    public static long LocalShrink(MemorySegment hMem, int cbNewSize) {
        var mh$ = LocalShrink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalShrink", hMem, cbNewSize);
            }
            return (long)mh$.invokeExact(hMem, cbNewSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalCompact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalCompact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T LocalCompact(UINT uMinFree)
     * }
     */
    public static FunctionDescriptor LocalCompact$descriptor() {
        return LocalCompact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T LocalCompact(UINT uMinFree)
     * }
     */
    public static MethodHandle LocalCompact$handle() {
        return LocalCompact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T LocalCompact(UINT uMinFree)
     * }
     */
    public static MemorySegment LocalCompact$address() {
        return LocalCompact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T LocalCompact(UINT uMinFree)
     * }
     */
    public static long LocalCompact(int uMinFree) {
        var mh$ = LocalCompact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalCompact", uMinFree);
            }
            return (long)mh$.invokeExact(uMinFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBinaryTypeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetBinaryTypeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static FunctionDescriptor GetBinaryTypeA$descriptor() {
        return GetBinaryTypeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static MethodHandle GetBinaryTypeA$handle() {
        return GetBinaryTypeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static MemorySegment GetBinaryTypeA$address() {
        return GetBinaryTypeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static int GetBinaryTypeA(MemorySegment lpApplicationName, MemorySegment lpBinaryType) {
        var mh$ = GetBinaryTypeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBinaryTypeA", lpApplicationName, lpBinaryType);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpBinaryType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBinaryTypeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetBinaryTypeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static FunctionDescriptor GetBinaryTypeW$descriptor() {
        return GetBinaryTypeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static MethodHandle GetBinaryTypeW$handle() {
        return GetBinaryTypeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static MemorySegment GetBinaryTypeW$address() {
        return GetBinaryTypeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static int GetBinaryTypeW(MemorySegment lpApplicationName, MemorySegment lpBinaryType) {
        var mh$ = GetBinaryTypeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBinaryTypeW", lpApplicationName, lpBinaryType);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpBinaryType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShortPathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetShortPathNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetShortPathNameA$descriptor() {
        return GetShortPathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetShortPathNameA$handle() {
        return GetShortPathNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MemorySegment GetShortPathNameA$address() {
        return GetShortPathNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static int GetShortPathNameA(MemorySegment lpszLongPath, MemorySegment lpszShortPath, int cchBuffer) {
        var mh$ = GetShortPathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShortPathNameA", lpszLongPath, lpszShortPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszLongPath, lpszShortPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLongPathNameTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetLongPathNameTransactedA$descriptor() {
        return GetLongPathNameTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetLongPathNameTransactedA$handle() {
        return GetLongPathNameTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetLongPathNameTransactedA$address() {
        return GetLongPathNameTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static int GetLongPathNameTransactedA(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer, MemorySegment hTransaction) {
        var mh$ = GetLongPathNameTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameTransactedA", lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLongPathNameTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetLongPathNameTransactedW$descriptor() {
        return GetLongPathNameTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetLongPathNameTransactedW$handle() {
        return GetLongPathNameTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetLongPathNameTransactedW$address() {
        return GetLongPathNameTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static int GetLongPathNameTransactedW(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer, MemorySegment hTransaction) {
        var mh$ = GetLongPathNameTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameTransactedW", lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessAffinityMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessAffinityMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
     * }
     */
    public static FunctionDescriptor GetProcessAffinityMask$descriptor() {
        return GetProcessAffinityMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
     * }
     */
    public static MethodHandle GetProcessAffinityMask$handle() {
        return GetProcessAffinityMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
     * }
     */
    public static MemorySegment GetProcessAffinityMask$address() {
        return GetProcessAffinityMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
     * }
     */
    public static int GetProcessAffinityMask(MemorySegment hProcess, MemorySegment lpProcessAffinityMask, MemorySegment lpSystemAffinityMask) {
        var mh$ = GetProcessAffinityMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessAffinityMask", hProcess, lpProcessAffinityMask, lpSystemAffinityMask);
            }
            return (int)mh$.invokeExact(hProcess, lpProcessAffinityMask, lpSystemAffinityMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessAffinityMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessAffinityMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
     * }
     */
    public static FunctionDescriptor SetProcessAffinityMask$descriptor() {
        return SetProcessAffinityMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
     * }
     */
    public static MethodHandle SetProcessAffinityMask$handle() {
        return SetProcessAffinityMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
     * }
     */
    public static MemorySegment SetProcessAffinityMask$address() {
        return SetProcessAffinityMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
     * }
     */
    public static int SetProcessAffinityMask(MemorySegment hProcess, long dwProcessAffinityMask) {
        var mh$ = SetProcessAffinityMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessAffinityMask", hProcess, dwProcessAffinityMask);
            }
            return (int)mh$.invokeExact(hProcess, dwProcessAffinityMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessIoCounters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessIoCounters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
     * }
     */
    public static FunctionDescriptor GetProcessIoCounters$descriptor() {
        return GetProcessIoCounters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
     * }
     */
    public static MethodHandle GetProcessIoCounters$handle() {
        return GetProcessIoCounters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
     * }
     */
    public static MemorySegment GetProcessIoCounters$address() {
        return GetProcessIoCounters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
     * }
     */
    public static int GetProcessIoCounters(MemorySegment hProcess, MemorySegment lpIoCounters) {
        var mh$ = GetProcessIoCounters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessIoCounters", hProcess, lpIoCounters);
            }
            return (int)mh$.invokeExact(hProcess, lpIoCounters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessWorkingSetSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessWorkingSetSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
     * }
     */
    public static FunctionDescriptor GetProcessWorkingSetSize$descriptor() {
        return GetProcessWorkingSetSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
     * }
     */
    public static MethodHandle GetProcessWorkingSetSize$handle() {
        return GetProcessWorkingSetSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
     * }
     */
    public static MemorySegment GetProcessWorkingSetSize$address() {
        return GetProcessWorkingSetSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
     * }
     */
    public static int GetProcessWorkingSetSize(MemorySegment hProcess, MemorySegment lpMinimumWorkingSetSize, MemorySegment lpMaximumWorkingSetSize) {
        var mh$ = GetProcessWorkingSetSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessWorkingSetSize", hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize);
            }
            return (int)mh$.invokeExact(hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessWorkingSetSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessWorkingSetSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
     * }
     */
    public static FunctionDescriptor SetProcessWorkingSetSize$descriptor() {
        return SetProcessWorkingSetSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
     * }
     */
    public static MethodHandle SetProcessWorkingSetSize$handle() {
        return SetProcessWorkingSetSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
     * }
     */
    public static MemorySegment SetProcessWorkingSetSize$address() {
        return SetProcessWorkingSetSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
     * }
     */
    public static int SetProcessWorkingSetSize(MemorySegment hProcess, long dwMinimumWorkingSetSize, long dwMaximumWorkingSetSize) {
        var mh$ = SetProcessWorkingSetSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessWorkingSetSize", hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize);
            }
            return (int)mh$.invokeExact(hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FatalExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FatalExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FatalExit(int ExitCode)
     * }
     */
    public static FunctionDescriptor FatalExit$descriptor() {
        return FatalExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FatalExit(int ExitCode)
     * }
     */
    public static MethodHandle FatalExit$handle() {
        return FatalExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FatalExit(int ExitCode)
     * }
     */
    public static MemorySegment FatalExit$address() {
        return FatalExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FatalExit(int ExitCode)
     * }
     */
    public static void FatalExit(int ExitCode) {
        var mh$ = FatalExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FatalExit", ExitCode);
            }
            mh$.invokeExact(ExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetEnvironmentStringsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsA(LPCH NewEnvironment)
     * }
     */
    public static FunctionDescriptor SetEnvironmentStringsA$descriptor() {
        return SetEnvironmentStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsA(LPCH NewEnvironment)
     * }
     */
    public static MethodHandle SetEnvironmentStringsA$handle() {
        return SetEnvironmentStringsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsA(LPCH NewEnvironment)
     * }
     */
    public static MemorySegment SetEnvironmentStringsA$address() {
        return SetEnvironmentStringsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsA(LPCH NewEnvironment)
     * }
     */
    public static int SetEnvironmentStringsA(MemorySegment NewEnvironment) {
        var mh$ = SetEnvironmentStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentStringsA", NewEnvironment);
            }
            return (int)mh$.invokeExact(NewEnvironment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchToFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SwitchToFiber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SwitchToFiber(LPVOID lpFiber)
     * }
     */
    public static FunctionDescriptor SwitchToFiber$descriptor() {
        return SwitchToFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SwitchToFiber(LPVOID lpFiber)
     * }
     */
    public static MethodHandle SwitchToFiber$handle() {
        return SwitchToFiber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SwitchToFiber(LPVOID lpFiber)
     * }
     */
    public static MemorySegment SwitchToFiber$address() {
        return SwitchToFiber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SwitchToFiber(LPVOID lpFiber)
     * }
     */
    public static void SwitchToFiber(MemorySegment lpFiber) {
        var mh$ = SwitchToFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchToFiber", lpFiber);
            }
            mh$.invokeExact(lpFiber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteFiber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteFiber(LPVOID lpFiber)
     * }
     */
    public static FunctionDescriptor DeleteFiber$descriptor() {
        return DeleteFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteFiber(LPVOID lpFiber)
     * }
     */
    public static MethodHandle DeleteFiber$handle() {
        return DeleteFiber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DeleteFiber(LPVOID lpFiber)
     * }
     */
    public static MemorySegment DeleteFiber$address() {
        return DeleteFiber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DeleteFiber(LPVOID lpFiber)
     * }
     */
    public static void DeleteFiber(MemorySegment lpFiber) {
        var mh$ = DeleteFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFiber", lpFiber);
            }
            mh$.invokeExact(lpFiber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertFiberToThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ConvertFiberToThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ConvertFiberToThread()
     * }
     */
    public static FunctionDescriptor ConvertFiberToThread$descriptor() {
        return ConvertFiberToThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ConvertFiberToThread()
     * }
     */
    public static MethodHandle ConvertFiberToThread$handle() {
        return ConvertFiberToThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ConvertFiberToThread()
     * }
     */
    public static MemorySegment ConvertFiberToThread$address() {
        return ConvertFiberToThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ConvertFiberToThread()
     * }
     */
    public static int ConvertFiberToThread() {
        var mh$ = ConvertFiberToThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertFiberToThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFiberEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFiberEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static FunctionDescriptor CreateFiberEx$descriptor() {
        return CreateFiberEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MethodHandle CreateFiberEx$handle() {
        return CreateFiberEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MemorySegment CreateFiberEx$address() {
        return CreateFiberEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MemorySegment CreateFiberEx(long dwStackCommitSize, long dwStackReserveSize, int dwFlags, MemorySegment lpStartAddress, MemorySegment lpParameter) {
        var mh$ = CreateFiberEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFiberEx", dwStackCommitSize, dwStackReserveSize, dwFlags, lpStartAddress, lpParameter);
            }
            return (MemorySegment)mh$.invokeExact(dwStackCommitSize, dwStackReserveSize, dwFlags, lpStartAddress, lpParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertThreadToFiberEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ConvertThreadToFiberEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor ConvertThreadToFiberEx$descriptor() {
        return ConvertThreadToFiberEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
     * }
     */
    public static MethodHandle ConvertThreadToFiberEx$handle() {
        return ConvertThreadToFiberEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
     * }
     */
    public static MemorySegment ConvertThreadToFiberEx$address() {
        return ConvertThreadToFiberEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
     * }
     */
    public static MemorySegment ConvertThreadToFiberEx(MemorySegment lpParameter, int dwFlags) {
        var mh$ = ConvertThreadToFiberEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertThreadToFiberEx", lpParameter, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpParameter, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFiber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static FunctionDescriptor CreateFiber$descriptor() {
        return CreateFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MethodHandle CreateFiber$handle() {
        return CreateFiber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MemorySegment CreateFiber$address() {
        return CreateFiber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MemorySegment CreateFiber(long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter) {
        var mh$ = CreateFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFiber", dwStackSize, lpStartAddress, lpParameter);
            }
            return (MemorySegment)mh$.invokeExact(dwStackSize, lpStartAddress, lpParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertThreadToFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ConvertThreadToFiber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiber(LPVOID lpParameter)
     * }
     */
    public static FunctionDescriptor ConvertThreadToFiber$descriptor() {
        return ConvertThreadToFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiber(LPVOID lpParameter)
     * }
     */
    public static MethodHandle ConvertThreadToFiber$handle() {
        return ConvertThreadToFiber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiber(LPVOID lpParameter)
     * }
     */
    public static MemorySegment ConvertThreadToFiber$address() {
        return ConvertThreadToFiber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiber(LPVOID lpParameter)
     * }
     */
    public static MemorySegment ConvertThreadToFiber(MemorySegment lpParameter) {
        var mh$ = ConvertThreadToFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertThreadToFiber", lpParameter);
            }
            return (MemorySegment)mh$.invokeExact(lpParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *PUMS_CONTEXT
     * }
     */
    public static final AddressLayout PUMS_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *PUMS_COMPLETION_LIST
     * }
     */
    public static final AddressLayout PUMS_COMPLETION_LIST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef enum _RTL_UMS_THREAD_INFO_CLASS {
     *     UmsThreadInvalidInfoClass = 0,
     *     UmsThreadUserContext,
     *     UmsThreadPriority,
     *     UmsThreadAffinity,
     *     UmsThreadTeb,
     *     UmsThreadIsSuspended,
     *     UmsThreadIsTerminated,
     *     UmsThreadMaxInfoClass
     * } *PUMS_THREAD_INFO_CLASS
     * }
     */
    public static final AddressLayout PUMS_THREAD_INFO_CLASS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UMS_SCHEDULER_STARTUP_INFO {
     *     ULONG UmsVersion;
     *     PUMS_COMPLETION_LIST CompletionList;
     *     PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;
     *     PVOID SchedulerParam;
     * } *PUMS_SCHEDULER_STARTUP_INFO
     * }
     */
    public static final AddressLayout PUMS_SCHEDULER_STARTUP_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UMS_SYSTEM_THREAD_INFORMATION {
     *     ULONG UmsVersion;
     *     union {
     *         struct {
     *             ULONG IsUmsSchedulerThread : 1;
     *             ULONG IsUmsWorkerThread : 1;
     *         };
     *         ULONG ThreadUmsFlags;
     *     };
     * } *PUMS_SYSTEM_THREAD_INFORMATION
     * }
     */
    public static final AddressLayout PUMS_SYSTEM_THREAD_INFORMATION = wgl_h.C_POINTER;

    private static class CreateUmsCompletionList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateUmsCompletionList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateUmsCompletionList(PUMS_COMPLETION_LIST *UmsCompletionList)
     * }
     */
    public static FunctionDescriptor CreateUmsCompletionList$descriptor() {
        return CreateUmsCompletionList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateUmsCompletionList(PUMS_COMPLETION_LIST *UmsCompletionList)
     * }
     */
    public static MethodHandle CreateUmsCompletionList$handle() {
        return CreateUmsCompletionList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateUmsCompletionList(PUMS_COMPLETION_LIST *UmsCompletionList)
     * }
     */
    public static MemorySegment CreateUmsCompletionList$address() {
        return CreateUmsCompletionList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateUmsCompletionList(PUMS_COMPLETION_LIST *UmsCompletionList)
     * }
     */
    public static int CreateUmsCompletionList(MemorySegment UmsCompletionList) {
        var mh$ = CreateUmsCompletionList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateUmsCompletionList", UmsCompletionList);
            }
            return (int)mh$.invokeExact(UmsCompletionList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DequeueUmsCompletionListItems {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DequeueUmsCompletionListItems");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT *UmsThreadList)
     * }
     */
    public static FunctionDescriptor DequeueUmsCompletionListItems$descriptor() {
        return DequeueUmsCompletionListItems.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT *UmsThreadList)
     * }
     */
    public static MethodHandle DequeueUmsCompletionListItems$handle() {
        return DequeueUmsCompletionListItems.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT *UmsThreadList)
     * }
     */
    public static MemorySegment DequeueUmsCompletionListItems$address() {
        return DequeueUmsCompletionListItems.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT *UmsThreadList)
     * }
     */
    public static int DequeueUmsCompletionListItems(MemorySegment UmsCompletionList, int WaitTimeOut, MemorySegment UmsThreadList) {
        var mh$ = DequeueUmsCompletionListItems.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DequeueUmsCompletionListItems", UmsCompletionList, WaitTimeOut, UmsThreadList);
            }
            return (int)mh$.invokeExact(UmsCompletionList, WaitTimeOut, UmsThreadList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUmsCompletionListEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetUmsCompletionListEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent)
     * }
     */
    public static FunctionDescriptor GetUmsCompletionListEvent$descriptor() {
        return GetUmsCompletionListEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent)
     * }
     */
    public static MethodHandle GetUmsCompletionListEvent$handle() {
        return GetUmsCompletionListEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent)
     * }
     */
    public static MemorySegment GetUmsCompletionListEvent$address() {
        return GetUmsCompletionListEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent)
     * }
     */
    public static int GetUmsCompletionListEvent(MemorySegment UmsCompletionList, MemorySegment UmsCompletionEvent) {
        var mh$ = GetUmsCompletionListEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUmsCompletionListEvent", UmsCompletionList, UmsCompletionEvent);
            }
            return (int)mh$.invokeExact(UmsCompletionList, UmsCompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExecuteUmsThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExecuteUmsThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExecuteUmsThread(PUMS_CONTEXT UmsThread)
     * }
     */
    public static FunctionDescriptor ExecuteUmsThread$descriptor() {
        return ExecuteUmsThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExecuteUmsThread(PUMS_CONTEXT UmsThread)
     * }
     */
    public static MethodHandle ExecuteUmsThread$handle() {
        return ExecuteUmsThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExecuteUmsThread(PUMS_CONTEXT UmsThread)
     * }
     */
    public static MemorySegment ExecuteUmsThread$address() {
        return ExecuteUmsThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExecuteUmsThread(PUMS_CONTEXT UmsThread)
     * }
     */
    public static int ExecuteUmsThread(MemorySegment UmsThread) {
        var mh$ = ExecuteUmsThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExecuteUmsThread", UmsThread);
            }
            return (int)mh$.invokeExact(UmsThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UmsThreadYield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UmsThreadYield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UmsThreadYield(PVOID SchedulerParam)
     * }
     */
    public static FunctionDescriptor UmsThreadYield$descriptor() {
        return UmsThreadYield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UmsThreadYield(PVOID SchedulerParam)
     * }
     */
    public static MethodHandle UmsThreadYield$handle() {
        return UmsThreadYield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UmsThreadYield(PVOID SchedulerParam)
     * }
     */
    public static MemorySegment UmsThreadYield$address() {
        return UmsThreadYield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UmsThreadYield(PVOID SchedulerParam)
     * }
     */
    public static int UmsThreadYield(MemorySegment SchedulerParam) {
        var mh$ = UmsThreadYield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UmsThreadYield", SchedulerParam);
            }
            return (int)mh$.invokeExact(SchedulerParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteUmsCompletionList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteUmsCompletionList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList)
     * }
     */
    public static FunctionDescriptor DeleteUmsCompletionList$descriptor() {
        return DeleteUmsCompletionList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList)
     * }
     */
    public static MethodHandle DeleteUmsCompletionList$handle() {
        return DeleteUmsCompletionList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList)
     * }
     */
    public static MemorySegment DeleteUmsCompletionList$address() {
        return DeleteUmsCompletionList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList)
     * }
     */
    public static int DeleteUmsCompletionList(MemorySegment UmsCompletionList) {
        var mh$ = DeleteUmsCompletionList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteUmsCompletionList", UmsCompletionList);
            }
            return (int)mh$.invokeExact(UmsCompletionList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentUmsThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentUmsThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetCurrentUmsThread()
     * }
     */
    public static FunctionDescriptor GetCurrentUmsThread$descriptor() {
        return GetCurrentUmsThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetCurrentUmsThread()
     * }
     */
    public static MethodHandle GetCurrentUmsThread$handle() {
        return GetCurrentUmsThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetCurrentUmsThread()
     * }
     */
    public static MemorySegment GetCurrentUmsThread$address() {
        return GetCurrentUmsThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUMS_CONTEXT GetCurrentUmsThread()
     * }
     */
    public static MemorySegment GetCurrentUmsThread() {
        var mh$ = GetCurrentUmsThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentUmsThread");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNextUmsListItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNextUmsListItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetNextUmsListItem(PUMS_CONTEXT UmsContext)
     * }
     */
    public static FunctionDescriptor GetNextUmsListItem$descriptor() {
        return GetNextUmsListItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetNextUmsListItem(PUMS_CONTEXT UmsContext)
     * }
     */
    public static MethodHandle GetNextUmsListItem$handle() {
        return GetNextUmsListItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetNextUmsListItem(PUMS_CONTEXT UmsContext)
     * }
     */
    public static MemorySegment GetNextUmsListItem$address() {
        return GetNextUmsListItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUMS_CONTEXT GetNextUmsListItem(PUMS_CONTEXT UmsContext)
     * }
     */
    public static MemorySegment GetNextUmsListItem(MemorySegment UmsContext) {
        var mh$ = GetNextUmsListItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNextUmsListItem", UmsContext);
            }
            return (MemorySegment)mh$.invokeExact(UmsContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryUmsThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryUmsThreadInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength)
     * }
     */
    public static FunctionDescriptor QueryUmsThreadInformation$descriptor() {
        return QueryUmsThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength)
     * }
     */
    public static MethodHandle QueryUmsThreadInformation$handle() {
        return QueryUmsThreadInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength)
     * }
     */
    public static MemorySegment QueryUmsThreadInformation$address() {
        return QueryUmsThreadInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength)
     * }
     */
    public static int QueryUmsThreadInformation(MemorySegment UmsThread, int UmsThreadInfoClass, MemorySegment UmsThreadInformation, int UmsThreadInformationLength, MemorySegment ReturnLength) {
        var mh$ = QueryUmsThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryUmsThreadInformation", UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength, ReturnLength);
            }
            return (int)mh$.invokeExact(UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUmsThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetUmsThreadInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength)
     * }
     */
    public static FunctionDescriptor SetUmsThreadInformation$descriptor() {
        return SetUmsThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength)
     * }
     */
    public static MethodHandle SetUmsThreadInformation$handle() {
        return SetUmsThreadInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength)
     * }
     */
    public static MemorySegment SetUmsThreadInformation$address() {
        return SetUmsThreadInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength)
     * }
     */
    public static int SetUmsThreadInformation(MemorySegment UmsThread, int UmsThreadInfoClass, MemorySegment UmsThreadInformation, int UmsThreadInformationLength) {
        var mh$ = SetUmsThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUmsThreadInformation", UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength);
            }
            return (int)mh$.invokeExact(UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteUmsThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteUmsThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteUmsThreadContext(PUMS_CONTEXT UmsThread)
     * }
     */
    public static FunctionDescriptor DeleteUmsThreadContext$descriptor() {
        return DeleteUmsThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteUmsThreadContext(PUMS_CONTEXT UmsThread)
     * }
     */
    public static MethodHandle DeleteUmsThreadContext$handle() {
        return DeleteUmsThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteUmsThreadContext(PUMS_CONTEXT UmsThread)
     * }
     */
    public static MemorySegment DeleteUmsThreadContext$address() {
        return DeleteUmsThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteUmsThreadContext(PUMS_CONTEXT UmsThread)
     * }
     */
    public static int DeleteUmsThreadContext(MemorySegment UmsThread) {
        var mh$ = DeleteUmsThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteUmsThreadContext", UmsThread);
            }
            return (int)mh$.invokeExact(UmsThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateUmsThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateUmsThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread)
     * }
     */
    public static FunctionDescriptor CreateUmsThreadContext$descriptor() {
        return CreateUmsThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread)
     * }
     */
    public static MethodHandle CreateUmsThreadContext$handle() {
        return CreateUmsThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread)
     * }
     */
    public static MemorySegment CreateUmsThreadContext$address() {
        return CreateUmsThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread)
     * }
     */
    public static int CreateUmsThreadContext(MemorySegment lpUmsThread) {
        var mh$ = CreateUmsThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateUmsThreadContext", lpUmsThread);
            }
            return (int)mh$.invokeExact(lpUmsThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnterUmsSchedulingMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnterUmsSchedulingMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
     * }
     */
    public static FunctionDescriptor EnterUmsSchedulingMode$descriptor() {
        return EnterUmsSchedulingMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
     * }
     */
    public static MethodHandle EnterUmsSchedulingMode$handle() {
        return EnterUmsSchedulingMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
     * }
     */
    public static MemorySegment EnterUmsSchedulingMode$address() {
        return EnterUmsSchedulingMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
     * }
     */
    public static int EnterUmsSchedulingMode(MemorySegment SchedulerStartupInfo) {
        var mh$ = EnterUmsSchedulingMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnterUmsSchedulingMode", SchedulerStartupInfo);
            }
            return (int)mh$.invokeExact(SchedulerStartupInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUmsSystemThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetUmsSystemThreadInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
     * }
     */
    public static FunctionDescriptor GetUmsSystemThreadInformation$descriptor() {
        return GetUmsSystemThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
     * }
     */
    public static MethodHandle GetUmsSystemThreadInformation$handle() {
        return GetUmsSystemThreadInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
     * }
     */
    public static MemorySegment GetUmsSystemThreadInformation$address() {
        return GetUmsSystemThreadInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
     * }
     */
    public static int GetUmsSystemThreadInformation(MemorySegment ThreadHandle, MemorySegment SystemThreadInfo) {
        var mh$ = GetUmsSystemThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUmsSystemThreadInformation", ThreadHandle, SystemThreadInfo);
            }
            return (int)mh$.invokeExact(ThreadHandle, SystemThreadInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadAffinityMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadAffinityMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
     * }
     */
    public static FunctionDescriptor SetThreadAffinityMask$descriptor() {
        return SetThreadAffinityMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
     * }
     */
    public static MethodHandle SetThreadAffinityMask$handle() {
        return SetThreadAffinityMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
     * }
     */
    public static MemorySegment SetThreadAffinityMask$address() {
        return SetThreadAffinityMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
     * }
     */
    public static long SetThreadAffinityMask(MemorySegment hThread, long dwThreadAffinityMask) {
        var mh$ = SetThreadAffinityMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadAffinityMask", hThread, dwThreadAffinityMask);
            }
            return (long)mh$.invokeExact(hThread, dwThreadAffinityMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDEPPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessDEPPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDEPPolicy(DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetProcessDEPPolicy$descriptor() {
        return SetProcessDEPPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDEPPolicy(DWORD dwFlags)
     * }
     */
    public static MethodHandle SetProcessDEPPolicy$handle() {
        return SetProcessDEPPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessDEPPolicy(DWORD dwFlags)
     * }
     */
    public static MemorySegment SetProcessDEPPolicy$address() {
        return SetProcessDEPPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessDEPPolicy(DWORD dwFlags)
     * }
     */
    public static int SetProcessDEPPolicy(int dwFlags) {
        var mh$ = SetProcessDEPPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDEPPolicy", dwFlags);
            }
            return (int)mh$.invokeExact(dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessDEPPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessDEPPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
     * }
     */
    public static FunctionDescriptor GetProcessDEPPolicy$descriptor() {
        return GetProcessDEPPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
     * }
     */
    public static MethodHandle GetProcessDEPPolicy$handle() {
        return GetProcessDEPPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
     * }
     */
    public static MemorySegment GetProcessDEPPolicy$address() {
        return GetProcessDEPPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
     * }
     */
    public static int GetProcessDEPPolicy(MemorySegment hProcess, MemorySegment lpFlags, MemorySegment lpPermanent) {
        var mh$ = GetProcessDEPPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessDEPPolicy", hProcess, lpFlags, lpPermanent);
            }
            return (int)mh$.invokeExact(hProcess, lpFlags, lpPermanent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestWakeupLatency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RequestWakeupLatency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RequestWakeupLatency(LATENCY_TIME latency)
     * }
     */
    public static FunctionDescriptor RequestWakeupLatency$descriptor() {
        return RequestWakeupLatency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RequestWakeupLatency(LATENCY_TIME latency)
     * }
     */
    public static MethodHandle RequestWakeupLatency$handle() {
        return RequestWakeupLatency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RequestWakeupLatency(LATENCY_TIME latency)
     * }
     */
    public static MemorySegment RequestWakeupLatency$address() {
        return RequestWakeupLatency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RequestWakeupLatency(LATENCY_TIME latency)
     * }
     */
    public static int RequestWakeupLatency(int latency) {
        var mh$ = RequestWakeupLatency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestWakeupLatency", latency);
            }
            return (int)mh$.invokeExact(latency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsSystemResumeAutomatic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsSystemResumeAutomatic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsSystemResumeAutomatic()
     * }
     */
    public static FunctionDescriptor IsSystemResumeAutomatic$descriptor() {
        return IsSystemResumeAutomatic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsSystemResumeAutomatic()
     * }
     */
    public static MethodHandle IsSystemResumeAutomatic$handle() {
        return IsSystemResumeAutomatic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsSystemResumeAutomatic()
     * }
     */
    public static MemorySegment IsSystemResumeAutomatic$address() {
        return IsSystemResumeAutomatic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsSystemResumeAutomatic()
     * }
     */
    public static int IsSystemResumeAutomatic() {
        var mh$ = IsSystemResumeAutomatic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsSystemResumeAutomatic");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadSelectorEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadSelectorEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
     * }
     */
    public static FunctionDescriptor GetThreadSelectorEntry$descriptor() {
        return GetThreadSelectorEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
     * }
     */
    public static MethodHandle GetThreadSelectorEntry$handle() {
        return GetThreadSelectorEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
     * }
     */
    public static MemorySegment GetThreadSelectorEntry$address() {
        return GetThreadSelectorEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
     * }
     */
    public static int GetThreadSelectorEntry(MemorySegment hThread, int dwSelector, MemorySegment lpSelectorEntry) {
        var mh$ = GetThreadSelectorEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadSelectorEntry", hThread, dwSelector, lpSelectorEntry);
            }
            return (int)mh$.invokeExact(hThread, dwSelector, lpSelectorEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadExecutionState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadExecutionState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags)
     * }
     */
    public static FunctionDescriptor SetThreadExecutionState$descriptor() {
        return SetThreadExecutionState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags)
     * }
     */
    public static MethodHandle SetThreadExecutionState$handle() {
        return SetThreadExecutionState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags)
     * }
     */
    public static MemorySegment SetThreadExecutionState$address() {
        return SetThreadExecutionState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags)
     * }
     */
    public static int SetThreadExecutionState(int esFlags) {
        var mh$ = SetThreadExecutionState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadExecutionState", esFlags);
            }
            return (int)mh$.invokeExact(esFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef REASON_CONTEXT *PPOWER_REQUEST_CONTEXT
     * }
     */
    public static final AddressLayout PPOWER_REQUEST_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef REASON_CONTEXT *LPPOWER_REQUEST_CONTEXT
     * }
     */
    public static final AddressLayout LPPOWER_REQUEST_CONTEXT = wgl_h.C_POINTER;

    private static class PowerCreateRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PowerCreateRequest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE PowerCreateRequest(PREASON_CONTEXT Context)
     * }
     */
    public static FunctionDescriptor PowerCreateRequest$descriptor() {
        return PowerCreateRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE PowerCreateRequest(PREASON_CONTEXT Context)
     * }
     */
    public static MethodHandle PowerCreateRequest$handle() {
        return PowerCreateRequest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE PowerCreateRequest(PREASON_CONTEXT Context)
     * }
     */
    public static MemorySegment PowerCreateRequest$address() {
        return PowerCreateRequest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE PowerCreateRequest(PREASON_CONTEXT Context)
     * }
     */
    public static MemorySegment PowerCreateRequest(MemorySegment Context) {
        var mh$ = PowerCreateRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PowerCreateRequest", Context);
            }
            return (MemorySegment)mh$.invokeExact(Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PowerSetRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PowerSetRequest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static FunctionDescriptor PowerSetRequest$descriptor() {
        return PowerSetRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static MethodHandle PowerSetRequest$handle() {
        return PowerSetRequest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static MemorySegment PowerSetRequest$address() {
        return PowerSetRequest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static int PowerSetRequest(MemorySegment PowerRequest, int RequestType) {
        var mh$ = PowerSetRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PowerSetRequest", PowerRequest, RequestType);
            }
            return (int)mh$.invokeExact(PowerRequest, RequestType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PowerClearRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PowerClearRequest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static FunctionDescriptor PowerClearRequest$descriptor() {
        return PowerClearRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static MethodHandle PowerClearRequest$handle() {
        return PowerClearRequest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static MemorySegment PowerClearRequest$address() {
        return PowerClearRequest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static int PowerClearRequest(MemorySegment PowerRequest, int RequestType) {
        var mh$ = PowerClearRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PowerClearRequest", PowerRequest, RequestType);
            }
            return (int)mh$.invokeExact(PowerRequest, RequestType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileCompletionNotificationModes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileCompletionNotificationModes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags)
     * }
     */
    public static FunctionDescriptor SetFileCompletionNotificationModes$descriptor() {
        return SetFileCompletionNotificationModes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags)
     * }
     */
    public static MethodHandle SetFileCompletionNotificationModes$handle() {
        return SetFileCompletionNotificationModes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags)
     * }
     */
    public static MemorySegment SetFileCompletionNotificationModes$address() {
        return SetFileCompletionNotificationModes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags)
     * }
     */
    public static int SetFileCompletionNotificationModes(MemorySegment FileHandle, byte Flags) {
        var mh$ = SetFileCompletionNotificationModes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileCompletionNotificationModes", FileHandle, Flags);
            }
            return (int)mh$.invokeExact(FileHandle, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64GetThreadSelectorEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Wow64GetThreadSelectorEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
     * }
     */
    public static FunctionDescriptor Wow64GetThreadSelectorEntry$descriptor() {
        return Wow64GetThreadSelectorEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
     * }
     */
    public static MethodHandle Wow64GetThreadSelectorEntry$handle() {
        return Wow64GetThreadSelectorEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
     * }
     */
    public static MemorySegment Wow64GetThreadSelectorEntry$address() {
        return Wow64GetThreadSelectorEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
     * }
     */
    public static int Wow64GetThreadSelectorEntry(MemorySegment hThread, int dwSelector, MemorySegment lpSelectorEntry) {
        var mh$ = Wow64GetThreadSelectorEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64GetThreadSelectorEntry", hThread, dwSelector, lpSelectorEntry);
            }
            return (int)mh$.invokeExact(hThread, dwSelector, lpSelectorEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugSetProcessKillOnExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DebugSetProcessKillOnExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugSetProcessKillOnExit(BOOL KillOnExit)
     * }
     */
    public static FunctionDescriptor DebugSetProcessKillOnExit$descriptor() {
        return DebugSetProcessKillOnExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugSetProcessKillOnExit(BOOL KillOnExit)
     * }
     */
    public static MethodHandle DebugSetProcessKillOnExit$handle() {
        return DebugSetProcessKillOnExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DebugSetProcessKillOnExit(BOOL KillOnExit)
     * }
     */
    public static MemorySegment DebugSetProcessKillOnExit$address() {
        return DebugSetProcessKillOnExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DebugSetProcessKillOnExit(BOOL KillOnExit)
     * }
     */
    public static int DebugSetProcessKillOnExit(int KillOnExit) {
        var mh$ = DebugSetProcessKillOnExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugSetProcessKillOnExit", KillOnExit);
            }
            return (int)mh$.invokeExact(KillOnExit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugBreakProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DebugBreakProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugBreakProcess(HANDLE Process)
     * }
     */
    public static FunctionDescriptor DebugBreakProcess$descriptor() {
        return DebugBreakProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugBreakProcess(HANDLE Process)
     * }
     */
    public static MethodHandle DebugBreakProcess$handle() {
        return DebugBreakProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DebugBreakProcess(HANDLE Process)
     * }
     */
    public static MemorySegment DebugBreakProcess$address() {
        return DebugBreakProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DebugBreakProcess(HANDLE Process)
     * }
     */
    public static int DebugBreakProcess(MemorySegment Process) {
        var mh$ = DebugBreakProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugBreakProcess", Process);
            }
            return (int)mh$.invokeExact(Process);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PulseEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PulseEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PulseEvent(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor PulseEvent$descriptor() {
        return PulseEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PulseEvent(HANDLE hEvent)
     * }
     */
    public static MethodHandle PulseEvent$handle() {
        return PulseEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PulseEvent(HANDLE hEvent)
     * }
     */
    public static MemorySegment PulseEvent$address() {
        return PulseEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PulseEvent(HANDLE hEvent)
     * }
     */
    public static int PulseEvent(MemorySegment hEvent) {
        var mh$ = PulseEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PulseEvent", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalDeleteAtom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalDeleteAtom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalDeleteAtom(ATOM nAtom)
     * }
     */
    public static FunctionDescriptor GlobalDeleteAtom$descriptor() {
        return GlobalDeleteAtom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalDeleteAtom(ATOM nAtom)
     * }
     */
    public static MethodHandle GlobalDeleteAtom$handle() {
        return GlobalDeleteAtom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalDeleteAtom(ATOM nAtom)
     * }
     */
    public static MemorySegment GlobalDeleteAtom$address() {
        return GlobalDeleteAtom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalDeleteAtom(ATOM nAtom)
     * }
     */
    public static short GlobalDeleteAtom(short nAtom) {
        var mh$ = GlobalDeleteAtom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalDeleteAtom", nAtom);
            }
            return (short)mh$.invokeExact(nAtom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitAtomTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitAtomTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitAtomTable(DWORD nSize)
     * }
     */
    public static FunctionDescriptor InitAtomTable$descriptor() {
        return InitAtomTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitAtomTable(DWORD nSize)
     * }
     */
    public static MethodHandle InitAtomTable$handle() {
        return InitAtomTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitAtomTable(DWORD nSize)
     * }
     */
    public static MemorySegment InitAtomTable$address() {
        return InitAtomTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitAtomTable(DWORD nSize)
     * }
     */
    public static int InitAtomTable(int nSize) {
        var mh$ = InitAtomTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitAtomTable", nSize);
            }
            return (int)mh$.invokeExact(nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteAtom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteAtom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM DeleteAtom(ATOM nAtom)
     * }
     */
    public static FunctionDescriptor DeleteAtom$descriptor() {
        return DeleteAtom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM DeleteAtom(ATOM nAtom)
     * }
     */
    public static MethodHandle DeleteAtom$handle() {
        return DeleteAtom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM DeleteAtom(ATOM nAtom)
     * }
     */
    public static MemorySegment DeleteAtom$address() {
        return DeleteAtom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM DeleteAtom(ATOM nAtom)
     * }
     */
    public static short DeleteAtom(short nAtom) {
        var mh$ = DeleteAtom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteAtom", nAtom);
            }
            return (short)mh$.invokeExact(nAtom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetHandleCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetHandleCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetHandleCount(UINT uNumber)
     * }
     */
    public static FunctionDescriptor SetHandleCount$descriptor() {
        return SetHandleCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetHandleCount(UINT uNumber)
     * }
     */
    public static MethodHandle SetHandleCount$handle() {
        return SetHandleCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetHandleCount(UINT uNumber)
     * }
     */
    public static MemorySegment SetHandleCount$address() {
        return SetHandleCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetHandleCount(UINT uNumber)
     * }
     */
    public static int SetHandleCount(int uNumber) {
        var mh$ = SetHandleCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetHandleCount", uNumber);
            }
            return (int)mh$.invokeExact(uNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestDeviceWakeup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RequestDeviceWakeup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RequestDeviceWakeup(HANDLE hDevice)
     * }
     */
    public static FunctionDescriptor RequestDeviceWakeup$descriptor() {
        return RequestDeviceWakeup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RequestDeviceWakeup(HANDLE hDevice)
     * }
     */
    public static MethodHandle RequestDeviceWakeup$handle() {
        return RequestDeviceWakeup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RequestDeviceWakeup(HANDLE hDevice)
     * }
     */
    public static MemorySegment RequestDeviceWakeup$address() {
        return RequestDeviceWakeup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RequestDeviceWakeup(HANDLE hDevice)
     * }
     */
    public static int RequestDeviceWakeup(MemorySegment hDevice) {
        var mh$ = RequestDeviceWakeup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestDeviceWakeup", hDevice);
            }
            return (int)mh$.invokeExact(hDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelDeviceWakeupRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CancelDeviceWakeupRequest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelDeviceWakeupRequest(HANDLE hDevice)
     * }
     */
    public static FunctionDescriptor CancelDeviceWakeupRequest$descriptor() {
        return CancelDeviceWakeupRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelDeviceWakeupRequest(HANDLE hDevice)
     * }
     */
    public static MethodHandle CancelDeviceWakeupRequest$handle() {
        return CancelDeviceWakeupRequest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelDeviceWakeupRequest(HANDLE hDevice)
     * }
     */
    public static MemorySegment CancelDeviceWakeupRequest$address() {
        return CancelDeviceWakeupRequest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelDeviceWakeupRequest(HANDLE hDevice)
     * }
     */
    public static int CancelDeviceWakeupRequest(MemorySegment hDevice) {
        var mh$ = CancelDeviceWakeupRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelDeviceWakeupRequest", hDevice);
            }
            return (int)mh$.invokeExact(hDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDevicePowerState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDevicePowerState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
     * }
     */
    public static FunctionDescriptor GetDevicePowerState$descriptor() {
        return GetDevicePowerState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
     * }
     */
    public static MethodHandle GetDevicePowerState$handle() {
        return GetDevicePowerState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
     * }
     */
    public static MemorySegment GetDevicePowerState$address() {
        return GetDevicePowerState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
     * }
     */
    public static int GetDevicePowerState(MemorySegment hDevice, MemorySegment pfOn) {
        var mh$ = GetDevicePowerState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDevicePowerState", hDevice, pfOn);
            }
            return (int)mh$.invokeExact(hDevice, pfOn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMessageWaitingIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMessageWaitingIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount)
     * }
     */
    public static FunctionDescriptor SetMessageWaitingIndicator$descriptor() {
        return SetMessageWaitingIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount)
     * }
     */
    public static MethodHandle SetMessageWaitingIndicator$handle() {
        return SetMessageWaitingIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount)
     * }
     */
    public static MemorySegment SetMessageWaitingIndicator$address() {
        return SetMessageWaitingIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount)
     * }
     */
    public static int SetMessageWaitingIndicator(MemorySegment hMsgIndicator, int ulMsgCount) {
        var mh$ = SetMessageWaitingIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMessageWaitingIndicator", hMsgIndicator, ulMsgCount);
            }
            return (int)mh$.invokeExact(hMsgIndicator, ulMsgCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileShortNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileShortNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
     * }
     */
    public static FunctionDescriptor SetFileShortNameA$descriptor() {
        return SetFileShortNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
     * }
     */
    public static MethodHandle SetFileShortNameA$handle() {
        return SetFileShortNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
     * }
     */
    public static MemorySegment SetFileShortNameA$address() {
        return SetFileShortNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
     * }
     */
    public static int SetFileShortNameA(MemorySegment hFile, MemorySegment lpShortName) {
        var mh$ = SetFileShortNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileShortNameA", hFile, lpShortName);
            }
            return (int)mh$.invokeExact(hFile, lpShortName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileShortNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileShortNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
     * }
     */
    public static FunctionDescriptor SetFileShortNameW$descriptor() {
        return SetFileShortNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
     * }
     */
    public static MethodHandle SetFileShortNameW$handle() {
        return SetFileShortNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
     * }
     */
    public static MemorySegment SetFileShortNameW$address() {
        return SetFileShortNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
     * }
     */
    public static int SetFileShortNameW(MemorySegment hFile, MemorySegment lpShortName) {
        var mh$ = SetFileShortNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileShortNameW", hFile, lpShortName);
            }
            return (int)mh$.invokeExact(hFile, lpShortName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
     * }
     */
    public static FunctionDescriptor LoadModule$descriptor() {
        return LoadModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
     * }
     */
    public static MethodHandle LoadModule$handle() {
        return LoadModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
     * }
     */
    public static MemorySegment LoadModule$address() {
        return LoadModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
     * }
     */
    public static int LoadModule(MemorySegment lpModuleName, MemorySegment lpParameterBlock) {
        var mh$ = LoadModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadModule", lpModuleName, lpParameterBlock);
            }
            return (int)mh$.invokeExact(lpModuleName, lpParameterBlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WinExec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WinExec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
     * }
     */
    public static FunctionDescriptor WinExec$descriptor() {
        return WinExec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
     * }
     */
    public static MethodHandle WinExec$handle() {
        return WinExec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
     * }
     */
    public static MemorySegment WinExec$address() {
        return WinExec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
     * }
     */
    public static int WinExec(MemorySegment lpCmdLine, int uCmdShow) {
        var mh$ = WinExec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WinExec", lpCmdLine, uCmdShow);
            }
            return (int)mh$.invokeExact(lpCmdLine, uCmdShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearCommBreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ClearCommBreak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearCommBreak(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor ClearCommBreak$descriptor() {
        return ClearCommBreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearCommBreak(HANDLE hFile)
     * }
     */
    public static MethodHandle ClearCommBreak$handle() {
        return ClearCommBreak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ClearCommBreak(HANDLE hFile)
     * }
     */
    public static MemorySegment ClearCommBreak$address() {
        return ClearCommBreak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClearCommBreak(HANDLE hFile)
     * }
     */
    public static int ClearCommBreak(MemorySegment hFile) {
        var mh$ = ClearCommBreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearCommBreak", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearCommError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ClearCommError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static FunctionDescriptor ClearCommError$descriptor() {
        return ClearCommError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static MethodHandle ClearCommError$handle() {
        return ClearCommError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static MemorySegment ClearCommError$address() {
        return ClearCommError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static int ClearCommError(MemorySegment hFile, MemorySegment lpErrors, MemorySegment lpStat) {
        var mh$ = ClearCommError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearCommError", hFile, lpErrors, lpStat);
            }
            return (int)mh$.invokeExact(hFile, lpErrors, lpStat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetupComm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetupComm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static FunctionDescriptor SetupComm$descriptor() {
        return SetupComm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static MethodHandle SetupComm$handle() {
        return SetupComm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static MemorySegment SetupComm$address() {
        return SetupComm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static int SetupComm(MemorySegment hFile, int dwInQueue, int dwOutQueue) {
        var mh$ = SetupComm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetupComm", hFile, dwInQueue, dwOutQueue);
            }
            return (int)mh$.invokeExact(hFile, dwInQueue, dwOutQueue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EscapeCommFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EscapeCommFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static FunctionDescriptor EscapeCommFunction$descriptor() {
        return EscapeCommFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static MethodHandle EscapeCommFunction$handle() {
        return EscapeCommFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static MemorySegment EscapeCommFunction$address() {
        return EscapeCommFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static int EscapeCommFunction(MemorySegment hFile, int dwFunc) {
        var mh$ = EscapeCommFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EscapeCommFunction", hFile, dwFunc);
            }
            return (int)mh$.invokeExact(hFile, dwFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCommConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor GetCommConfig$descriptor() {
        return GetCommConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MethodHandle GetCommConfig$handle() {
        return GetCommConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MemorySegment GetCommConfig$address() {
        return GetCommConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static int GetCommConfig(MemorySegment hCommDev, MemorySegment lpCC, MemorySegment lpdwSize) {
        var mh$ = GetCommConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommConfig", hCommDev, lpCC, lpdwSize);
            }
            return (int)mh$.invokeExact(hCommDev, lpCC, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCommMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static FunctionDescriptor GetCommMask$descriptor() {
        return GetCommMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static MethodHandle GetCommMask$handle() {
        return GetCommMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static MemorySegment GetCommMask$address() {
        return GetCommMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static int GetCommMask(MemorySegment hFile, MemorySegment lpEvtMask) {
        var mh$ = GetCommMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommMask", hFile, lpEvtMask);
            }
            return (int)mh$.invokeExact(hFile, lpEvtMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCommProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static FunctionDescriptor GetCommProperties$descriptor() {
        return GetCommProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static MethodHandle GetCommProperties$handle() {
        return GetCommProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static MemorySegment GetCommProperties$address() {
        return GetCommProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static int GetCommProperties(MemorySegment hFile, MemorySegment lpCommProp) {
        var mh$ = GetCommProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommProperties", hFile, lpCommProp);
            }
            return (int)mh$.invokeExact(hFile, lpCommProp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommModemStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCommModemStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static FunctionDescriptor GetCommModemStatus$descriptor() {
        return GetCommModemStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static MethodHandle GetCommModemStatus$handle() {
        return GetCommModemStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static MemorySegment GetCommModemStatus$address() {
        return GetCommModemStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static int GetCommModemStatus(MemorySegment hFile, MemorySegment lpModemStat) {
        var mh$ = GetCommModemStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommModemStatus", hFile, lpModemStat);
            }
            return (int)mh$.invokeExact(hFile, lpModemStat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCommState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor GetCommState$descriptor() {
        return GetCommState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MethodHandle GetCommState$handle() {
        return GetCommState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MemorySegment GetCommState$address() {
        return GetCommState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static int GetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = GetCommState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommState", hFile, lpDCB);
            }
            return (int)mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommTimeouts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCommTimeouts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor GetCommTimeouts$descriptor() {
        return GetCommTimeouts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle GetCommTimeouts$handle() {
        return GetCommTimeouts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MemorySegment GetCommTimeouts$address() {
        return GetCommTimeouts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int GetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = GetCommTimeouts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommTimeouts", hFile, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PurgeComm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PurgeComm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PurgeComm(HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor PurgeComm$descriptor() {
        return PurgeComm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PurgeComm(HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle PurgeComm$handle() {
        return PurgeComm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PurgeComm(HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment PurgeComm$address() {
        return PurgeComm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PurgeComm(HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static int PurgeComm(MemorySegment hFile, int dwFlags) {
        var mh$ = PurgeComm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PurgeComm", hFile, dwFlags);
            }
            return (int)mh$.invokeExact(hFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommBreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetCommBreak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommBreak(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor SetCommBreak$descriptor() {
        return SetCommBreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommBreak(HANDLE hFile)
     * }
     */
    public static MethodHandle SetCommBreak$handle() {
        return SetCommBreak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommBreak(HANDLE hFile)
     * }
     */
    public static MemorySegment SetCommBreak$address() {
        return SetCommBreak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommBreak(HANDLE hFile)
     * }
     */
    public static int SetCommBreak(MemorySegment hFile) {
        var mh$ = SetCommBreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommBreak", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetCommConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor SetCommConfig$descriptor() {
        return SetCommConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MethodHandle SetCommConfig$handle() {
        return SetCommConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MemorySegment SetCommConfig$address() {
        return SetCommConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static int SetCommConfig(MemorySegment hCommDev, MemorySegment lpCC, int dwSize) {
        var mh$ = SetCommConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommConfig", hCommDev, lpCC, dwSize);
            }
            return (int)mh$.invokeExact(hCommDev, lpCC, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetCommMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static FunctionDescriptor SetCommMask$descriptor() {
        return SetCommMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static MethodHandle SetCommMask$handle() {
        return SetCommMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static MemorySegment SetCommMask$address() {
        return SetCommMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static int SetCommMask(MemorySegment hFile, int dwEvtMask) {
        var mh$ = SetCommMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommMask", hFile, dwEvtMask);
            }
            return (int)mh$.invokeExact(hFile, dwEvtMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetCommState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor SetCommState$descriptor() {
        return SetCommState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MethodHandle SetCommState$handle() {
        return SetCommState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MemorySegment SetCommState$address() {
        return SetCommState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static int SetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = SetCommState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommState", hFile, lpDCB);
            }
            return (int)mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommTimeouts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetCommTimeouts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor SetCommTimeouts$descriptor() {
        return SetCommTimeouts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle SetCommTimeouts$handle() {
        return SetCommTimeouts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MemorySegment SetCommTimeouts$address() {
        return SetCommTimeouts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int SetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = SetCommTimeouts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommTimeouts", hFile, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmitCommChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TransmitCommChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransmitCommChar(HANDLE hFile, char cChar)
     * }
     */
    public static FunctionDescriptor TransmitCommChar$descriptor() {
        return TransmitCommChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransmitCommChar(HANDLE hFile, char cChar)
     * }
     */
    public static MethodHandle TransmitCommChar$handle() {
        return TransmitCommChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TransmitCommChar(HANDLE hFile, char cChar)
     * }
     */
    public static MemorySegment TransmitCommChar$address() {
        return TransmitCommChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TransmitCommChar(HANDLE hFile, char cChar)
     * }
     */
    public static int TransmitCommChar(MemorySegment hFile, byte cChar) {
        var mh$ = TransmitCommChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmitCommChar", hFile, cChar);
            }
            return (int)mh$.invokeExact(hFile, cChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitCommEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitCommEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WaitCommEvent$descriptor() {
        return WaitCommEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WaitCommEvent$handle() {
        return WaitCommEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment WaitCommEvent$address() {
        return WaitCommEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WaitCommEvent(MemorySegment hFile, MemorySegment lpEvtMask, MemorySegment lpOverlapped) {
        var mh$ = WaitCommEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitCommEvent", hFile, lpEvtMask, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpEvtMask, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenCommPort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenCommPort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes)
     * }
     */
    public static FunctionDescriptor OpenCommPort$descriptor() {
        return OpenCommPort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MethodHandle OpenCommPort$handle() {
        return OpenCommPort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenCommPort$address() {
        return OpenCommPort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenCommPort(int uPortNumber, int dwDesiredAccess, int dwFlagsAndAttributes) {
        var mh$ = OpenCommPort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenCommPort", uPortNumber, dwDesiredAccess, dwFlagsAndAttributes);
            }
            return (MemorySegment)mh$.invokeExact(uPortNumber, dwDesiredAccess, dwFlagsAndAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommPorts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCommPorts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound)
     * }
     */
    public static FunctionDescriptor GetCommPorts$descriptor() {
        return GetCommPorts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound)
     * }
     */
    public static MethodHandle GetCommPorts$handle() {
        return GetCommPorts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound)
     * }
     */
    public static MemorySegment GetCommPorts$address() {
        return GetCommPorts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound)
     * }
     */
    public static int GetCommPorts(MemorySegment lpPortNumbers, int uPortNumbersCount, MemorySegment puPortNumbersFound) {
        var mh$ = GetCommPorts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommPorts", lpPortNumbers, uPortNumbersCount, puPortNumbersFound);
            }
            return (int)mh$.invokeExact(lpPortNumbers, uPortNumbersCount, puPortNumbersFound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTapePosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetTapePosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor SetTapePosition$descriptor() {
        return SetTapePosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
     * }
     */
    public static MethodHandle SetTapePosition$handle() {
        return SetTapePosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
     * }
     */
    public static MemorySegment SetTapePosition$address() {
        return SetTapePosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
     * }
     */
    public static int SetTapePosition(MemorySegment hDevice, int dwPositionMethod, int dwPartition, int dwOffsetLow, int dwOffsetHigh, int bImmediate) {
        var mh$ = SetTapePosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTapePosition", hDevice, dwPositionMethod, dwPartition, dwOffsetLow, dwOffsetHigh, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwPositionMethod, dwPartition, dwOffsetLow, dwOffsetHigh, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTapePosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTapePosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
     * }
     */
    public static FunctionDescriptor GetTapePosition$descriptor() {
        return GetTapePosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
     * }
     */
    public static MethodHandle GetTapePosition$handle() {
        return GetTapePosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
     * }
     */
    public static MemorySegment GetTapePosition$address() {
        return GetTapePosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
     * }
     */
    public static int GetTapePosition(MemorySegment hDevice, int dwPositionType, MemorySegment lpdwPartition, MemorySegment lpdwOffsetLow, MemorySegment lpdwOffsetHigh) {
        var mh$ = GetTapePosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTapePosition", hDevice, dwPositionType, lpdwPartition, lpdwOffsetLow, lpdwOffsetHigh);
            }
            return (int)mh$.invokeExact(hDevice, dwPositionType, lpdwPartition, lpdwOffsetLow, lpdwOffsetHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrepareTape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PrepareTape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor PrepareTape$descriptor() {
        return PrepareTape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
     * }
     */
    public static MethodHandle PrepareTape$handle() {
        return PrepareTape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
     * }
     */
    public static MemorySegment PrepareTape$address() {
        return PrepareTape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
     * }
     */
    public static int PrepareTape(MemorySegment hDevice, int dwOperation, int bImmediate) {
        var mh$ = PrepareTape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrepareTape", hDevice, dwOperation, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwOperation, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EraseTape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EraseTape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor EraseTape$descriptor() {
        return EraseTape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
     * }
     */
    public static MethodHandle EraseTape$handle() {
        return EraseTape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
     * }
     */
    public static MemorySegment EraseTape$address() {
        return EraseTape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
     * }
     */
    public static int EraseTape(MemorySegment hDevice, int dwEraseType, int bImmediate) {
        var mh$ = EraseTape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EraseTape", hDevice, dwEraseType, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwEraseType, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateTapePartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateTapePartition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor CreateTapePartition$descriptor() {
        return CreateTapePartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
     * }
     */
    public static MethodHandle CreateTapePartition$handle() {
        return CreateTapePartition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
     * }
     */
    public static MemorySegment CreateTapePartition$address() {
        return CreateTapePartition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
     * }
     */
    public static int CreateTapePartition(MemorySegment hDevice, int dwPartitionMethod, int dwCount, int dwSize) {
        var mh$ = CreateTapePartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateTapePartition", hDevice, dwPartitionMethod, dwCount, dwSize);
            }
            return (int)mh$.invokeExact(hDevice, dwPartitionMethod, dwCount, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteTapemark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WriteTapemark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor WriteTapemark$descriptor() {
        return WriteTapemark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
     * }
     */
    public static MethodHandle WriteTapemark$handle() {
        return WriteTapemark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
     * }
     */
    public static MemorySegment WriteTapemark$address() {
        return WriteTapemark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
     * }
     */
    public static int WriteTapemark(MemorySegment hDevice, int dwTapemarkType, int dwTapemarkCount, int bImmediate) {
        var mh$ = WriteTapemark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteTapemark", hDevice, dwTapemarkType, dwTapemarkCount, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwTapemarkType, dwTapemarkCount, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTapeStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTapeStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTapeStatus(HANDLE hDevice)
     * }
     */
    public static FunctionDescriptor GetTapeStatus$descriptor() {
        return GetTapeStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTapeStatus(HANDLE hDevice)
     * }
     */
    public static MethodHandle GetTapeStatus$handle() {
        return GetTapeStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTapeStatus(HANDLE hDevice)
     * }
     */
    public static MemorySegment GetTapeStatus$address() {
        return GetTapeStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTapeStatus(HANDLE hDevice)
     * }
     */
    public static int GetTapeStatus(MemorySegment hDevice) {
        var mh$ = GetTapeStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTapeStatus", hDevice);
            }
            return (int)mh$.invokeExact(hDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTapeParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTapeParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
     * }
     */
    public static FunctionDescriptor GetTapeParameters$descriptor() {
        return GetTapeParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
     * }
     */
    public static MethodHandle GetTapeParameters$handle() {
        return GetTapeParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
     * }
     */
    public static MemorySegment GetTapeParameters$address() {
        return GetTapeParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
     * }
     */
    public static int GetTapeParameters(MemorySegment hDevice, int dwOperation, MemorySegment lpdwSize, MemorySegment lpTapeInformation) {
        var mh$ = GetTapeParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTapeParameters", hDevice, dwOperation, lpdwSize, lpTapeInformation);
            }
            return (int)mh$.invokeExact(hDevice, dwOperation, lpdwSize, lpTapeInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTapeParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetTapeParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
     * }
     */
    public static FunctionDescriptor SetTapeParameters$descriptor() {
        return SetTapeParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
     * }
     */
    public static MethodHandle SetTapeParameters$handle() {
        return SetTapeParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
     * }
     */
    public static MemorySegment SetTapeParameters$address() {
        return SetTapeParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
     * }
     */
    public static int SetTapeParameters(MemorySegment hDevice, int dwOperation, MemorySegment lpTapeInformation) {
        var mh$ = SetTapeParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTapeParameters", hDevice, dwOperation, lpTapeInformation);
            }
            return (int)mh$.invokeExact(hDevice, dwOperation, lpTapeInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MulDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MulDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MulDiv(int nNumber, int nNumerator, int nDenominator)
     * }
     */
    public static FunctionDescriptor MulDiv$descriptor() {
        return MulDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MulDiv(int nNumber, int nNumerator, int nDenominator)
     * }
     */
    public static MethodHandle MulDiv$handle() {
        return MulDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MulDiv(int nNumber, int nNumerator, int nDenominator)
     * }
     */
    public static MemorySegment MulDiv$address() {
        return MulDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MulDiv(int nNumber, int nNumerator, int nDenominator)
     * }
     */
    public static int MulDiv(int nNumber, int nNumerator, int nDenominator) {
        var mh$ = MulDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MulDiv", nNumber, nNumerator, nDenominator);
            }
            return (int)mh$.invokeExact(nNumber, nNumerator, nDenominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int DEPPolicyAlwaysOff = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyAlwaysOff = 0
     * }
     */
    public static int DEPPolicyAlwaysOff() {
        return DEPPolicyAlwaysOff;
    }
    private static final int DEPPolicyAlwaysOn = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyAlwaysOn = 1
     * }
     */
    public static int DEPPolicyAlwaysOn() {
        return DEPPolicyAlwaysOn;
    }
    private static final int DEPPolicyOptIn = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyOptIn = 2
     * }
     */
    public static int DEPPolicyOptIn() {
        return DEPPolicyOptIn;
    }
    private static final int DEPPolicyOptOut = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyOptOut = 3
     * }
     */
    public static int DEPPolicyOptOut() {
        return DEPPolicyOptOut;
    }
    private static final int DEPTotalPolicyCount = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPTotalPolicyCount = 4
     * }
     */
    public static int DEPTotalPolicyCount() {
        return DEPTotalPolicyCount;
    }

    private static class GetSystemDEPPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemDEPPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy()
     * }
     */
    public static FunctionDescriptor GetSystemDEPPolicy$descriptor() {
        return GetSystemDEPPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy()
     * }
     */
    public static MethodHandle GetSystemDEPPolicy$handle() {
        return GetSystemDEPPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy()
     * }
     */
    public static MemorySegment GetSystemDEPPolicy$address() {
        return GetSystemDEPPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy()
     * }
     */
    public static int GetSystemDEPPolicy() {
        var mh$ = GetSystemDEPPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDEPPolicy");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemRegistryQuota {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemRegistryQuota");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
     * }
     */
    public static FunctionDescriptor GetSystemRegistryQuota$descriptor() {
        return GetSystemRegistryQuota.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
     * }
     */
    public static MethodHandle GetSystemRegistryQuota$handle() {
        return GetSystemRegistryQuota.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
     * }
     */
    public static MemorySegment GetSystemRegistryQuota$address() {
        return GetSystemRegistryQuota.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
     * }
     */
    public static int GetSystemRegistryQuota(MemorySegment pdwQuotaAllowed, MemorySegment pdwQuotaUsed) {
        var mh$ = GetSystemRegistryQuota.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemRegistryQuota", pdwQuotaAllowed, pdwQuotaUsed);
            }
            return (int)mh$.invokeExact(pdwQuotaAllowed, pdwQuotaUsed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileTimeToDosDateTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FileTimeToDosDateTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
     * }
     */
    public static FunctionDescriptor FileTimeToDosDateTime$descriptor() {
        return FileTimeToDosDateTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
     * }
     */
    public static MethodHandle FileTimeToDosDateTime$handle() {
        return FileTimeToDosDateTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
     * }
     */
    public static MemorySegment FileTimeToDosDateTime$address() {
        return FileTimeToDosDateTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
     * }
     */
    public static int FileTimeToDosDateTime(MemorySegment lpFileTime, MemorySegment lpFatDate, MemorySegment lpFatTime) {
        var mh$ = FileTimeToDosDateTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileTimeToDosDateTime", lpFileTime, lpFatDate, lpFatTime);
            }
            return (int)mh$.invokeExact(lpFileTime, lpFatDate, lpFatTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DosDateTimeToFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DosDateTimeToFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
     * }
     */
    public static FunctionDescriptor DosDateTimeToFileTime$descriptor() {
        return DosDateTimeToFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
     * }
     */
    public static MethodHandle DosDateTimeToFileTime$handle() {
        return DosDateTimeToFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
     * }
     */
    public static MemorySegment DosDateTimeToFileTime$address() {
        return DosDateTimeToFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
     * }
     */
    public static int DosDateTimeToFileTime(short wFatDate, short wFatTime, MemorySegment lpFileTime) {
        var mh$ = DosDateTimeToFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DosDateTimeToFileTime", wFatDate, wFatTime, lpFileTime);
            }
            return (int)mh$.invokeExact(wFatDate, wFatTime, lpFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FormatMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FormatMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static FunctionDescriptor FormatMessageA$descriptor() {
        return FormatMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MethodHandle FormatMessageA$handle() {
        return FormatMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MemorySegment FormatMessageA$address() {
        return FormatMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static int FormatMessageA(int dwFlags, MemorySegment lpSource, int dwMessageId, int dwLanguageId, MemorySegment lpBuffer, int nSize, MemorySegment Arguments) {
        var mh$ = FormatMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FormatMessageA", dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
            }
            return (int)mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FormatMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FormatMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static FunctionDescriptor FormatMessageW$descriptor() {
        return FormatMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MethodHandle FormatMessageW$handle() {
        return FormatMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MemorySegment FormatMessageW$address() {
        return FormatMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static int FormatMessageW(int dwFlags, MemorySegment lpSource, int dwMessageId, int dwLanguageId, MemorySegment lpBuffer, int nSize, MemorySegment Arguments) {
        var mh$ = FormatMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FormatMessageW", dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
            }
            return (int)mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMailslotA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateMailslotA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateMailslotA$descriptor() {
        return CreateMailslotA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateMailslotA$handle() {
        return CreateMailslotA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateMailslotA$address() {
        return CreateMailslotA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateMailslotA(MemorySegment lpName, int nMaxMessageSize, int lReadTimeout, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateMailslotA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMailslotA", lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMailslotW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateMailslotW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateMailslotW$descriptor() {
        return CreateMailslotW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateMailslotW$handle() {
        return CreateMailslotW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateMailslotW$address() {
        return CreateMailslotW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateMailslotW(MemorySegment lpName, int nMaxMessageSize, int lReadTimeout, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateMailslotW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMailslotW", lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMailslotInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMailslotInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
     * }
     */
    public static FunctionDescriptor GetMailslotInfo$descriptor() {
        return GetMailslotInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
     * }
     */
    public static MethodHandle GetMailslotInfo$handle() {
        return GetMailslotInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
     * }
     */
    public static MemorySegment GetMailslotInfo$address() {
        return GetMailslotInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
     * }
     */
    public static int GetMailslotInfo(MemorySegment hMailslot, MemorySegment lpMaxMessageSize, MemorySegment lpNextSize, MemorySegment lpMessageCount, MemorySegment lpReadTimeout) {
        var mh$ = GetMailslotInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMailslotInfo", hMailslot, lpMaxMessageSize, lpNextSize, lpMessageCount, lpReadTimeout);
            }
            return (int)mh$.invokeExact(hMailslot, lpMaxMessageSize, lpNextSize, lpMessageCount, lpReadTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMailslotInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMailslotInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
     * }
     */
    public static FunctionDescriptor SetMailslotInfo$descriptor() {
        return SetMailslotInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
     * }
     */
    public static MethodHandle SetMailslotInfo$handle() {
        return SetMailslotInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
     * }
     */
    public static MemorySegment SetMailslotInfo$address() {
        return SetMailslotInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
     * }
     */
    public static int SetMailslotInfo(MemorySegment hMailslot, int lReadTimeout) {
        var mh$ = SetMailslotInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMailslotInfo", hMailslot, lReadTimeout);
            }
            return (int)mh$.invokeExact(hMailslot, lReadTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncryptFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EncryptFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EncryptFileA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor EncryptFileA$descriptor() {
        return EncryptFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EncryptFileA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle EncryptFileA$handle() {
        return EncryptFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EncryptFileA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment EncryptFileA$address() {
        return EncryptFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EncryptFileA(LPCSTR lpFileName)
     * }
     */
    public static int EncryptFileA(MemorySegment lpFileName) {
        var mh$ = EncryptFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncryptFileA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncryptFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EncryptFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EncryptFileW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor EncryptFileW$descriptor() {
        return EncryptFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EncryptFileW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle EncryptFileW$handle() {
        return EncryptFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EncryptFileW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment EncryptFileW$address() {
        return EncryptFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EncryptFileW(LPCWSTR lpFileName)
     * }
     */
    public static int EncryptFileW(MemorySegment lpFileName) {
        var mh$ = EncryptFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncryptFileW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecryptFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DecryptFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DecryptFileA(LPCSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static FunctionDescriptor DecryptFileA$descriptor() {
        return DecryptFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DecryptFileA(LPCSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static MethodHandle DecryptFileA$handle() {
        return DecryptFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DecryptFileA(LPCSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static MemorySegment DecryptFileA$address() {
        return DecryptFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DecryptFileA(LPCSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static int DecryptFileA(MemorySegment lpFileName, int dwReserved) {
        var mh$ = DecryptFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecryptFileA", lpFileName, dwReserved);
            }
            return (int)mh$.invokeExact(lpFileName, dwReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecryptFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DecryptFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static FunctionDescriptor DecryptFileW$descriptor() {
        return DecryptFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static MethodHandle DecryptFileW$handle() {
        return DecryptFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static MemorySegment DecryptFileW$address() {
        return DecryptFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static int DecryptFileW(MemorySegment lpFileName, int dwReserved) {
        var mh$ = DecryptFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecryptFileW", lpFileName, dwReserved);
            }
            return (int)mh$.invokeExact(lpFileName, dwReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileEncryptionStatusA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FileEncryptionStatusA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static FunctionDescriptor FileEncryptionStatusA$descriptor() {
        return FileEncryptionStatusA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static MethodHandle FileEncryptionStatusA$handle() {
        return FileEncryptionStatusA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static MemorySegment FileEncryptionStatusA$address() {
        return FileEncryptionStatusA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static int FileEncryptionStatusA(MemorySegment lpFileName, MemorySegment lpStatus) {
        var mh$ = FileEncryptionStatusA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileEncryptionStatusA", lpFileName, lpStatus);
            }
            return (int)mh$.invokeExact(lpFileName, lpStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileEncryptionStatusW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FileEncryptionStatusW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static FunctionDescriptor FileEncryptionStatusW$descriptor() {
        return FileEncryptionStatusW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static MethodHandle FileEncryptionStatusW$handle() {
        return FileEncryptionStatusW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static MemorySegment FileEncryptionStatusW$address() {
        return FileEncryptionStatusW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static int FileEncryptionStatusW(MemorySegment lpFileName, MemorySegment lpStatus) {
        var mh$ = FileEncryptionStatusW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileEncryptionStatusW", lpFileName, lpStatus);
            }
            return (int)mh$.invokeExact(lpFileName, lpStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEncryptedFileRawA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenEncryptedFileRawA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static FunctionDescriptor OpenEncryptedFileRawA$descriptor() {
        return OpenEncryptedFileRawA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static MethodHandle OpenEncryptedFileRawA$handle() {
        return OpenEncryptedFileRawA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static MemorySegment OpenEncryptedFileRawA$address() {
        return OpenEncryptedFileRawA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static int OpenEncryptedFileRawA(MemorySegment lpFileName, int ulFlags, MemorySegment pvContext) {
        var mh$ = OpenEncryptedFileRawA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEncryptedFileRawA", lpFileName, ulFlags, pvContext);
            }
            return (int)mh$.invokeExact(lpFileName, ulFlags, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEncryptedFileRawW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenEncryptedFileRawW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static FunctionDescriptor OpenEncryptedFileRawW$descriptor() {
        return OpenEncryptedFileRawW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static MethodHandle OpenEncryptedFileRawW$handle() {
        return OpenEncryptedFileRawW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static MemorySegment OpenEncryptedFileRawW$address() {
        return OpenEncryptedFileRawW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static int OpenEncryptedFileRawW(MemorySegment lpFileName, int ulFlags, MemorySegment pvContext) {
        var mh$ = OpenEncryptedFileRawW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEncryptedFileRawW", lpFileName, ulFlags, pvContext);
            }
            return (int)mh$.invokeExact(lpFileName, ulFlags, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadEncryptedFileRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReadEncryptedFileRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static FunctionDescriptor ReadEncryptedFileRaw$descriptor() {
        return ReadEncryptedFileRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static MethodHandle ReadEncryptedFileRaw$handle() {
        return ReadEncryptedFileRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static MemorySegment ReadEncryptedFileRaw$address() {
        return ReadEncryptedFileRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static int ReadEncryptedFileRaw(MemorySegment pfExportCallback, MemorySegment pvCallbackContext, MemorySegment pvContext) {
        var mh$ = ReadEncryptedFileRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadEncryptedFileRaw", pfExportCallback, pvCallbackContext, pvContext);
            }
            return (int)mh$.invokeExact(pfExportCallback, pvCallbackContext, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteEncryptedFileRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WriteEncryptedFileRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static FunctionDescriptor WriteEncryptedFileRaw$descriptor() {
        return WriteEncryptedFileRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static MethodHandle WriteEncryptedFileRaw$handle() {
        return WriteEncryptedFileRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static MemorySegment WriteEncryptedFileRaw$address() {
        return WriteEncryptedFileRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static int WriteEncryptedFileRaw(MemorySegment pfImportCallback, MemorySegment pvCallbackContext, MemorySegment pvContext) {
        var mh$ = WriteEncryptedFileRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteEncryptedFileRaw", pfImportCallback, pvCallbackContext, pvContext);
            }
            return (int)mh$.invokeExact(pfImportCallback, pvCallbackContext, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseEncryptedFileRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseEncryptedFileRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseEncryptedFileRaw(PVOID pvContext)
     * }
     */
    public static FunctionDescriptor CloseEncryptedFileRaw$descriptor() {
        return CloseEncryptedFileRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseEncryptedFileRaw(PVOID pvContext)
     * }
     */
    public static MethodHandle CloseEncryptedFileRaw$handle() {
        return CloseEncryptedFileRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseEncryptedFileRaw(PVOID pvContext)
     * }
     */
    public static MemorySegment CloseEncryptedFileRaw$address() {
        return CloseEncryptedFileRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseEncryptedFileRaw(PVOID pvContext)
     * }
     */
    public static void CloseEncryptedFileRaw(MemorySegment pvContext) {
        var mh$ = CloseEncryptedFileRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseEncryptedFileRaw", pvContext);
            }
            mh$.invokeExact(pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrcmpA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpA$descriptor() {
        return lstrcmpA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpA$handle() {
        return lstrcmpA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcmpA$address() {
        return lstrcmpA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static int lstrcmpA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpA", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrcmpW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpW$descriptor() {
        return lstrcmpW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpW$handle() {
        return lstrcmpW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcmpW$address() {
        return lstrcmpW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static int lstrcmpW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpW", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpiA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrcmpiA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpiA$descriptor() {
        return lstrcmpiA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpiA$handle() {
        return lstrcmpiA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcmpiA$address() {
        return lstrcmpiA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static int lstrcmpiA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpiA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpiA", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpiW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrcmpiW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpiW$descriptor() {
        return lstrcmpiW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpiW$handle() {
        return lstrcmpiW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcmpiW$address() {
        return lstrcmpiW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static int lstrcmpiW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpiW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpiW", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpynA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrcpynA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
     * }
     */
    public static FunctionDescriptor lstrcpynA$descriptor() {
        return lstrcpynA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
     * }
     */
    public static MethodHandle lstrcpynA$handle() {
        return lstrcpynA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
     * }
     */
    public static MemorySegment lstrcpynA$address() {
        return lstrcpynA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
     * }
     */
    public static MemorySegment lstrcpynA(MemorySegment lpString1, MemorySegment lpString2, int iMaxLength) {
        var mh$ = lstrcpynA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpynA", lpString1, lpString2, iMaxLength);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2, iMaxLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpynW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrcpynW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
     * }
     */
    public static FunctionDescriptor lstrcpynW$descriptor() {
        return lstrcpynW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
     * }
     */
    public static MethodHandle lstrcpynW$handle() {
        return lstrcpynW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
     * }
     */
    public static MemorySegment lstrcpynW$address() {
        return lstrcpynW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
     * }
     */
    public static MemorySegment lstrcpynW(MemorySegment lpString1, MemorySegment lpString2, int iMaxLength) {
        var mh$ = lstrcpynW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpynW", lpString1, lpString2, iMaxLength);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2, iMaxLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrcpyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcpyA$descriptor() {
        return lstrcpyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcpyA$handle() {
        return lstrcpyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcpyA$address() {
        return lstrcpyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcpyA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcpyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpyA", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrcpyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcpyW$descriptor() {
        return lstrcpyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcpyW$handle() {
        return lstrcpyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcpyW$address() {
        return lstrcpyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcpyW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcpyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpyW", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrcatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR lstrcatA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcatA$descriptor() {
        return lstrcatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR lstrcatA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcatA$handle() {
        return lstrcatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR lstrcatA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcatA$address() {
        return lstrcatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR lstrcatA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcatA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcatA", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrcatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcatW$descriptor() {
        return lstrcatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcatW$handle() {
        return lstrcatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcatW$address() {
        return lstrcatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcatW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcatW", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrlenA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrlenA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrlenA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor lstrlenA$descriptor() {
        return lstrlenA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrlenA(LPCSTR lpString)
     * }
     */
    public static MethodHandle lstrlenA$handle() {
        return lstrlenA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrlenA(LPCSTR lpString)
     * }
     */
    public static MemorySegment lstrlenA$address() {
        return lstrlenA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrlenA(LPCSTR lpString)
     * }
     */
    public static int lstrlenA(MemorySegment lpString) {
        var mh$ = lstrlenA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrlenA", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrlenW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("lstrlenW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrlenW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor lstrlenW$descriptor() {
        return lstrlenW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrlenW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle lstrlenW$handle() {
        return lstrlenW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrlenW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment lstrlenW$address() {
        return lstrlenW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrlenW(LPCWSTR lpString)
     * }
     */
    public static int lstrlenW(MemorySegment lpString) {
        var mh$ = lstrlenW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrlenW", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
     * }
     */
    public static FunctionDescriptor OpenFile$descriptor() {
        return OpenFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
     * }
     */
    public static MethodHandle OpenFile$handle() {
        return OpenFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFILE OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
     * }
     */
    public static MemorySegment OpenFile$address() {
        return OpenFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFILE OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
     * }
     */
    public static int OpenFile(MemorySegment lpFileName, MemorySegment lpReOpenBuff, int uStyle) {
        var mh$ = OpenFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFile", lpFileName, lpReOpenBuff, uStyle);
            }
            return (int)mh$.invokeExact(lpFileName, lpReOpenBuff, uStyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("_lopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE _lopen(LPCSTR lpPathName, int iReadWrite)
     * }
     */
    public static FunctionDescriptor _lopen$descriptor() {
        return _lopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE _lopen(LPCSTR lpPathName, int iReadWrite)
     * }
     */
    public static MethodHandle _lopen$handle() {
        return _lopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFILE _lopen(LPCSTR lpPathName, int iReadWrite)
     * }
     */
    public static MemorySegment _lopen$address() {
        return _lopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFILE _lopen(LPCSTR lpPathName, int iReadWrite)
     * }
     */
    public static int _lopen(MemorySegment lpPathName, int iReadWrite) {
        var mh$ = _lopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lopen", lpPathName, iReadWrite);
            }
            return (int)mh$.invokeExact(lpPathName, iReadWrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lcreat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("_lcreat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE _lcreat(LPCSTR lpPathName, int iAttribute)
     * }
     */
    public static FunctionDescriptor _lcreat$descriptor() {
        return _lcreat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE _lcreat(LPCSTR lpPathName, int iAttribute)
     * }
     */
    public static MethodHandle _lcreat$handle() {
        return _lcreat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFILE _lcreat(LPCSTR lpPathName, int iAttribute)
     * }
     */
    public static MemorySegment _lcreat$address() {
        return _lcreat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFILE _lcreat(LPCSTR lpPathName, int iAttribute)
     * }
     */
    public static int _lcreat(MemorySegment lpPathName, int iAttribute) {
        var mh$ = _lcreat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lcreat", lpPathName, iAttribute);
            }
            return (int)mh$.invokeExact(lpPathName, iAttribute);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("_lread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
     * }
     */
    public static FunctionDescriptor _lread$descriptor() {
        return _lread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
     * }
     */
    public static MethodHandle _lread$handle() {
        return _lread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
     * }
     */
    public static MemorySegment _lread$address() {
        return _lread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
     * }
     */
    public static int _lread(int hFile, MemorySegment lpBuffer, int uBytes) {
        var mh$ = _lread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lread", hFile, lpBuffer, uBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, uBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("_lwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
     * }
     */
    public static FunctionDescriptor _lwrite$descriptor() {
        return _lwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
     * }
     */
    public static MethodHandle _lwrite$handle() {
        return _lwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
     * }
     */
    public static MemorySegment _lwrite$address() {
        return _lwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
     * }
     */
    public static int _lwrite(int hFile, MemorySegment lpBuffer, int uBytes) {
        var mh$ = _lwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lwrite", hFile, lpBuffer, uBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, uBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("_hread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
     * }
     */
    public static FunctionDescriptor _hread$descriptor() {
        return _hread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
     * }
     */
    public static MethodHandle _hread$handle() {
        return _hread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
     * }
     */
    public static MemorySegment _hread$address() {
        return _hread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
     * }
     */
    public static int _hread(int hFile, MemorySegment lpBuffer, int lBytes) {
        var mh$ = _hread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hread", hFile, lpBuffer, lBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, lBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("_hwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes)
     * }
     */
    public static FunctionDescriptor _hwrite$descriptor() {
        return _hwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes)
     * }
     */
    public static MethodHandle _hwrite$handle() {
        return _hwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes)
     * }
     */
    public static MemorySegment _hwrite$address() {
        return _hwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes)
     * }
     */
    public static int _hwrite(int hFile, MemorySegment lpBuffer, int lBytes) {
        var mh$ = _hwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hwrite", hFile, lpBuffer, lBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, lBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("_lclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE _lclose(HFILE hFile)
     * }
     */
    public static FunctionDescriptor _lclose$descriptor() {
        return _lclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE _lclose(HFILE hFile)
     * }
     */
    public static MethodHandle _lclose$handle() {
        return _lclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFILE _lclose(HFILE hFile)
     * }
     */
    public static MemorySegment _lclose$address() {
        return _lclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFILE _lclose(HFILE hFile)
     * }
     */
    public static int _lclose(int hFile) {
        var mh$ = _lclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lclose", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _llseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("_llseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG _llseek(HFILE hFile, LONG lOffset, int iOrigin)
     * }
     */
    public static FunctionDescriptor _llseek$descriptor() {
        return _llseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG _llseek(HFILE hFile, LONG lOffset, int iOrigin)
     * }
     */
    public static MethodHandle _llseek$handle() {
        return _llseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG _llseek(HFILE hFile, LONG lOffset, int iOrigin)
     * }
     */
    public static MemorySegment _llseek$address() {
        return _llseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG _llseek(HFILE hFile, LONG lOffset, int iOrigin)
     * }
     */
    public static int _llseek(int hFile, int lOffset, int iOrigin) {
        var mh$ = _llseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_llseek", hFile, lOffset, iOrigin);
            }
            return (int)mh$.invokeExact(hFile, lOffset, iOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTextUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsTextUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
     * }
     */
    public static FunctionDescriptor IsTextUnicode$descriptor() {
        return IsTextUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
     * }
     */
    public static MethodHandle IsTextUnicode$handle() {
        return IsTextUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
     * }
     */
    public static MemorySegment IsTextUnicode$address() {
        return IsTextUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
     * }
     */
    public static int IsTextUnicode(MemorySegment lpv, int iSize, MemorySegment lpiResult) {
        var mh$ = IsTextUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTextUnicode", lpv, iSize, lpiResult);
            }
            return (int)mh$.invokeExact(lpv, iSize, lpiResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BackupRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor BackupRead$descriptor() {
        return BackupRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static MethodHandle BackupRead$handle() {
        return BackupRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static MemorySegment BackupRead$address() {
        return BackupRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static int BackupRead(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpNumberOfBytesRead, int bAbort, int bProcessSecurity, MemorySegment lpContext) {
        var mh$ = BackupRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupRead", hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, bAbort, bProcessSecurity, lpContext);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, bAbort, bProcessSecurity, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupSeek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BackupSeek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor BackupSeek$descriptor() {
        return BackupSeek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
     * }
     */
    public static MethodHandle BackupSeek$handle() {
        return BackupSeek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
     * }
     */
    public static MemorySegment BackupSeek$address() {
        return BackupSeek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
     * }
     */
    public static int BackupSeek(MemorySegment hFile, int dwLowBytesToSeek, int dwHighBytesToSeek, MemorySegment lpdwLowByteSeeked, MemorySegment lpdwHighByteSeeked, MemorySegment lpContext) {
        var mh$ = BackupSeek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupSeek", hFile, dwLowBytesToSeek, dwHighBytesToSeek, lpdwLowByteSeeked, lpdwHighByteSeeked, lpContext);
            }
            return (int)mh$.invokeExact(hFile, dwLowBytesToSeek, dwHighBytesToSeek, lpdwLowByteSeeked, lpdwHighByteSeeked, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BackupWrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor BackupWrite$descriptor() {
        return BackupWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static MethodHandle BackupWrite$handle() {
        return BackupWrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static MemorySegment BackupWrite$address() {
        return BackupWrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static int BackupWrite(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpNumberOfBytesWritten, int bAbort, int bProcessSecurity, MemorySegment lpContext) {
        var mh$ = BackupWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupWrite", hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, bAbort, bProcessSecurity, lpContext);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, bAbort, bProcessSecurity, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_STREAM_ID {
     *     DWORD dwStreamId;
     *     DWORD dwStreamAttributes;
     *     LARGE_INTEGER Size;
     *     DWORD dwStreamNameSize;
     *     WCHAR cStreamName[1];
     * } *LPWIN32_STREAM_ID
     * }
     */
    public static final AddressLayout LPWIN32_STREAM_ID = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOEXA {
     *     STARTUPINFOA StartupInfo;
     *     LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
     * } *LPSTARTUPINFOEXA
     * }
     */
    public static final AddressLayout LPSTARTUPINFOEXA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOEXW {
     *     STARTUPINFOW StartupInfo;
     *     LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
     * } *LPSTARTUPINFOEXW
     * }
     */
    public static final AddressLayout LPSTARTUPINFOEXW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTARTUPINFOEXA LPSTARTUPINFOEX
     * }
     */
    public static final AddressLayout LPSTARTUPINFOEX = wgl_h.C_POINTER;

    private static class OpenMutexA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenMutexA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenMutexA$descriptor() {
        return OpenMutexA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenMutexA$handle() {
        return OpenMutexA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexA$address() {
        return OpenMutexA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenMutexA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenMutexA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateSemaphoreA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreA$descriptor() {
        return CreateSemaphoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateSemaphoreA$handle() {
        return CreateSemaphoreA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreA$address() {
        return CreateSemaphoreA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreA(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName) {
        var mh$ = CreateSemaphoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreA", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenSemaphoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenSemaphoreA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenSemaphoreA$descriptor() {
        return OpenSemaphoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenSemaphoreA$handle() {
        return OpenSemaphoreA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreA$address() {
        return OpenSemaphoreA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenSemaphoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenSemaphoreA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateWaitableTimerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerA$descriptor() {
        return CreateWaitableTimerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
     * }
     */
    public static MethodHandle CreateWaitableTimerA$handle() {
        return CreateWaitableTimerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerA$address() {
        return CreateWaitableTimerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerA(MemorySegment lpTimerAttributes, int bManualReset, MemorySegment lpTimerName) {
        var mh$ = CreateWaitableTimerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerA", lpTimerAttributes, bManualReset, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, bManualReset, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWaitableTimerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenWaitableTimerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor OpenWaitableTimerA$descriptor() {
        return OpenWaitableTimerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
     * }
     */
    public static MethodHandle OpenWaitableTimerA$handle() {
        return OpenWaitableTimerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerA$address() {
        return OpenWaitableTimerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpTimerName) {
        var mh$ = OpenWaitableTimerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWaitableTimerA", dwDesiredAccess, bInheritHandle, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateSemaphoreExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreExA$descriptor() {
        return CreateSemaphoreExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateSemaphoreExA$handle() {
        return CreateSemaphoreExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExA$address() {
        return CreateSemaphoreExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExA(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateSemaphoreExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreExA", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateWaitableTimerExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerExA$descriptor() {
        return CreateWaitableTimerExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateWaitableTimerExA$handle() {
        return CreateWaitableTimerExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExA$address() {
        return CreateWaitableTimerExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExA(MemorySegment lpTimerAttributes, MemorySegment lpTimerName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateWaitableTimerExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerExA", lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFileMappingA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateFileMappingA$descriptor() {
        return CreateFileMappingA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateFileMappingA$handle() {
        return CreateFileMappingA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateFileMappingA$address() {
        return CreateFileMappingA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateFileMappingA(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName) {
        var mh$ = CreateFileMappingA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingA", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingNumaA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFileMappingNumaA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor CreateFileMappingNumaA$descriptor() {
        return CreateFileMappingNumaA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MethodHandle CreateFileMappingNumaA$handle() {
        return CreateFileMappingNumaA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MemorySegment CreateFileMappingNumaA$address() {
        return CreateFileMappingNumaA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MemorySegment CreateFileMappingNumaA(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName, int nndPreferred) {
        var mh$ = CreateFileMappingNumaA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingNumaA", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFileMappingA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenFileMappingA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenFileMappingA$descriptor() {
        return OpenFileMappingA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenFileMappingA$handle() {
        return OpenFileMappingA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenFileMappingA$address() {
        return OpenFileMappingA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenFileMappingA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenFileMappingA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileMappingA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalDriveStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLogicalDriveStringsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetLogicalDriveStringsA$descriptor() {
        return GetLogicalDriveStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetLogicalDriveStringsA$handle() {
        return GetLogicalDriveStringsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MemorySegment GetLogicalDriveStringsA$address() {
        return GetLogicalDriveStringsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetLogicalDriveStringsA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetLogicalDriveStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalDriveStringsA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadPackagedLibrary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadPackagedLibrary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor LoadPackagedLibrary$descriptor() {
        return LoadPackagedLibrary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved)
     * }
     */
    public static MethodHandle LoadPackagedLibrary$handle() {
        return LoadPackagedLibrary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved)
     * }
     */
    public static MemorySegment LoadPackagedLibrary$address() {
        return LoadPackagedLibrary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved)
     * }
     */
    public static MemorySegment LoadPackagedLibrary(MemorySegment lpwLibFileName, int Reserved) {
        var mh$ = LoadPackagedLibrary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadPackagedLibrary", lpwLibFileName, Reserved);
            }
            return (MemorySegment)mh$.invokeExact(lpwLibFileName, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryFullProcessImageNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryFullProcessImageNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor QueryFullProcessImageNameA$descriptor() {
        return QueryFullProcessImageNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static MethodHandle QueryFullProcessImageNameA$handle() {
        return QueryFullProcessImageNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static MemorySegment QueryFullProcessImageNameA$address() {
        return QueryFullProcessImageNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static int QueryFullProcessImageNameA(MemorySegment hProcess, int dwFlags, MemorySegment lpExeName, MemorySegment lpdwSize) {
        var mh$ = QueryFullProcessImageNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryFullProcessImageNameA", hProcess, dwFlags, lpExeName, lpdwSize);
            }
            return (int)mh$.invokeExact(hProcess, dwFlags, lpExeName, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryFullProcessImageNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryFullProcessImageNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor QueryFullProcessImageNameW$descriptor() {
        return QueryFullProcessImageNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static MethodHandle QueryFullProcessImageNameW$handle() {
        return QueryFullProcessImageNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static MemorySegment QueryFullProcessImageNameW$address() {
        return QueryFullProcessImageNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static int QueryFullProcessImageNameW(MemorySegment hProcess, int dwFlags, MemorySegment lpExeName, MemorySegment lpdwSize) {
        var mh$ = QueryFullProcessImageNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryFullProcessImageNameW", hProcess, dwFlags, lpExeName, lpdwSize);
            }
            return (int)mh$.invokeExact(hProcess, dwFlags, lpExeName, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ProcThreadAttributeParentProcess = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeParentProcess = 0
     * }
     */
    public static int ProcThreadAttributeParentProcess() {
        return ProcThreadAttributeParentProcess;
    }
    private static final int ProcThreadAttributeHandleList = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeHandleList = 2
     * }
     */
    public static int ProcThreadAttributeHandleList() {
        return ProcThreadAttributeHandleList;
    }
    private static final int ProcThreadAttributeGroupAffinity = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeGroupAffinity = 3
     * }
     */
    public static int ProcThreadAttributeGroupAffinity() {
        return ProcThreadAttributeGroupAffinity;
    }
    private static final int ProcThreadAttributePreferredNode = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributePreferredNode = 4
     * }
     */
    public static int ProcThreadAttributePreferredNode() {
        return ProcThreadAttributePreferredNode;
    }
    private static final int ProcThreadAttributeIdealProcessor = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeIdealProcessor = 5
     * }
     */
    public static int ProcThreadAttributeIdealProcessor() {
        return ProcThreadAttributeIdealProcessor;
    }
    private static final int ProcThreadAttributeUmsThread = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeUmsThread = 6
     * }
     */
    public static int ProcThreadAttributeUmsThread() {
        return ProcThreadAttributeUmsThread;
    }
    private static final int ProcThreadAttributeMitigationPolicy = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeMitigationPolicy = 7
     * }
     */
    public static int ProcThreadAttributeMitigationPolicy() {
        return ProcThreadAttributeMitigationPolicy;
    }
    private static final int ProcThreadAttributeSecurityCapabilities = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeSecurityCapabilities = 9
     * }
     */
    public static int ProcThreadAttributeSecurityCapabilities() {
        return ProcThreadAttributeSecurityCapabilities;
    }
    private static final int ProcThreadAttributeProtectionLevel = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeProtectionLevel = 11
     * }
     */
    public static int ProcThreadAttributeProtectionLevel() {
        return ProcThreadAttributeProtectionLevel;
    }
    private static final int ProcThreadAttributeJobList = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeJobList = 13
     * }
     */
    public static int ProcThreadAttributeJobList() {
        return ProcThreadAttributeJobList;
    }
    private static final int ProcThreadAttributeChildProcessPolicy = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeChildProcessPolicy = 14
     * }
     */
    public static int ProcThreadAttributeChildProcessPolicy() {
        return ProcThreadAttributeChildProcessPolicy;
    }
    private static final int ProcThreadAttributeAllApplicationPackagesPolicy = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeAllApplicationPackagesPolicy = 15
     * }
     */
    public static int ProcThreadAttributeAllApplicationPackagesPolicy() {
        return ProcThreadAttributeAllApplicationPackagesPolicy;
    }
    private static final int ProcThreadAttributeWin32kFilter = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeWin32kFilter = 16
     * }
     */
    public static int ProcThreadAttributeWin32kFilter() {
        return ProcThreadAttributeWin32kFilter;
    }
    private static final int ProcThreadAttributeSafeOpenPromptOriginClaim = (int)17L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeSafeOpenPromptOriginClaim = 17
     * }
     */
    public static int ProcThreadAttributeSafeOpenPromptOriginClaim() {
        return ProcThreadAttributeSafeOpenPromptOriginClaim;
    }
    private static final int ProcThreadAttributeDesktopAppPolicy = (int)18L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeDesktopAppPolicy = 18
     * }
     */
    public static int ProcThreadAttributeDesktopAppPolicy() {
        return ProcThreadAttributeDesktopAppPolicy;
    }
    private static final int ProcThreadAttributePseudoConsole = (int)22L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributePseudoConsole = 22
     * }
     */
    public static int ProcThreadAttributePseudoConsole() {
        return ProcThreadAttributePseudoConsole;
    }
    private static final int ProcThreadAttributeMitigationAuditPolicy = (int)24L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeMitigationAuditPolicy = 24
     * }
     */
    public static int ProcThreadAttributeMitigationAuditPolicy() {
        return ProcThreadAttributeMitigationAuditPolicy;
    }

    private static class GetStartupInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetStartupInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
     * }
     */
    public static FunctionDescriptor GetStartupInfoA$descriptor() {
        return GetStartupInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
     * }
     */
    public static MethodHandle GetStartupInfoA$handle() {
        return GetStartupInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
     * }
     */
    public static MemorySegment GetStartupInfoA$address() {
        return GetStartupInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
     * }
     */
    public static void GetStartupInfoA(MemorySegment lpStartupInfo) {
        var mh$ = GetStartupInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStartupInfoA", lpStartupInfo);
            }
            mh$.invokeExact(lpStartupInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFirmwareEnvironmentVariableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableA$descriptor() {
        return GetFirmwareEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableA$handle() {
        return GetFirmwareEnvironmentVariableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetFirmwareEnvironmentVariableA$address() {
        return GetFirmwareEnvironmentVariableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static int GetFirmwareEnvironmentVariableA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize) {
        var mh$ = GetFirmwareEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableA", lpName, lpGuid, pBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFirmwareEnvironmentVariableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableW$descriptor() {
        return GetFirmwareEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableW$handle() {
        return GetFirmwareEnvironmentVariableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetFirmwareEnvironmentVariableW$address() {
        return GetFirmwareEnvironmentVariableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static int GetFirmwareEnvironmentVariableW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize) {
        var mh$ = GetFirmwareEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableW", lpName, lpGuid, pBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFirmwareEnvironmentVariableExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableExA$descriptor() {
        return GetFirmwareEnvironmentVariableExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableExA$handle() {
        return GetFirmwareEnvironmentVariableExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static MemorySegment GetFirmwareEnvironmentVariableExA$address() {
        return GetFirmwareEnvironmentVariableExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static int GetFirmwareEnvironmentVariableExA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize, MemorySegment pdwAttribubutes) {
        var mh$ = GetFirmwareEnvironmentVariableExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableExA", lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFirmwareEnvironmentVariableExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableExW$descriptor() {
        return GetFirmwareEnvironmentVariableExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableExW$handle() {
        return GetFirmwareEnvironmentVariableExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static MemorySegment GetFirmwareEnvironmentVariableExW$address() {
        return GetFirmwareEnvironmentVariableExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static int GetFirmwareEnvironmentVariableExW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize, MemorySegment pdwAttribubutes) {
        var mh$ = GetFirmwareEnvironmentVariableExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableExW", lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFirmwareEnvironmentVariableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableA$descriptor() {
        return SetFirmwareEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableA$handle() {
        return SetFirmwareEnvironmentVariableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static MemorySegment SetFirmwareEnvironmentVariableA$address() {
        return SetFirmwareEnvironmentVariableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static int SetFirmwareEnvironmentVariableA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize) {
        var mh$ = SetFirmwareEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableA", lpName, lpGuid, pValue, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFirmwareEnvironmentVariableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableW$descriptor() {
        return SetFirmwareEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableW$handle() {
        return SetFirmwareEnvironmentVariableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static MemorySegment SetFirmwareEnvironmentVariableW$address() {
        return SetFirmwareEnvironmentVariableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static int SetFirmwareEnvironmentVariableW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize) {
        var mh$ = SetFirmwareEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableW", lpName, lpGuid, pValue, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFirmwareEnvironmentVariableExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableExA$descriptor() {
        return SetFirmwareEnvironmentVariableExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableExA$handle() {
        return SetFirmwareEnvironmentVariableExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static MemorySegment SetFirmwareEnvironmentVariableExA$address() {
        return SetFirmwareEnvironmentVariableExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static int SetFirmwareEnvironmentVariableExA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize, int dwAttributes) {
        var mh$ = SetFirmwareEnvironmentVariableExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableExA", lpName, lpGuid, pValue, nSize, dwAttributes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize, dwAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFirmwareEnvironmentVariableExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableExW$descriptor() {
        return SetFirmwareEnvironmentVariableExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableExW$handle() {
        return SetFirmwareEnvironmentVariableExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static MemorySegment SetFirmwareEnvironmentVariableExW$address() {
        return SetFirmwareEnvironmentVariableExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static int SetFirmwareEnvironmentVariableExW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize, int dwAttributes) {
        var mh$ = SetFirmwareEnvironmentVariableExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableExW", lpName, lpGuid, pValue, nSize, dwAttributes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize, dwAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFirmwareType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFirmwareType(PFIRMWARE_TYPE FirmwareType)
     * }
     */
    public static FunctionDescriptor GetFirmwareType$descriptor() {
        return GetFirmwareType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFirmwareType(PFIRMWARE_TYPE FirmwareType)
     * }
     */
    public static MethodHandle GetFirmwareType$handle() {
        return GetFirmwareType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFirmwareType(PFIRMWARE_TYPE FirmwareType)
     * }
     */
    public static MemorySegment GetFirmwareType$address() {
        return GetFirmwareType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFirmwareType(PFIRMWARE_TYPE FirmwareType)
     * }
     */
    public static int GetFirmwareType(MemorySegment FirmwareType) {
        var mh$ = GetFirmwareType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareType", FirmwareType);
            }
            return (int)mh$.invokeExact(FirmwareType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsNativeVhdBoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsNativeVhdBoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsNativeVhdBoot(PBOOL NativeVhdBoot)
     * }
     */
    public static FunctionDescriptor IsNativeVhdBoot$descriptor() {
        return IsNativeVhdBoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsNativeVhdBoot(PBOOL NativeVhdBoot)
     * }
     */
    public static MethodHandle IsNativeVhdBoot$handle() {
        return IsNativeVhdBoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsNativeVhdBoot(PBOOL NativeVhdBoot)
     * }
     */
    public static MemorySegment IsNativeVhdBoot$address() {
        return IsNativeVhdBoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsNativeVhdBoot(PBOOL NativeVhdBoot)
     * }
     */
    public static int IsNativeVhdBoot(MemorySegment NativeVhdBoot) {
        var mh$ = IsNativeVhdBoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsNativeVhdBoot", NativeVhdBoot);
            }
            return (int)mh$.invokeExact(NativeVhdBoot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
     * }
     */
    public static FunctionDescriptor FindResourceA$descriptor() {
        return FindResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
     * }
     */
    public static MethodHandle FindResourceA$handle() {
        return FindResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRSRC FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
     * }
     */
    public static MemorySegment FindResourceA$address() {
        return FindResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRSRC FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
     * }
     */
    public static MemorySegment FindResourceA(MemorySegment hModule, MemorySegment lpName, MemorySegment lpType) {
        var mh$ = FindResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceA", hModule, lpName, lpType);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpName, lpType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindResourceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
     * }
     */
    public static FunctionDescriptor FindResourceExA$descriptor() {
        return FindResourceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
     * }
     */
    public static MethodHandle FindResourceExA$handle() {
        return FindResourceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRSRC FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
     * }
     */
    public static MemorySegment FindResourceExA$address() {
        return FindResourceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRSRC FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
     * }
     */
    public static MemorySegment FindResourceExA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, short wLanguage) {
        var mh$ = FindResourceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceExA", hModule, lpType, lpName, wLanguage);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpType, lpName, wLanguage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceTypesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesA$descriptor() {
        return EnumResourceTypesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceTypesA$handle() {
        return EnumResourceTypesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceTypesA$address() {
        return EnumResourceTypesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceTypesA(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceTypesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesA", hModule, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceTypesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesW$descriptor() {
        return EnumResourceTypesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceTypesW$handle() {
        return EnumResourceTypesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceTypesW$address() {
        return EnumResourceTypesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceTypesW(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceTypesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesW", hModule, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceNamesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesA$descriptor() {
        return EnumResourceNamesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceNamesA$handle() {
        return EnumResourceNamesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceNamesA$address() {
        return EnumResourceNamesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceNamesA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceNamesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesA", hModule, lpType, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceLanguagesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesA$descriptor() {
        return EnumResourceLanguagesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceLanguagesA$handle() {
        return EnumResourceLanguagesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceLanguagesA$address() {
        return EnumResourceLanguagesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceLanguagesA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceLanguagesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesA", hModule, lpType, lpName, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceLanguagesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesW$descriptor() {
        return EnumResourceLanguagesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceLanguagesW$handle() {
        return EnumResourceLanguagesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceLanguagesW$address() {
        return EnumResourceLanguagesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceLanguagesW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceLanguagesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesW", hModule, lpType, lpName, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginUpdateResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BeginUpdateResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static FunctionDescriptor BeginUpdateResourceA$descriptor() {
        return BeginUpdateResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MethodHandle BeginUpdateResourceA$handle() {
        return BeginUpdateResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MemorySegment BeginUpdateResourceA$address() {
        return BeginUpdateResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MemorySegment BeginUpdateResourceA(MemorySegment pFileName, int bDeleteExistingResources) {
        var mh$ = BeginUpdateResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginUpdateResourceA", pFileName, bDeleteExistingResources);
            }
            return (MemorySegment)mh$.invokeExact(pFileName, bDeleteExistingResources);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginUpdateResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BeginUpdateResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static FunctionDescriptor BeginUpdateResourceW$descriptor() {
        return BeginUpdateResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MethodHandle BeginUpdateResourceW$handle() {
        return BeginUpdateResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MemorySegment BeginUpdateResourceW$address() {
        return BeginUpdateResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MemorySegment BeginUpdateResourceW(MemorySegment pFileName, int bDeleteExistingResources) {
        var mh$ = BeginUpdateResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginUpdateResourceW", pFileName, bDeleteExistingResources);
            }
            return (MemorySegment)mh$.invokeExact(pFileName, bDeleteExistingResources);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UpdateResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static FunctionDescriptor UpdateResourceA$descriptor() {
        return UpdateResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static MethodHandle UpdateResourceA$handle() {
        return UpdateResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static MemorySegment UpdateResourceA$address() {
        return UpdateResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static int UpdateResourceA(MemorySegment hUpdate, MemorySegment lpType, MemorySegment lpName, short wLanguage, MemorySegment lpData, int cb) {
        var mh$ = UpdateResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateResourceA", hUpdate, lpType, lpName, wLanguage, lpData, cb);
            }
            return (int)mh$.invokeExact(hUpdate, lpType, lpName, wLanguage, lpData, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UpdateResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static FunctionDescriptor UpdateResourceW$descriptor() {
        return UpdateResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static MethodHandle UpdateResourceW$handle() {
        return UpdateResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static MemorySegment UpdateResourceW$address() {
        return UpdateResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static int UpdateResourceW(MemorySegment hUpdate, MemorySegment lpType, MemorySegment lpName, short wLanguage, MemorySegment lpData, int cb) {
        var mh$ = UpdateResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateResourceW", hUpdate, lpType, lpName, wLanguage, lpData, cb);
            }
            return (int)mh$.invokeExact(hUpdate, lpType, lpName, wLanguage, lpData, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndUpdateResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EndUpdateResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static FunctionDescriptor EndUpdateResourceA$descriptor() {
        return EndUpdateResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static MethodHandle EndUpdateResourceA$handle() {
        return EndUpdateResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static MemorySegment EndUpdateResourceA$address() {
        return EndUpdateResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static int EndUpdateResourceA(MemorySegment hUpdate, int fDiscard) {
        var mh$ = EndUpdateResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndUpdateResourceA", hUpdate, fDiscard);
            }
            return (int)mh$.invokeExact(hUpdate, fDiscard);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndUpdateResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EndUpdateResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static FunctionDescriptor EndUpdateResourceW$descriptor() {
        return EndUpdateResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static MethodHandle EndUpdateResourceW$handle() {
        return EndUpdateResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static MemorySegment EndUpdateResourceW$address() {
        return EndUpdateResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static int EndUpdateResourceW(MemorySegment hUpdate, int fDiscard) {
        var mh$ = EndUpdateResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndUpdateResourceW", hUpdate, fDiscard);
            }
            return (int)mh$.invokeExact(hUpdate, fDiscard);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalAddAtomA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomA$descriptor() {
        return GlobalAddAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle GlobalAddAtomA$handle() {
        return GlobalAddAtomA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomA(LPCSTR lpString)
     * }
     */
    public static MemorySegment GlobalAddAtomA$address() {
        return GlobalAddAtomA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomA(LPCSTR lpString)
     * }
     */
    public static short GlobalAddAtomA(MemorySegment lpString) {
        var mh$ = GlobalAddAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalAddAtomW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomW$descriptor() {
        return GlobalAddAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle GlobalAddAtomW$handle() {
        return GlobalAddAtomW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment GlobalAddAtomW$address() {
        return GlobalAddAtomW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomW(LPCWSTR lpString)
     * }
     */
    public static short GlobalAddAtomW(MemorySegment lpString) {
        var mh$ = GlobalAddAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalAddAtomExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExA(LPCSTR lpString, DWORD Flags)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomExA$descriptor() {
        return GlobalAddAtomExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExA(LPCSTR lpString, DWORD Flags)
     * }
     */
    public static MethodHandle GlobalAddAtomExA$handle() {
        return GlobalAddAtomExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExA(LPCSTR lpString, DWORD Flags)
     * }
     */
    public static MemorySegment GlobalAddAtomExA$address() {
        return GlobalAddAtomExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExA(LPCSTR lpString, DWORD Flags)
     * }
     */
    public static short GlobalAddAtomExA(MemorySegment lpString, int Flags) {
        var mh$ = GlobalAddAtomExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomExA", lpString, Flags);
            }
            return (short)mh$.invokeExact(lpString, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalAddAtomExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomExW$descriptor() {
        return GlobalAddAtomExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags)
     * }
     */
    public static MethodHandle GlobalAddAtomExW$handle() {
        return GlobalAddAtomExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags)
     * }
     */
    public static MemorySegment GlobalAddAtomExW$address() {
        return GlobalAddAtomExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags)
     * }
     */
    public static short GlobalAddAtomExW(MemorySegment lpString, int Flags) {
        var mh$ = GlobalAddAtomExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomExW", lpString, Flags);
            }
            return (short)mh$.invokeExact(lpString, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFindAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalFindAtomA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalFindAtomA$descriptor() {
        return GlobalFindAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle GlobalFindAtomA$handle() {
        return GlobalFindAtomA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomA(LPCSTR lpString)
     * }
     */
    public static MemorySegment GlobalFindAtomA$address() {
        return GlobalFindAtomA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalFindAtomA(LPCSTR lpString)
     * }
     */
    public static short GlobalFindAtomA(MemorySegment lpString) {
        var mh$ = GlobalFindAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFindAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFindAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalFindAtomW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalFindAtomW$descriptor() {
        return GlobalFindAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle GlobalFindAtomW$handle() {
        return GlobalFindAtomW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment GlobalFindAtomW$address() {
        return GlobalFindAtomW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalFindAtomW(LPCWSTR lpString)
     * }
     */
    public static short GlobalFindAtomW(MemorySegment lpString) {
        var mh$ = GlobalFindAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFindAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalGetAtomNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalGetAtomNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GlobalGetAtomNameA$descriptor() {
        return GlobalGetAtomNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GlobalGetAtomNameA$handle() {
        return GlobalGetAtomNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static MemorySegment GlobalGetAtomNameA$address() {
        return GlobalGetAtomNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static int GlobalGetAtomNameA(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GlobalGetAtomNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalGetAtomNameA", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalGetAtomNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalGetAtomNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GlobalGetAtomNameW$descriptor() {
        return GlobalGetAtomNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GlobalGetAtomNameW$handle() {
        return GlobalGetAtomNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static MemorySegment GlobalGetAtomNameW$address() {
        return GlobalGetAtomNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static int GlobalGetAtomNameW(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GlobalGetAtomNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalGetAtomNameW", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAtomA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM AddAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor AddAtomA$descriptor() {
        return AddAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM AddAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle AddAtomA$handle() {
        return AddAtomA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM AddAtomA(LPCSTR lpString)
     * }
     */
    public static MemorySegment AddAtomA$address() {
        return AddAtomA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM AddAtomA(LPCSTR lpString)
     * }
     */
    public static short AddAtomA(MemorySegment lpString) {
        var mh$ = AddAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAtomW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM AddAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor AddAtomW$descriptor() {
        return AddAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM AddAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle AddAtomW$handle() {
        return AddAtomW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM AddAtomW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment AddAtomW$address() {
        return AddAtomW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM AddAtomW(LPCWSTR lpString)
     * }
     */
    public static short AddAtomW(MemorySegment lpString) {
        var mh$ = AddAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindAtomA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM FindAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor FindAtomA$descriptor() {
        return FindAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM FindAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle FindAtomA$handle() {
        return FindAtomA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM FindAtomA(LPCSTR lpString)
     * }
     */
    public static MemorySegment FindAtomA$address() {
        return FindAtomA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM FindAtomA(LPCSTR lpString)
     * }
     */
    public static short FindAtomA(MemorySegment lpString) {
        var mh$ = FindAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindAtomW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM FindAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor FindAtomW$descriptor() {
        return FindAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM FindAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle FindAtomW$handle() {
        return FindAtomW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM FindAtomW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment FindAtomW$address() {
        return FindAtomW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM FindAtomW(LPCWSTR lpString)
     * }
     */
    public static short FindAtomW(MemorySegment lpString) {
        var mh$ = FindAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAtomNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetAtomNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GetAtomNameA$descriptor() {
        return GetAtomNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GetAtomNameA$handle() {
        return GetAtomNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static MemorySegment GetAtomNameA$address() {
        return GetAtomNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static int GetAtomNameA(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetAtomNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAtomNameA", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAtomNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetAtomNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GetAtomNameW$descriptor() {
        return GetAtomNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GetAtomNameW$handle() {
        return GetAtomNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static MemorySegment GetAtomNameW$address() {
        return GetAtomNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static int GetAtomNameW(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetAtomNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAtomNameW", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileIntA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProfileIntA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
     * }
     */
    public static FunctionDescriptor GetProfileIntA$descriptor() {
        return GetProfileIntA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
     * }
     */
    public static MethodHandle GetProfileIntA$handle() {
        return GetProfileIntA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
     * }
     */
    public static MemorySegment GetProfileIntA$address() {
        return GetProfileIntA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
     * }
     */
    public static int GetProfileIntA(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault) {
        var mh$ = GetProfileIntA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileIntA", lpAppName, lpKeyName, nDefault);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileIntW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProfileIntW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
     * }
     */
    public static FunctionDescriptor GetProfileIntW$descriptor() {
        return GetProfileIntW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
     * }
     */
    public static MethodHandle GetProfileIntW$handle() {
        return GetProfileIntW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
     * }
     */
    public static MemorySegment GetProfileIntW$address() {
        return GetProfileIntW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
     * }
     */
    public static int GetProfileIntW(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault) {
        var mh$ = GetProfileIntW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileIntW", lpAppName, lpKeyName, nDefault);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProfileStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileStringA$descriptor() {
        return GetProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileStringA$handle() {
        return GetProfileStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MemorySegment GetProfileStringA$address() {
        return GetProfileStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileStringA", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProfileStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileStringW$descriptor() {
        return GetProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileStringW$handle() {
        return GetProfileStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MemorySegment GetProfileStringW$address() {
        return GetProfileStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileStringW", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WriteProfileStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileStringA$descriptor() {
        return WriteProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileStringA$handle() {
        return WriteProfileStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
     * }
     */
    public static MemorySegment WriteProfileStringA$address() {
        return WriteProfileStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
     * }
     */
    public static int WriteProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString) {
        var mh$ = WriteProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileStringA", lpAppName, lpKeyName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WriteProfileStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileStringW$descriptor() {
        return WriteProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileStringW$handle() {
        return WriteProfileStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
     * }
     */
    public static MemorySegment WriteProfileStringW$address() {
        return WriteProfileStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
     * }
     */
    public static int WriteProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString) {
        var mh$ = WriteProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileStringW", lpAppName, lpKeyName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProfileSectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileSectionA$descriptor() {
        return GetProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileSectionA$handle() {
        return GetProfileSectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MemorySegment GetProfileSectionA$address() {
        return GetProfileSectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileSectionA(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileSectionA", lpAppName, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProfileSectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileSectionW$descriptor() {
        return GetProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileSectionW$handle() {
        return GetProfileSectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MemorySegment GetProfileSectionW$address() {
        return GetProfileSectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileSectionW(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileSectionW", lpAppName, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WriteProfileSectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileSectionA$descriptor() {
        return WriteProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileSectionA$handle() {
        return WriteProfileSectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
     * }
     */
    public static MemorySegment WriteProfileSectionA$address() {
        return WriteProfileSectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
     * }
     */
    public static int WriteProfileSectionA(MemorySegment lpAppName, MemorySegment lpString) {
        var mh$ = WriteProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileSectionA", lpAppName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WriteProfileSectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileSectionW$descriptor() {
        return WriteProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileSectionW$handle() {
        return WriteProfileSectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
     * }
     */
    public static MemorySegment WriteProfileSectionW$address() {
        return WriteProfileSectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
     * }
     */
    public static int WriteProfileSectionW(MemorySegment lpAppName, MemorySegment lpString) {
        var mh$ = WriteProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileSectionW", lpAppName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileIntA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPrivateProfileIntA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileIntA$descriptor() {
        return GetPrivateProfileIntA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileIntA$handle() {
        return GetPrivateProfileIntA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileIntA$address() {
        return GetPrivateProfileIntA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileIntA(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileIntA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileIntA", lpAppName, lpKeyName, nDefault, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileIntW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPrivateProfileIntW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileIntW$descriptor() {
        return GetPrivateProfileIntW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileIntW$handle() {
        return GetPrivateProfileIntW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileIntW$address() {
        return GetPrivateProfileIntW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileIntW(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileIntW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileIntW", lpAppName, lpKeyName, nDefault, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPrivateProfileStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStringA$descriptor() {
        return GetPrivateProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileStringA$handle() {
        return GetPrivateProfileStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileStringA$address() {
        return GetPrivateProfileStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStringA", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPrivateProfileStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStringW$descriptor() {
        return GetPrivateProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileStringW$handle() {
        return GetPrivateProfileStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileStringW$address() {
        return GetPrivateProfileStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStringW", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WritePrivateProfileStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStringA$descriptor() {
        return WritePrivateProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileStringA$handle() {
        return WritePrivateProfileStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment WritePrivateProfileStringA$address() {
        return WritePrivateProfileStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStringA", lpAppName, lpKeyName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WritePrivateProfileStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStringW$descriptor() {
        return WritePrivateProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileStringW$handle() {
        return WritePrivateProfileStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment WritePrivateProfileStringW$address() {
        return WritePrivateProfileStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStringW", lpAppName, lpKeyName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPrivateProfileSectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionA$descriptor() {
        return GetPrivateProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionA$handle() {
        return GetPrivateProfileSectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileSectionA$address() {
        return GetPrivateProfileSectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionA(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionA", lpAppName, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPrivateProfileSectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionW$descriptor() {
        return GetPrivateProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionW$handle() {
        return GetPrivateProfileSectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileSectionW$address() {
        return GetPrivateProfileSectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionW(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionW", lpAppName, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WritePrivateProfileSectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileSectionA$descriptor() {
        return WritePrivateProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileSectionA$handle() {
        return WritePrivateProfileSectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment WritePrivateProfileSectionA$address() {
        return WritePrivateProfileSectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileSectionA(MemorySegment lpAppName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileSectionA", lpAppName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WritePrivateProfileSectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileSectionW$descriptor() {
        return WritePrivateProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileSectionW$handle() {
        return WritePrivateProfileSectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment WritePrivateProfileSectionW$address() {
        return WritePrivateProfileSectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileSectionW(MemorySegment lpAppName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileSectionW", lpAppName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionNamesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPrivateProfileSectionNamesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionNamesA$descriptor() {
        return GetPrivateProfileSectionNamesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionNamesA$handle() {
        return GetPrivateProfileSectionNamesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileSectionNamesA$address() {
        return GetPrivateProfileSectionNamesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionNamesA(MemorySegment lpszReturnBuffer, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionNamesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionNamesA", lpszReturnBuffer, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpszReturnBuffer, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionNamesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPrivateProfileSectionNamesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionNamesW$descriptor() {
        return GetPrivateProfileSectionNamesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionNamesW$handle() {
        return GetPrivateProfileSectionNamesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileSectionNamesW$address() {
        return GetPrivateProfileSectionNamesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionNamesW(MemorySegment lpszReturnBuffer, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionNamesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionNamesW", lpszReturnBuffer, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpszReturnBuffer, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileStructA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPrivateProfileStructA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStructA$descriptor() {
        return GetPrivateProfileStructA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static MethodHandle GetPrivateProfileStructA$handle() {
        return GetPrivateProfileStructA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static MemorySegment GetPrivateProfileStructA$address() {
        return GetPrivateProfileStructA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static int GetPrivateProfileStructA(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = GetPrivateProfileStructA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStructA", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileStructW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPrivateProfileStructW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStructW$descriptor() {
        return GetPrivateProfileStructW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static MethodHandle GetPrivateProfileStructW$handle() {
        return GetPrivateProfileStructW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static MemorySegment GetPrivateProfileStructW$address() {
        return GetPrivateProfileStructW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static int GetPrivateProfileStructW(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = GetPrivateProfileStructW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStructW", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStructA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WritePrivateProfileStructA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStructA$descriptor() {
        return WritePrivateProfileStructA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static MethodHandle WritePrivateProfileStructA$handle() {
        return WritePrivateProfileStructA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static MemorySegment WritePrivateProfileStructA$address() {
        return WritePrivateProfileStructA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static int WritePrivateProfileStructA(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = WritePrivateProfileStructA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStructA", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStructW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WritePrivateProfileStructW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStructW$descriptor() {
        return WritePrivateProfileStructW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static MethodHandle WritePrivateProfileStructW$handle() {
        return WritePrivateProfileStructW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static MemorySegment WritePrivateProfileStructW$address() {
        return WritePrivateProfileStructW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static int WritePrivateProfileStructW(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = WritePrivateProfileStructW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStructW", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64EnableWow64FsRedirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Wow64EnableWow64FsRedirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
     * }
     */
    public static FunctionDescriptor Wow64EnableWow64FsRedirection$descriptor() {
        return Wow64EnableWow64FsRedirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
     * }
     */
    public static MethodHandle Wow64EnableWow64FsRedirection$handle() {
        return Wow64EnableWow64FsRedirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
     * }
     */
    public static MemorySegment Wow64EnableWow64FsRedirection$address() {
        return Wow64EnableWow64FsRedirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
     * }
     */
    public static byte Wow64EnableWow64FsRedirection(byte Wow64FsEnableRedirection) {
        var mh$ = Wow64EnableWow64FsRedirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64EnableWow64FsRedirection", Wow64FsEnableRedirection);
            }
            return (byte)mh$.invokeExact(Wow64FsEnableRedirection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDllDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDllDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetDllDirectoryA$descriptor() {
        return SetDllDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MethodHandle SetDllDirectoryA$handle() {
        return SetDllDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MemorySegment SetDllDirectoryA$address() {
        return SetDllDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDllDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static int SetDllDirectoryA(MemorySegment lpPathName) {
        var mh$ = SetDllDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDllDirectoryA", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDllDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDllDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetDllDirectoryW$descriptor() {
        return SetDllDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle SetDllDirectoryW$handle() {
        return SetDllDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MemorySegment SetDllDirectoryW$address() {
        return SetDllDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDllDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static int SetDllDirectoryW(MemorySegment lpPathName) {
        var mh$ = SetDllDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDllDirectoryW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDllDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDllDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetDllDirectoryA$descriptor() {
        return GetDllDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetDllDirectoryA$handle() {
        return GetDllDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MemorySegment GetDllDirectoryA$address() {
        return GetDllDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetDllDirectoryA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetDllDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDllDirectoryA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDllDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDllDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetDllDirectoryW$descriptor() {
        return GetDllDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetDllDirectoryW$handle() {
        return GetDllDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MemorySegment GetDllDirectoryW$address() {
        return GetDllDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetDllDirectoryW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetDllDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDllDirectoryW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSearchPathMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSearchPathMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSearchPathMode(DWORD Flags)
     * }
     */
    public static FunctionDescriptor SetSearchPathMode$descriptor() {
        return SetSearchPathMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSearchPathMode(DWORD Flags)
     * }
     */
    public static MethodHandle SetSearchPathMode$handle() {
        return SetSearchPathMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSearchPathMode(DWORD Flags)
     * }
     */
    public static MemorySegment SetSearchPathMode$address() {
        return SetSearchPathMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSearchPathMode(DWORD Flags)
     * }
     */
    public static int SetSearchPathMode(int Flags) {
        var mh$ = SetSearchPathMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSearchPathMode", Flags);
            }
            return (int)mh$.invokeExact(Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDirectoryExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryExA$descriptor() {
        return CreateDirectoryExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryExA$handle() {
        return CreateDirectoryExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectoryExA$address() {
        return CreateDirectoryExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryExA(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryExA", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDirectoryExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryExW$descriptor() {
        return CreateDirectoryExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryExW$handle() {
        return CreateDirectoryExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectoryExW$address() {
        return CreateDirectoryExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryExW(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryExW", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDirectoryTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateDirectoryTransactedA$descriptor() {
        return CreateDirectoryTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateDirectoryTransactedA$handle() {
        return CreateDirectoryTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateDirectoryTransactedA$address() {
        return CreateDirectoryTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateDirectoryTransactedA(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateDirectoryTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryTransactedA", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDirectoryTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateDirectoryTransactedW$descriptor() {
        return CreateDirectoryTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateDirectoryTransactedW$handle() {
        return CreateDirectoryTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateDirectoryTransactedW$address() {
        return CreateDirectoryTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateDirectoryTransactedW(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateDirectoryTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryTransactedW", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveDirectoryTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryTransactedA$descriptor() {
        return RemoveDirectoryTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle RemoveDirectoryTransactedA$handle() {
        return RemoveDirectoryTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment RemoveDirectoryTransactedA$address() {
        return RemoveDirectoryTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static int RemoveDirectoryTransactedA(MemorySegment lpPathName, MemorySegment hTransaction) {
        var mh$ = RemoveDirectoryTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryTransactedA", lpPathName, hTransaction);
            }
            return (int)mh$.invokeExact(lpPathName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveDirectoryTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryTransactedW$descriptor() {
        return RemoveDirectoryTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle RemoveDirectoryTransactedW$handle() {
        return RemoveDirectoryTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment RemoveDirectoryTransactedW$address() {
        return RemoveDirectoryTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static int RemoveDirectoryTransactedW(MemorySegment lpPathName, MemorySegment hTransaction) {
        var mh$ = RemoveDirectoryTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryTransactedW", lpPathName, hTransaction);
            }
            return (int)mh$.invokeExact(lpPathName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFullPathNameTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFullPathNameTransactedA$descriptor() {
        return GetFullPathNameTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFullPathNameTransactedA$handle() {
        return GetFullPathNameTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetFullPathNameTransactedA$address() {
        return GetFullPathNameTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static int GetFullPathNameTransactedA(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart, MemorySegment hTransaction) {
        var mh$ = GetFullPathNameTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameTransactedA", lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFullPathNameTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFullPathNameTransactedW$descriptor() {
        return GetFullPathNameTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFullPathNameTransactedW$handle() {
        return GetFullPathNameTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetFullPathNameTransactedW$address() {
        return GetFullPathNameTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static int GetFullPathNameTransactedW(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart, MemorySegment hTransaction) {
        var mh$ = GetFullPathNameTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameTransactedW", lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefineDosDeviceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DefineDosDeviceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
     * }
     */
    public static FunctionDescriptor DefineDosDeviceA$descriptor() {
        return DefineDosDeviceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
     * }
     */
    public static MethodHandle DefineDosDeviceA$handle() {
        return DefineDosDeviceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
     * }
     */
    public static MemorySegment DefineDosDeviceA$address() {
        return DefineDosDeviceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
     * }
     */
    public static int DefineDosDeviceA(int dwFlags, MemorySegment lpDeviceName, MemorySegment lpTargetPath) {
        var mh$ = DefineDosDeviceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefineDosDeviceA", dwFlags, lpDeviceName, lpTargetPath);
            }
            return (int)mh$.invokeExact(dwFlags, lpDeviceName, lpTargetPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDosDeviceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryDosDeviceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static FunctionDescriptor QueryDosDeviceA$descriptor() {
        return QueryDosDeviceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MethodHandle QueryDosDeviceA$handle() {
        return QueryDosDeviceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MemorySegment QueryDosDeviceA$address() {
        return QueryDosDeviceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static int QueryDosDeviceA(MemorySegment lpDeviceName, MemorySegment lpTargetPath, int ucchMax) {
        var mh$ = QueryDosDeviceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDosDeviceA", lpDeviceName, lpTargetPath, ucchMax);
            }
            return (int)mh$.invokeExact(lpDeviceName, lpTargetPath, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFileTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static FunctionDescriptor CreateFileTransactedA$descriptor() {
        return CreateFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MethodHandle CreateFileTransactedA$handle() {
        return CreateFileTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MemorySegment CreateFileTransactedA$address() {
        return CreateFileTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MemorySegment CreateFileTransactedA(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile, MemorySegment hTransaction, MemorySegment pusMiniVersion, MemorySegment lpExtendedParameter) {
        var mh$ = CreateFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileTransactedA", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFileTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static FunctionDescriptor CreateFileTransactedW$descriptor() {
        return CreateFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MethodHandle CreateFileTransactedW$handle() {
        return CreateFileTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MemorySegment CreateFileTransactedW$address() {
        return CreateFileTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MemorySegment CreateFileTransactedW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile, MemorySegment hTransaction, MemorySegment pusMiniVersion, MemorySegment lpExtendedParameter) {
        var mh$ = CreateFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileTransactedW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReOpenFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReOpenFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes)
     * }
     */
    public static FunctionDescriptor ReOpenFile$descriptor() {
        return ReOpenFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MethodHandle ReOpenFile$handle() {
        return ReOpenFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment ReOpenFile$address() {
        return ReOpenFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment ReOpenFile(MemorySegment hOriginalFile, int dwDesiredAccess, int dwShareMode, int dwFlagsAndAttributes) {
        var mh$ = ReOpenFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReOpenFile", hOriginalFile, dwDesiredAccess, dwShareMode, dwFlagsAndAttributes);
            }
            return (MemorySegment)mh$.invokeExact(hOriginalFile, dwDesiredAccess, dwShareMode, dwFlagsAndAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileAttributesTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor SetFileAttributesTransactedA$descriptor() {
        return SetFileAttributesTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle SetFileAttributesTransactedA$handle() {
        return SetFileAttributesTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment SetFileAttributesTransactedA$address() {
        return SetFileAttributesTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static int SetFileAttributesTransactedA(MemorySegment lpFileName, int dwFileAttributes, MemorySegment hTransaction) {
        var mh$ = SetFileAttributesTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesTransactedA", lpFileName, dwFileAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileAttributesTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor SetFileAttributesTransactedW$descriptor() {
        return SetFileAttributesTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle SetFileAttributesTransactedW$handle() {
        return SetFileAttributesTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment SetFileAttributesTransactedW$address() {
        return SetFileAttributesTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static int SetFileAttributesTransactedW(MemorySegment lpFileName, int dwFileAttributes, MemorySegment hTransaction) {
        var mh$ = SetFileAttributesTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesTransactedW", lpFileName, dwFileAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileAttributesTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFileAttributesTransactedA$descriptor() {
        return GetFileAttributesTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFileAttributesTransactedA$handle() {
        return GetFileAttributesTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetFileAttributesTransactedA$address() {
        return GetFileAttributesTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static int GetFileAttributesTransactedA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation, MemorySegment hTransaction) {
        var mh$ = GetFileAttributesTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesTransactedA", lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileAttributesTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFileAttributesTransactedW$descriptor() {
        return GetFileAttributesTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFileAttributesTransactedW$handle() {
        return GetFileAttributesTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetFileAttributesTransactedW$address() {
        return GetFileAttributesTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static int GetFileAttributesTransactedW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation, MemorySegment hTransaction) {
        var mh$ = GetFileAttributesTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesTransactedW", lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCompressedFileSizeTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeTransactedA$descriptor() {
        return GetCompressedFileSizeTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetCompressedFileSizeTransactedA$handle() {
        return GetCompressedFileSizeTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetCompressedFileSizeTransactedA$address() {
        return GetCompressedFileSizeTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static int GetCompressedFileSizeTransactedA(MemorySegment lpFileName, MemorySegment lpFileSizeHigh, MemorySegment hTransaction) {
        var mh$ = GetCompressedFileSizeTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeTransactedA", lpFileName, lpFileSizeHigh, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCompressedFileSizeTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeTransactedW$descriptor() {
        return GetCompressedFileSizeTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetCompressedFileSizeTransactedW$handle() {
        return GetCompressedFileSizeTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetCompressedFileSizeTransactedW$address() {
        return GetCompressedFileSizeTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static int GetCompressedFileSizeTransactedW(MemorySegment lpFileName, MemorySegment lpFileSizeHigh, MemorySegment hTransaction) {
        var mh$ = GetCompressedFileSizeTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeTransactedW", lpFileName, lpFileSizeHigh, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteFileTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor DeleteFileTransactedA$descriptor() {
        return DeleteFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle DeleteFileTransactedA$handle() {
        return DeleteFileTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment DeleteFileTransactedA$address() {
        return DeleteFileTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static int DeleteFileTransactedA(MemorySegment lpFileName, MemorySegment hTransaction) {
        var mh$ = DeleteFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileTransactedA", lpFileName, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteFileTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor DeleteFileTransactedW$descriptor() {
        return DeleteFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle DeleteFileTransactedW$handle() {
        return DeleteFileTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment DeleteFileTransactedW$address() {
        return DeleteFileTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static int DeleteFileTransactedW(MemorySegment lpFileName, MemorySegment hTransaction) {
        var mh$ = DeleteFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileTransactedW", lpFileName, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckNameLegalDOS8Dot3A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CheckNameLegalDOS8Dot3A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static FunctionDescriptor CheckNameLegalDOS8Dot3A$descriptor() {
        return CheckNameLegalDOS8Dot3A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static MethodHandle CheckNameLegalDOS8Dot3A$handle() {
        return CheckNameLegalDOS8Dot3A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static MemorySegment CheckNameLegalDOS8Dot3A$address() {
        return CheckNameLegalDOS8Dot3A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static int CheckNameLegalDOS8Dot3A(MemorySegment lpName, MemorySegment lpOemName, int OemNameSize, MemorySegment pbNameContainsSpaces, MemorySegment pbNameLegal) {
        var mh$ = CheckNameLegalDOS8Dot3A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckNameLegalDOS8Dot3A", lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
            }
            return (int)mh$.invokeExact(lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckNameLegalDOS8Dot3W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CheckNameLegalDOS8Dot3W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static FunctionDescriptor CheckNameLegalDOS8Dot3W$descriptor() {
        return CheckNameLegalDOS8Dot3W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static MethodHandle CheckNameLegalDOS8Dot3W$handle() {
        return CheckNameLegalDOS8Dot3W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static MemorySegment CheckNameLegalDOS8Dot3W$address() {
        return CheckNameLegalDOS8Dot3W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static int CheckNameLegalDOS8Dot3W(MemorySegment lpName, MemorySegment lpOemName, int OemNameSize, MemorySegment pbNameContainsSpaces, MemorySegment pbNameLegal) {
        var mh$ = CheckNameLegalDOS8Dot3W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckNameLegalDOS8Dot3W", lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
            }
            return (int)mh$.invokeExact(lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstFileTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstFileTransactedA$descriptor() {
        return FindFirstFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstFileTransactedA$handle() {
        return FindFirstFileTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileTransactedA$address() {
        return FindFirstFileTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileTransactedA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags, MemorySegment hTransaction) {
        var mh$ = FindFirstFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileTransactedA", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstFileTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstFileTransactedW$descriptor() {
        return FindFirstFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstFileTransactedW$handle() {
        return FindFirstFileTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileTransactedW$address() {
        return FindFirstFileTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileTransactedW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags, MemorySegment hTransaction) {
        var mh$ = FindFirstFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileTransactedW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static FunctionDescriptor CopyFileA$descriptor() {
        return CopyFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MethodHandle CopyFileA$handle() {
        return CopyFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MemorySegment CopyFileA$address() {
        return CopyFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static int CopyFileA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int bFailIfExists) {
        var mh$ = CopyFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileA", lpExistingFileName, lpNewFileName, bFailIfExists);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, bFailIfExists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static FunctionDescriptor CopyFileW$descriptor() {
        return CopyFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MethodHandle CopyFileW$handle() {
        return CopyFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MemorySegment CopyFileW$address() {
        return CopyFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static int CopyFileW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int bFailIfExists) {
        var mh$ = CopyFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileW", lpExistingFileName, lpNewFileName, bFailIfExists);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, bFailIfExists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyFileExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static FunctionDescriptor CopyFileExA$descriptor() {
        return CopyFileExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static MethodHandle CopyFileExA$handle() {
        return CopyFileExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static MemorySegment CopyFileExA$address() {
        return CopyFileExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static int CopyFileExA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags) {
        var mh$ = CopyFileExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileExA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyFileExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static FunctionDescriptor CopyFileExW$descriptor() {
        return CopyFileExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static MethodHandle CopyFileExW$handle() {
        return CopyFileExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static MemorySegment CopyFileExW$address() {
        return CopyFileExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static int CopyFileExW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags) {
        var mh$ = CopyFileExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileExW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyFileTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CopyFileTransactedA$descriptor() {
        return CopyFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CopyFileTransactedA$handle() {
        return CopyFileTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CopyFileTransactedA$address() {
        return CopyFileTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static int CopyFileTransactedA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags, MemorySegment hTransaction) {
        var mh$ = CopyFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileTransactedA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyFileTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CopyFileTransactedW$descriptor() {
        return CopyFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CopyFileTransactedW$handle() {
        return CopyFileTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CopyFileTransactedW$address() {
        return CopyFileTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static int CopyFileTransactedW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags, MemorySegment hTransaction) {
        var mh$ = CopyFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileTransactedW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int COPYFILE2_CALLBACK_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_NONE = 0
     * }
     */
    public static int COPYFILE2_CALLBACK_NONE() {
        return COPYFILE2_CALLBACK_NONE;
    }
    private static final int COPYFILE2_CALLBACK_CHUNK_STARTED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_CHUNK_STARTED = 1
     * }
     */
    public static int COPYFILE2_CALLBACK_CHUNK_STARTED() {
        return COPYFILE2_CALLBACK_CHUNK_STARTED;
    }
    private static final int COPYFILE2_CALLBACK_CHUNK_FINISHED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_CHUNK_FINISHED = 2
     * }
     */
    public static int COPYFILE2_CALLBACK_CHUNK_FINISHED() {
        return COPYFILE2_CALLBACK_CHUNK_FINISHED;
    }
    private static final int COPYFILE2_CALLBACK_STREAM_STARTED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_STREAM_STARTED = 3
     * }
     */
    public static int COPYFILE2_CALLBACK_STREAM_STARTED() {
        return COPYFILE2_CALLBACK_STREAM_STARTED;
    }
    private static final int COPYFILE2_CALLBACK_STREAM_FINISHED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_STREAM_FINISHED = 4
     * }
     */
    public static int COPYFILE2_CALLBACK_STREAM_FINISHED() {
        return COPYFILE2_CALLBACK_STREAM_FINISHED;
    }
    private static final int COPYFILE2_CALLBACK_POLL_CONTINUE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_POLL_CONTINUE = 5
     * }
     */
    public static int COPYFILE2_CALLBACK_POLL_CONTINUE() {
        return COPYFILE2_CALLBACK_POLL_CONTINUE;
    }
    private static final int COPYFILE2_CALLBACK_ERROR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_ERROR = 6
     * }
     */
    public static int COPYFILE2_CALLBACK_ERROR() {
        return COPYFILE2_CALLBACK_ERROR;
    }
    private static final int COPYFILE2_CALLBACK_MAX = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_MAX = 7
     * }
     */
    public static int COPYFILE2_CALLBACK_MAX() {
        return COPYFILE2_CALLBACK_MAX;
    }
    private static final int COPYFILE2_PROGRESS_CONTINUE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_CONTINUE = 0
     * }
     */
    public static int COPYFILE2_PROGRESS_CONTINUE() {
        return COPYFILE2_PROGRESS_CONTINUE;
    }
    private static final int COPYFILE2_PROGRESS_CANCEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_CANCEL = 1
     * }
     */
    public static int COPYFILE2_PROGRESS_CANCEL() {
        return COPYFILE2_PROGRESS_CANCEL;
    }
    private static final int COPYFILE2_PROGRESS_STOP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_STOP = 2
     * }
     */
    public static int COPYFILE2_PROGRESS_STOP() {
        return COPYFILE2_PROGRESS_STOP;
    }
    private static final int COPYFILE2_PROGRESS_QUIET = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_QUIET = 3
     * }
     */
    public static int COPYFILE2_PROGRESS_QUIET() {
        return COPYFILE2_PROGRESS_QUIET;
    }
    private static final int COPYFILE2_PROGRESS_PAUSE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_PAUSE = 4
     * }
     */
    public static int COPYFILE2_PROGRESS_PAUSE() {
        return COPYFILE2_PROGRESS_PAUSE;
    }
    private static final int COPYFILE2_PHASE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_NONE = 0
     * }
     */
    public static int COPYFILE2_PHASE_NONE() {
        return COPYFILE2_PHASE_NONE;
    }
    private static final int COPYFILE2_PHASE_PREPARE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_PREPARE_SOURCE = 1
     * }
     */
    public static int COPYFILE2_PHASE_PREPARE_SOURCE() {
        return COPYFILE2_PHASE_PREPARE_SOURCE;
    }
    private static final int COPYFILE2_PHASE_PREPARE_DEST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_PREPARE_DEST = 2
     * }
     */
    public static int COPYFILE2_PHASE_PREPARE_DEST() {
        return COPYFILE2_PHASE_PREPARE_DEST;
    }
    private static final int COPYFILE2_PHASE_READ_SOURCE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_READ_SOURCE = 3
     * }
     */
    public static int COPYFILE2_PHASE_READ_SOURCE() {
        return COPYFILE2_PHASE_READ_SOURCE;
    }
    private static final int COPYFILE2_PHASE_WRITE_DESTINATION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_WRITE_DESTINATION = 4
     * }
     */
    public static int COPYFILE2_PHASE_WRITE_DESTINATION() {
        return COPYFILE2_PHASE_WRITE_DESTINATION;
    }
    private static final int COPYFILE2_PHASE_SERVER_COPY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_SERVER_COPY = 5
     * }
     */
    public static int COPYFILE2_PHASE_SERVER_COPY() {
        return COPYFILE2_PHASE_SERVER_COPY;
    }
    private static final int COPYFILE2_PHASE_NAMEGRAFT_COPY = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_NAMEGRAFT_COPY = 6
     * }
     */
    public static int COPYFILE2_PHASE_NAMEGRAFT_COPY() {
        return COPYFILE2_PHASE_NAMEGRAFT_COPY;
    }
    private static final int COPYFILE2_PHASE_MAX = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_MAX = 7
     * }
     */
    public static int COPYFILE2_PHASE_MAX() {
        return COPYFILE2_PHASE_MAX;
    }

    private static class CopyFile2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyFile2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters)
     * }
     */
    public static FunctionDescriptor CopyFile2$descriptor() {
        return CopyFile2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters)
     * }
     */
    public static MethodHandle CopyFile2$handle() {
        return CopyFile2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters)
     * }
     */
    public static MemorySegment CopyFile2$address() {
        return CopyFile2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters)
     * }
     */
    public static int CopyFile2(MemorySegment pwszExistingFileName, MemorySegment pwszNewFileName, MemorySegment pExtendedParameters) {
        var mh$ = CopyFile2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFile2", pwszExistingFileName, pwszNewFileName, pExtendedParameters);
            }
            return (int)mh$.invokeExact(pwszExistingFileName, pwszNewFileName, pExtendedParameters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MoveFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
     * }
     */
    public static FunctionDescriptor MoveFileA$descriptor() {
        return MoveFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
     * }
     */
    public static MethodHandle MoveFileA$handle() {
        return MoveFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
     * }
     */
    public static MemorySegment MoveFileA$address() {
        return MoveFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
     * }
     */
    public static int MoveFileA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName) {
        var mh$ = MoveFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileA", lpExistingFileName, lpNewFileName);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MoveFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static FunctionDescriptor MoveFileW$descriptor() {
        return MoveFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MethodHandle MoveFileW$handle() {
        return MoveFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MemorySegment MoveFileW$address() {
        return MoveFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static int MoveFileW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName) {
        var mh$ = MoveFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileW", lpExistingFileName, lpNewFileName);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MoveFileExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileExA$descriptor() {
        return MoveFileExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileExA$handle() {
        return MoveFileExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static MemorySegment MoveFileExA$address() {
        return MoveFileExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static int MoveFileExA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int dwFlags) {
        var mh$ = MoveFileExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileExA", lpExistingFileName, lpNewFileName, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MoveFileExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileExW$descriptor() {
        return MoveFileExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileExW$handle() {
        return MoveFileExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static MemorySegment MoveFileExW$address() {
        return MoveFileExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static int MoveFileExW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int dwFlags) {
        var mh$ = MoveFileExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileExW", lpExistingFileName, lpNewFileName, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileWithProgressA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MoveFileWithProgressA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileWithProgressA$descriptor() {
        return MoveFileWithProgressA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileWithProgressA$handle() {
        return MoveFileWithProgressA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static MemorySegment MoveFileWithProgressA$address() {
        return MoveFileWithProgressA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static int MoveFileWithProgressA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags) {
        var mh$ = MoveFileWithProgressA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileWithProgressA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileWithProgressW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MoveFileWithProgressW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileWithProgressW$descriptor() {
        return MoveFileWithProgressW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileWithProgressW$handle() {
        return MoveFileWithProgressW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static MemorySegment MoveFileWithProgressW$address() {
        return MoveFileWithProgressW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static int MoveFileWithProgressW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags) {
        var mh$ = MoveFileWithProgressW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileWithProgressW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MoveFileTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor MoveFileTransactedA$descriptor() {
        return MoveFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle MoveFileTransactedA$handle() {
        return MoveFileTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment MoveFileTransactedA$address() {
        return MoveFileTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static int MoveFileTransactedA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags, MemorySegment hTransaction) {
        var mh$ = MoveFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileTransactedA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MoveFileTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor MoveFileTransactedW$descriptor() {
        return MoveFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle MoveFileTransactedW$handle() {
        return MoveFileTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment MoveFileTransactedW$address() {
        return MoveFileTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static int MoveFileTransactedW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags, MemorySegment hTransaction) {
        var mh$ = MoveFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileTransactedW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReplaceFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor ReplaceFileA$descriptor() {
        return ReplaceFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MethodHandle ReplaceFileA$handle() {
        return ReplaceFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MemorySegment ReplaceFileA$address() {
        return ReplaceFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static int ReplaceFileA(MemorySegment lpReplacedFileName, MemorySegment lpReplacementFileName, MemorySegment lpBackupFileName, int dwReplaceFlags, MemorySegment lpExclude, MemorySegment lpReserved) {
        var mh$ = ReplaceFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceFileA", lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
            }
            return (int)mh$.invokeExact(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReplaceFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor ReplaceFileW$descriptor() {
        return ReplaceFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MethodHandle ReplaceFileW$handle() {
        return ReplaceFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MemorySegment ReplaceFileW$address() {
        return ReplaceFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static int ReplaceFileW(MemorySegment lpReplacedFileName, MemorySegment lpReplacementFileName, MemorySegment lpBackupFileName, int dwReplaceFlags, MemorySegment lpExclude, MemorySegment lpReserved) {
        var mh$ = ReplaceFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceFileW", lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
            }
            return (int)mh$.invokeExact(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateHardLinkA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateHardLinkA$descriptor() {
        return CreateHardLinkA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateHardLinkA$handle() {
        return CreateHardLinkA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateHardLinkA$address() {
        return CreateHardLinkA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateHardLinkA(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateHardLinkA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkA", lpFileName, lpExistingFileName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateHardLinkW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateHardLinkW$descriptor() {
        return CreateHardLinkW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateHardLinkW$handle() {
        return CreateHardLinkW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateHardLinkW$address() {
        return CreateHardLinkW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateHardLinkW(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateHardLinkW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkW", lpFileName, lpExistingFileName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateHardLinkTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateHardLinkTransactedA$descriptor() {
        return CreateHardLinkTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateHardLinkTransactedA$handle() {
        return CreateHardLinkTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateHardLinkTransactedA$address() {
        return CreateHardLinkTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateHardLinkTransactedA(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateHardLinkTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkTransactedA", lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateHardLinkTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateHardLinkTransactedW$descriptor() {
        return CreateHardLinkTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateHardLinkTransactedW$handle() {
        return CreateHardLinkTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateHardLinkTransactedW$address() {
        return CreateHardLinkTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateHardLinkTransactedW(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateHardLinkTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkTransactedW", lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstStreamTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstStreamTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstStreamTransactedW$descriptor() {
        return FindFirstStreamTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstStreamTransactedW$handle() {
        return FindFirstStreamTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstStreamTransactedW$address() {
        return FindFirstStreamTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstStreamTransactedW(MemorySegment lpFileName, int InfoLevel, MemorySegment lpFindStreamData, int dwFlags, MemorySegment hTransaction) {
        var mh$ = FindFirstStreamTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstStreamTransactedW", lpFileName, InfoLevel, lpFindStreamData, dwFlags, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, InfoLevel, lpFindStreamData, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileNameTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstFileNameTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstFileNameTransactedW$descriptor() {
        return FindFirstFileNameTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstFileNameTransactedW$handle() {
        return FindFirstFileNameTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileNameTransactedW$address() {
        return FindFirstFileNameTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileNameTransactedW(MemorySegment lpFileName, int dwFlags, MemorySegment StringLength, MemorySegment LinkName, MemorySegment hTransaction) {
        var mh$ = FindFirstFileNameTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileNameTransactedW", lpFileName, dwFlags, StringLength, LinkName, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwFlags, StringLength, LinkName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateNamedPipeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateNamedPipeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateNamedPipeA$descriptor() {
        return CreateNamedPipeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateNamedPipeA$handle() {
        return CreateNamedPipeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeA$address() {
        return CreateNamedPipeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeA(MemorySegment lpName, int dwOpenMode, int dwPipeMode, int nMaxInstances, int nOutBufferSize, int nInBufferSize, int nDefaultTimeOut, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateNamedPipeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateNamedPipeA", lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeHandleStateA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNamedPipeHandleStateA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static FunctionDescriptor GetNamedPipeHandleStateA$descriptor() {
        return GetNamedPipeHandleStateA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MethodHandle GetNamedPipeHandleStateA$handle() {
        return GetNamedPipeHandleStateA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MemorySegment GetNamedPipeHandleStateA$address() {
        return GetNamedPipeHandleStateA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static int GetNamedPipeHandleStateA(MemorySegment hNamedPipe, MemorySegment lpState, MemorySegment lpCurInstances, MemorySegment lpMaxCollectionCount, MemorySegment lpCollectDataTimeout, MemorySegment lpUserName, int nMaxUserNameSize) {
        var mh$ = GetNamedPipeHandleStateA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeHandleStateA", hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallNamedPipeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CallNamedPipeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor CallNamedPipeA$descriptor() {
        return CallNamedPipeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MethodHandle CallNamedPipeA$handle() {
        return CallNamedPipeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MemorySegment CallNamedPipeA$address() {
        return CallNamedPipeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static int CallNamedPipeA(MemorySegment lpNamedPipeName, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesRead, int nTimeOut) {
        var mh$ = CallNamedPipeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallNamedPipeA", lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitNamedPipeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitNamedPipeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor WaitNamedPipeA$descriptor() {
        return WaitNamedPipeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MethodHandle WaitNamedPipeA$handle() {
        return WaitNamedPipeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MemorySegment WaitNamedPipeA$address() {
        return WaitNamedPipeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static int WaitNamedPipeA(MemorySegment lpNamedPipeName, int nTimeOut) {
        var mh$ = WaitNamedPipeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitNamedPipeA", lpNamedPipeName, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNamedPipeClientComputerNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientComputerNameA$descriptor() {
        return GetNamedPipeClientComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MethodHandle GetNamedPipeClientComputerNameA$handle() {
        return GetNamedPipeClientComputerNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MemorySegment GetNamedPipeClientComputerNameA$address() {
        return GetNamedPipeClientComputerNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static int GetNamedPipeClientComputerNameA(MemorySegment Pipe, MemorySegment ClientComputerName, int ClientComputerNameLength) {
        var mh$ = GetNamedPipeClientComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientComputerNameA", Pipe, ClientComputerName, ClientComputerNameLength);
            }
            return (int)mh$.invokeExact(Pipe, ClientComputerName, ClientComputerNameLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNamedPipeClientProcessId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientProcessId$descriptor() {
        return GetNamedPipeClientProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
     * }
     */
    public static MethodHandle GetNamedPipeClientProcessId$handle() {
        return GetNamedPipeClientProcessId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
     * }
     */
    public static MemorySegment GetNamedPipeClientProcessId$address() {
        return GetNamedPipeClientProcessId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
     * }
     */
    public static int GetNamedPipeClientProcessId(MemorySegment Pipe, MemorySegment ClientProcessId) {
        var mh$ = GetNamedPipeClientProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientProcessId", Pipe, ClientProcessId);
            }
            return (int)mh$.invokeExact(Pipe, ClientProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNamedPipeClientSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientSessionId$descriptor() {
        return GetNamedPipeClientSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
     * }
     */
    public static MethodHandle GetNamedPipeClientSessionId$handle() {
        return GetNamedPipeClientSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
     * }
     */
    public static MemorySegment GetNamedPipeClientSessionId$address() {
        return GetNamedPipeClientSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
     * }
     */
    public static int GetNamedPipeClientSessionId(MemorySegment Pipe, MemorySegment ClientSessionId) {
        var mh$ = GetNamedPipeClientSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientSessionId", Pipe, ClientSessionId);
            }
            return (int)mh$.invokeExact(Pipe, ClientSessionId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeServerProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNamedPipeServerProcessId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeServerProcessId$descriptor() {
        return GetNamedPipeServerProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
     * }
     */
    public static MethodHandle GetNamedPipeServerProcessId$handle() {
        return GetNamedPipeServerProcessId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
     * }
     */
    public static MemorySegment GetNamedPipeServerProcessId$address() {
        return GetNamedPipeServerProcessId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
     * }
     */
    public static int GetNamedPipeServerProcessId(MemorySegment Pipe, MemorySegment ServerProcessId) {
        var mh$ = GetNamedPipeServerProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeServerProcessId", Pipe, ServerProcessId);
            }
            return (int)mh$.invokeExact(Pipe, ServerProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeServerSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNamedPipeServerSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeServerSessionId$descriptor() {
        return GetNamedPipeServerSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
     * }
     */
    public static MethodHandle GetNamedPipeServerSessionId$handle() {
        return GetNamedPipeServerSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
     * }
     */
    public static MemorySegment GetNamedPipeServerSessionId$address() {
        return GetNamedPipeServerSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
     * }
     */
    public static int GetNamedPipeServerSessionId(MemorySegment Pipe, MemorySegment ServerSessionId) {
        var mh$ = GetNamedPipeServerSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeServerSessionId", Pipe, ServerSessionId);
            }
            return (int)mh$.invokeExact(Pipe, ServerSessionId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeLabelA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetVolumeLabelA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeLabelA$descriptor() {
        return SetVolumeLabelA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
     * }
     */
    public static MethodHandle SetVolumeLabelA$handle() {
        return SetVolumeLabelA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
     * }
     */
    public static MemorySegment SetVolumeLabelA$address() {
        return SetVolumeLabelA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
     * }
     */
    public static int SetVolumeLabelA(MemorySegment lpRootPathName, MemorySegment lpVolumeName) {
        var mh$ = SetVolumeLabelA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeLabelA", lpRootPathName, lpVolumeName);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeLabelW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetVolumeLabelW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeLabelW$descriptor() {
        return SetVolumeLabelW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
     * }
     */
    public static MethodHandle SetVolumeLabelW$handle() {
        return SetVolumeLabelW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
     * }
     */
    public static MemorySegment SetVolumeLabelW$address() {
        return SetVolumeLabelW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
     * }
     */
    public static int SetVolumeLabelW(MemorySegment lpRootPathName, MemorySegment lpVolumeName) {
        var mh$ = SetVolumeLabelW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeLabelW", lpRootPathName, lpVolumeName);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileBandwidthReservation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileBandwidthReservation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static FunctionDescriptor SetFileBandwidthReservation$descriptor() {
        return SetFileBandwidthReservation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static MethodHandle SetFileBandwidthReservation$handle() {
        return SetFileBandwidthReservation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static MemorySegment SetFileBandwidthReservation$address() {
        return SetFileBandwidthReservation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static int SetFileBandwidthReservation(MemorySegment hFile, int nPeriodMilliseconds, int nBytesPerPeriod, int bDiscardable, MemorySegment lpTransferSize, MemorySegment lpNumOutstandingRequests) {
        var mh$ = SetFileBandwidthReservation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileBandwidthReservation", hFile, nPeriodMilliseconds, nBytesPerPeriod, bDiscardable, lpTransferSize, lpNumOutstandingRequests);
            }
            return (int)mh$.invokeExact(hFile, nPeriodMilliseconds, nBytesPerPeriod, bDiscardable, lpTransferSize, lpNumOutstandingRequests);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileBandwidthReservation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileBandwidthReservation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static FunctionDescriptor GetFileBandwidthReservation$descriptor() {
        return GetFileBandwidthReservation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static MethodHandle GetFileBandwidthReservation$handle() {
        return GetFileBandwidthReservation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static MemorySegment GetFileBandwidthReservation$address() {
        return GetFileBandwidthReservation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static int GetFileBandwidthReservation(MemorySegment hFile, MemorySegment lpPeriodMilliseconds, MemorySegment lpBytesPerPeriod, MemorySegment pDiscardable, MemorySegment lpTransferSize, MemorySegment lpNumOutstandingRequests) {
        var mh$ = GetFileBandwidthReservation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileBandwidthReservation", hFile, lpPeriodMilliseconds, lpBytesPerPeriod, pDiscardable, lpTransferSize, lpNumOutstandingRequests);
            }
            return (int)mh$.invokeExact(hFile, lpPeriodMilliseconds, lpBytesPerPeriod, pDiscardable, lpTransferSize, lpNumOutstandingRequests);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ClearEventLogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor ClearEventLogA$descriptor() {
        return ClearEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static MethodHandle ClearEventLogA$handle() {
        return ClearEventLogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static MemorySegment ClearEventLogA$address() {
        return ClearEventLogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static int ClearEventLogA(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = ClearEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearEventLogA", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ClearEventLogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor ClearEventLogW$descriptor() {
        return ClearEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static MethodHandle ClearEventLogW$handle() {
        return ClearEventLogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static MemorySegment ClearEventLogW$address() {
        return ClearEventLogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static int ClearEventLogW(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = ClearEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearEventLogW", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BackupEventLogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor BackupEventLogA$descriptor() {
        return BackupEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static MethodHandle BackupEventLogA$handle() {
        return BackupEventLogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static MemorySegment BackupEventLogA$address() {
        return BackupEventLogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static int BackupEventLogA(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = BackupEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupEventLogA", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BackupEventLogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor BackupEventLogW$descriptor() {
        return BackupEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static MethodHandle BackupEventLogW$handle() {
        return BackupEventLogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static MemorySegment BackupEventLogW$address() {
        return BackupEventLogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static int BackupEventLogW(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = BackupEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupEventLogW", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseEventLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseEventLog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseEventLog(HANDLE hEventLog)
     * }
     */
    public static FunctionDescriptor CloseEventLog$descriptor() {
        return CloseEventLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseEventLog(HANDLE hEventLog)
     * }
     */
    public static MethodHandle CloseEventLog$handle() {
        return CloseEventLog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseEventLog(HANDLE hEventLog)
     * }
     */
    public static MemorySegment CloseEventLog$address() {
        return CloseEventLog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseEventLog(HANDLE hEventLog)
     * }
     */
    public static int CloseEventLog(MemorySegment hEventLog) {
        var mh$ = CloseEventLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseEventLog", hEventLog);
            }
            return (int)mh$.invokeExact(hEventLog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeregisterEventSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeregisterEventSource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeregisterEventSource(HANDLE hEventLog)
     * }
     */
    public static FunctionDescriptor DeregisterEventSource$descriptor() {
        return DeregisterEventSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeregisterEventSource(HANDLE hEventLog)
     * }
     */
    public static MethodHandle DeregisterEventSource$handle() {
        return DeregisterEventSource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeregisterEventSource(HANDLE hEventLog)
     * }
     */
    public static MemorySegment DeregisterEventSource$address() {
        return DeregisterEventSource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeregisterEventSource(HANDLE hEventLog)
     * }
     */
    public static int DeregisterEventSource(MemorySegment hEventLog) {
        var mh$ = DeregisterEventSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeregisterEventSource", hEventLog);
            }
            return (int)mh$.invokeExact(hEventLog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyChangeEventLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NotifyChangeEventLog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor NotifyChangeEventLog$descriptor() {
        return NotifyChangeEventLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent)
     * }
     */
    public static MethodHandle NotifyChangeEventLog$handle() {
        return NotifyChangeEventLog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent)
     * }
     */
    public static MemorySegment NotifyChangeEventLog$address() {
        return NotifyChangeEventLog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent)
     * }
     */
    public static int NotifyChangeEventLog(MemorySegment hEventLog, MemorySegment hEvent) {
        var mh$ = NotifyChangeEventLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyChangeEventLog", hEventLog, hEvent);
            }
            return (int)mh$.invokeExact(hEventLog, hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberOfEventLogRecords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNumberOfEventLogRecords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords)
     * }
     */
    public static FunctionDescriptor GetNumberOfEventLogRecords$descriptor() {
        return GetNumberOfEventLogRecords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords)
     * }
     */
    public static MethodHandle GetNumberOfEventLogRecords$handle() {
        return GetNumberOfEventLogRecords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords)
     * }
     */
    public static MemorySegment GetNumberOfEventLogRecords$address() {
        return GetNumberOfEventLogRecords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords)
     * }
     */
    public static int GetNumberOfEventLogRecords(MemorySegment hEventLog, MemorySegment NumberOfRecords) {
        var mh$ = GetNumberOfEventLogRecords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberOfEventLogRecords", hEventLog, NumberOfRecords);
            }
            return (int)mh$.invokeExact(hEventLog, NumberOfRecords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOldestEventLogRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetOldestEventLogRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord)
     * }
     */
    public static FunctionDescriptor GetOldestEventLogRecord$descriptor() {
        return GetOldestEventLogRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord)
     * }
     */
    public static MethodHandle GetOldestEventLogRecord$handle() {
        return GetOldestEventLogRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord)
     * }
     */
    public static MemorySegment GetOldestEventLogRecord$address() {
        return GetOldestEventLogRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord)
     * }
     */
    public static int GetOldestEventLogRecord(MemorySegment hEventLog, MemorySegment OldestRecord) {
        var mh$ = GetOldestEventLogRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOldestEventLogRecord", hEventLog, OldestRecord);
            }
            return (int)mh$.invokeExact(hEventLog, OldestRecord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenEventLogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor OpenEventLogA$descriptor() {
        return OpenEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MethodHandle OpenEventLogA$handle() {
        return OpenEventLogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MemorySegment OpenEventLogA$address() {
        return OpenEventLogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MemorySegment OpenEventLogA(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = OpenEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventLogA", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenEventLogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor OpenEventLogW$descriptor() {
        return OpenEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MethodHandle OpenEventLogW$handle() {
        return OpenEventLogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MemorySegment OpenEventLogW$address() {
        return OpenEventLogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MemorySegment OpenEventLogW(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = OpenEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventLogW", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterEventSourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterEventSourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor RegisterEventSourceA$descriptor() {
        return RegisterEventSourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MethodHandle RegisterEventSourceA$handle() {
        return RegisterEventSourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MemorySegment RegisterEventSourceA$address() {
        return RegisterEventSourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MemorySegment RegisterEventSourceA(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = RegisterEventSourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterEventSourceA", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterEventSourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterEventSourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor RegisterEventSourceW$descriptor() {
        return RegisterEventSourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MethodHandle RegisterEventSourceW$handle() {
        return RegisterEventSourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MemorySegment RegisterEventSourceW$address() {
        return RegisterEventSourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MemorySegment RegisterEventSourceW(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = RegisterEventSourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterEventSourceW", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenBackupEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenBackupEventLogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor OpenBackupEventLogA$descriptor() {
        return OpenBackupEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle OpenBackupEventLogA$handle() {
        return OpenBackupEventLogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment OpenBackupEventLogA$address() {
        return OpenBackupEventLogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment OpenBackupEventLogA(MemorySegment lpUNCServerName, MemorySegment lpFileName) {
        var mh$ = OpenBackupEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenBackupEventLogA", lpUNCServerName, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenBackupEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenBackupEventLogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor OpenBackupEventLogW$descriptor() {
        return OpenBackupEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle OpenBackupEventLogW$handle() {
        return OpenBackupEventLogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment OpenBackupEventLogW$address() {
        return OpenBackupEventLogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment OpenBackupEventLogW(MemorySegment lpUNCServerName, MemorySegment lpFileName) {
        var mh$ = OpenBackupEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenBackupEventLogW", lpUNCServerName, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReadEventLogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static FunctionDescriptor ReadEventLogA$descriptor() {
        return ReadEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static MethodHandle ReadEventLogA$handle() {
        return ReadEventLogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static MemorySegment ReadEventLogA$address() {
        return ReadEventLogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static int ReadEventLogA(MemorySegment hEventLog, int dwReadFlags, int dwRecordOffset, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment pnBytesRead, MemorySegment pnMinNumberOfBytesNeeded) {
        var mh$ = ReadEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadEventLogA", hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
            }
            return (int)mh$.invokeExact(hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReadEventLogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static FunctionDescriptor ReadEventLogW$descriptor() {
        return ReadEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static MethodHandle ReadEventLogW$handle() {
        return ReadEventLogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static MemorySegment ReadEventLogW$address() {
        return ReadEventLogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static int ReadEventLogW(MemorySegment hEventLog, int dwReadFlags, int dwRecordOffset, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment pnBytesRead, MemorySegment pnMinNumberOfBytesNeeded) {
        var mh$ = ReadEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadEventLogW", hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
            }
            return (int)mh$.invokeExact(hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReportEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReportEventA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static FunctionDescriptor ReportEventA$descriptor() {
        return ReportEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static MethodHandle ReportEventA$handle() {
        return ReportEventA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static MemorySegment ReportEventA$address() {
        return ReportEventA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static int ReportEventA(MemorySegment hEventLog, short wType, short wCategory, int dwEventID, MemorySegment lpUserSid, short wNumStrings, int dwDataSize, MemorySegment lpStrings, MemorySegment lpRawData) {
        var mh$ = ReportEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReportEventA", hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
            }
            return (int)mh$.invokeExact(hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReportEventW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReportEventW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static FunctionDescriptor ReportEventW$descriptor() {
        return ReportEventW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static MethodHandle ReportEventW$handle() {
        return ReportEventW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static MemorySegment ReportEventW$address() {
        return ReportEventW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static int ReportEventW(MemorySegment hEventLog, short wType, short wCategory, int dwEventID, MemorySegment lpUserSid, short wNumStrings, int dwDataSize, MemorySegment lpStrings, MemorySegment lpRawData) {
        var mh$ = ReportEventW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReportEventW", hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
            }
            return (int)mh$.invokeExact(hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _EVENTLOG_FULL_INFORMATION {
     *     DWORD dwFull;
     * } *LPEVENTLOG_FULL_INFORMATION
     * }
     */
    public static final AddressLayout LPEVENTLOG_FULL_INFORMATION = wgl_h.C_POINTER;

    private static class GetEventLogInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEventLogInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor GetEventLogInformation$descriptor() {
        return GetEventLogInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle GetEventLogInformation$handle() {
        return GetEventLogInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment GetEventLogInformation$address() {
        return GetEventLogInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int GetEventLogInformation(MemorySegment hEventLog, int dwInfoLevel, MemorySegment lpBuffer, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = GetEventLogInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEventLogInformation", hEventLog, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hEventLog, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef ULONG OPERATION_ID
     * }
     */
    public static final OfInt OPERATION_ID = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _OPERATION_START_PARAMETERS {
     *     ULONG Version;
     *     OPERATION_ID OperationId;
     *     ULONG Flags;
     * } *POPERATION_START_PARAMETERS
     * }
     */
    public static final AddressLayout POPERATION_START_PARAMETERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OPERATION_END_PARAMETERS {
     *     ULONG Version;
     *     OPERATION_ID OperationId;
     *     ULONG Flags;
     * } *POPERATION_END_PARAMETERS
     * }
     */
    public static final AddressLayout POPERATION_END_PARAMETERS = wgl_h.C_POINTER;

    private static class OperationStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OperationStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OperationStart(OPERATION_START_PARAMETERS *OperationStartParams)
     * }
     */
    public static FunctionDescriptor OperationStart$descriptor() {
        return OperationStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OperationStart(OPERATION_START_PARAMETERS *OperationStartParams)
     * }
     */
    public static MethodHandle OperationStart$handle() {
        return OperationStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OperationStart(OPERATION_START_PARAMETERS *OperationStartParams)
     * }
     */
    public static MemorySegment OperationStart$address() {
        return OperationStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OperationStart(OPERATION_START_PARAMETERS *OperationStartParams)
     * }
     */
    public static int OperationStart(MemorySegment OperationStartParams) {
        var mh$ = OperationStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OperationStart", OperationStartParams);
            }
            return (int)mh$.invokeExact(OperationStartParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OperationEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OperationEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OperationEnd(OPERATION_END_PARAMETERS *OperationEndParams)
     * }
     */
    public static FunctionDescriptor OperationEnd$descriptor() {
        return OperationEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OperationEnd(OPERATION_END_PARAMETERS *OperationEndParams)
     * }
     */
    public static MethodHandle OperationEnd$handle() {
        return OperationEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OperationEnd(OPERATION_END_PARAMETERS *OperationEndParams)
     * }
     */
    public static MemorySegment OperationEnd$address() {
        return OperationEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OperationEnd(OPERATION_END_PARAMETERS *OperationEndParams)
     * }
     */
    public static int OperationEnd(MemorySegment OperationEndParams) {
        var mh$ = OperationEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OperationEnd", OperationEndParams);
            }
            return (int)mh$.invokeExact(OperationEndParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckAndAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AccessCheckAndAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckAndAuditAlarmA$descriptor() {
        return AccessCheckAndAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckAndAuditAlarmA$handle() {
        return AccessCheckAndAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckAndAuditAlarmA$address() {
        return AccessCheckAndAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckAndAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, int DesiredAccess, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckAndAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckAndAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeAndAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AccessCheckByTypeAndAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeAndAuditAlarmA$descriptor() {
        return AccessCheckByTypeAndAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeAndAuditAlarmA$handle() {
        return AccessCheckByTypeAndAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeAndAuditAlarmA$address() {
        return AccessCheckByTypeAndAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeAndAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeAndAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeAndAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AccessCheckByTypeResultListAndAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmA$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmA$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeResultListAndAuditAlarmA$address() {
        return AccessCheckByTypeResultListAndAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmByHandleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AccessCheckByTypeResultListAndAuditAlarmByHandleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmByHandleA$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmByHandleA$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeResultListAndAuditAlarmByHandleA$address() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmByHandleA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmByHandleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmByHandleA", SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectOpenAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ObjectOpenAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectOpenAuditAlarmA$descriptor() {
        return ObjectOpenAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectOpenAuditAlarmA$handle() {
        return ObjectOpenAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectOpenAuditAlarmA$address() {
        return ObjectOpenAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static int ObjectOpenAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment pSecurityDescriptor, MemorySegment ClientToken, int DesiredAccess, int GrantedAccess, MemorySegment Privileges, int ObjectCreation, int AccessGranted, MemorySegment GenerateOnClose) {
        var mh$ = ObjectOpenAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectOpenAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectPrivilegeAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ObjectPrivilegeAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor ObjectPrivilegeAuditAlarmA$descriptor() {
        return ObjectPrivilegeAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle ObjectPrivilegeAuditAlarmA$handle() {
        return ObjectPrivilegeAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MemorySegment ObjectPrivilegeAuditAlarmA$address() {
        return ObjectPrivilegeAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int ObjectPrivilegeAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, int DesiredAccess, MemorySegment Privileges, int AccessGranted) {
        var mh$ = ObjectPrivilegeAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectPrivilegeAuditAlarmA", SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCloseAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ObjectCloseAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectCloseAuditAlarmA$descriptor() {
        return ObjectCloseAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectCloseAuditAlarmA$handle() {
        return ObjectCloseAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectCloseAuditAlarmA$address() {
        return ObjectCloseAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectCloseAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectCloseAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCloseAuditAlarmA", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectDeleteAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ObjectDeleteAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectDeleteAuditAlarmA$descriptor() {
        return ObjectDeleteAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectDeleteAuditAlarmA$handle() {
        return ObjectDeleteAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectDeleteAuditAlarmA$address() {
        return ObjectDeleteAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectDeleteAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectDeleteAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectDeleteAuditAlarmA", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivilegedServiceAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PrivilegedServiceAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor PrivilegedServiceAuditAlarmA$descriptor() {
        return PrivilegedServiceAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle PrivilegedServiceAuditAlarmA$handle() {
        return PrivilegedServiceAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MemorySegment PrivilegedServiceAuditAlarmA$address() {
        return PrivilegedServiceAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int PrivilegedServiceAuditAlarmA(MemorySegment SubsystemName, MemorySegment ServiceName, MemorySegment ClientToken, MemorySegment Privileges, int AccessGranted) {
        var mh$ = PrivilegedServiceAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivilegedServiceAuditAlarmA", SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddConditionalAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_CHAR,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddConditionalAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength)
     * }
     */
    public static FunctionDescriptor AddConditionalAce$descriptor() {
        return AddConditionalAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength)
     * }
     */
    public static MethodHandle AddConditionalAce$handle() {
        return AddConditionalAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength)
     * }
     */
    public static MemorySegment AddConditionalAce$address() {
        return AddConditionalAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength)
     * }
     */
    public static int AddConditionalAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, byte AceType, int AccessMask, MemorySegment pSid, MemorySegment ConditionStr, MemorySegment ReturnLength) {
        var mh$ = AddConditionalAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddConditionalAce", pAcl, dwAceRevision, AceFlags, AceType, AccessMask, pSid, ConditionStr, ReturnLength);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AceType, AccessMask, pSid, ConditionStr, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileSecurityA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileSecurityA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor SetFileSecurityA$descriptor() {
        return SetFileSecurityA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle SetFileSecurityA$handle() {
        return SetFileSecurityA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MemorySegment SetFileSecurityA$address() {
        return SetFileSecurityA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int SetFileSecurityA(MemorySegment lpFileName, int SecurityInformation, MemorySegment pSecurityDescriptor) {
        var mh$ = SetFileSecurityA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileSecurityA", lpFileName, SecurityInformation, pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(lpFileName, SecurityInformation, pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSecurityA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileSecurityA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetFileSecurityA$descriptor() {
        return GetFileSecurityA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetFileSecurityA$handle() {
        return GetFileSecurityA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetFileSecurityA$address() {
        return GetFileSecurityA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetFileSecurityA(MemorySegment lpFileName, int RequestedInformation, MemorySegment pSecurityDescriptor, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetFileSecurityA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSecurityA", lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadDirectoryChangesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReadDirectoryChangesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor ReadDirectoryChangesW$descriptor() {
        return ReadDirectoryChangesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle ReadDirectoryChangesW$handle() {
        return ReadDirectoryChangesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MemorySegment ReadDirectoryChangesW$address() {
        return ReadDirectoryChangesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int ReadDirectoryChangesW(MemorySegment hDirectory, MemorySegment lpBuffer, int nBufferLength, int bWatchSubtree, int dwNotifyFilter, MemorySegment lpBytesReturned, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = ReadDirectoryChangesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadDirectoryChangesW", hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadDirectoryChangesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReadDirectoryChangesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesExW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
     * }
     */
    public static FunctionDescriptor ReadDirectoryChangesExW$descriptor() {
        return ReadDirectoryChangesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesExW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
     * }
     */
    public static MethodHandle ReadDirectoryChangesExW$handle() {
        return ReadDirectoryChangesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesExW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
     * }
     */
    public static MemorySegment ReadDirectoryChangesExW$address() {
        return ReadDirectoryChangesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesExW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
     * }
     */
    public static int ReadDirectoryChangesExW(MemorySegment hDirectory, MemorySegment lpBuffer, int nBufferLength, int bWatchSubtree, int dwNotifyFilter, MemorySegment lpBytesReturned, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine, int ReadDirectoryNotifyInformationClass) {
        var mh$ = ReadDirectoryChangesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadDirectoryChangesExW", hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine, ReadDirectoryNotifyInformationClass);
            }
            return (int)mh$.invokeExact(hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine, ReadDirectoryNotifyInformationClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileExNuma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapViewOfFileExNuma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor MapViewOfFileExNuma$descriptor() {
        return MapViewOfFileExNuma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
     * }
     */
    public static MethodHandle MapViewOfFileExNuma$handle() {
        return MapViewOfFileExNuma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
     * }
     */
    public static MemorySegment MapViewOfFileExNuma$address() {
        return MapViewOfFileExNuma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
     * }
     */
    public static MemorySegment MapViewOfFileExNuma(MemorySegment hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, long dwNumberOfBytesToMap, MemorySegment lpBaseAddress, int nndPreferred) {
        var mh$ = MapViewOfFileExNuma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileExNuma", hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadReadPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsBadReadPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadReadPtr$descriptor() {
        return IsBadReadPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadReadPtr$handle() {
        return IsBadReadPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static MemorySegment IsBadReadPtr$address() {
        return IsBadReadPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadReadPtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadReadPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadReadPtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadWritePtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsBadWritePtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadWritePtr$descriptor() {
        return IsBadWritePtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadWritePtr$handle() {
        return IsBadWritePtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static MemorySegment IsBadWritePtr$address() {
        return IsBadWritePtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadWritePtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadWritePtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadWritePtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadHugeReadPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsBadHugeReadPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadHugeReadPtr$descriptor() {
        return IsBadHugeReadPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadHugeReadPtr$handle() {
        return IsBadHugeReadPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static MemorySegment IsBadHugeReadPtr$address() {
        return IsBadHugeReadPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadHugeReadPtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadHugeReadPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadHugeReadPtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadHugeWritePtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsBadHugeWritePtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadHugeWritePtr$descriptor() {
        return IsBadHugeWritePtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadHugeWritePtr$handle() {
        return IsBadHugeWritePtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static MemorySegment IsBadHugeWritePtr$address() {
        return IsBadHugeWritePtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadHugeWritePtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadHugeWritePtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadHugeWritePtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadCodePtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsBadCodePtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadCodePtr(FARPROC lpfn)
     * }
     */
    public static FunctionDescriptor IsBadCodePtr$descriptor() {
        return IsBadCodePtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadCodePtr(FARPROC lpfn)
     * }
     */
    public static MethodHandle IsBadCodePtr$handle() {
        return IsBadCodePtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadCodePtr(FARPROC lpfn)
     * }
     */
    public static MemorySegment IsBadCodePtr$address() {
        return IsBadCodePtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadCodePtr(FARPROC lpfn)
     * }
     */
    public static int IsBadCodePtr(MemorySegment lpfn) {
        var mh$ = IsBadCodePtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadCodePtr", lpfn);
            }
            return (int)mh$.invokeExact(lpfn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadStringPtrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsBadStringPtrA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static FunctionDescriptor IsBadStringPtrA$descriptor() {
        return IsBadStringPtrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static MethodHandle IsBadStringPtrA$handle() {
        return IsBadStringPtrA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static MemorySegment IsBadStringPtrA$address() {
        return IsBadStringPtrA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static int IsBadStringPtrA(MemorySegment lpsz, long ucchMax) {
        var mh$ = IsBadStringPtrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadStringPtrA", lpsz, ucchMax);
            }
            return (int)mh$.invokeExact(lpsz, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadStringPtrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsBadStringPtrW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static FunctionDescriptor IsBadStringPtrW$descriptor() {
        return IsBadStringPtrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static MethodHandle IsBadStringPtrW$handle() {
        return IsBadStringPtrW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static MemorySegment IsBadStringPtrW$address() {
        return IsBadStringPtrW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static int IsBadStringPtrW(MemorySegment lpsz, long ucchMax) {
        var mh$ = IsBadStringPtrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadStringPtrW", lpsz, ucchMax);
            }
            return (int)mh$.invokeExact(lpsz, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupAccountSidA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidA$descriptor() {
        return LookupAccountSidA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidA$handle() {
        return LookupAccountSidA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountSidA$address() {
        return LookupAccountSidA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidA(MemorySegment lpSystemName, MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidA", lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupAccountSidW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidW$descriptor() {
        return LookupAccountSidW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidW$handle() {
        return LookupAccountSidW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountSidW$address() {
        return LookupAccountSidW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidW(MemorySegment lpSystemName, MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidW", lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupAccountNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameA$descriptor() {
        return LookupAccountNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameA$handle() {
        return LookupAccountNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountNameA$address() {
        return LookupAccountNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameA(MemorySegment lpSystemName, MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameA", lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupAccountNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameW$descriptor() {
        return LookupAccountNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameW$handle() {
        return LookupAccountNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountNameW$address() {
        return LookupAccountNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameW(MemorySegment lpSystemName, MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameW", lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameLocalA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupAccountNameLocalA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameLocalA$descriptor() {
        return LookupAccountNameLocalA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameLocalA$handle() {
        return LookupAccountNameLocalA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountNameLocalA$address() {
        return LookupAccountNameLocalA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameLocalA(MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameLocalA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameLocalA", lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameLocalW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupAccountNameLocalW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameLocalW$descriptor() {
        return LookupAccountNameLocalW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameLocalW$handle() {
        return LookupAccountNameLocalW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountNameLocalW$address() {
        return LookupAccountNameLocalW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameLocalW(MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameLocalW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameLocalW", lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidLocalA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupAccountSidLocalA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidLocalA$descriptor() {
        return LookupAccountSidLocalA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidLocalA$handle() {
        return LookupAccountSidLocalA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountSidLocalA$address() {
        return LookupAccountSidLocalA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidLocalA(MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidLocalA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidLocalA", Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidLocalW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupAccountSidLocalW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidLocalW$descriptor() {
        return LookupAccountSidLocalW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidLocalW$handle() {
        return LookupAccountSidLocalW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountSidLocalW$address() {
        return LookupAccountSidLocalW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidLocalW(MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidLocalW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidLocalW", Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupPrivilegeValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeValueA$descriptor() {
        return LookupPrivilegeValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
     * }
     */
    public static MethodHandle LookupPrivilegeValueA$handle() {
        return LookupPrivilegeValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
     * }
     */
    public static MemorySegment LookupPrivilegeValueA$address() {
        return LookupPrivilegeValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
     * }
     */
    public static int LookupPrivilegeValueA(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpLuid) {
        var mh$ = LookupPrivilegeValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeValueA", lpSystemName, lpName, lpLuid);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpLuid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupPrivilegeValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeValueW$descriptor() {
        return LookupPrivilegeValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
     * }
     */
    public static MethodHandle LookupPrivilegeValueW$handle() {
        return LookupPrivilegeValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
     * }
     */
    public static MemorySegment LookupPrivilegeValueW$address() {
        return LookupPrivilegeValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
     * }
     */
    public static int LookupPrivilegeValueW(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpLuid) {
        var mh$ = LookupPrivilegeValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeValueW", lpSystemName, lpName, lpLuid);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpLuid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupPrivilegeNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeNameA$descriptor() {
        return LookupPrivilegeNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName)
     * }
     */
    public static MethodHandle LookupPrivilegeNameA$handle() {
        return LookupPrivilegeNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName)
     * }
     */
    public static MemorySegment LookupPrivilegeNameA$address() {
        return LookupPrivilegeNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName)
     * }
     */
    public static int LookupPrivilegeNameA(MemorySegment lpSystemName, MemorySegment lpLuid, MemorySegment lpName, MemorySegment cchName) {
        var mh$ = LookupPrivilegeNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeNameA", lpSystemName, lpLuid, lpName, cchName);
            }
            return (int)mh$.invokeExact(lpSystemName, lpLuid, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupPrivilegeNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeNameW$descriptor() {
        return LookupPrivilegeNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName)
     * }
     */
    public static MethodHandle LookupPrivilegeNameW$handle() {
        return LookupPrivilegeNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName)
     * }
     */
    public static MemorySegment LookupPrivilegeNameW$address() {
        return LookupPrivilegeNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName)
     * }
     */
    public static int LookupPrivilegeNameW(MemorySegment lpSystemName, MemorySegment lpLuid, MemorySegment lpName, MemorySegment cchName) {
        var mh$ = LookupPrivilegeNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeNameW", lpSystemName, lpLuid, lpName, cchName);
            }
            return (int)mh$.invokeExact(lpSystemName, lpLuid, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeDisplayNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupPrivilegeDisplayNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeDisplayNameA$descriptor() {
        return LookupPrivilegeDisplayNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static MethodHandle LookupPrivilegeDisplayNameA$handle() {
        return LookupPrivilegeDisplayNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static MemorySegment LookupPrivilegeDisplayNameA$address() {
        return LookupPrivilegeDisplayNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static int LookupPrivilegeDisplayNameA(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpDisplayName, MemorySegment cchDisplayName, MemorySegment lpLanguageId) {
        var mh$ = LookupPrivilegeDisplayNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeDisplayNameA", lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeDisplayNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LookupPrivilegeDisplayNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeDisplayNameW$descriptor() {
        return LookupPrivilegeDisplayNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static MethodHandle LookupPrivilegeDisplayNameW$handle() {
        return LookupPrivilegeDisplayNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static MemorySegment LookupPrivilegeDisplayNameW$address() {
        return LookupPrivilegeDisplayNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static int LookupPrivilegeDisplayNameW(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpDisplayName, MemorySegment cchDisplayName, MemorySegment lpLanguageId) {
        var mh$ = LookupPrivilegeDisplayNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeDisplayNameW", lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BuildCommDCBA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor BuildCommDCBA$descriptor() {
        return BuildCommDCBA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static MethodHandle BuildCommDCBA$handle() {
        return BuildCommDCBA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static MemorySegment BuildCommDCBA$address() {
        return BuildCommDCBA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static int BuildCommDCBA(MemorySegment lpDef, MemorySegment lpDCB) {
        var mh$ = BuildCommDCBA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBA", lpDef, lpDCB);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BuildCommDCBW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor BuildCommDCBW$descriptor() {
        return BuildCommDCBW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static MethodHandle BuildCommDCBW$handle() {
        return BuildCommDCBW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static MemorySegment BuildCommDCBW$address() {
        return BuildCommDCBW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static int BuildCommDCBW(MemorySegment lpDef, MemorySegment lpDCB) {
        var mh$ = BuildCommDCBW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBW", lpDef, lpDCB);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBAndTimeoutsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BuildCommDCBAndTimeoutsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor BuildCommDCBAndTimeoutsA$descriptor() {
        return BuildCommDCBAndTimeoutsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle BuildCommDCBAndTimeoutsA$handle() {
        return BuildCommDCBAndTimeoutsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MemorySegment BuildCommDCBAndTimeoutsA$address() {
        return BuildCommDCBAndTimeoutsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int BuildCommDCBAndTimeoutsA(MemorySegment lpDef, MemorySegment lpDCB, MemorySegment lpCommTimeouts) {
        var mh$ = BuildCommDCBAndTimeoutsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBAndTimeoutsA", lpDef, lpDCB, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBAndTimeoutsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BuildCommDCBAndTimeoutsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor BuildCommDCBAndTimeoutsW$descriptor() {
        return BuildCommDCBAndTimeoutsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle BuildCommDCBAndTimeoutsW$handle() {
        return BuildCommDCBAndTimeoutsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MemorySegment BuildCommDCBAndTimeoutsW$address() {
        return BuildCommDCBAndTimeoutsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int BuildCommDCBAndTimeoutsW(MemorySegment lpDef, MemorySegment lpDCB, MemorySegment lpCommTimeouts) {
        var mh$ = BuildCommDCBAndTimeoutsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBAndTimeoutsW", lpDef, lpDCB, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CommConfigDialogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CommConfigDialogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static FunctionDescriptor CommConfigDialogA$descriptor() {
        return CommConfigDialogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static MethodHandle CommConfigDialogA$handle() {
        return CommConfigDialogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static MemorySegment CommConfigDialogA$address() {
        return CommConfigDialogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static int CommConfigDialogA(MemorySegment lpszName, MemorySegment hWnd, MemorySegment lpCC) {
        var mh$ = CommConfigDialogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CommConfigDialogA", lpszName, hWnd, lpCC);
            }
            return (int)mh$.invokeExact(lpszName, hWnd, lpCC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CommConfigDialogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CommConfigDialogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static FunctionDescriptor CommConfigDialogW$descriptor() {
        return CommConfigDialogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static MethodHandle CommConfigDialogW$handle() {
        return CommConfigDialogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static MemorySegment CommConfigDialogW$address() {
        return CommConfigDialogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static int CommConfigDialogW(MemorySegment lpszName, MemorySegment hWnd, MemorySegment lpCC) {
        var mh$ = CommConfigDialogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CommConfigDialogW", lpszName, hWnd, lpCC);
            }
            return (int)mh$.invokeExact(lpszName, hWnd, lpCC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDefaultCommConfigA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDefaultCommConfigA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor GetDefaultCommConfigA$descriptor() {
        return GetDefaultCommConfigA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MethodHandle GetDefaultCommConfigA$handle() {
        return GetDefaultCommConfigA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MemorySegment GetDefaultCommConfigA$address() {
        return GetDefaultCommConfigA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static int GetDefaultCommConfigA(MemorySegment lpszName, MemorySegment lpCC, MemorySegment lpdwSize) {
        var mh$ = GetDefaultCommConfigA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDefaultCommConfigA", lpszName, lpCC, lpdwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDefaultCommConfigW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDefaultCommConfigW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor GetDefaultCommConfigW$descriptor() {
        return GetDefaultCommConfigW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MethodHandle GetDefaultCommConfigW$handle() {
        return GetDefaultCommConfigW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MemorySegment GetDefaultCommConfigW$address() {
        return GetDefaultCommConfigW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static int GetDefaultCommConfigW(MemorySegment lpszName, MemorySegment lpCC, MemorySegment lpdwSize) {
        var mh$ = GetDefaultCommConfigW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDefaultCommConfigW", lpszName, lpCC, lpdwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDefaultCommConfigA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDefaultCommConfigA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor SetDefaultCommConfigA$descriptor() {
        return SetDefaultCommConfigA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MethodHandle SetDefaultCommConfigA$handle() {
        return SetDefaultCommConfigA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MemorySegment SetDefaultCommConfigA$address() {
        return SetDefaultCommConfigA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static int SetDefaultCommConfigA(MemorySegment lpszName, MemorySegment lpCC, int dwSize) {
        var mh$ = SetDefaultCommConfigA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDefaultCommConfigA", lpszName, lpCC, dwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDefaultCommConfigW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDefaultCommConfigW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor SetDefaultCommConfigW$descriptor() {
        return SetDefaultCommConfigW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MethodHandle SetDefaultCommConfigW$handle() {
        return SetDefaultCommConfigW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MemorySegment SetDefaultCommConfigW$address() {
        return SetDefaultCommConfigW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static int SetDefaultCommConfigW(MemorySegment lpszName, MemorySegment lpCC, int dwSize) {
        var mh$ = SetDefaultCommConfigW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDefaultCommConfigW", lpszName, lpCC, dwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetComputerNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameA$descriptor() {
        return GetComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameA$handle() {
        return GetComputerNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MemorySegment GetComputerNameA$address() {
        return GetComputerNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameA(MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameA", lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetComputerNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameW$descriptor() {
        return GetComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameW$handle() {
        return GetComputerNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MemorySegment GetComputerNameW$address() {
        return GetComputerNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameW(MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameW", lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DnsHostnameToComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DnsHostnameToComputerNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor DnsHostnameToComputerNameA$descriptor() {
        return DnsHostnameToComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MethodHandle DnsHostnameToComputerNameA$handle() {
        return DnsHostnameToComputerNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MemorySegment DnsHostnameToComputerNameA$address() {
        return DnsHostnameToComputerNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static int DnsHostnameToComputerNameA(MemorySegment Hostname, MemorySegment ComputerName, MemorySegment nSize) {
        var mh$ = DnsHostnameToComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DnsHostnameToComputerNameA", Hostname, ComputerName, nSize);
            }
            return (int)mh$.invokeExact(Hostname, ComputerName, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DnsHostnameToComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DnsHostnameToComputerNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor DnsHostnameToComputerNameW$descriptor() {
        return DnsHostnameToComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MethodHandle DnsHostnameToComputerNameW$handle() {
        return DnsHostnameToComputerNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MemorySegment DnsHostnameToComputerNameW$address() {
        return DnsHostnameToComputerNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static int DnsHostnameToComputerNameW(MemorySegment Hostname, MemorySegment ComputerName, MemorySegment nSize) {
        var mh$ = DnsHostnameToComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DnsHostnameToComputerNameW", Hostname, ComputerName, nSize);
            }
            return (int)mh$.invokeExact(Hostname, ComputerName, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetUserNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static FunctionDescriptor GetUserNameA$descriptor() {
        return GetUserNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static MethodHandle GetUserNameA$handle() {
        return GetUserNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static MemorySegment GetUserNameA$address() {
        return GetUserNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static int GetUserNameA(MemorySegment lpBuffer, MemorySegment pcbBuffer) {
        var mh$ = GetUserNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserNameA", lpBuffer, pcbBuffer);
            }
            return (int)mh$.invokeExact(lpBuffer, pcbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetUserNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static FunctionDescriptor GetUserNameW$descriptor() {
        return GetUserNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static MethodHandle GetUserNameW$handle() {
        return GetUserNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static MemorySegment GetUserNameW$address() {
        return GetUserNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static int GetUserNameW(MemorySegment lpBuffer, MemorySegment pcbBuffer) {
        var mh$ = GetUserNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserNameW", lpBuffer, pcbBuffer);
            }
            return (int)mh$.invokeExact(lpBuffer, pcbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LogonUserA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static FunctionDescriptor LogonUserA$descriptor() {
        return LogonUserA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static MethodHandle LogonUserA$handle() {
        return LogonUserA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static MemorySegment LogonUserA$address() {
        return LogonUserA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static int LogonUserA(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken) {
        var mh$ = LogonUserA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserA", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LogonUserW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static FunctionDescriptor LogonUserW$descriptor() {
        return LogonUserW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static MethodHandle LogonUserW$handle() {
        return LogonUserW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static MemorySegment LogonUserW$address() {
        return LogonUserW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static int LogonUserW(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken) {
        var mh$ = LogonUserW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserW", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LogonUserExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static FunctionDescriptor LogonUserExA$descriptor() {
        return LogonUserExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static MethodHandle LogonUserExA$handle() {
        return LogonUserExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static MemorySegment LogonUserExA$address() {
        return LogonUserExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static int LogonUserExA(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken, MemorySegment ppLogonSid, MemorySegment ppProfileBuffer, MemorySegment pdwProfileLength, MemorySegment pQuotaLimits) {
        var mh$ = LogonUserExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserExA", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LogonUserExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static FunctionDescriptor LogonUserExW$descriptor() {
        return LogonUserExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static MethodHandle LogonUserExW$handle() {
        return LogonUserExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static MemorySegment LogonUserExW$address() {
        return LogonUserExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static int LogonUserExW(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken, MemorySegment ppLogonSid, MemorySegment ppProfileBuffer, MemorySegment pdwProfileLength, MemorySegment pQuotaLimits) {
        var mh$ = LogonUserExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserExW", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessWithLogonW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateProcessWithLogonW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessWithLogonW$descriptor() {
        return CreateProcessWithLogonW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessWithLogonW$handle() {
        return CreateProcessWithLogonW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessWithLogonW$address() {
        return CreateProcessWithLogonW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessWithLogonW(MemorySegment lpUsername, MemorySegment lpDomain, MemorySegment lpPassword, int dwLogonFlags, MemorySegment lpApplicationName, MemorySegment lpCommandLine, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessWithLogonW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessWithLogonW", lpUsername, lpDomain, lpPassword, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(lpUsername, lpDomain, lpPassword, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessWithTokenW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateProcessWithTokenW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessWithTokenW$descriptor() {
        return CreateProcessWithTokenW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessWithTokenW$handle() {
        return CreateProcessWithTokenW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessWithTokenW$address() {
        return CreateProcessWithTokenW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessWithTokenW(MemorySegment hToken, int dwLogonFlags, MemorySegment lpApplicationName, MemorySegment lpCommandLine, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessWithTokenW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessWithTokenW", hToken, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(hToken, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTokenUntrusted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsTokenUntrusted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTokenUntrusted(HANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor IsTokenUntrusted$descriptor() {
        return IsTokenUntrusted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTokenUntrusted(HANDLE TokenHandle)
     * }
     */
    public static MethodHandle IsTokenUntrusted$handle() {
        return IsTokenUntrusted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsTokenUntrusted(HANDLE TokenHandle)
     * }
     */
    public static MemorySegment IsTokenUntrusted$address() {
        return IsTokenUntrusted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsTokenUntrusted(HANDLE TokenHandle)
     * }
     */
    public static int IsTokenUntrusted(MemorySegment TokenHandle) {
        var mh$ = IsTokenUntrusted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTokenUntrusted", TokenHandle);
            }
            return (int)mh$.invokeExact(TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterWaitForSingleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterWaitForSingleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor RegisterWaitForSingleObject$descriptor() {
        return RegisterWaitForSingleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
     * }
     */
    public static MethodHandle RegisterWaitForSingleObject$handle() {
        return RegisterWaitForSingleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
     * }
     */
    public static MemorySegment RegisterWaitForSingleObject$address() {
        return RegisterWaitForSingleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
     * }
     */
    public static int RegisterWaitForSingleObject(MemorySegment phNewWaitObject, MemorySegment hObject, MemorySegment Callback, MemorySegment Context, int dwMilliseconds, int dwFlags) {
        var mh$ = RegisterWaitForSingleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterWaitForSingleObject", phNewWaitObject, hObject, Callback, Context, dwMilliseconds, dwFlags);
            }
            return (int)mh$.invokeExact(phNewWaitObject, hObject, Callback, Context, dwMilliseconds, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterWait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterWait(HANDLE WaitHandle)
     * }
     */
    public static FunctionDescriptor UnregisterWait$descriptor() {
        return UnregisterWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterWait(HANDLE WaitHandle)
     * }
     */
    public static MethodHandle UnregisterWait$handle() {
        return UnregisterWait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterWait(HANDLE WaitHandle)
     * }
     */
    public static MemorySegment UnregisterWait$address() {
        return UnregisterWait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterWait(HANDLE WaitHandle)
     * }
     */
    public static int UnregisterWait(MemorySegment WaitHandle) {
        var mh$ = UnregisterWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterWait", WaitHandle);
            }
            return (int)mh$.invokeExact(WaitHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BindIoCompletionCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BindIoCompletionCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
     * }
     */
    public static FunctionDescriptor BindIoCompletionCallback$descriptor() {
        return BindIoCompletionCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
     * }
     */
    public static MethodHandle BindIoCompletionCallback$handle() {
        return BindIoCompletionCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
     * }
     */
    public static MemorySegment BindIoCompletionCallback$address() {
        return BindIoCompletionCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
     * }
     */
    public static int BindIoCompletionCallback(MemorySegment FileHandle, MemorySegment Function, int Flags) {
        var mh$ = BindIoCompletionCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BindIoCompletionCallback", FileHandle, Function, Flags);
            }
            return (int)mh$.invokeExact(FileHandle, Function, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetTimerQueueTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
     * }
     */
    public static FunctionDescriptor SetTimerQueueTimer$descriptor() {
        return SetTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
     * }
     */
    public static MethodHandle SetTimerQueueTimer$handle() {
        return SetTimerQueueTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
     * }
     */
    public static MemorySegment SetTimerQueueTimer$address() {
        return SetTimerQueueTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
     * }
     */
    public static MemorySegment SetTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Callback, MemorySegment Parameter, int DueTime, int Period, int PreferIo) {
        var mh$ = SetTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTimerQueueTimer", TimerQueue, Callback, Parameter, DueTime, Period, PreferIo);
            }
            return (MemorySegment)mh$.invokeExact(TimerQueue, Callback, Parameter, DueTime, Period, PreferIo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CancelTimerQueueTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
     * }
     */
    public static FunctionDescriptor CancelTimerQueueTimer$descriptor() {
        return CancelTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
     * }
     */
    public static MethodHandle CancelTimerQueueTimer$handle() {
        return CancelTimerQueueTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
     * }
     */
    public static MemorySegment CancelTimerQueueTimer$address() {
        return CancelTimerQueueTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
     * }
     */
    public static int CancelTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Timer) {
        var mh$ = CancelTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelTimerQueueTimer", TimerQueue, Timer);
            }
            return (int)mh$.invokeExact(TimerQueue, Timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteTimerQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteTimerQueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueue(HANDLE TimerQueue)
     * }
     */
    public static FunctionDescriptor DeleteTimerQueue$descriptor() {
        return DeleteTimerQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueue(HANDLE TimerQueue)
     * }
     */
    public static MethodHandle DeleteTimerQueue$handle() {
        return DeleteTimerQueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueue(HANDLE TimerQueue)
     * }
     */
    public static MemorySegment DeleteTimerQueue$address() {
        return DeleteTimerQueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteTimerQueue(HANDLE TimerQueue)
     * }
     */
    public static int DeleteTimerQueue(MemorySegment TimerQueue) {
        var mh$ = DeleteTimerQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteTimerQueue", TimerQueue);
            }
            return (int)mh$.invokeExact(TimerQueue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateNamespaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePrivateNamespaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor CreatePrivateNamespaceA$descriptor() {
        return CreatePrivateNamespaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle CreatePrivateNamespaceA$handle() {
        return CreatePrivateNamespaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment CreatePrivateNamespaceA$address() {
        return CreatePrivateNamespaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment CreatePrivateNamespaceA(MemorySegment lpPrivateNamespaceAttributes, MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = CreatePrivateNamespaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateNamespaceA", lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenPrivateNamespaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenPrivateNamespaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor OpenPrivateNamespaceA$descriptor() {
        return OpenPrivateNamespaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle OpenPrivateNamespaceA$handle() {
        return OpenPrivateNamespaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment OpenPrivateNamespaceA$address() {
        return OpenPrivateNamespaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment OpenPrivateNamespaceA(MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = OpenPrivateNamespaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenPrivateNamespaceA", lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBoundaryDescriptorA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateBoundaryDescriptorA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateBoundaryDescriptorA$descriptor() {
        return CreateBoundaryDescriptorA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
     * }
     */
    public static MethodHandle CreateBoundaryDescriptorA$handle() {
        return CreateBoundaryDescriptorA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
     * }
     */
    public static MemorySegment CreateBoundaryDescriptorA$address() {
        return CreateBoundaryDescriptorA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
     * }
     */
    public static MemorySegment CreateBoundaryDescriptorA(MemorySegment Name, int Flags) {
        var mh$ = CreateBoundaryDescriptorA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBoundaryDescriptorA", Name, Flags);
            }
            return (MemorySegment)mh$.invokeExact(Name, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddIntegrityLabelToBoundaryDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddIntegrityLabelToBoundaryDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
     * }
     */
    public static FunctionDescriptor AddIntegrityLabelToBoundaryDescriptor$descriptor() {
        return AddIntegrityLabelToBoundaryDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
     * }
     */
    public static MethodHandle AddIntegrityLabelToBoundaryDescriptor$handle() {
        return AddIntegrityLabelToBoundaryDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
     * }
     */
    public static MemorySegment AddIntegrityLabelToBoundaryDescriptor$address() {
        return AddIntegrityLabelToBoundaryDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
     * }
     */
    public static int AddIntegrityLabelToBoundaryDescriptor(MemorySegment BoundaryDescriptor, MemorySegment IntegrityLabel) {
        var mh$ = AddIntegrityLabelToBoundaryDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddIntegrityLabelToBoundaryDescriptor", BoundaryDescriptor, IntegrityLabel);
            }
            return (int)mh$.invokeExact(BoundaryDescriptor, IntegrityLabel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagHW_PROFILE_INFOA {
     *     DWORD dwDockInfo;
     *     CHAR szHwProfileGuid[39];
     *     CHAR szHwProfileName[80];
     * } *LPHW_PROFILE_INFOA
     * }
     */
    public static final AddressLayout LPHW_PROFILE_INFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHW_PROFILE_INFOW {
     *     DWORD dwDockInfo;
     *     WCHAR szHwProfileGuid[39];
     *     WCHAR szHwProfileName[80];
     * } *LPHW_PROFILE_INFOW
     * }
     */
    public static final AddressLayout LPHW_PROFILE_INFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO
     * }
     */
    public static final AddressLayout LPHW_PROFILE_INFO = wgl_h.C_POINTER;

    private static class GetCurrentHwProfileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentHwProfileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo)
     * }
     */
    public static FunctionDescriptor GetCurrentHwProfileA$descriptor() {
        return GetCurrentHwProfileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo)
     * }
     */
    public static MethodHandle GetCurrentHwProfileA$handle() {
        return GetCurrentHwProfileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo)
     * }
     */
    public static MemorySegment GetCurrentHwProfileA$address() {
        return GetCurrentHwProfileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo)
     * }
     */
    public static int GetCurrentHwProfileA(MemorySegment lpHwProfileInfo) {
        var mh$ = GetCurrentHwProfileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentHwProfileA", lpHwProfileInfo);
            }
            return (int)mh$.invokeExact(lpHwProfileInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentHwProfileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentHwProfileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo)
     * }
     */
    public static FunctionDescriptor GetCurrentHwProfileW$descriptor() {
        return GetCurrentHwProfileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo)
     * }
     */
    public static MethodHandle GetCurrentHwProfileW$handle() {
        return GetCurrentHwProfileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo)
     * }
     */
    public static MemorySegment GetCurrentHwProfileW$address() {
        return GetCurrentHwProfileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo)
     * }
     */
    public static int GetCurrentHwProfileW(MemorySegment lpHwProfileInfo) {
        var mh$ = GetCurrentHwProfileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentHwProfileW", lpHwProfileInfo);
            }
            return (int)mh$.invokeExact(lpHwProfileInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerifyVersionInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VerifyVersionInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static FunctionDescriptor VerifyVersionInfoA$descriptor() {
        return VerifyVersionInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static MethodHandle VerifyVersionInfoA$handle() {
        return VerifyVersionInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static MemorySegment VerifyVersionInfoA$address() {
        return VerifyVersionInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static int VerifyVersionInfoA(MemorySegment lpVersionInformation, int dwTypeMask, long dwlConditionMask) {
        var mh$ = VerifyVersionInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerifyVersionInfoA", lpVersionInformation, dwTypeMask, dwlConditionMask);
            }
            return (int)mh$.invokeExact(lpVersionInformation, dwTypeMask, dwlConditionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerifyVersionInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VerifyVersionInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static FunctionDescriptor VerifyVersionInfoW$descriptor() {
        return VerifyVersionInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static MethodHandle VerifyVersionInfoW$handle() {
        return VerifyVersionInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static MemorySegment VerifyVersionInfoW$address() {
        return VerifyVersionInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static int VerifyVersionInfoW(MemorySegment lpVersionInformation, int dwTypeMask, long dwlConditionMask) {
        var mh$ = VerifyVersionInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerifyVersionInfoW", lpVersionInformation, dwTypeMask, dwlConditionMask);
            }
            return (int)mh$.invokeExact(lpVersionInformation, dwTypeMask, dwlConditionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TIME_ZONE_INFORMATION {
     *     LONG Bias;
     *     WCHAR StandardName[32];
     *     SYSTEMTIME StandardDate;
     *     LONG StandardBias;
     *     WCHAR DaylightName[32];
     *     SYSTEMTIME DaylightDate;
     *     LONG DaylightBias;
     * } *PTIME_ZONE_INFORMATION
     * }
     */
    public static final AddressLayout PTIME_ZONE_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TIME_ZONE_INFORMATION {
     *     LONG Bias;
     *     WCHAR StandardName[32];
     *     SYSTEMTIME StandardDate;
     *     LONG StandardBias;
     *     WCHAR DaylightName[32];
     *     SYSTEMTIME DaylightDate;
     *     LONG DaylightBias;
     * } *LPTIME_ZONE_INFORMATION
     * }
     */
    public static final AddressLayout LPTIME_ZONE_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
     *     LONG Bias;
     *     WCHAR StandardName[32];
     *     SYSTEMTIME StandardDate;
     *     LONG StandardBias;
     *     WCHAR DaylightName[32];
     *     SYSTEMTIME DaylightDate;
     *     LONG DaylightBias;
     *     WCHAR TimeZoneKeyName[128];
     *     BOOLEAN DynamicDaylightTimeDisabled;
     * } *PDYNAMIC_TIME_ZONE_INFORMATION
     * }
     */
    public static final AddressLayout PDYNAMIC_TIME_ZONE_INFORMATION = wgl_h.C_POINTER;

    private static class SystemTimeToTzSpecificLocalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SystemTimeToTzSpecificLocalTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static FunctionDescriptor SystemTimeToTzSpecificLocalTime$descriptor() {
        return SystemTimeToTzSpecificLocalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static MethodHandle SystemTimeToTzSpecificLocalTime$handle() {
        return SystemTimeToTzSpecificLocalTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static MemorySegment SystemTimeToTzSpecificLocalTime$address() {
        return SystemTimeToTzSpecificLocalTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static int SystemTimeToTzSpecificLocalTime(MemorySegment lpTimeZoneInformation, MemorySegment lpUniversalTime, MemorySegment lpLocalTime) {
        var mh$ = SystemTimeToTzSpecificLocalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemTimeToTzSpecificLocalTime", lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TzSpecificLocalTimeToSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TzSpecificLocalTimeToSystemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static FunctionDescriptor TzSpecificLocalTimeToSystemTime$descriptor() {
        return TzSpecificLocalTimeToSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static MethodHandle TzSpecificLocalTimeToSystemTime$handle() {
        return TzSpecificLocalTimeToSystemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static MemorySegment TzSpecificLocalTimeToSystemTime$address() {
        return TzSpecificLocalTimeToSystemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static int TzSpecificLocalTimeToSystemTime(MemorySegment lpTimeZoneInformation, MemorySegment lpLocalTime, MemorySegment lpUniversalTime) {
        var mh$ = TzSpecificLocalTimeToSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TzSpecificLocalTimeToSystemTime", lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileTimeToSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FileTimeToSystemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static FunctionDescriptor FileTimeToSystemTime$descriptor() {
        return FileTimeToSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MethodHandle FileTimeToSystemTime$handle() {
        return FileTimeToSystemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MemorySegment FileTimeToSystemTime$address() {
        return FileTimeToSystemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static int FileTimeToSystemTime(MemorySegment lpFileTime, MemorySegment lpSystemTime) {
        var mh$ = FileTimeToSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileTimeToSystemTime", lpFileTime, lpSystemTime);
            }
            return (int)mh$.invokeExact(lpFileTime, lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemTimeToFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SystemTimeToFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
     * }
     */
    public static FunctionDescriptor SystemTimeToFileTime$descriptor() {
        return SystemTimeToFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
     * }
     */
    public static MethodHandle SystemTimeToFileTime$handle() {
        return SystemTimeToFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
     * }
     */
    public static MemorySegment SystemTimeToFileTime$address() {
        return SystemTimeToFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
     * }
     */
    public static int SystemTimeToFileTime(MemorySegment lpSystemTime, MemorySegment lpFileTime) {
        var mh$ = SystemTimeToFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemTimeToFileTime", lpSystemTime, lpFileTime);
            }
            return (int)mh$.invokeExact(lpSystemTime, lpFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTimeZoneInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor GetTimeZoneInformation$descriptor() {
        return GetTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static MethodHandle GetTimeZoneInformation$handle() {
        return GetTimeZoneInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static MemorySegment GetTimeZoneInformation$address() {
        return GetTimeZoneInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static int GetTimeZoneInformation(MemorySegment lpTimeZoneInformation) {
        var mh$ = GetTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeZoneInformation", lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetTimeZoneInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor SetTimeZoneInformation$descriptor() {
        return SetTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static MethodHandle SetTimeZoneInformation$handle() {
        return SetTimeZoneInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static MemorySegment SetTimeZoneInformation$address() {
        return SetTimeZoneInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static int SetTimeZoneInformation(MemorySegment lpTimeZoneInformation) {
        var mh$ = SetTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTimeZoneInformation", lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDynamicTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDynamicTimeZoneInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor SetDynamicTimeZoneInformation$descriptor() {
        return SetDynamicTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static MethodHandle SetDynamicTimeZoneInformation$handle() {
        return SetDynamicTimeZoneInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static MemorySegment SetDynamicTimeZoneInformation$address() {
        return SetDynamicTimeZoneInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static int SetDynamicTimeZoneInformation(MemorySegment lpTimeZoneInformation) {
        var mh$ = SetDynamicTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDynamicTimeZoneInformation", lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDynamicTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDynamicTimeZoneInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor GetDynamicTimeZoneInformation$descriptor() {
        return GetDynamicTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
     * }
     */
    public static MethodHandle GetDynamicTimeZoneInformation$handle() {
        return GetDynamicTimeZoneInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
     * }
     */
    public static MemorySegment GetDynamicTimeZoneInformation$address() {
        return GetDynamicTimeZoneInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
     * }
     */
    public static int GetDynamicTimeZoneInformation(MemorySegment pTimeZoneInformation) {
        var mh$ = GetDynamicTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDynamicTimeZoneInformation", pTimeZoneInformation);
            }
            return (int)mh$.invokeExact(pTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeZoneInformationForYear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTimeZoneInformationForYear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
     * }
     */
    public static FunctionDescriptor GetTimeZoneInformationForYear$descriptor() {
        return GetTimeZoneInformationForYear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
     * }
     */
    public static MethodHandle GetTimeZoneInformationForYear$handle() {
        return GetTimeZoneInformationForYear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
     * }
     */
    public static MemorySegment GetTimeZoneInformationForYear$address() {
        return GetTimeZoneInformationForYear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
     * }
     */
    public static int GetTimeZoneInformationForYear(short wYear, MemorySegment pdtzi, MemorySegment ptzi) {
        var mh$ = GetTimeZoneInformationForYear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeZoneInformationForYear", wYear, pdtzi, ptzi);
            }
            return (int)mh$.invokeExact(wYear, pdtzi, ptzi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDynamicTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumDynamicTimeZoneInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor EnumDynamicTimeZoneInformation$descriptor() {
        return EnumDynamicTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static MethodHandle EnumDynamicTimeZoneInformation$handle() {
        return EnumDynamicTimeZoneInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static MemorySegment EnumDynamicTimeZoneInformation$address() {
        return EnumDynamicTimeZoneInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static int EnumDynamicTimeZoneInformation(int dwIndex, MemorySegment lpTimeZoneInformation) {
        var mh$ = EnumDynamicTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDynamicTimeZoneInformation", dwIndex, lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(dwIndex, lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDynamicTimeZoneInformationEffectiveYears {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDynamicTimeZoneInformationEffectiveYears");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, LPDWORD FirstYear, LPDWORD LastYear)
     * }
     */
    public static FunctionDescriptor GetDynamicTimeZoneInformationEffectiveYears$descriptor() {
        return GetDynamicTimeZoneInformationEffectiveYears.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, LPDWORD FirstYear, LPDWORD LastYear)
     * }
     */
    public static MethodHandle GetDynamicTimeZoneInformationEffectiveYears$handle() {
        return GetDynamicTimeZoneInformationEffectiveYears.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, LPDWORD FirstYear, LPDWORD LastYear)
     * }
     */
    public static MemorySegment GetDynamicTimeZoneInformationEffectiveYears$address() {
        return GetDynamicTimeZoneInformationEffectiveYears.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, LPDWORD FirstYear, LPDWORD LastYear)
     * }
     */
    public static int GetDynamicTimeZoneInformationEffectiveYears(MemorySegment lpTimeZoneInformation, MemorySegment FirstYear, MemorySegment LastYear) {
        var mh$ = GetDynamicTimeZoneInformationEffectiveYears.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDynamicTimeZoneInformationEffectiveYears", lpTimeZoneInformation, FirstYear, LastYear);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, FirstYear, LastYear);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemTimeToTzSpecificLocalTimeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SystemTimeToTzSpecificLocalTimeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static FunctionDescriptor SystemTimeToTzSpecificLocalTimeEx$descriptor() {
        return SystemTimeToTzSpecificLocalTimeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static MethodHandle SystemTimeToTzSpecificLocalTimeEx$handle() {
        return SystemTimeToTzSpecificLocalTimeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static MemorySegment SystemTimeToTzSpecificLocalTimeEx$address() {
        return SystemTimeToTzSpecificLocalTimeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static int SystemTimeToTzSpecificLocalTimeEx(MemorySegment lpTimeZoneInformation, MemorySegment lpUniversalTime, MemorySegment lpLocalTime) {
        var mh$ = SystemTimeToTzSpecificLocalTimeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemTimeToTzSpecificLocalTimeEx", lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TzSpecificLocalTimeToSystemTimeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TzSpecificLocalTimeToSystemTimeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static FunctionDescriptor TzSpecificLocalTimeToSystemTimeEx$descriptor() {
        return TzSpecificLocalTimeToSystemTimeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static MethodHandle TzSpecificLocalTimeToSystemTimeEx$handle() {
        return TzSpecificLocalTimeToSystemTimeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static MemorySegment TzSpecificLocalTimeToSystemTimeEx$address() {
        return TzSpecificLocalTimeToSystemTimeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static int TzSpecificLocalTimeToSystemTimeEx(MemorySegment lpTimeZoneInformation, MemorySegment lpLocalTime, MemorySegment lpUniversalTime) {
        var mh$ = TzSpecificLocalTimeToSystemTimeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TzSpecificLocalTimeToSystemTimeEx", lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFileTimeToLocalSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalFileTimeToLocalSystemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const FILETIME *localFileTime, SYSTEMTIME *localSystemTime)
     * }
     */
    public static FunctionDescriptor LocalFileTimeToLocalSystemTime$descriptor() {
        return LocalFileTimeToLocalSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const FILETIME *localFileTime, SYSTEMTIME *localSystemTime)
     * }
     */
    public static MethodHandle LocalFileTimeToLocalSystemTime$handle() {
        return LocalFileTimeToLocalSystemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const FILETIME *localFileTime, SYSTEMTIME *localSystemTime)
     * }
     */
    public static MemorySegment LocalFileTimeToLocalSystemTime$address() {
        return LocalFileTimeToLocalSystemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const FILETIME *localFileTime, SYSTEMTIME *localSystemTime)
     * }
     */
    public static int LocalFileTimeToLocalSystemTime(MemorySegment timeZoneInformation, MemorySegment localFileTime, MemorySegment localSystemTime) {
        var mh$ = LocalFileTimeToLocalSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFileTimeToLocalSystemTime", timeZoneInformation, localFileTime, localSystemTime);
            }
            return (int)mh$.invokeExact(timeZoneInformation, localFileTime, localSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalSystemTimeToLocalFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalSystemTimeToLocalFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const SYSTEMTIME *localSystemTime, FILETIME *localFileTime)
     * }
     */
    public static FunctionDescriptor LocalSystemTimeToLocalFileTime$descriptor() {
        return LocalSystemTimeToLocalFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const SYSTEMTIME *localSystemTime, FILETIME *localFileTime)
     * }
     */
    public static MethodHandle LocalSystemTimeToLocalFileTime$handle() {
        return LocalSystemTimeToLocalFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const SYSTEMTIME *localSystemTime, FILETIME *localFileTime)
     * }
     */
    public static MemorySegment LocalSystemTimeToLocalFileTime$address() {
        return LocalSystemTimeToLocalFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const SYSTEMTIME *localSystemTime, FILETIME *localFileTime)
     * }
     */
    public static int LocalSystemTimeToLocalFileTime(MemorySegment timeZoneInformation, MemorySegment localSystemTime, MemorySegment localFileTime) {
        var mh$ = LocalSystemTimeToLocalFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalSystemTimeToLocalFileTime", timeZoneInformation, localSystemTime, localFileTime);
            }
            return (int)mh$.invokeExact(timeZoneInformation, localSystemTime, localFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemPowerState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSystemPowerState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static FunctionDescriptor SetSystemPowerState$descriptor() {
        return SetSystemPowerState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static MethodHandle SetSystemPowerState$handle() {
        return SetSystemPowerState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static MemorySegment SetSystemPowerState$address() {
        return SetSystemPowerState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static int SetSystemPowerState(int fSuspend, int fForce) {
        var mh$ = SetSystemPowerState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemPowerState", fSuspend, fForce);
            }
            return (int)mh$.invokeExact(fSuspend, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_POWER_STATUS {
     *     BYTE ACLineStatus;
     *     BYTE BatteryFlag;
     *     BYTE BatteryLifePercent;
     *     BYTE SystemStatusFlag;
     *     DWORD BatteryLifeTime;
     *     DWORD BatteryFullLifeTime;
     * } *LPSYSTEM_POWER_STATUS
     * }
     */
    public static final AddressLayout LPSYSTEM_POWER_STATUS = wgl_h.C_POINTER;

    private static class GetSystemPowerStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemPowerStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static FunctionDescriptor GetSystemPowerStatus$descriptor() {
        return GetSystemPowerStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static MethodHandle GetSystemPowerStatus$handle() {
        return GetSystemPowerStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static MemorySegment GetSystemPowerStatus$address() {
        return GetSystemPowerStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static int GetSystemPowerStatus(MemorySegment lpSystemPowerStatus) {
        var mh$ = GetSystemPowerStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPowerStatus", lpSystemPowerStatus);
            }
            return (int)mh$.invokeExact(lpSystemPowerStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapUserPhysicalPagesScatter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapUserPhysicalPagesScatter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor MapUserPhysicalPagesScatter$descriptor() {
        return MapUserPhysicalPagesScatter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle MapUserPhysicalPagesScatter$handle() {
        return MapUserPhysicalPagesScatter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MemorySegment MapUserPhysicalPagesScatter$address() {
        return MapUserPhysicalPagesScatter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int MapUserPhysicalPagesScatter(MemorySegment VirtualAddresses, long NumberOfPages, MemorySegment PageArray) {
        var mh$ = MapUserPhysicalPagesScatter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapUserPhysicalPagesScatter", VirtualAddresses, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(VirtualAddresses, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateJobObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateJobObjectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateJobObjectA$descriptor() {
        return CreateJobObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateJobObjectA$handle() {
        return CreateJobObjectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectA$address() {
        return CreateJobObjectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectA(MemorySegment lpJobAttributes, MemorySegment lpName) {
        var mh$ = CreateJobObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateJobObjectA", lpJobAttributes, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpJobAttributes, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenJobObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenJobObjectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenJobObjectA$descriptor() {
        return OpenJobObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenJobObjectA$handle() {
        return OpenJobObjectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectA$address() {
        return OpenJobObjectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenJobObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenJobObjectA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateJobSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateJobSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateJobSet$descriptor() {
        return CreateJobSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static MethodHandle CreateJobSet$handle() {
        return CreateJobSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static MemorySegment CreateJobSet$address() {
        return CreateJobSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static int CreateJobSet(int NumJob, MemorySegment UserJobSet, int Flags) {
        var mh$ = CreateJobSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateJobSet", NumJob, UserJobSet, Flags);
            }
            return (int)mh$.invokeExact(NumJob, UserJobSet, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstVolumeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeA$descriptor() {
        return FindFirstVolumeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeA$handle() {
        return FindFirstVolumeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeA$address() {
        return FindFirstVolumeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeA(MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindFirstVolumeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeA", lpszVolumeName, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindNextVolumeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeA$descriptor() {
        return FindNextVolumeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeA$handle() {
        return FindNextVolumeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindNextVolumeA$address() {
        return FindNextVolumeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeA(MemorySegment hFindVolume, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindNextVolumeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeA", hFindVolume, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolume, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeMountPointA$descriptor() {
        return FindFirstVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeMountPointA$handle() {
        return FindFirstVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointA$address() {
        return FindFirstVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointA(MemorySegment lpszRootPathName, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindFirstVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeMountPointA", lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeMountPointW$descriptor() {
        return FindFirstVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeMountPointW$handle() {
        return FindFirstVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointW$address() {
        return FindFirstVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointW(MemorySegment lpszRootPathName, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindFirstVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeMountPointW", lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindNextVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeMountPointA$descriptor() {
        return FindNextVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeMountPointA$handle() {
        return FindNextVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindNextVolumeMountPointA$address() {
        return FindNextVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeMountPointA(MemorySegment hFindVolumeMountPoint, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindNextVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeMountPointA", hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindNextVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeMountPointW$descriptor() {
        return FindNextVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeMountPointW$handle() {
        return FindNextVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindNextVolumeMountPointW$address() {
        return FindNextVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeMountPointW(MemorySegment hFindVolumeMountPoint, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindNextVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeMountPointW", hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindVolumeMountPointClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindVolumeMountPointClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static FunctionDescriptor FindVolumeMountPointClose$descriptor() {
        return FindVolumeMountPointClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static MethodHandle FindVolumeMountPointClose$handle() {
        return FindVolumeMountPointClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static MemorySegment FindVolumeMountPointClose$address() {
        return FindVolumeMountPointClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static int FindVolumeMountPointClose(MemorySegment hFindVolumeMountPoint) {
        var mh$ = FindVolumeMountPointClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindVolumeMountPointClose", hFindVolumeMountPoint);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeMountPointA$descriptor() {
        return SetVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static MethodHandle SetVolumeMountPointA$handle() {
        return SetVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static MemorySegment SetVolumeMountPointA$address() {
        return SetVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static int SetVolumeMountPointA(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName) {
        var mh$ = SetVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeMountPointA", lpszVolumeMountPoint, lpszVolumeName);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeMountPointW$descriptor() {
        return SetVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static MethodHandle SetVolumeMountPointW$handle() {
        return SetVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static MemorySegment SetVolumeMountPointW$address() {
        return SetVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static int SetVolumeMountPointW(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName) {
        var mh$ = SetVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeMountPointW", lpszVolumeMountPoint, lpszVolumeName);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static FunctionDescriptor DeleteVolumeMountPointA$descriptor() {
        return DeleteVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static MethodHandle DeleteVolumeMountPointA$handle() {
        return DeleteVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static MemorySegment DeleteVolumeMountPointA$address() {
        return DeleteVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static int DeleteVolumeMountPointA(MemorySegment lpszVolumeMountPoint) {
        var mh$ = DeleteVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteVolumeMountPointA", lpszVolumeMountPoint);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeNameForVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVolumeNameForVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumeNameForVolumeMountPointA$descriptor() {
        return GetVolumeNameForVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumeNameForVolumeMountPointA$handle() {
        return GetVolumeNameForVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumeNameForVolumeMountPointA$address() {
        return GetVolumeNameForVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumeNameForVolumeMountPointA(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = GetVolumeNameForVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeNameForVolumeMountPointA", lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVolumePathNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNameA$descriptor() {
        return GetVolumePathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumePathNameA$handle() {
        return GetVolumePathNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumePathNameA$address() {
        return GetVolumePathNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumePathNameA(MemorySegment lpszFileName, MemorySegment lpszVolumePathName, int cchBufferLength) {
        var mh$ = GetVolumePathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNameA", lpszFileName, lpszVolumePathName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszFileName, lpszVolumePathName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNamesForVolumeNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVolumePathNamesForVolumeNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNamesForVolumeNameA$descriptor() {
        return GetVolumePathNamesForVolumeNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MethodHandle GetVolumePathNamesForVolumeNameA$handle() {
        return GetVolumePathNamesForVolumeNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MemorySegment GetVolumePathNamesForVolumeNameA$address() {
        return GetVolumePathNamesForVolumeNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static int GetVolumePathNamesForVolumeNameA(MemorySegment lpszVolumeName, MemorySegment lpszVolumePathNames, int cchBufferLength, MemorySegment lpcchReturnLength) {
        var mh$ = GetVolumePathNamesForVolumeNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNamesForVolumeNameA", lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
            }
            return (int)mh$.invokeExact(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTXA {
     *     ULONG cbSize;
     *     DWORD dwFlags;
     *     LPCSTR lpSource;
     *     USHORT wProcessorArchitecture;
     *     LANGID wLangId;
     *     LPCSTR lpAssemblyDirectory;
     *     LPCSTR lpResourceName;
     *     LPCSTR lpApplicationName;
     *     HMODULE hModule;
     * } *PACTCTXA
     * }
     */
    public static final AddressLayout PACTCTXA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTXW {
     *     ULONG cbSize;
     *     DWORD dwFlags;
     *     LPCWSTR lpSource;
     *     USHORT wProcessorArchitecture;
     *     LANGID wLangId;
     *     LPCWSTR lpAssemblyDirectory;
     *     LPCWSTR lpResourceName;
     *     LPCWSTR lpApplicationName;
     *     HMODULE hModule;
     * } *PACTCTXW
     * }
     */
    public static final AddressLayout PACTCTXW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PACTCTXA PACTCTX
     * }
     */
    public static final AddressLayout PACTCTX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTXA *PCACTCTXA
     * }
     */
    public static final AddressLayout PCACTCTXA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTXW *PCACTCTXW
     * }
     */
    public static final AddressLayout PCACTCTXW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCACTCTXA PCACTCTX
     * }
     */
    public static final AddressLayout PCACTCTX = wgl_h.C_POINTER;

    private static class CreateActCtxA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateActCtxA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static FunctionDescriptor CreateActCtxA$descriptor() {
        return CreateActCtxA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static MethodHandle CreateActCtxA$handle() {
        return CreateActCtxA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxA$address() {
        return CreateActCtxA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxA(MemorySegment pActCtx) {
        var mh$ = CreateActCtxA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateActCtxA", pActCtx);
            }
            return (MemorySegment)mh$.invokeExact(pActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateActCtxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateActCtxW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static FunctionDescriptor CreateActCtxW$descriptor() {
        return CreateActCtxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static MethodHandle CreateActCtxW$handle() {
        return CreateActCtxW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxW$address() {
        return CreateActCtxW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxW(MemorySegment pActCtx) {
        var mh$ = CreateActCtxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateActCtxW", pActCtx);
            }
            return (MemorySegment)mh$.invokeExact(pActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddRefActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddRefActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor AddRefActCtx$descriptor() {
        return AddRefActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle AddRefActCtx$handle() {
        return AddRefActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static MemorySegment AddRefActCtx$address() {
        return AddRefActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static void AddRefActCtx(MemorySegment hActCtx) {
        var mh$ = AddRefActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddRefActCtx", hActCtx);
            }
            mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReleaseActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor ReleaseActCtx$descriptor() {
        return ReleaseActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle ReleaseActCtx$handle() {
        return ReleaseActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static MemorySegment ReleaseActCtx$address() {
        return ReleaseActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static void ReleaseActCtx(MemorySegment hActCtx) {
        var mh$ = ReleaseActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseActCtx", hActCtx);
            }
            mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZombifyActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ZombifyActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor ZombifyActCtx$descriptor() {
        return ZombifyActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle ZombifyActCtx$handle() {
        return ZombifyActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static MemorySegment ZombifyActCtx$address() {
        return ZombifyActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static int ZombifyActCtx(MemorySegment hActCtx) {
        var mh$ = ZombifyActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZombifyActCtx", hActCtx);
            }
            return (int)mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ActivateActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ActivateActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static FunctionDescriptor ActivateActCtx$descriptor() {
        return ActivateActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static MethodHandle ActivateActCtx$handle() {
        return ActivateActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static MemorySegment ActivateActCtx$address() {
        return ActivateActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static int ActivateActCtx(MemorySegment hActCtx, MemorySegment lpCookie) {
        var mh$ = ActivateActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ActivateActCtx", hActCtx, lpCookie);
            }
            return (int)mh$.invokeExact(hActCtx, lpCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeactivateActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeactivateActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static FunctionDescriptor DeactivateActCtx$descriptor() {
        return DeactivateActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static MethodHandle DeactivateActCtx$handle() {
        return DeactivateActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static MemorySegment DeactivateActCtx$address() {
        return DeactivateActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static int DeactivateActCtx(int dwFlags, long ulCookie) {
        var mh$ = DeactivateActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeactivateActCtx", dwFlags, ulCookie);
            }
            return (int)mh$.invokeExact(dwFlags, ulCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static FunctionDescriptor GetCurrentActCtx$descriptor() {
        return GetCurrentActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static MethodHandle GetCurrentActCtx$handle() {
        return GetCurrentActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static MemorySegment GetCurrentActCtx$address() {
        return GetCurrentActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static int GetCurrentActCtx(MemorySegment lphActCtx) {
        var mh$ = GetCurrentActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentActCtx", lphActCtx);
            }
            return (int)mh$.invokeExact(lphActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
     *     ULONG cbSize;
     *     ULONG ulDataFormatVersion;
     *     PVOID lpData;
     *     ULONG ulLength;
     *     PVOID lpSectionGlobalData;
     *     ULONG ulSectionGlobalDataLength;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionTotalLength;
     *     HANDLE hActCtx;
     *     ULONG ulAssemblyRosterIndex;
     * } *PACTCTX_SECTION_KEYED_DATA_2600
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA_2600 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA_2600 *PCACTCTX_SECTION_KEYED_DATA_2600
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA_2600 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
     *     PVOID lpInformation;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionLength;
     *     PVOID lpSectionGlobalDataBase;
     *     ULONG ulSectionGlobalDataLength;
     * } *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA {
     *     ULONG cbSize;
     *     ULONG ulDataFormatVersion;
     *     PVOID lpData;
     *     ULONG ulLength;
     *     PVOID lpSectionGlobalData;
     *     ULONG ulSectionGlobalDataLength;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionTotalLength;
     *     HANDLE hActCtx;
     *     ULONG ulAssemblyRosterIndex;
     *     ULONG ulFlags;
     *     ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
     * } *PACTCTX_SECTION_KEYED_DATA
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA *PCACTCTX_SECTION_KEYED_DATA
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA = wgl_h.C_POINTER;

    private static class FindActCtxSectionStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindActCtxSectionStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionStringA$descriptor() {
        return FindActCtxSectionStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionStringA$handle() {
        return FindActCtxSectionStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MemorySegment FindActCtxSectionStringA$address() {
        return FindActCtxSectionStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionStringA(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpStringToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionStringA", dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindActCtxSectionStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindActCtxSectionStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionStringW$descriptor() {
        return FindActCtxSectionStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionStringW$handle() {
        return FindActCtxSectionStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MemorySegment FindActCtxSectionStringW$address() {
        return FindActCtxSectionStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionStringW(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpStringToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionStringW", dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindActCtxSectionGuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindActCtxSectionGuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionGuid$descriptor() {
        return FindActCtxSectionGuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionGuid$handle() {
        return FindActCtxSectionGuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MemorySegment FindActCtxSectionGuid$address() {
        return FindActCtxSectionGuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionGuid(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpGuidToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionGuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionGuid", dwFlags, lpExtensionGuid, ulSectionId, lpGuidToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpGuidToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
     *     HANDLE hActCtx;
     *     DWORD dwFlags;
     * } *PACTIVATION_CONTEXT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_BASIC_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
     *     HANDLE hActCtx;
     *     DWORD dwFlags;
     * } *PCACTIVATION_CONTEXT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_BASIC_INFORMATION = wgl_h.C_POINTER;

    private static class QueryActCtxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryActCtxW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static FunctionDescriptor QueryActCtxW$descriptor() {
        return QueryActCtxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static MethodHandle QueryActCtxW$handle() {
        return QueryActCtxW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static MemorySegment QueryActCtxW$address() {
        return QueryActCtxW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static int QueryActCtxW(int dwFlags, MemorySegment hActCtx, MemorySegment pvSubInstance, int ulInfoClass, MemorySegment pvBuffer, long cbBuffer, MemorySegment pcbWrittenOrRequired) {
        var mh$ = QueryActCtxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryActCtxW", dwFlags, hActCtx, pvSubInstance, ulInfoClass, pvBuffer, cbBuffer, pcbWrittenOrRequired);
            }
            return (int)mh$.invokeExact(dwFlags, hActCtx, pvSubInstance, ulInfoClass, pvBuffer, cbBuffer, pcbWrittenOrRequired);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSGetActiveConsoleSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WTSGetActiveConsoleSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static FunctionDescriptor WTSGetActiveConsoleSessionId$descriptor() {
        return WTSGetActiveConsoleSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static MethodHandle WTSGetActiveConsoleSessionId$handle() {
        return WTSGetActiveConsoleSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static MemorySegment WTSGetActiveConsoleSessionId$address() {
        return WTSGetActiveConsoleSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static int WTSGetActiveConsoleSessionId() {
        var mh$ = WTSGetActiveConsoleSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSGetActiveConsoleSessionId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSGetServiceSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WTSGetServiceSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static FunctionDescriptor WTSGetServiceSessionId$descriptor() {
        return WTSGetServiceSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static MethodHandle WTSGetServiceSessionId$handle() {
        return WTSGetServiceSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static MemorySegment WTSGetServiceSessionId$address() {
        return WTSGetServiceSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static int WTSGetServiceSessionId() {
        var mh$ = WTSGetServiceSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSGetServiceSessionId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSIsServerContainer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WTSIsServerContainer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static FunctionDescriptor WTSIsServerContainer$descriptor() {
        return WTSIsServerContainer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static MethodHandle WTSIsServerContainer$handle() {
        return WTSIsServerContainer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static MemorySegment WTSIsServerContainer$address() {
        return WTSIsServerContainer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static byte WTSIsServerContainer() {
        var mh$ = WTSIsServerContainer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSIsServerContainer");
            }
            return (byte)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetActiveProcessorGroupCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetActiveProcessorGroupCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static FunctionDescriptor GetActiveProcessorGroupCount$descriptor() {
        return GetActiveProcessorGroupCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static MethodHandle GetActiveProcessorGroupCount$handle() {
        return GetActiveProcessorGroupCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static MemorySegment GetActiveProcessorGroupCount$address() {
        return GetActiveProcessorGroupCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static short GetActiveProcessorGroupCount() {
        var mh$ = GetActiveProcessorGroupCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetActiveProcessorGroupCount");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMaximumProcessorGroupCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMaximumProcessorGroupCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static FunctionDescriptor GetMaximumProcessorGroupCount$descriptor() {
        return GetMaximumProcessorGroupCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static MethodHandle GetMaximumProcessorGroupCount$handle() {
        return GetMaximumProcessorGroupCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static MemorySegment GetMaximumProcessorGroupCount$address() {
        return GetMaximumProcessorGroupCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static short GetMaximumProcessorGroupCount() {
        var mh$ = GetMaximumProcessorGroupCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMaximumProcessorGroupCount");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetActiveProcessorCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetActiveProcessorCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static FunctionDescriptor GetActiveProcessorCount$descriptor() {
        return GetActiveProcessorCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static MethodHandle GetActiveProcessorCount$handle() {
        return GetActiveProcessorCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static MemorySegment GetActiveProcessorCount$address() {
        return GetActiveProcessorCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static int GetActiveProcessorCount(short GroupNumber) {
        var mh$ = GetActiveProcessorCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetActiveProcessorCount", GroupNumber);
            }
            return (int)mh$.invokeExact(GroupNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMaximumProcessorCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMaximumProcessorCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static FunctionDescriptor GetMaximumProcessorCount$descriptor() {
        return GetMaximumProcessorCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static MethodHandle GetMaximumProcessorCount$handle() {
        return GetMaximumProcessorCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static MemorySegment GetMaximumProcessorCount$address() {
        return GetMaximumProcessorCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static int GetMaximumProcessorCount(short GroupNumber) {
        var mh$ = GetMaximumProcessorCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMaximumProcessorCount", GroupNumber);
            }
            return (int)mh$.invokeExact(GroupNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProcessorNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_CHAR,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNumaProcessorNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProcessorNode$descriptor() {
        return GetNumaProcessorNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProcessorNode$handle() {
        return GetNumaProcessorNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static MemorySegment GetNumaProcessorNode$address() {
        return GetNumaProcessorNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static int GetNumaProcessorNode(byte Processor, MemorySegment NodeNumber) {
        var mh$ = GetNumaProcessorNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProcessorNode", Processor, NodeNumber);
            }
            return (int)mh$.invokeExact(Processor, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeNumberFromHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNumaNodeNumberFromHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaNodeNumberFromHandle$descriptor() {
        return GetNumaNodeNumberFromHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static MethodHandle GetNumaNodeNumberFromHandle$handle() {
        return GetNumaNodeNumberFromHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static MemorySegment GetNumaNodeNumberFromHandle$address() {
        return GetNumaNodeNumberFromHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static int GetNumaNodeNumberFromHandle(MemorySegment hFile, MemorySegment NodeNumber) {
        var mh$ = GetNumaNodeNumberFromHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeNumberFromHandle", hFile, NodeNumber);
            }
            return (int)mh$.invokeExact(hFile, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProcessorNodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNumaProcessorNodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProcessorNodeEx$descriptor() {
        return GetNumaProcessorNodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProcessorNodeEx$handle() {
        return GetNumaProcessorNodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static MemorySegment GetNumaProcessorNodeEx$address() {
        return GetNumaProcessorNodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static int GetNumaProcessorNodeEx(MemorySegment Processor, MemorySegment NodeNumber) {
        var mh$ = GetNumaProcessorNodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProcessorNodeEx", Processor, NodeNumber);
            }
            return (int)mh$.invokeExact(Processor, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeProcessorMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_CHAR,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNumaNodeProcessorMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static FunctionDescriptor GetNumaNodeProcessorMask$descriptor() {
        return GetNumaNodeProcessorMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static MethodHandle GetNumaNodeProcessorMask$handle() {
        return GetNumaNodeProcessorMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static MemorySegment GetNumaNodeProcessorMask$address() {
        return GetNumaNodeProcessorMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static int GetNumaNodeProcessorMask(byte Node, MemorySegment ProcessorMask) {
        var mh$ = GetNumaNodeProcessorMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeProcessorMask", Node, ProcessorMask);
            }
            return (int)mh$.invokeExact(Node, ProcessorMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaAvailableMemoryNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_CHAR,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNumaAvailableMemoryNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static FunctionDescriptor GetNumaAvailableMemoryNode$descriptor() {
        return GetNumaAvailableMemoryNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MethodHandle GetNumaAvailableMemoryNode$handle() {
        return GetNumaAvailableMemoryNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MemorySegment GetNumaAvailableMemoryNode$address() {
        return GetNumaAvailableMemoryNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static int GetNumaAvailableMemoryNode(byte Node, MemorySegment AvailableBytes) {
        var mh$ = GetNumaAvailableMemoryNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaAvailableMemoryNode", Node, AvailableBytes);
            }
            return (int)mh$.invokeExact(Node, AvailableBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaAvailableMemoryNodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNumaAvailableMemoryNodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static FunctionDescriptor GetNumaAvailableMemoryNodeEx$descriptor() {
        return GetNumaAvailableMemoryNodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MethodHandle GetNumaAvailableMemoryNodeEx$handle() {
        return GetNumaAvailableMemoryNodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MemorySegment GetNumaAvailableMemoryNodeEx$address() {
        return GetNumaAvailableMemoryNodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static int GetNumaAvailableMemoryNodeEx(short Node, MemorySegment AvailableBytes) {
        var mh$ = GetNumaAvailableMemoryNodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaAvailableMemoryNodeEx", Node, AvailableBytes);
            }
            return (int)mh$.invokeExact(Node, AvailableBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProximityNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNumaProximityNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProximityNode$descriptor() {
        return GetNumaProximityNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProximityNode$handle() {
        return GetNumaProximityNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static MemorySegment GetNumaProximityNode$address() {
        return GetNumaProximityNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static int GetNumaProximityNode(int ProximityId, MemorySegment NodeNumber) {
        var mh$ = GetNumaProximityNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProximityNode", ProximityId, NodeNumber);
            }
            return (int)mh$.invokeExact(ProximityId, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterApplicationRecoveryCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegisterApplicationRecoveryCallback$descriptor() {
        return RegisterApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegisterApplicationRecoveryCallback$handle() {
        return RegisterApplicationRecoveryCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static MemorySegment RegisterApplicationRecoveryCallback$address() {
        return RegisterApplicationRecoveryCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static int RegisterApplicationRecoveryCallback(MemorySegment pRecoveyCallback, MemorySegment pvParameter, int dwPingInterval, int dwFlags) {
        var mh$ = RegisterApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterApplicationRecoveryCallback", pRecoveyCallback, pvParameter, dwPingInterval, dwFlags);
            }
            return (int)mh$.invokeExact(pRecoveyCallback, pvParameter, dwPingInterval, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterApplicationRecoveryCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static FunctionDescriptor UnregisterApplicationRecoveryCallback$descriptor() {
        return UnregisterApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static MethodHandle UnregisterApplicationRecoveryCallback$handle() {
        return UnregisterApplicationRecoveryCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static MemorySegment UnregisterApplicationRecoveryCallback$address() {
        return UnregisterApplicationRecoveryCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static int UnregisterApplicationRecoveryCallback() {
        var mh$ = UnregisterApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterApplicationRecoveryCallback");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterApplicationRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterApplicationRestart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegisterApplicationRestart$descriptor() {
        return RegisterApplicationRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegisterApplicationRestart$handle() {
        return RegisterApplicationRestart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static MemorySegment RegisterApplicationRestart$address() {
        return RegisterApplicationRestart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static int RegisterApplicationRestart(MemorySegment pwzCommandline, int dwFlags) {
        var mh$ = RegisterApplicationRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterApplicationRestart", pwzCommandline, dwFlags);
            }
            return (int)mh$.invokeExact(pwzCommandline, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterApplicationRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterApplicationRestart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static FunctionDescriptor UnregisterApplicationRestart$descriptor() {
        return UnregisterApplicationRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static MethodHandle UnregisterApplicationRestart$handle() {
        return UnregisterApplicationRestart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static MemorySegment UnregisterApplicationRestart$address() {
        return UnregisterApplicationRestart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static int UnregisterApplicationRestart() {
        var mh$ = UnregisterApplicationRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterApplicationRestart");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetApplicationRecoveryCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static FunctionDescriptor GetApplicationRecoveryCallback$descriptor() {
        return GetApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static MethodHandle GetApplicationRecoveryCallback$handle() {
        return GetApplicationRecoveryCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static MemorySegment GetApplicationRecoveryCallback$address() {
        return GetApplicationRecoveryCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static int GetApplicationRecoveryCallback(MemorySegment hProcess, MemorySegment pRecoveryCallback, MemorySegment ppvParameter, MemorySegment pdwPingInterval, MemorySegment pdwFlags) {
        var mh$ = GetApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetApplicationRecoveryCallback", hProcess, pRecoveryCallback, ppvParameter, pdwPingInterval, pdwFlags);
            }
            return (int)mh$.invokeExact(hProcess, pRecoveryCallback, ppvParameter, pdwPingInterval, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetApplicationRestartSettings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetApplicationRestartSettings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static FunctionDescriptor GetApplicationRestartSettings$descriptor() {
        return GetApplicationRestartSettings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static MethodHandle GetApplicationRestartSettings$handle() {
        return GetApplicationRestartSettings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static MemorySegment GetApplicationRestartSettings$address() {
        return GetApplicationRestartSettings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static int GetApplicationRestartSettings(MemorySegment hProcess, MemorySegment pwzCommandline, MemorySegment pcchSize, MemorySegment pdwFlags) {
        var mh$ = GetApplicationRestartSettings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetApplicationRestartSettings", hProcess, pwzCommandline, pcchSize, pdwFlags);
            }
            return (int)mh$.invokeExact(hProcess, pwzCommandline, pcchSize, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ApplicationRecoveryInProgress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ApplicationRecoveryInProgress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static FunctionDescriptor ApplicationRecoveryInProgress$descriptor() {
        return ApplicationRecoveryInProgress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static MethodHandle ApplicationRecoveryInProgress$handle() {
        return ApplicationRecoveryInProgress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static MemorySegment ApplicationRecoveryInProgress$address() {
        return ApplicationRecoveryInProgress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static int ApplicationRecoveryInProgress(MemorySegment pbCancelled) {
        var mh$ = ApplicationRecoveryInProgress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ApplicationRecoveryInProgress", pbCancelled);
            }
            return (int)mh$.invokeExact(pbCancelled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ApplicationRecoveryFinished {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ApplicationRecoveryFinished");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static FunctionDescriptor ApplicationRecoveryFinished$descriptor() {
        return ApplicationRecoveryFinished.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static MethodHandle ApplicationRecoveryFinished$handle() {
        return ApplicationRecoveryFinished.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static MemorySegment ApplicationRecoveryFinished$address() {
        return ApplicationRecoveryFinished.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static void ApplicationRecoveryFinished(int bSuccess) {
        var mh$ = ApplicationRecoveryFinished.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ApplicationRecoveryFinished", bSuccess);
            }
            mh$.invokeExact(bSuccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_BASIC_INFO {
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     DWORD FileAttributes;
     * } *PFILE_BASIC_INFO
     * }
     */
    public static final AddressLayout PFILE_BASIC_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STANDARD_INFO {
     *     LARGE_INTEGER AllocationSize;
     *     LARGE_INTEGER EndOfFile;
     *     DWORD NumberOfLinks;
     *     BOOLEAN DeletePending;
     *     BOOLEAN Directory;
     * } *PFILE_STANDARD_INFO
     * }
     */
    public static final AddressLayout PFILE_STANDARD_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_NAME_INFO {
     *     DWORD FileNameLength;
     *     WCHAR FileName[1];
     * } *PFILE_NAME_INFO
     * }
     */
    public static final AddressLayout PFILE_NAME_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_CASE_SENSITIVE_INFO {
     *     ULONG Flags;
     * } *PFILE_CASE_SENSITIVE_INFO
     * }
     */
    public static final AddressLayout PFILE_CASE_SENSITIVE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_RENAME_INFO {
     *     union {
     *         BOOLEAN ReplaceIfExists;
     *         DWORD Flags;
     *     };
     *     HANDLE RootDirectory;
     *     DWORD FileNameLength;
     *     WCHAR FileName[1];
     * } *PFILE_RENAME_INFO
     * }
     */
    public static final AddressLayout PFILE_RENAME_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ALLOCATION_INFO {
     *     LARGE_INTEGER AllocationSize;
     * } *PFILE_ALLOCATION_INFO
     * }
     */
    public static final AddressLayout PFILE_ALLOCATION_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_END_OF_FILE_INFO {
     *     LARGE_INTEGER EndOfFile;
     * } *PFILE_END_OF_FILE_INFO
     * }
     */
    public static final AddressLayout PFILE_END_OF_FILE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STREAM_INFO {
     *     DWORD NextEntryOffset;
     *     DWORD StreamNameLength;
     *     LARGE_INTEGER StreamSize;
     *     LARGE_INTEGER StreamAllocationSize;
     *     WCHAR StreamName[1];
     * } *PFILE_STREAM_INFO
     * }
     */
    public static final AddressLayout PFILE_STREAM_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_COMPRESSION_INFO {
     *     LARGE_INTEGER CompressedFileSize;
     *     WORD CompressionFormat;
     *     UCHAR CompressionUnitShift;
     *     UCHAR ChunkShift;
     *     UCHAR ClusterShift;
     *     UCHAR Reserved[3];
     * } *PFILE_COMPRESSION_INFO
     * }
     */
    public static final AddressLayout PFILE_COMPRESSION_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ATTRIBUTE_TAG_INFO {
     *     DWORD FileAttributes;
     *     DWORD ReparseTag;
     * } *PFILE_ATTRIBUTE_TAG_INFO
     * }
     */
    public static final AddressLayout PFILE_ATTRIBUTE_TAG_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_DISPOSITION_INFO {
     *     BOOLEAN DeleteFileA;
     * } *PFILE_DISPOSITION_INFO
     * }
     */
    public static final AddressLayout PFILE_DISPOSITION_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_DISPOSITION_INFO_EX {
     *     DWORD Flags;
     * } *PFILE_DISPOSITION_INFO_EX
     * }
     */
    public static final AddressLayout PFILE_DISPOSITION_INFO_EX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_BOTH_DIR_INFO {
     *     DWORD NextEntryOffset;
     *     DWORD FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     DWORD FileAttributes;
     *     DWORD FileNameLength;
     *     DWORD EaSize;
     *     CCHAR ShortNameLength;
     *     WCHAR ShortName[12];
     *     LARGE_INTEGER FileId;
     *     WCHAR FileName[1];
     * } *PFILE_ID_BOTH_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_BOTH_DIR_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_FULL_DIR_INFO {
     *     ULONG NextEntryOffset;
     *     ULONG FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     ULONG FileAttributes;
     *     ULONG FileNameLength;
     *     ULONG EaSize;
     *     WCHAR FileName[1];
     * } *PFILE_FULL_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_FULL_DIR_INFO = wgl_h.C_POINTER;
    private static final int IoPriorityHintVeryLow = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintVeryLow = 0
     * }
     */
    public static int IoPriorityHintVeryLow() {
        return IoPriorityHintVeryLow;
    }
    private static final int IoPriorityHintLow = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintLow = 1
     * }
     */
    public static int IoPriorityHintLow() {
        return IoPriorityHintLow;
    }
    private static final int IoPriorityHintNormal = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintNormal = 2
     * }
     */
    public static int IoPriorityHintNormal() {
        return IoPriorityHintNormal;
    }
    private static final int MaximumIoPriorityHintType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.MaximumIoPriorityHintType = 3
     * }
     */
    public static int MaximumIoPriorityHintType() {
        return MaximumIoPriorityHintType;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_IO_PRIORITY_HINT_INFO {
     *     PRIORITY_HINT PriorityHint;
     * } *PFILE_IO_PRIORITY_HINT_INFO
     * }
     */
    public static final AddressLayout PFILE_IO_PRIORITY_HINT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ALIGNMENT_INFO {
     *     ULONG AlignmentRequirement;
     * } *PFILE_ALIGNMENT_INFO
     * }
     */
    public static final AddressLayout PFILE_ALIGNMENT_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STORAGE_INFO {
     *     ULONG LogicalBytesPerSector;
     *     ULONG PhysicalBytesPerSectorForAtomicity;
     *     ULONG PhysicalBytesPerSectorForPerformance;
     *     ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
     *     ULONG Flags;
     *     ULONG ByteOffsetForSectorAlignment;
     *     ULONG ByteOffsetForPartitionAlignment;
     * } *PFILE_STORAGE_INFO
     * }
     */
    public static final AddressLayout PFILE_STORAGE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_INFO {
     *     ULONGLONG VolumeSerialNumber;
     *     FILE_ID_128 FileId;
     * } *PFILE_ID_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_EXTD_DIR_INFO {
     *     ULONG NextEntryOffset;
     *     ULONG FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     ULONG FileAttributes;
     *     ULONG FileNameLength;
     *     ULONG EaSize;
     *     ULONG ReparsePointTag;
     *     FILE_ID_128 FileId;
     *     WCHAR FileName[1];
     * } *PFILE_ID_EXTD_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_EXTD_DIR_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_REMOTE_PROTOCOL_INFO {
     *     USHORT StructureVersion;
     *     USHORT StructureSize;
     *     ULONG Protocol;
     *     USHORT ProtocolMajorVersion;
     *     USHORT ProtocolMinorVersion;
     *     USHORT ProtocolRevision;
     *     USHORT Reserved;
     *     ULONG Flags;
     *     struct {
     *         ULONG Reserved[8];
     *     } GenericReserved;
     *     union {
     *         struct {
     *             struct {
     *                 ULONG Capabilities;
     *             } Server;
     *             struct {
     *                 ULONG Capabilities;
     *                 ULONG CachingFlags;
     *             } Share;
     *         } Smb2;
     *         ULONG Reserved[16];
     *     } ProtocolSpecific;
     * } *PFILE_REMOTE_PROTOCOL_INFO
     * }
     */
    public static final AddressLayout PFILE_REMOTE_PROTOCOL_INFO = wgl_h.C_POINTER;

    private static class GetFileInformationByHandleEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileInformationByHandleEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static FunctionDescriptor GetFileInformationByHandleEx$descriptor() {
        return GetFileInformationByHandleEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MethodHandle GetFileInformationByHandleEx$handle() {
        return GetFileInformationByHandleEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MemorySegment GetFileInformationByHandleEx$address() {
        return GetFileInformationByHandleEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static int GetFileInformationByHandleEx(MemorySegment hFile, int FileInformationClass, MemorySegment lpFileInformation, int dwBufferSize) {
        var mh$ = GetFileInformationByHandleEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileInformationByHandleEx", hFile, FileInformationClass, lpFileInformation, dwBufferSize);
            }
            return (int)mh$.invokeExact(hFile, FileInformationClass, lpFileInformation, dwBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FileIdType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.FileIdType = 0
     * }
     */
    public static int FileIdType() {
        return FileIdType;
    }
    private static final int ObjectIdType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.ObjectIdType = 1
     * }
     */
    public static int ObjectIdType() {
        return ObjectIdType;
    }
    private static final int ExtendedFileIdType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.ExtendedFileIdType = 2
     * }
     */
    public static int ExtendedFileIdType() {
        return ExtendedFileIdType;
    }
    private static final int MaximumFileIdType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.MaximumFileIdType = 3
     * }
     */
    public static int MaximumFileIdType() {
        return MaximumFileIdType;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _FILE_ID_TYPE {
     *     FileIdType,
     *     ObjectIdType,
     *     ExtendedFileIdType,
     *     MaximumFileIdType
     * } *PFILE_ID_TYPE
     * }
     */
    public static final AddressLayout PFILE_ID_TYPE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct FILE_ID_DESCRIPTOR {
     *     DWORD dwSize;
     *     FILE_ID_TYPE Type;
     *     union {
     *         LARGE_INTEGER FileId;
     *         GUID ObjectId;
     *         FILE_ID_128 ExtendedFileId;
     *     };
     * } *LPFILE_ID_DESCRIPTOR
     * }
     */
    public static final AddressLayout LPFILE_ID_DESCRIPTOR = wgl_h.C_POINTER;

    private static class OpenFileById {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenFileById");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static FunctionDescriptor OpenFileById$descriptor() {
        return OpenFileById.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MethodHandle OpenFileById$handle() {
        return OpenFileById.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenFileById$address() {
        return OpenFileById.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenFileById(MemorySegment hVolumeHint, MemorySegment lpFileId, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwFlagsAndAttributes) {
        var mh$ = OpenFileById.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileById", hVolumeHint, lpFileId, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlagsAndAttributes);
            }
            return (MemorySegment)mh$.invokeExact(hVolumeHint, lpFileId, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlagsAndAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateSymbolicLinkA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkA$descriptor() {
        return CreateSymbolicLinkA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle CreateSymbolicLinkA$handle() {
        return CreateSymbolicLinkA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MemorySegment CreateSymbolicLinkA$address() {
        return CreateSymbolicLinkA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static byte CreateSymbolicLinkA(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags) {
        var mh$ = CreateSymbolicLinkA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkA", lpSymlinkFileName, lpTargetFileName, dwFlags);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateSymbolicLinkW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkW$descriptor() {
        return CreateSymbolicLinkW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle CreateSymbolicLinkW$handle() {
        return CreateSymbolicLinkW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MemorySegment CreateSymbolicLinkW$address() {
        return CreateSymbolicLinkW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static byte CreateSymbolicLinkW(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags) {
        var mh$ = CreateSymbolicLinkW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkW", lpSymlinkFileName, lpTargetFileName, dwFlags);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryActCtxSettingsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryActCtxSettingsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static FunctionDescriptor QueryActCtxSettingsW$descriptor() {
        return QueryActCtxSettingsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static MethodHandle QueryActCtxSettingsW$handle() {
        return QueryActCtxSettingsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static MemorySegment QueryActCtxSettingsW$address() {
        return QueryActCtxSettingsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static int QueryActCtxSettingsW(int dwFlags, MemorySegment hActCtx, MemorySegment settingsNameSpace, MemorySegment settingName, MemorySegment pvBuffer, long dwBuffer, MemorySegment pdwWrittenOrRequired) {
        var mh$ = QueryActCtxSettingsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryActCtxSettingsW", dwFlags, hActCtx, settingsNameSpace, settingName, pvBuffer, dwBuffer, pdwWrittenOrRequired);
            }
            return (int)mh$.invokeExact(dwFlags, hActCtx, settingsNameSpace, settingName, pvBuffer, dwBuffer, pdwWrittenOrRequired);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateSymbolicLinkTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkTransactedA$descriptor() {
        return CreateSymbolicLinkTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateSymbolicLinkTransactedA$handle() {
        return CreateSymbolicLinkTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateSymbolicLinkTransactedA$address() {
        return CreateSymbolicLinkTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static byte CreateSymbolicLinkTransactedA(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags, MemorySegment hTransaction) {
        var mh$ = CreateSymbolicLinkTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkTransactedA", lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateSymbolicLinkTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkTransactedW$descriptor() {
        return CreateSymbolicLinkTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateSymbolicLinkTransactedW$handle() {
        return CreateSymbolicLinkTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateSymbolicLinkTransactedW$address() {
        return CreateSymbolicLinkTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static byte CreateSymbolicLinkTransactedW(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags, MemorySegment hTransaction) {
        var mh$ = CreateSymbolicLinkTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkTransactedW", lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplacePartitionUnit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReplacePartitionUnit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static FunctionDescriptor ReplacePartitionUnit$descriptor() {
        return ReplacePartitionUnit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static MethodHandle ReplacePartitionUnit$handle() {
        return ReplacePartitionUnit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static MemorySegment ReplacePartitionUnit$address() {
        return ReplacePartitionUnit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static int ReplacePartitionUnit(MemorySegment TargetPartition, MemorySegment SparePartition, int Flags) {
        var mh$ = ReplacePartitionUnit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplacePartitionUnit", TargetPartition, SparePartition, Flags);
            }
            return (int)mh$.invokeExact(TargetPartition, SparePartition, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddSecureMemoryCacheCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddSecureMemoryCacheCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static FunctionDescriptor AddSecureMemoryCacheCallback$descriptor() {
        return AddSecureMemoryCacheCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MethodHandle AddSecureMemoryCacheCallback$handle() {
        return AddSecureMemoryCacheCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MemorySegment AddSecureMemoryCacheCallback$address() {
        return AddSecureMemoryCacheCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static int AddSecureMemoryCacheCallback(MemorySegment pfnCallBack) {
        var mh$ = AddSecureMemoryCacheCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddSecureMemoryCacheCallback", pfnCallBack);
            }
            return (int)mh$.invokeExact(pfnCallBack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveSecureMemoryCacheCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveSecureMemoryCacheCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static FunctionDescriptor RemoveSecureMemoryCacheCallback$descriptor() {
        return RemoveSecureMemoryCacheCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MethodHandle RemoveSecureMemoryCacheCallback$handle() {
        return RemoveSecureMemoryCacheCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MemorySegment RemoveSecureMemoryCacheCallback$address() {
        return RemoveSecureMemoryCacheCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static int RemoveSecureMemoryCacheCallback(MemorySegment pfnCallBack) {
        var mh$ = RemoveSecureMemoryCacheCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveSecureMemoryCacheCallback", pfnCallBack);
            }
            return (int)mh$.invokeExact(pfnCallBack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static FunctionDescriptor CopyContext$descriptor() {
        return CopyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static MethodHandle CopyContext$handle() {
        return CopyContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static MemorySegment CopyContext$address() {
        return CopyContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static int CopyContext(MemorySegment Destination, int ContextFlags, MemorySegment Source) {
        var mh$ = CopyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyContext", Destination, ContextFlags, Source);
            }
            return (int)mh$.invokeExact(Destination, ContextFlags, Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static FunctionDescriptor InitializeContext$descriptor() {
        return InitializeContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static MethodHandle InitializeContext$handle() {
        return InitializeContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static MemorySegment InitializeContext$address() {
        return InitializeContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static int InitializeContext(MemorySegment Buffer, int ContextFlags, MemorySegment Context, MemorySegment ContextLength) {
        var mh$ = InitializeContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeContext", Buffer, ContextFlags, Context, ContextLength);
            }
            return (int)mh$.invokeExact(Buffer, ContextFlags, Context, ContextLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeContext2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeContext2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static FunctionDescriptor InitializeContext2$descriptor() {
        return InitializeContext2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static MethodHandle InitializeContext2$handle() {
        return InitializeContext2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static MemorySegment InitializeContext2$address() {
        return InitializeContext2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static int InitializeContext2(MemorySegment Buffer, int ContextFlags, MemorySegment Context, MemorySegment ContextLength, long XStateCompactionMask) {
        var mh$ = InitializeContext2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeContext2", Buffer, ContextFlags, Context, ContextLength, XStateCompactionMask);
            }
            return (int)mh$.invokeExact(Buffer, ContextFlags, Context, ContextLength, XStateCompactionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnabledXStateFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnabledXStateFeatures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static FunctionDescriptor GetEnabledXStateFeatures$descriptor() {
        return GetEnabledXStateFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static MethodHandle GetEnabledXStateFeatures$handle() {
        return GetEnabledXStateFeatures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static MemorySegment GetEnabledXStateFeatures$address() {
        return GetEnabledXStateFeatures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static long GetEnabledXStateFeatures() {
        var mh$ = GetEnabledXStateFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnabledXStateFeatures");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetXStateFeaturesMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetXStateFeaturesMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static FunctionDescriptor GetXStateFeaturesMask$descriptor() {
        return GetXStateFeaturesMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static MethodHandle GetXStateFeaturesMask$handle() {
        return GetXStateFeaturesMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static MemorySegment GetXStateFeaturesMask$address() {
        return GetXStateFeaturesMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static int GetXStateFeaturesMask(MemorySegment Context, MemorySegment FeatureMask) {
        var mh$ = GetXStateFeaturesMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetXStateFeaturesMask", Context, FeatureMask);
            }
            return (int)mh$.invokeExact(Context, FeatureMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocateXStateFeature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocateXStateFeature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static FunctionDescriptor LocateXStateFeature$descriptor() {
        return LocateXStateFeature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static MethodHandle LocateXStateFeature$handle() {
        return LocateXStateFeature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static MemorySegment LocateXStateFeature$address() {
        return LocateXStateFeature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static MemorySegment LocateXStateFeature(MemorySegment Context, int FeatureId, MemorySegment Length) {
        var mh$ = LocateXStateFeature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocateXStateFeature", Context, FeatureId, Length);
            }
            return (MemorySegment)mh$.invokeExact(Context, FeatureId, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetXStateFeaturesMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetXStateFeaturesMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static FunctionDescriptor SetXStateFeaturesMask$descriptor() {
        return SetXStateFeaturesMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static MethodHandle SetXStateFeaturesMask$handle() {
        return SetXStateFeaturesMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static MemorySegment SetXStateFeaturesMask$address() {
        return SetXStateFeaturesMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static int SetXStateFeaturesMask(MemorySegment Context, long FeatureMask) {
        var mh$ = SetXStateFeaturesMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetXStateFeaturesMask", Context, FeatureMask);
            }
            return (int)mh$.invokeExact(Context, FeatureMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnableThreadProfiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static FunctionDescriptor EnableThreadProfiling$descriptor() {
        return EnableThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static MethodHandle EnableThreadProfiling$handle() {
        return EnableThreadProfiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static MemorySegment EnableThreadProfiling$address() {
        return EnableThreadProfiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static int EnableThreadProfiling(MemorySegment ThreadHandle, int Flags, long HardwareCounters, MemorySegment PerformanceDataHandle) {
        var mh$ = EnableThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableThreadProfiling", ThreadHandle, Flags, HardwareCounters, PerformanceDataHandle);
            }
            return (int)mh$.invokeExact(ThreadHandle, Flags, HardwareCounters, PerformanceDataHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisableThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DisableThreadProfiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static FunctionDescriptor DisableThreadProfiling$descriptor() {
        return DisableThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static MethodHandle DisableThreadProfiling$handle() {
        return DisableThreadProfiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static MemorySegment DisableThreadProfiling$address() {
        return DisableThreadProfiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static int DisableThreadProfiling(MemorySegment PerformanceDataHandle) {
        var mh$ = DisableThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableThreadProfiling", PerformanceDataHandle);
            }
            return (int)mh$.invokeExact(PerformanceDataHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryThreadProfiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static FunctionDescriptor QueryThreadProfiling$descriptor() {
        return QueryThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static MethodHandle QueryThreadProfiling$handle() {
        return QueryThreadProfiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static MemorySegment QueryThreadProfiling$address() {
        return QueryThreadProfiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static int QueryThreadProfiling(MemorySegment ThreadHandle, MemorySegment Enabled) {
        var mh$ = QueryThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryThreadProfiling", ThreadHandle, Enabled);
            }
            return (int)mh$.invokeExact(ThreadHandle, Enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadThreadProfilingData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReadThreadProfilingData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static FunctionDescriptor ReadThreadProfilingData$descriptor() {
        return ReadThreadProfilingData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static MethodHandle ReadThreadProfilingData$handle() {
        return ReadThreadProfilingData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static MemorySegment ReadThreadProfilingData$address() {
        return ReadThreadProfilingData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static int ReadThreadProfilingData(MemorySegment PerformanceDataHandle, int Flags, MemorySegment PerformanceData) {
        var mh$ = ReadThreadProfilingData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadThreadProfilingData", PerformanceDataHandle, Flags, PerformanceData);
            }
            return (int)mh$.invokeExact(PerformanceDataHandle, Flags, PerformanceData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseCustomSystemEventTrigger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RaiseCustomSystemEventTrigger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static FunctionDescriptor RaiseCustomSystemEventTrigger$descriptor() {
        return RaiseCustomSystemEventTrigger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static MethodHandle RaiseCustomSystemEventTrigger$handle() {
        return RaiseCustomSystemEventTrigger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static MemorySegment RaiseCustomSystemEventTrigger$address() {
        return RaiseCustomSystemEventTrigger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static int RaiseCustomSystemEventTrigger(MemorySegment CustomSystemEventTriggerConfig) {
        var mh$ = RaiseCustomSystemEventTrigger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseCustomSystemEventTrigger", CustomSystemEventTriggerConfig);
            }
            return (int)mh$.invokeExact(CustomSystemEventTriggerConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DRAWPATRECT {
     *     POINT ptPosition;
     *     POINT ptSize;
     *     WORD wStyle;
     *     WORD wPattern;
     * } *PDRAWPATRECT
     * }
     */
    public static final AddressLayout PDRAWPATRECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSINJECTDATA {
     *     DWORD DataBytes;
     *     WORD InjectionPoint;
     *     WORD PageNumber;
     * } *PPSINJECTDATA
     * }
     */
    public static final AddressLayout PPSINJECTDATA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSFEATURE_OUTPUT {
     *     BOOL bPageIndependent;
     *     BOOL bSetPageDevice;
     * } *PPSFEATURE_OUTPUT
     * }
     */
    public static final AddressLayout PPSFEATURE_OUTPUT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSFEATURE_CUSTPAPER {
     *     LONG lOrientation;
     *     LONG lWidth;
     *     LONG lHeight;
     *     LONG lWidthOffset;
     *     LONG lHeightOffset;
     * } *PPSFEATURE_CUSTPAPER
     * }
     */
    public static final AddressLayout PPSFEATURE_CUSTPAPER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagXFORM {
     *     FLOAT eM11;
     *     FLOAT eM12;
     *     FLOAT eM21;
     *     FLOAT eM22;
     *     FLOAT eDx;
     *     FLOAT eDy;
     * } *PXFORM
     * }
     */
    public static final AddressLayout PXFORM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagXFORM {
     *     FLOAT eM11;
     *     FLOAT eM12;
     *     FLOAT eM21;
     *     FLOAT eM22;
     *     FLOAT eDx;
     *     FLOAT eDy;
     * } *LPXFORM
     * }
     */
    public static final AddressLayout LPXFORM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *PBITMAP
     * }
     */
    public static final AddressLayout PBITMAP = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *NPBITMAP
     * }
     */
    public static final AddressLayout NPBITMAP = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *LPBITMAP
     * }
     */
    public static final AddressLayout LPBITMAP = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *PRGBTRIPLE
     * }
     */
    public static final AddressLayout PRGBTRIPLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *NPRGBTRIPLE
     * }
     */
    public static final AddressLayout NPRGBTRIPLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *LPRGBTRIPLE
     * }
     */
    public static final AddressLayout LPRGBTRIPLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RGBQUAD *LPRGBQUAD
     * }
     */
    public static final AddressLayout LPRGBQUAD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LONG LCSCSTYPE
     * }
     */
    public static final OfInt LCSCSTYPE = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG LCSGAMUTMATCH
     * }
     */
    public static final OfInt LCSGAMUTMATCH = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long FXPT16DOT16
     * }
     */
    public static final OfInt FXPT16DOT16 = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long *LPFXPT16DOT16
     * }
     */
    public static final AddressLayout LPFXPT16DOT16 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long FXPT2DOT30
     * }
     */
    public static final OfInt FXPT2DOT30 = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long *LPFXPT2DOT30
     * }
     */
    public static final AddressLayout LPFXPT2DOT30 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CIEXYZ *LPCIEXYZ
     * }
     */
    public static final AddressLayout LPCIEXYZ = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CIEXYZTRIPLE *LPCIEXYZTRIPLE
     * }
     */
    public static final AddressLayout LPCIEXYZTRIPLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGCOLORSPACEA {
     *     DWORD lcsSignature;
     *     DWORD lcsVersion;
     *     DWORD lcsSize;
     *     LCSCSTYPE lcsCSType;
     *     LCSGAMUTMATCH lcsIntent;
     *     CIEXYZTRIPLE lcsEndpoints;
     *     DWORD lcsGammaRed;
     *     DWORD lcsGammaGreen;
     *     DWORD lcsGammaBlue;
     *     CHAR lcsFilename[260];
     * } *LPLOGCOLORSPACEA
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGCOLORSPACEW {
     *     DWORD lcsSignature;
     *     DWORD lcsVersion;
     *     DWORD lcsSize;
     *     LCSCSTYPE lcsCSType;
     *     LCSGAMUTMATCH lcsIntent;
     *     CIEXYZTRIPLE lcsEndpoints;
     *     DWORD lcsGammaRed;
     *     DWORD lcsGammaGreen;
     *     DWORD lcsGammaBlue;
     *     WCHAR lcsFilename[260];
     * } *LPLOGCOLORSPACEW
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREHEADER {
     *     DWORD bcSize;
     *     WORD bcWidth;
     *     WORD bcHeight;
     *     WORD bcPlanes;
     *     WORD bcBitCount;
     * } *LPBITMAPCOREHEADER
     * }
     */
    public static final AddressLayout LPBITMAPCOREHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREHEADER {
     *     DWORD bcSize;
     *     WORD bcWidth;
     *     WORD bcHeight;
     *     WORD bcPlanes;
     *     WORD bcBitCount;
     * } *PBITMAPCOREHEADER
     * }
     */
    public static final AddressLayout PBITMAPCOREHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFOHEADER {
     *     DWORD biSize;
     *     LONG biWidth;
     *     LONG biHeight;
     *     WORD biPlanes;
     *     WORD biBitCount;
     *     DWORD biCompression;
     *     DWORD biSizeImage;
     *     LONG biXPelsPerMeter;
     *     LONG biYPelsPerMeter;
     *     DWORD biClrUsed;
     *     DWORD biClrImportant;
     * } *LPBITMAPINFOHEADER
     * }
     */
    public static final AddressLayout LPBITMAPINFOHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFOHEADER {
     *     DWORD biSize;
     *     LONG biWidth;
     *     LONG biHeight;
     *     WORD biPlanes;
     *     WORD biBitCount;
     *     DWORD biCompression;
     *     DWORD biSizeImage;
     *     LONG biXPelsPerMeter;
     *     LONG biYPelsPerMeter;
     *     DWORD biClrUsed;
     *     DWORD biClrImportant;
     * } *PBITMAPINFOHEADER
     * }
     */
    public static final AddressLayout PBITMAPINFOHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV4Size;
     *     LONG bV4Width;
     *     LONG bV4Height;
     *     WORD bV4Planes;
     *     WORD bV4BitCount;
     *     DWORD bV4V4Compression;
     *     DWORD bV4SizeImage;
     *     LONG bV4XPelsPerMeter;
     *     LONG bV4YPelsPerMeter;
     *     DWORD bV4ClrUsed;
     *     DWORD bV4ClrImportant;
     *     DWORD bV4RedMask;
     *     DWORD bV4GreenMask;
     *     DWORD bV4BlueMask;
     *     DWORD bV4AlphaMask;
     *     DWORD bV4CSType;
     *     CIEXYZTRIPLE bV4Endpoints;
     *     DWORD bV4GammaRed;
     *     DWORD bV4GammaGreen;
     *     DWORD bV4GammaBlue;
     * } *LPBITMAPV4HEADER
     * }
     */
    public static final AddressLayout LPBITMAPV4HEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV4Size;
     *     LONG bV4Width;
     *     LONG bV4Height;
     *     WORD bV4Planes;
     *     WORD bV4BitCount;
     *     DWORD bV4V4Compression;
     *     DWORD bV4SizeImage;
     *     LONG bV4XPelsPerMeter;
     *     LONG bV4YPelsPerMeter;
     *     DWORD bV4ClrUsed;
     *     DWORD bV4ClrImportant;
     *     DWORD bV4RedMask;
     *     DWORD bV4GreenMask;
     *     DWORD bV4BlueMask;
     *     DWORD bV4AlphaMask;
     *     DWORD bV4CSType;
     *     CIEXYZTRIPLE bV4Endpoints;
     *     DWORD bV4GammaRed;
     *     DWORD bV4GammaGreen;
     *     DWORD bV4GammaBlue;
     * } *PBITMAPV4HEADER
     * }
     */
    public static final AddressLayout PBITMAPV4HEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV5Size;
     *     LONG bV5Width;
     *     LONG bV5Height;
     *     WORD bV5Planes;
     *     WORD bV5BitCount;
     *     DWORD bV5Compression;
     *     DWORD bV5SizeImage;
     *     LONG bV5XPelsPerMeter;
     *     LONG bV5YPelsPerMeter;
     *     DWORD bV5ClrUsed;
     *     DWORD bV5ClrImportant;
     *     DWORD bV5RedMask;
     *     DWORD bV5GreenMask;
     *     DWORD bV5BlueMask;
     *     DWORD bV5AlphaMask;
     *     DWORD bV5CSType;
     *     CIEXYZTRIPLE bV5Endpoints;
     *     DWORD bV5GammaRed;
     *     DWORD bV5GammaGreen;
     *     DWORD bV5GammaBlue;
     *     DWORD bV5Intent;
     *     DWORD bV5ProfileData;
     *     DWORD bV5ProfileSize;
     *     DWORD bV5Reserved;
     * } *LPBITMAPV5HEADER
     * }
     */
    public static final AddressLayout LPBITMAPV5HEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV5Size;
     *     LONG bV5Width;
     *     LONG bV5Height;
     *     WORD bV5Planes;
     *     WORD bV5BitCount;
     *     DWORD bV5Compression;
     *     DWORD bV5SizeImage;
     *     LONG bV5XPelsPerMeter;
     *     LONG bV5YPelsPerMeter;
     *     DWORD bV5ClrUsed;
     *     DWORD bV5ClrImportant;
     *     DWORD bV5RedMask;
     *     DWORD bV5GreenMask;
     *     DWORD bV5BlueMask;
     *     DWORD bV5AlphaMask;
     *     DWORD bV5CSType;
     *     CIEXYZTRIPLE bV5Endpoints;
     *     DWORD bV5GammaRed;
     *     DWORD bV5GammaGreen;
     *     DWORD bV5GammaBlue;
     *     DWORD bV5Intent;
     *     DWORD bV5ProfileData;
     *     DWORD bV5ProfileSize;
     *     DWORD bV5Reserved;
     * } *PBITMAPV5HEADER
     * }
     */
    public static final AddressLayout PBITMAPV5HEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFO {
     *     BITMAPINFOHEADER bmiHeader;
     *     RGBQUAD bmiColors[1];
     * } *LPBITMAPINFO
     * }
     */
    public static final AddressLayout LPBITMAPINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFO {
     *     BITMAPINFOHEADER bmiHeader;
     *     RGBQUAD bmiColors[1];
     * } *PBITMAPINFO
     * }
     */
    public static final AddressLayout PBITMAPINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREINFO {
     *     BITMAPCOREHEADER bmciHeader;
     *     RGBTRIPLE bmciColors[1];
     * } *LPBITMAPCOREINFO
     * }
     */
    public static final AddressLayout LPBITMAPCOREINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREINFO {
     *     BITMAPCOREHEADER bmciHeader;
     *     RGBTRIPLE bmciColors[1];
     * } *PBITMAPCOREINFO
     * }
     */
    public static final AddressLayout PBITMAPCOREINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPFILEHEADER {
     *     WORD bfType;
     *     DWORD bfSize;
     *     WORD bfReserved1;
     *     WORD bfReserved2;
     *     DWORD bfOffBits;
     * } *LPBITMAPFILEHEADER
     * }
     */
    public static final AddressLayout LPBITMAPFILEHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPFILEHEADER {
     *     WORD bfType;
     *     DWORD bfSize;
     *     WORD bfReserved1;
     *     WORD bfReserved2;
     *     DWORD bfOffBits;
     * } *PBITMAPFILEHEADER
     * }
     */
    public static final AddressLayout PBITMAPFILEHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagFONTSIGNATURE {
     *     DWORD fsUsb[4];
     *     DWORD fsCsb[2];
     * } *PFONTSIGNATURE
     * }
     */
    public static final AddressLayout PFONTSIGNATURE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagFONTSIGNATURE {
     *     DWORD fsUsb[4];
     *     DWORD fsCsb[2];
     * } *LPFONTSIGNATURE
     * }
     */
    public static final AddressLayout LPFONTSIGNATURE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *PCHARSETINFO
     * }
     */
    public static final AddressLayout PCHARSETINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *NPCHARSETINFO
     * }
     */
    public static final AddressLayout NPCHARSETINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *LPCHARSETINFO
     * }
     */
    public static final AddressLayout LPCHARSETINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOCALESIGNATURE {
     *     DWORD lsUsb[4];
     *     DWORD lsCsbDefault[2];
     *     DWORD lsCsbSupported[2];
     * } *PLOCALESIGNATURE
     * }
     */
    public static final AddressLayout PLOCALESIGNATURE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOCALESIGNATURE {
     *     DWORD lsUsb[4];
     *     DWORD lsCsbDefault[2];
     *     DWORD lsCsbSupported[2];
     * } *LPLOCALESIGNATURE
     * }
     */
    public static final AddressLayout LPLOCALESIGNATURE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHANDLETABLE {
     *     HGDIOBJ objectHandle[1];
     * } *PHANDLETABLE
     * }
     */
    public static final AddressLayout PHANDLETABLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHANDLETABLE {
     *     HGDIOBJ objectHandle[1];
     * } *LPHANDLETABLE
     * }
     */
    public static final AddressLayout LPHANDLETABLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETARECORD {
     *     DWORD rdSize;
     *     WORD rdFunction;
     *     WORD rdParm[1];
     * } *PMETARECORD
     * }
     */
    public static final AddressLayout PMETARECORD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETARECORD {
     *     DWORD rdSize;
     *     WORD rdFunction;
     *     WORD rdParm[1];
     * } *LPMETARECORD
     * }
     */
    public static final AddressLayout LPMETARECORD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMETAFILEPICT {
     *     LONG mm;
     *     LONG xExt;
     *     LONG yExt;
     *     HMETAFILE hMF;
     * } *LPMETAFILEPICT
     * }
     */
    public static final AddressLayout LPMETAFILEPICT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETAHEADER {
     *     WORD mtType;
     *     WORD mtHeaderSize;
     *     WORD mtVersion;
     *     DWORD mtSize;
     *     WORD mtNoObjects;
     *     DWORD mtMaxRecord;
     *     WORD mtNoParameters;
     * } *PMETAHEADER
     * }
     */
    public static final AddressLayout PMETAHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETAHEADER {
     *     WORD mtType;
     *     WORD mtHeaderSize;
     *     WORD mtVersion;
     *     DWORD mtSize;
     *     WORD mtNoObjects;
     *     DWORD mtMaxRecord;
     *     WORD mtNoParameters;
     * } *LPMETAHEADER
     * }
     */
    public static final AddressLayout LPMETAHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETARECORD {
     *     DWORD iType;
     *     DWORD nSize;
     *     DWORD dParm[1];
     * } *PENHMETARECORD
     * }
     */
    public static final AddressLayout PENHMETARECORD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETARECORD {
     *     DWORD iType;
     *     DWORD nSize;
     *     DWORD dParm[1];
     * } *LPENHMETARECORD
     * }
     */
    public static final AddressLayout LPENHMETARECORD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETAHEADER {
     *     DWORD iType;
     *     DWORD nSize;
     *     RECTL rclBounds;
     *     RECTL rclFrame;
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD nBytes;
     *     DWORD nRecords;
     *     WORD nHandles;
     *     WORD sReserved;
     *     DWORD nDescription;
     *     DWORD offDescription;
     *     DWORD nPalEntries;
     *     SIZEL szlDevice;
     *     SIZEL szlMillimeters;
     *     DWORD cbPixelFormat;
     *     DWORD offPixelFormat;
     *     DWORD bOpenGL;
     *     SIZEL szlMicrometers;
     * } *PENHMETAHEADER
     * }
     */
    public static final AddressLayout PENHMETAHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETAHEADER {
     *     DWORD iType;
     *     DWORD nSize;
     *     RECTL rclBounds;
     *     RECTL rclFrame;
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD nBytes;
     *     DWORD nRecords;
     *     WORD nHandles;
     *     WORD sReserved;
     *     DWORD nDescription;
     *     DWORD offDescription;
     *     DWORD nPalEntries;
     *     SIZEL szlDevice;
     *     SIZEL szlMillimeters;
     *     DWORD cbPixelFormat;
     *     DWORD offPixelFormat;
     *     DWORD bOpenGL;
     *     SIZEL szlMicrometers;
     * } *LPENHMETAHEADER
     * }
     */
    public static final AddressLayout LPENHMETAHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef BYTE BCHAR
     * }
     */
    public static final OfByte BCHAR = wgl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *PTEXTMETRICA
     * }
     */
    public static final AddressLayout PTEXTMETRICA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *NPTEXTMETRICA
     * }
     */
    public static final AddressLayout NPTEXTMETRICA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *LPTEXTMETRICA
     * }
     */
    public static final AddressLayout LPTEXTMETRICA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *PTEXTMETRICW
     * }
     */
    public static final AddressLayout PTEXTMETRICW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *NPTEXTMETRICW
     * }
     */
    public static final AddressLayout NPTEXTMETRICW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *LPTEXTMETRICW
     * }
     */
    public static final AddressLayout LPTEXTMETRICW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PTEXTMETRICA PTEXTMETRIC
     * }
     */
    public static final AddressLayout PTEXTMETRIC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPTEXTMETRICA NPTEXTMETRIC
     * }
     */
    public static final AddressLayout NPTEXTMETRIC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPTEXTMETRICA LPTEXTMETRIC
     * }
     */
    public static final AddressLayout LPTEXTMETRIC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *PNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout PNEWTEXTMETRICA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *NPNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRICA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *LPNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRICA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *PNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout PNEWTEXTMETRICW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *NPNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRICW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *LPNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRICW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PNEWTEXTMETRICA PNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout PNEWTEXTMETRIC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRIC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRIC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *PPELARRAY
     * }
     */
    public static final AddressLayout PPELARRAY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *NPPELARRAY
     * }
     */
    public static final AddressLayout NPPELARRAY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *LPPELARRAY
     * }
     */
    public static final AddressLayout LPPELARRAY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *PLOGBRUSH
     * }
     */
    public static final AddressLayout PLOGBRUSH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *NPLOGBRUSH
     * }
     */
    public static final AddressLayout NPLOGBRUSH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *LPLOGBRUSH
     * }
     */
    public static final AddressLayout LPLOGBRUSH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *PLOGBRUSH32
     * }
     */
    public static final AddressLayout PLOGBRUSH32 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *NPLOGBRUSH32
     * }
     */
    public static final AddressLayout NPLOGBRUSH32 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *LPLOGBRUSH32
     * }
     */
    public static final AddressLayout LPLOGBRUSH32 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *PPATTERN
     * }
     */
    public static final AddressLayout PPATTERN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *NPPATTERN
     * }
     */
    public static final AddressLayout NPPATTERN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *LPPATTERN
     * }
     */
    public static final AddressLayout LPPATTERN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *PLOGPEN
     * }
     */
    public static final AddressLayout PLOGPEN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *NPLOGPEN
     * }
     */
    public static final AddressLayout NPLOGPEN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *LPLOGPEN
     * }
     */
    public static final AddressLayout LPLOGPEN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *PEXTLOGPEN
     * }
     */
    public static final AddressLayout PEXTLOGPEN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *NPEXTLOGPEN
     * }
     */
    public static final AddressLayout NPEXTLOGPEN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *LPEXTLOGPEN
     * }
     */
    public static final AddressLayout LPEXTLOGPEN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *PEXTLOGPEN32
     * }
     */
    public static final AddressLayout PEXTLOGPEN32 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *NPEXTLOGPEN32
     * }
     */
    public static final AddressLayout NPEXTLOGPEN32 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *LPEXTLOGPEN32
     * }
     */
    public static final AddressLayout LPEXTLOGPEN32 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPALETTEENTRY {
     *     BYTE peRed;
     *     BYTE peGreen;
     *     BYTE peBlue;
     *     BYTE peFlags;
     * } *PPALETTEENTRY
     * }
     */
    public static final AddressLayout PPALETTEENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPALETTEENTRY {
     *     BYTE peRed;
     *     BYTE peGreen;
     *     BYTE peBlue;
     *     BYTE peFlags;
     * } *LPPALETTEENTRY
     * }
     */
    public static final AddressLayout LPPALETTEENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *PLOGPALETTE
     * }
     */
    public static final AddressLayout PLOGPALETTE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *NPLOGPALETTE
     * }
     */
    public static final AddressLayout NPLOGPALETTE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *LPLOGPALETTE
     * }
     */
    public static final AddressLayout LPLOGPALETTE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *PLOGFONTA
     * }
     */
    public static final AddressLayout PLOGFONTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *NPLOGFONTA
     * }
     */
    public static final AddressLayout NPLOGFONTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *LPLOGFONTA
     * }
     */
    public static final AddressLayout LPLOGFONTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *PLOGFONTW
     * }
     */
    public static final AddressLayout PLOGFONTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *NPLOGFONTW
     * }
     */
    public static final AddressLayout NPLOGFONTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *LPLOGFONTW
     * }
     */
    public static final AddressLayout LPLOGFONTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PLOGFONTA PLOGFONT
     * }
     */
    public static final AddressLayout PLOGFONT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPLOGFONTA NPLOGFONT
     * }
     */
    public static final AddressLayout NPLOGFONT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPLOGFONTA LPLOGFONT
     * }
     */
    public static final AddressLayout LPLOGFONT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     * } *LPENUMLOGFONTA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     * } *LPENUMLOGFONTW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTA LPENUMLOGFONT
     * }
     */
    public static final AddressLayout LPENUMLOGFONT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     BYTE elfScript[32];
     * } *LPENUMLOGFONTEXA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     WCHAR elfScript[32];
     * } *LPENUMLOGFONTEXW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPANOSE {
     *     BYTE bFamilyType;
     *     BYTE bSerifStyle;
     *     BYTE bWeight;
     *     BYTE bProportion;
     *     BYTE bContrast;
     *     BYTE bStrokeVariation;
     *     BYTE bArmStyle;
     *     BYTE bLetterform;
     *     BYTE bMidline;
     *     BYTE bXHeight;
     * } *LPPANOSE
     * }
     */
    public static final AddressLayout LPPANOSE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *PEXTLOGFONTA
     * }
     */
    public static final AddressLayout PEXTLOGFONTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *NPEXTLOGFONTA
     * }
     */
    public static final AddressLayout NPEXTLOGFONTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *LPEXTLOGFONTA
     * }
     */
    public static final AddressLayout LPEXTLOGFONTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *PEXTLOGFONTW
     * }
     */
    public static final AddressLayout PEXTLOGFONTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *NPEXTLOGFONTW
     * }
     */
    public static final AddressLayout NPEXTLOGFONTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *LPEXTLOGFONTW
     * }
     */
    public static final AddressLayout LPEXTLOGFONTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PEXTLOGFONTA PEXTLOGFONT
     * }
     */
    public static final AddressLayout PEXTLOGFONT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPEXTLOGFONTA NPEXTLOGFONT
     * }
     */
    public static final AddressLayout NPEXTLOGFONT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPEXTLOGFONTA LPEXTLOGFONT
     * }
     */
    public static final AddressLayout LPEXTLOGFONT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *PDEVMODEA
     * }
     */
    public static final AddressLayout PDEVMODEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *NPDEVMODEA
     * }
     */
    public static final AddressLayout NPDEVMODEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *LPDEVMODEA
     * }
     */
    public static final AddressLayout LPDEVMODEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *PDEVMODEW
     * }
     */
    public static final AddressLayout PDEVMODEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *NPDEVMODEW
     * }
     */
    public static final AddressLayout NPDEVMODEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *LPDEVMODEW
     * }
     */
    public static final AddressLayout LPDEVMODEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PDEVMODEA PDEVMODE
     * }
     */
    public static final AddressLayout PDEVMODE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPDEVMODEA NPDEVMODE
     * }
     */
    public static final AddressLayout NPDEVMODE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDEVMODEA LPDEVMODE
     * }
     */
    public static final AddressLayout LPDEVMODE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEA {
     *     DWORD cb;
     *     CHAR DeviceName[32];
     *     CHAR DeviceString[128];
     *     DWORD StateFlags;
     *     CHAR DeviceID[128];
     *     CHAR DeviceKey[128];
     * } *PDISPLAY_DEVICEA
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEA {
     *     DWORD cb;
     *     CHAR DeviceName[32];
     *     CHAR DeviceString[128];
     *     DWORD StateFlags;
     *     CHAR DeviceID[128];
     *     CHAR DeviceKey[128];
     * } *LPDISPLAY_DEVICEA
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEW {
     *     DWORD cb;
     *     WCHAR DeviceName[32];
     *     WCHAR DeviceString[128];
     *     DWORD StateFlags;
     *     WCHAR DeviceID[128];
     *     WCHAR DeviceKey[128];
     * } *PDISPLAY_DEVICEW
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEW {
     *     DWORD cb;
     *     WCHAR DeviceName[32];
     *     WCHAR DeviceString[128];
     *     DWORD StateFlags;
     *     WCHAR DeviceID[128];
     *     WCHAR DeviceKey[128];
     * } *LPDISPLAY_DEVICEW
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICE = wgl_h.C_POINTER;
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = 15
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = 16
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = 17
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = -2147483648
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = 2
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_SCALING_IDENTITY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_IDENTITY = 1
     * }
     */
    public static int DISPLAYCONFIG_SCALING_IDENTITY() {
        return DISPLAYCONFIG_SCALING_IDENTITY;
    }
    private static final int DISPLAYCONFIG_SCALING_CENTERED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_CENTERED = 2
     * }
     */
    public static int DISPLAYCONFIG_SCALING_CENTERED() {
        return DISPLAYCONFIG_SCALING_CENTERED;
    }
    private static final int DISPLAYCONFIG_SCALING_STRETCHED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_STRETCHED = 3
     * }
     */
    public static int DISPLAYCONFIG_SCALING_STRETCHED() {
        return DISPLAYCONFIG_SCALING_STRETCHED;
    }
    private static final int DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4
     * }
     */
    public static int DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX() {
        return DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX;
    }
    private static final int DISPLAYCONFIG_SCALING_CUSTOM = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_CUSTOM = 5
     * }
     */
    public static int DISPLAYCONFIG_SCALING_CUSTOM() {
        return DISPLAYCONFIG_SCALING_CUSTOM;
    }
    private static final int DISPLAYCONFIG_SCALING_PREFERRED = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_PREFERRED = 128
     * }
     */
    public static int DISPLAYCONFIG_SCALING_PREFERRED() {
        return DISPLAYCONFIG_SCALING_PREFERRED;
    }
    private static final int DISPLAYCONFIG_SCALING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_SCALING_FORCE_UINT32() {
        return DISPLAYCONFIG_SCALING_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_ROTATION_IDENTITY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_IDENTITY = 1
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_IDENTITY() {
        return DISPLAYCONFIG_ROTATION_IDENTITY;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE90 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE90 = 2
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE90() {
        return DISPLAYCONFIG_ROTATION_ROTATE90;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE180 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE180 = 3
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE180() {
        return DISPLAYCONFIG_ROTATION_ROTATE180;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE270 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE270 = 4
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE270() {
        return DISPLAYCONFIG_ROTATION_ROTATE270;
    }
    private static final int DISPLAYCONFIG_ROTATION_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_FORCE_UINT32() {
        return DISPLAYCONFIG_ROTATION_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_TARGET() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_TARGET;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_8BPP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_8BPP = 1
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_8BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_8BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_16BPP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_16BPP = 2
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_16BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_16BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_24BPP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_24BPP = 3
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_24BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_24BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_32BPP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_32BPP = 4
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_32BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_32BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_NONGDI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_NONGDI() {
        return DISPLAYCONFIG_PIXELFORMAT_NONGDI;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32() {
        return DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_INTERNAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_INTERNAL = 1
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_INTERNAL() {
        return DISPLAYCONFIG_TOPOLOGY_INTERNAL;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_CLONE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_CLONE = 2
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_CLONE() {
        return DISPLAYCONFIG_TOPOLOGY_CLONE;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_EXTEND = (int)4L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_EXTEND = 4
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_EXTEND() {
        return DISPLAYCONFIG_TOPOLOGY_EXTEND;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_EXTERNAL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 8
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_EXTERNAL() {
        return DISPLAYCONFIG_TOPOLOGY_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32() {
        return DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = 6
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = 7
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = 8
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = 9
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = 10
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = 11
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32() {
        return DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_RGB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_RGB = 0
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_RGB() {
        return DISPLAYCONFIG_COLOR_ENCODING_RGB;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = 1
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR444() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR444;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = 2
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR422() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR422;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = 3
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR420() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR420;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = 4
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_INTENSITY() {
        return DISPLAYCONFIG_COLOR_ENCODING_INTENSITY;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32() {
        return DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATAHEADER {
     *     DWORD dwSize;
     *     DWORD iType;
     *     DWORD nCount;
     *     DWORD nRgnSize;
     *     RECT rcBound;
     * } *PRGNDATAHEADER
     * }
     */
    public static final AddressLayout PRGNDATAHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *PRGNDATA
     * }
     */
    public static final AddressLayout PRGNDATA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *NPRGNDATA
     * }
     */
    public static final AddressLayout NPRGNDATA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *LPRGNDATA
     * }
     */
    public static final AddressLayout LPRGNDATA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *PABC
     * }
     */
    public static final AddressLayout PABC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *NPABC
     * }
     */
    public static final AddressLayout NPABC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *LPABC
     * }
     */
    public static final AddressLayout LPABC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *PABCFLOAT
     * }
     */
    public static final AddressLayout PABCFLOAT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *NPABCFLOAT
     * }
     */
    public static final AddressLayout NPABCFLOAT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *LPABCFLOAT
     * }
     */
    public static final AddressLayout LPABCFLOAT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *POUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRICA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *NPOUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRICA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *LPOUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRICA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *POUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRICW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *NPOUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRICW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *LPOUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRICW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRIC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRIC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRIC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *PPOLYTEXTA
     * }
     */
    public static final AddressLayout PPOLYTEXTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *NPPOLYTEXTA
     * }
     */
    public static final AddressLayout NPPOLYTEXTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *LPPOLYTEXTA
     * }
     */
    public static final AddressLayout LPPOLYTEXTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *PPOLYTEXTW
     * }
     */
    public static final AddressLayout PPOLYTEXTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *NPPOLYTEXTW
     * }
     */
    public static final AddressLayout NPPOLYTEXTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *LPPOLYTEXTW
     * }
     */
    public static final AddressLayout LPPOLYTEXTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PPOLYTEXTA PPOLYTEXT
     * }
     */
    public static final AddressLayout PPOLYTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPPOLYTEXTA NPPOLYTEXT
     * }
     */
    public static final AddressLayout NPPOLYTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPPOLYTEXTA LPPOLYTEXT
     * }
     */
    public static final AddressLayout LPPOLYTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MAT2 {
     *     FIXED eM11;
     *     FIXED eM12;
     *     FIXED eM21;
     *     FIXED eM22;
     * } *LPMAT2
     * }
     */
    public static final AddressLayout LPMAT2 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICS {
     *     UINT gmBlackBoxX;
     *     UINT gmBlackBoxY;
     *     POINT gmptGlyphOrigin;
     *     short gmCellIncX;
     *     short gmCellIncY;
     * } *LPGLYPHMETRICS
     * }
     */
    public static final AddressLayout LPGLYPHMETRICS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTFX {
     *     FIXED x;
     *     FIXED y;
     * } *LPPOINTFX
     * }
     */
    public static final AddressLayout LPPOINTFX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTTPOLYCURVE {
     *     WORD wType;
     *     WORD cpfx;
     *     POINTFX apfx[1];
     * } *LPTTPOLYCURVE
     * }
     */
    public static final AddressLayout LPTTPOLYCURVE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTTPOLYGONHEADER {
     *     DWORD cb;
     *     DWORD dwType;
     *     POINTFX pfxStart;
     * } *LPTTPOLYGONHEADER
     * }
     */
    public static final AddressLayout LPTTPOLYGONHEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGCP_RESULTSA {
     *     DWORD lStructSize;
     *     LPSTR lpOutString;
     *     UINT *lpOrder;
     *     int *lpDx;
     *     int *lpCaretPos;
     *     LPSTR lpClass;
     *     LPWSTR lpGlyphs;
     *     UINT nGlyphs;
     *     int nMaxFit;
     * } *LPGCP_RESULTSA
     * }
     */
    public static final AddressLayout LPGCP_RESULTSA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGCP_RESULTSW {
     *     DWORD lStructSize;
     *     LPWSTR lpOutString;
     *     UINT *lpOrder;
     *     int *lpDx;
     *     int *lpCaretPos;
     *     LPSTR lpClass;
     *     LPWSTR lpGlyphs;
     *     UINT nGlyphs;
     *     int nMaxFit;
     * } *LPGCP_RESULTSW
     * }
     */
    public static final AddressLayout LPGCP_RESULTSW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPGCP_RESULTSA LPGCP_RESULTS
     * }
     */
    public static final AddressLayout LPGCP_RESULTS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RASTERIZER_STATUS {
     *     short nSize;
     *     short wFlags;
     *     short nLanguageID;
     * } *LPRASTERIZER_STATUS
     * }
     */
    public static final AddressLayout LPRASTERIZER_STATUS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPIXELFORMATDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerType;
     *     BYTE bReserved;
     *     DWORD dwLayerMask;
     *     DWORD dwVisibleMask;
     *     DWORD dwDamageMask;
     * } *PPIXELFORMATDESCRIPTOR
     * }
     */
    public static final AddressLayout PPIXELFORMATDESCRIPTOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPIXELFORMATDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerType;
     *     BYTE bReserved;
     *     DWORD dwLayerMask;
     *     DWORD dwVisibleMask;
     *     DWORD dwDamageMask;
     * } *LPPIXELFORMATDESCRIPTOR
     * }
     */
    public static final AddressLayout LPPIXELFORMATDESCRIPTOR = wgl_h.C_POINTER;

    private static class AddFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddFontResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static FunctionDescriptor AddFontResourceA$descriptor() {
        return AddFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static MethodHandle AddFontResourceA$handle() {
        return AddFontResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static MemorySegment AddFontResourceA$address() {
        return AddFontResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static int AddFontResourceA(MemorySegment x0) {
        var mh$ = AddFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceA", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddFontResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static FunctionDescriptor AddFontResourceW$descriptor() {
        return AddFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static MethodHandle AddFontResourceW$handle() {
        return AddFontResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static MemorySegment AddFontResourceW$address() {
        return AddFontResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static int AddFontResourceW(MemorySegment x0) {
        var mh$ = AddFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceW", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimatePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AnimatePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static FunctionDescriptor AnimatePalette$descriptor() {
        return AnimatePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static MethodHandle AnimatePalette$handle() {
        return AnimatePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static MemorySegment AnimatePalette$address() {
        return AnimatePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static int AnimatePalette(MemorySegment hPal, int iStartIndex, int cEntries, MemorySegment ppe) {
        var mh$ = AnimatePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimatePalette", hPal, iStartIndex, cEntries, ppe);
            }
            return (int)mh$.invokeExact(hPal, iStartIndex, cEntries, ppe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Arc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Arc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static FunctionDescriptor Arc$descriptor() {
        return Arc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MethodHandle Arc$handle() {
        return Arc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MemorySegment Arc$address() {
        return Arc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static int Arc(MemorySegment hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {
        var mh$ = Arc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Arc", hdc, x1, y1, x2, y2, x3, y3, x4, y4);
            }
            return (int)mh$.invokeExact(hdc, x1, y1, x2, y2, x3, y3, x4, y4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BitBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BitBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static FunctionDescriptor BitBlt$descriptor() {
        return BitBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static MethodHandle BitBlt$handle() {
        return BitBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static MemorySegment BitBlt$address() {
        return BitBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static int BitBlt(MemorySegment hdc, int x, int y, int cx, int cy, MemorySegment hdcSrc, int x1, int y1, int rop) {
        var mh$ = BitBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BitBlt", hdc, x, y, cx, cy, hdcSrc, x1, y1, rop);
            }
            return (int)mh$.invokeExact(hdc, x, y, cx, cy, hdcSrc, x1, y1, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CancelDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor CancelDC$descriptor() {
        return CancelDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static MethodHandle CancelDC$handle() {
        return CancelDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static MemorySegment CancelDC$address() {
        return CancelDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static int CancelDC(MemorySegment hdc) {
        var mh$ = CancelDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Chord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Chord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static FunctionDescriptor Chord$descriptor() {
        return Chord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MethodHandle Chord$handle() {
        return Chord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MemorySegment Chord$address() {
        return Chord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static int Chord(MemorySegment hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {
        var mh$ = Chord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Chord", hdc, x1, y1, x2, y2, x3, y3, x4, y4);
            }
            return (int)mh$.invokeExact(hdc, x1, y1, x2, y2, x3, y3, x4, y4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChoosePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChoosePixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor ChoosePixelFormat$descriptor() {
        return ChoosePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle ChoosePixelFormat$handle() {
        return ChoosePixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MemorySegment ChoosePixelFormat$address() {
        return ChoosePixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int ChoosePixelFormat(MemorySegment hdc, MemorySegment ppfd) {
        var mh$ = ChoosePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChoosePixelFormat", hdc, ppfd);
            }
            return (int)mh$.invokeExact(hdc, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseMetaFile$descriptor() {
        return CloseMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static MethodHandle CloseMetaFile$handle() {
        return CloseMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseMetaFile$address() {
        return CloseMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseMetaFile(MemorySegment hdc) {
        var mh$ = CloseMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseMetaFile", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CombineRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CombineRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static FunctionDescriptor CombineRgn$descriptor() {
        return CombineRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static MethodHandle CombineRgn$handle() {
        return CombineRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static MemorySegment CombineRgn$address() {
        return CombineRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static int CombineRgn(MemorySegment hrgnDst, MemorySegment hrgnSrc1, MemorySegment hrgnSrc2, int iMode) {
        var mh$ = CombineRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CombineRgn", hrgnDst, hrgnSrc1, hrgnSrc2, iMode);
            }
            return (int)mh$.invokeExact(hrgnDst, hrgnSrc1, hrgnSrc2, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static FunctionDescriptor CopyMetaFileA$descriptor() {
        return CopyMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static MethodHandle CopyMetaFileA$handle() {
        return CopyMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static MemorySegment CopyMetaFileA$address() {
        return CopyMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static MemorySegment CopyMetaFileA(MemorySegment x0, MemorySegment x1) {
        var mh$ = CopyMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyMetaFileA", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static FunctionDescriptor CopyMetaFileW$descriptor() {
        return CopyMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static MethodHandle CopyMetaFileW$handle() {
        return CopyMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static MemorySegment CopyMetaFileW$address() {
        return CopyMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static MemorySegment CopyMetaFileW(MemorySegment x0, MemorySegment x1) {
        var mh$ = CopyMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyMetaFileW", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static FunctionDescriptor CreateBitmap$descriptor() {
        return CreateBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static MethodHandle CreateBitmap$handle() {
        return CreateBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static MemorySegment CreateBitmap$address() {
        return CreateBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static MemorySegment CreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitCount, MemorySegment lpBits) {
        var mh$ = CreateBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBitmap", nWidth, nHeight, nPlanes, nBitCount, lpBits);
            }
            return (MemorySegment)mh$.invokeExact(nWidth, nHeight, nPlanes, nBitCount, lpBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBitmapIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateBitmapIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static FunctionDescriptor CreateBitmapIndirect$descriptor() {
        return CreateBitmapIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static MethodHandle CreateBitmapIndirect$handle() {
        return CreateBitmapIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static MemorySegment CreateBitmapIndirect$address() {
        return CreateBitmapIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static MemorySegment CreateBitmapIndirect(MemorySegment pbm) {
        var mh$ = CreateBitmapIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBitmapIndirect", pbm);
            }
            return (MemorySegment)mh$.invokeExact(pbm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBrushIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateBrushIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static FunctionDescriptor CreateBrushIndirect$descriptor() {
        return CreateBrushIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static MethodHandle CreateBrushIndirect$handle() {
        return CreateBrushIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static MemorySegment CreateBrushIndirect$address() {
        return CreateBrushIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static MemorySegment CreateBrushIndirect(MemorySegment plbrush) {
        var mh$ = CreateBrushIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBrushIndirect", plbrush);
            }
            return (MemorySegment)mh$.invokeExact(plbrush);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCompatibleBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateCompatibleBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static FunctionDescriptor CreateCompatibleBitmap$descriptor() {
        return CreateCompatibleBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MethodHandle CreateCompatibleBitmap$handle() {
        return CreateCompatibleBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateCompatibleBitmap$address() {
        return CreateCompatibleBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateCompatibleBitmap(MemorySegment hdc, int cx, int cy) {
        var mh$ = CreateCompatibleBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCompatibleBitmap", hdc, cx, cy);
            }
            return (MemorySegment)mh$.invokeExact(hdc, cx, cy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDiscardableBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDiscardableBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static FunctionDescriptor CreateDiscardableBitmap$descriptor() {
        return CreateDiscardableBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MethodHandle CreateDiscardableBitmap$handle() {
        return CreateDiscardableBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateDiscardableBitmap$address() {
        return CreateDiscardableBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateDiscardableBitmap(MemorySegment hdc, int cx, int cy) {
        var mh$ = CreateDiscardableBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDiscardableBitmap", hdc, cx, cy);
            }
            return (MemorySegment)mh$.invokeExact(hdc, cx, cy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCompatibleDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateCompatibleDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor CreateCompatibleDC$descriptor() {
        return CreateCompatibleDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static MethodHandle CreateCompatibleDC$handle() {
        return CreateCompatibleDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static MemorySegment CreateCompatibleDC$address() {
        return CreateCompatibleDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static MemorySegment CreateCompatibleDC(MemorySegment hdc) {
        var mh$ = CreateCompatibleDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCompatibleDC", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDCA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDCA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static FunctionDescriptor CreateDCA$descriptor() {
        return CreateDCA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MethodHandle CreateDCA$handle() {
        return CreateDCA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateDCA$address() {
        return CreateDCA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateDCA(MemorySegment pwszDriver, MemorySegment pwszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateDCA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDCA", pwszDriver, pwszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pwszDriver, pwszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDCW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDCW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static FunctionDescriptor CreateDCW$descriptor() {
        return CreateDCW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MethodHandle CreateDCW$handle() {
        return CreateDCW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateDCW$address() {
        return CreateDCW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateDCW(MemorySegment pwszDriver, MemorySegment pwszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateDCW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDCW", pwszDriver, pwszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pwszDriver, pwszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDIBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBitmap$descriptor() {
        return CreateDIBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBitmap$handle() {
        return CreateDIBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBitmap$address() {
        return CreateDIBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBitmap(MemorySegment hdc, MemorySegment pbmih, int flInit, MemorySegment pjBits, MemorySegment pbmi, int iUsage) {
        var mh$ = CreateDIBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBitmap", hdc, pbmih, flInit, pjBits, pbmi, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(hdc, pbmih, flInit, pjBits, pbmi, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBPatternBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDIBPatternBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBPatternBrush$descriptor() {
        return CreateDIBPatternBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBPatternBrush$handle() {
        return CreateDIBPatternBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrush$address() {
        return CreateDIBPatternBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrush(MemorySegment h, int iUsage) {
        var mh$ = CreateDIBPatternBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBPatternBrush", h, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(h, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBPatternBrushPt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDIBPatternBrushPt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBPatternBrushPt$descriptor() {
        return CreateDIBPatternBrushPt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBPatternBrushPt$handle() {
        return CreateDIBPatternBrushPt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrushPt$address() {
        return CreateDIBPatternBrushPt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrushPt(MemorySegment lpPackedDIB, int iUsage) {
        var mh$ = CreateDIBPatternBrushPt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBPatternBrushPt", lpPackedDIB, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(lpPackedDIB, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEllipticRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateEllipticRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static FunctionDescriptor CreateEllipticRgn$descriptor() {
        return CreateEllipticRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MethodHandle CreateEllipticRgn$handle() {
        return CreateEllipticRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateEllipticRgn$address() {
        return CreateEllipticRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateEllipticRgn(int x1, int y1, int x2, int y2) {
        var mh$ = CreateEllipticRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEllipticRgn", x1, y1, x2, y2);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEllipticRgnIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateEllipticRgnIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static FunctionDescriptor CreateEllipticRgnIndirect$descriptor() {
        return CreateEllipticRgnIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static MethodHandle CreateEllipticRgnIndirect$handle() {
        return CreateEllipticRgnIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateEllipticRgnIndirect$address() {
        return CreateEllipticRgnIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateEllipticRgnIndirect(MemorySegment lprect) {
        var mh$ = CreateEllipticRgnIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEllipticRgnIndirect", lprect);
            }
            return (MemorySegment)mh$.invokeExact(lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFontIndirectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectA$descriptor() {
        return CreateFontIndirectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static MethodHandle CreateFontIndirectA$handle() {
        return CreateFontIndirectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectA$address() {
        return CreateFontIndirectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectA(MemorySegment lplf) {
        var mh$ = CreateFontIndirectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectA", lplf);
            }
            return (MemorySegment)mh$.invokeExact(lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFontIndirectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectW$descriptor() {
        return CreateFontIndirectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static MethodHandle CreateFontIndirectW$handle() {
        return CreateFontIndirectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectW$address() {
        return CreateFontIndirectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectW(MemorySegment lplf) {
        var mh$ = CreateFontIndirectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectW", lplf);
            }
            return (MemorySegment)mh$.invokeExact(lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFontA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static FunctionDescriptor CreateFontA$descriptor() {
        return CreateFontA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static MethodHandle CreateFontA$handle() {
        return CreateFontA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontA$address() {
        return CreateFontA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, int bItalic, int bUnderline, int bStrikeOut, int iCharSet, int iOutPrecision, int iClipPrecision, int iQuality, int iPitchAndFamily, MemorySegment pszFaceName) {
        var mh$ = CreateFontA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontA", cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
            }
            return (MemorySegment)mh$.invokeExact(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFontW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static FunctionDescriptor CreateFontW$descriptor() {
        return CreateFontW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static MethodHandle CreateFontW$handle() {
        return CreateFontW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontW$address() {
        return CreateFontW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, int bItalic, int bUnderline, int bStrikeOut, int iCharSet, int iOutPrecision, int iClipPrecision, int iQuality, int iPitchAndFamily, MemorySegment pszFaceName) {
        var mh$ = CreateFontW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontW", cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
            }
            return (MemorySegment)mh$.invokeExact(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHatchBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateHatchBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static FunctionDescriptor CreateHatchBrush$descriptor() {
        return CreateHatchBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static MethodHandle CreateHatchBrush$handle() {
        return CreateHatchBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static MemorySegment CreateHatchBrush$address() {
        return CreateHatchBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static MemorySegment CreateHatchBrush(int iHatch, int color) {
        var mh$ = CreateHatchBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHatchBrush", iHatch, color);
            }
            return (MemorySegment)mh$.invokeExact(iHatch, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateICA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateICA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static FunctionDescriptor CreateICA$descriptor() {
        return CreateICA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MethodHandle CreateICA$handle() {
        return CreateICA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateICA$address() {
        return CreateICA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateICA(MemorySegment pszDriver, MemorySegment pszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateICA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateICA", pszDriver, pszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pszDriver, pszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateICW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateICW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static FunctionDescriptor CreateICW$descriptor() {
        return CreateICW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MethodHandle CreateICW$handle() {
        return CreateICW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateICW$address() {
        return CreateICW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateICW(MemorySegment pszDriver, MemorySegment pszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateICW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateICW", pszDriver, pszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pszDriver, pszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static FunctionDescriptor CreateMetaFileA$descriptor() {
        return CreateMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static MethodHandle CreateMetaFileA$handle() {
        return CreateMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileA$address() {
        return CreateMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileA(MemorySegment pszFile) {
        var mh$ = CreateMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMetaFileA", pszFile);
            }
            return (MemorySegment)mh$.invokeExact(pszFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static FunctionDescriptor CreateMetaFileW$descriptor() {
        return CreateMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static MethodHandle CreateMetaFileW$handle() {
        return CreateMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileW$address() {
        return CreateMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileW(MemorySegment pszFile) {
        var mh$ = CreateMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMetaFileW", pszFile);
            }
            return (MemorySegment)mh$.invokeExact(pszFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static FunctionDescriptor CreatePalette$descriptor() {
        return CreatePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static MethodHandle CreatePalette$handle() {
        return CreatePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static MemorySegment CreatePalette$address() {
        return CreatePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static MemorySegment CreatePalette(MemorySegment plpal) {
        var mh$ = CreatePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePalette", plpal);
            }
            return (MemorySegment)mh$.invokeExact(plpal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static FunctionDescriptor CreatePen$descriptor() {
        return CreatePen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static MethodHandle CreatePen$handle() {
        return CreatePen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static MemorySegment CreatePen$address() {
        return CreatePen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static MemorySegment CreatePen(int iStyle, int cWidth, int color) {
        var mh$ = CreatePen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePen", iStyle, cWidth, color);
            }
            return (MemorySegment)mh$.invokeExact(iStyle, cWidth, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePenIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePenIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static FunctionDescriptor CreatePenIndirect$descriptor() {
        return CreatePenIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static MethodHandle CreatePenIndirect$handle() {
        return CreatePenIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static MemorySegment CreatePenIndirect$address() {
        return CreatePenIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static MemorySegment CreatePenIndirect(MemorySegment plpen) {
        var mh$ = CreatePenIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePenIndirect", plpen);
            }
            return (MemorySegment)mh$.invokeExact(plpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePolyPolygonRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePolyPolygonRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static FunctionDescriptor CreatePolyPolygonRgn$descriptor() {
        return CreatePolyPolygonRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static MethodHandle CreatePolyPolygonRgn$handle() {
        return CreatePolyPolygonRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static MemorySegment CreatePolyPolygonRgn$address() {
        return CreatePolyPolygonRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static MemorySegment CreatePolyPolygonRgn(MemorySegment pptl, MemorySegment pc, int cPoly, int iMode) {
        var mh$ = CreatePolyPolygonRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePolyPolygonRgn", pptl, pc, cPoly, iMode);
            }
            return (MemorySegment)mh$.invokeExact(pptl, pc, cPoly, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePatternBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePatternBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static FunctionDescriptor CreatePatternBrush$descriptor() {
        return CreatePatternBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static MethodHandle CreatePatternBrush$handle() {
        return CreatePatternBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static MemorySegment CreatePatternBrush$address() {
        return CreatePatternBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static MemorySegment CreatePatternBrush(MemorySegment hbm) {
        var mh$ = CreatePatternBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePatternBrush", hbm);
            }
            return (MemorySegment)mh$.invokeExact(hbm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateRectRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static FunctionDescriptor CreateRectRgn$descriptor() {
        return CreateRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MethodHandle CreateRectRgn$handle() {
        return CreateRectRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateRectRgn$address() {
        return CreateRectRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateRectRgn(int x1, int y1, int x2, int y2) {
        var mh$ = CreateRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRectRgn", x1, y1, x2, y2);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRectRgnIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateRectRgnIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static FunctionDescriptor CreateRectRgnIndirect$descriptor() {
        return CreateRectRgnIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static MethodHandle CreateRectRgnIndirect$handle() {
        return CreateRectRgnIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateRectRgnIndirect$address() {
        return CreateRectRgnIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateRectRgnIndirect(MemorySegment lprect) {
        var mh$ = CreateRectRgnIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRectRgnIndirect", lprect);
            }
            return (MemorySegment)mh$.invokeExact(lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRoundRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateRoundRectRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static FunctionDescriptor CreateRoundRectRgn$descriptor() {
        return CreateRoundRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static MethodHandle CreateRoundRectRgn$handle() {
        return CreateRoundRectRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static MemorySegment CreateRoundRectRgn$address() {
        return CreateRoundRectRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static MemorySegment CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h) {
        var mh$ = CreateRoundRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRoundRectRgn", x1, y1, x2, y2, w, h);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateScalableFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateScalableFontResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static FunctionDescriptor CreateScalableFontResourceA$descriptor() {
        return CreateScalableFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static MethodHandle CreateScalableFontResourceA$handle() {
        return CreateScalableFontResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static MemorySegment CreateScalableFontResourceA$address() {
        return CreateScalableFontResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static int CreateScalableFontResourceA(int fdwHidden, MemorySegment lpszFont, MemorySegment lpszFile, MemorySegment lpszPath) {
        var mh$ = CreateScalableFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateScalableFontResourceA", fdwHidden, lpszFont, lpszFile, lpszPath);
            }
            return (int)mh$.invokeExact(fdwHidden, lpszFont, lpszFile, lpszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateScalableFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateScalableFontResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static FunctionDescriptor CreateScalableFontResourceW$descriptor() {
        return CreateScalableFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static MethodHandle CreateScalableFontResourceW$handle() {
        return CreateScalableFontResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static MemorySegment CreateScalableFontResourceW$address() {
        return CreateScalableFontResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static int CreateScalableFontResourceW(int fdwHidden, MemorySegment lpszFont, MemorySegment lpszFile, MemorySegment lpszPath) {
        var mh$ = CreateScalableFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateScalableFontResourceW", fdwHidden, lpszFont, lpszFile, lpszPath);
            }
            return (int)mh$.invokeExact(fdwHidden, lpszFont, lpszFile, lpszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSolidBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateSolidBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static FunctionDescriptor CreateSolidBrush$descriptor() {
        return CreateSolidBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static MethodHandle CreateSolidBrush$handle() {
        return CreateSolidBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static MemorySegment CreateSolidBrush$address() {
        return CreateSolidBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static MemorySegment CreateSolidBrush(int color) {
        var mh$ = CreateSolidBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSolidBrush", color);
            }
            return (MemorySegment)mh$.invokeExact(color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor DeleteDC$descriptor() {
        return DeleteDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static MethodHandle DeleteDC$handle() {
        return DeleteDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static MemorySegment DeleteDC$address() {
        return DeleteDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static int DeleteDC(MemorySegment hdc) {
        var mh$ = DeleteDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor DeleteMetaFile$descriptor() {
        return DeleteMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static MethodHandle DeleteMetaFile$handle() {
        return DeleteMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static MemorySegment DeleteMetaFile$address() {
        return DeleteMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static int DeleteMetaFile(MemorySegment hmf) {
        var mh$ = DeleteMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteMetaFile", hmf);
            }
            return (int)mh$.invokeExact(hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static FunctionDescriptor DeleteObject$descriptor() {
        return DeleteObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static MethodHandle DeleteObject$handle() {
        return DeleteObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static MemorySegment DeleteObject$address() {
        return DeleteObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static int DeleteObject(MemorySegment ho) {
        var mh$ = DeleteObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteObject", ho);
            }
            return (int)mh$.invokeExact(ho);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DescribePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DescribePixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static FunctionDescriptor DescribePixelFormat$descriptor() {
        return DescribePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static MethodHandle DescribePixelFormat$handle() {
        return DescribePixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static MemorySegment DescribePixelFormat$address() {
        return DescribePixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static int DescribePixelFormat(MemorySegment hdc, int iPixelFormat, int nBytes, MemorySegment ppfd) {
        var mh$ = DescribePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DescribePixelFormat", hdc, iPixelFormat, nBytes, ppfd);
            }
            return (int)mh$.invokeExact(hdc, iPixelFormat, nBytes, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceCapabilitiesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeviceCapabilitiesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static FunctionDescriptor DeviceCapabilitiesA$descriptor() {
        return DeviceCapabilitiesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static MethodHandle DeviceCapabilitiesA$handle() {
        return DeviceCapabilitiesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static MemorySegment DeviceCapabilitiesA$address() {
        return DeviceCapabilitiesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static int DeviceCapabilitiesA(MemorySegment pDevice, MemorySegment pPort, short fwCapability, MemorySegment pOutput, MemorySegment pDevMode) {
        var mh$ = DeviceCapabilitiesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceCapabilitiesA", pDevice, pPort, fwCapability, pOutput, pDevMode);
            }
            return (int)mh$.invokeExact(pDevice, pPort, fwCapability, pOutput, pDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceCapabilitiesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeviceCapabilitiesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static FunctionDescriptor DeviceCapabilitiesW$descriptor() {
        return DeviceCapabilitiesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static MethodHandle DeviceCapabilitiesW$handle() {
        return DeviceCapabilitiesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static MemorySegment DeviceCapabilitiesW$address() {
        return DeviceCapabilitiesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static int DeviceCapabilitiesW(MemorySegment pDevice, MemorySegment pPort, short fwCapability, MemorySegment pOutput, MemorySegment pDevMode) {
        var mh$ = DeviceCapabilitiesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceCapabilitiesW", pDevice, pPort, fwCapability, pOutput, pDevMode);
            }
            return (int)mh$.invokeExact(pDevice, pPort, fwCapability, pOutput, pDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static FunctionDescriptor DrawEscape$descriptor() {
        return DrawEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static MethodHandle DrawEscape$handle() {
        return DrawEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static MemorySegment DrawEscape$address() {
        return DrawEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static int DrawEscape(MemorySegment hdc, int iEscape, int cjIn, MemorySegment lpIn) {
        var mh$ = DrawEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawEscape", hdc, iEscape, cjIn, lpIn);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjIn, lpIn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ellipse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Ellipse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor Ellipse$descriptor() {
        return Ellipse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle Ellipse$handle() {
        return Ellipse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment Ellipse$address() {
        return Ellipse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int Ellipse(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = Ellipse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ellipse", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumFontFamiliesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesExA$descriptor() {
        return EnumFontFamiliesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumFontFamiliesExA$handle() {
        return EnumFontFamiliesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumFontFamiliesExA$address() {
        return EnumFontFamiliesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static int EnumFontFamiliesExA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam, int dwFlags) {
        var mh$ = EnumFontFamiliesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesExA", hdc, lpLogfont, lpProc, lParam, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumFontFamiliesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesExW$descriptor() {
        return EnumFontFamiliesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumFontFamiliesExW$handle() {
        return EnumFontFamiliesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumFontFamiliesExW$address() {
        return EnumFontFamiliesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static int EnumFontFamiliesExW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam, int dwFlags) {
        var mh$ = EnumFontFamiliesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesExW", hdc, lpLogfont, lpProc, lParam, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumFontFamiliesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesA$descriptor() {
        return EnumFontFamiliesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontFamiliesA$handle() {
        return EnumFontFamiliesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontFamiliesA$address() {
        return EnumFontFamiliesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontFamiliesA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontFamiliesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesA", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumFontFamiliesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesW$descriptor() {
        return EnumFontFamiliesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontFamiliesW$handle() {
        return EnumFontFamiliesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontFamiliesW$address() {
        return EnumFontFamiliesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontFamiliesW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontFamiliesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesW", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumFontsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontsA$descriptor() {
        return EnumFontsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontsA$handle() {
        return EnumFontsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontsA$address() {
        return EnumFontsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontsA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontsA", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumFontsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontsW$descriptor() {
        return EnumFontsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontsW$handle() {
        return EnumFontsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontsW$address() {
        return EnumFontsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontsW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontsW", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumObjects$descriptor() {
        return EnumObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumObjects$handle() {
        return EnumObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumObjects$address() {
        return EnumObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static int EnumObjects(MemorySegment hdc, int nType, MemorySegment lpFunc, long lParam) {
        var mh$ = EnumObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumObjects", hdc, nType, lpFunc, lParam);
            }
            return (int)mh$.invokeExact(hdc, nType, lpFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EqualRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static FunctionDescriptor EqualRgn$descriptor() {
        return EqualRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static MethodHandle EqualRgn$handle() {
        return EqualRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static MemorySegment EqualRgn$address() {
        return EqualRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static int EqualRgn(MemorySegment hrgn1, MemorySegment hrgn2) {
        var mh$ = EqualRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualRgn", hrgn1, hrgn2);
            }
            return (int)mh$.invokeExact(hrgn1, hrgn2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Escape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Escape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static FunctionDescriptor Escape$descriptor() {
        return Escape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static MethodHandle Escape$handle() {
        return Escape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static MemorySegment Escape$address() {
        return Escape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static int Escape(MemorySegment hdc, int iEscape, int cjIn, MemorySegment pvIn, MemorySegment pvOut) {
        var mh$ = Escape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Escape", hdc, iEscape, cjIn, pvIn, pvOut);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjIn, pvIn, pvOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExtEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static FunctionDescriptor ExtEscape$descriptor() {
        return ExtEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static MethodHandle ExtEscape$handle() {
        return ExtEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static MemorySegment ExtEscape$address() {
        return ExtEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static int ExtEscape(MemorySegment hdc, int iEscape, int cjInput, MemorySegment lpInData, int cjOutput, MemorySegment lpOutData) {
        var mh$ = ExtEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtEscape", hdc, iEscape, cjInput, lpInData, cjOutput, lpOutData);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjInput, lpInData, cjOutput, lpOutData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExcludeClipRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExcludeClipRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor ExcludeClipRect$descriptor() {
        return ExcludeClipRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle ExcludeClipRect$handle() {
        return ExcludeClipRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment ExcludeClipRect$address() {
        return ExcludeClipRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int ExcludeClipRect(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = ExcludeClipRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExcludeClipRect", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtCreateRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExtCreateRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static FunctionDescriptor ExtCreateRegion$descriptor() {
        return ExtCreateRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static MethodHandle ExtCreateRegion$handle() {
        return ExtCreateRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static MemorySegment ExtCreateRegion$address() {
        return ExtCreateRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static MemorySegment ExtCreateRegion(MemorySegment lpx, int nCount, MemorySegment lpData) {
        var mh$ = ExtCreateRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtCreateRegion", lpx, nCount, lpData);
            }
            return (MemorySegment)mh$.invokeExact(lpx, nCount, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtFloodFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExtFloodFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static FunctionDescriptor ExtFloodFill$descriptor() {
        return ExtFloodFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static MethodHandle ExtFloodFill$handle() {
        return ExtFloodFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static MemorySegment ExtFloodFill$address() {
        return ExtFloodFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static int ExtFloodFill(MemorySegment hdc, int x, int y, int color, int type) {
        var mh$ = ExtFloodFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtFloodFill", hdc, x, y, color, type);
            }
            return (int)mh$.invokeExact(hdc, x, y, color, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FillRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static FunctionDescriptor FillRgn$descriptor() {
        return FillRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static MethodHandle FillRgn$handle() {
        return FillRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static MemorySegment FillRgn$address() {
        return FillRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static int FillRgn(MemorySegment hdc, MemorySegment hrgn, MemorySegment hbr) {
        var mh$ = FillRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillRgn", hdc, hrgn, hbr);
            }
            return (int)mh$.invokeExact(hdc, hrgn, hbr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FloodFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FloodFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor FloodFill$descriptor() {
        return FloodFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle FloodFill$handle() {
        return FloodFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MemorySegment FloodFill$address() {
        return FloodFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int FloodFill(MemorySegment hdc, int x, int y, int color) {
        var mh$ = FloodFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FloodFill", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FrameRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FrameRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static FunctionDescriptor FrameRgn$descriptor() {
        return FrameRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static MethodHandle FrameRgn$handle() {
        return FrameRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static MemorySegment FrameRgn$address() {
        return FrameRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static int FrameRgn(MemorySegment hdc, MemorySegment hrgn, MemorySegment hbr, int w, int h) {
        var mh$ = FrameRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FrameRgn", hdc, hrgn, hbr, w, h);
            }
            return (int)mh$.invokeExact(hdc, hrgn, hbr, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetROP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetROP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetROP2$descriptor() {
        return GetROP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static MethodHandle GetROP2$handle() {
        return GetROP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static MemorySegment GetROP2$address() {
        return GetROP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static int GetROP2(MemorySegment hdc) {
        var mh$ = GetROP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetROP2", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAspectRatioFilterEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetAspectRatioFilterEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetAspectRatioFilterEx$descriptor() {
        return GetAspectRatioFilterEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetAspectRatioFilterEx$handle() {
        return GetAspectRatioFilterEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetAspectRatioFilterEx$address() {
        return GetAspectRatioFilterEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetAspectRatioFilterEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetAspectRatioFilterEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAspectRatioFilterEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBkColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetBkColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetBkColor$descriptor() {
        return GetBkColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static MethodHandle GetBkColor$handle() {
        return GetBkColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static MemorySegment GetBkColor$address() {
        return GetBkColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static int GetBkColor(MemorySegment hdc) {
        var mh$ = GetBkColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBkColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCBrushColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDCBrushColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetDCBrushColor$descriptor() {
        return GetDCBrushColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static MethodHandle GetDCBrushColor$handle() {
        return GetDCBrushColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static MemorySegment GetDCBrushColor$address() {
        return GetDCBrushColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static int GetDCBrushColor(MemorySegment hdc) {
        var mh$ = GetDCBrushColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCBrushColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCPenColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDCPenColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetDCPenColor$descriptor() {
        return GetDCPenColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static MethodHandle GetDCPenColor$handle() {
        return GetDCPenColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static MemorySegment GetDCPenColor$address() {
        return GetDCPenColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static int GetDCPenColor(MemorySegment hdc) {
        var mh$ = GetDCPenColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCPenColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBkMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetBkMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetBkMode$descriptor() {
        return GetBkMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static MethodHandle GetBkMode$handle() {
        return GetBkMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static MemorySegment GetBkMode$address() {
        return GetBkMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static int GetBkMode(MemorySegment hdc) {
        var mh$ = GetBkMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBkMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBitmapBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetBitmapBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static FunctionDescriptor GetBitmapBits$descriptor() {
        return GetBitmapBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static MethodHandle GetBitmapBits$handle() {
        return GetBitmapBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static MemorySegment GetBitmapBits$address() {
        return GetBitmapBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static int GetBitmapBits(MemorySegment hbit, int cb, MemorySegment lpvBits) {
        var mh$ = GetBitmapBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBitmapBits", hbit, cb, lpvBits);
            }
            return (int)mh$.invokeExact(hbit, cb, lpvBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBitmapDimensionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetBitmapDimensionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetBitmapDimensionEx$descriptor() {
        return GetBitmapDimensionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetBitmapDimensionEx$handle() {
        return GetBitmapDimensionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetBitmapDimensionEx$address() {
        return GetBitmapDimensionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static int GetBitmapDimensionEx(MemorySegment hbit, MemorySegment lpsize) {
        var mh$ = GetBitmapDimensionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBitmapDimensionEx", hbit, lpsize);
            }
            return (int)mh$.invokeExact(hbit, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBoundsRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetBoundsRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static FunctionDescriptor GetBoundsRect$descriptor() {
        return GetBoundsRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static MethodHandle GetBoundsRect$handle() {
        return GetBoundsRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static MemorySegment GetBoundsRect$address() {
        return GetBoundsRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static int GetBoundsRect(MemorySegment hdc, MemorySegment lprect, int flags) {
        var mh$ = GetBoundsRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBoundsRect", hdc, lprect, flags);
            }
            return (int)mh$.invokeExact(hdc, lprect, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetBrushOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetBrushOrgEx$descriptor() {
        return GetBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetBrushOrgEx$handle() {
        return GetBrushOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MemorySegment GetBrushOrgEx$address() {
        return GetBrushOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetBrushOrgEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBrushOrgEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharWidthA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthA$descriptor() {
        return GetCharWidthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthA$handle() {
        return GetCharWidthA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthA$address() {
        return GetCharWidthA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidthA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthA", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharWidthW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthW$descriptor() {
        return GetCharWidthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthW$handle() {
        return GetCharWidthW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthW$address() {
        return GetCharWidthW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidthW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthW", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidth32A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharWidth32A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidth32A$descriptor() {
        return GetCharWidth32A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidth32A$handle() {
        return GetCharWidth32A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidth32A$address() {
        return GetCharWidth32A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidth32A(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidth32A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidth32A", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidth32W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharWidth32W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidth32W$descriptor() {
        return GetCharWidth32W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidth32W$handle() {
        return GetCharWidth32W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidth32W$address() {
        return GetCharWidth32W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidth32W(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidth32W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidth32W", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthFloatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharWidthFloatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthFloatA$descriptor() {
        return GetCharWidthFloatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthFloatA$handle() {
        return GetCharWidthFloatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthFloatA$address() {
        return GetCharWidthFloatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static int GetCharWidthFloatA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthFloatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthFloatA", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthFloatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharWidthFloatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthFloatW$descriptor() {
        return GetCharWidthFloatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthFloatW$handle() {
        return GetCharWidthFloatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthFloatW$address() {
        return GetCharWidthFloatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static int GetCharWidthFloatW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthFloatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthFloatW", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharABCWidthsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsA$descriptor() {
        return GetCharABCWidthsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsA$handle() {
        return GetCharABCWidthsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsA$address() {
        return GetCharABCWidthsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static int GetCharABCWidthsA(MemorySegment hdc, int wFirst, int wLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsA", hdc, wFirst, wLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, wFirst, wLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharABCWidthsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsW$descriptor() {
        return GetCharABCWidthsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsW$handle() {
        return GetCharABCWidthsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsW$address() {
        return GetCharABCWidthsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static int GetCharABCWidthsW(MemorySegment hdc, int wFirst, int wLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsW", hdc, wFirst, wLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, wFirst, wLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsFloatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharABCWidthsFloatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsFloatA$descriptor() {
        return GetCharABCWidthsFloatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsFloatA$handle() {
        return GetCharABCWidthsFloatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsFloatA$address() {
        return GetCharABCWidthsFloatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static int GetCharABCWidthsFloatA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsFloatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsFloatA", hdc, iFirst, iLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsFloatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharABCWidthsFloatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsFloatW$descriptor() {
        return GetCharABCWidthsFloatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsFloatW$handle() {
        return GetCharABCWidthsFloatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsFloatW$address() {
        return GetCharABCWidthsFloatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static int GetCharABCWidthsFloatW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsFloatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsFloatW", hdc, iFirst, iLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClipBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static FunctionDescriptor GetClipBox$descriptor() {
        return GetClipBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static MethodHandle GetClipBox$handle() {
        return GetClipBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static MemorySegment GetClipBox$address() {
        return GetClipBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static int GetClipBox(MemorySegment hdc, MemorySegment lprect) {
        var mh$ = GetClipBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipBox", hdc, lprect);
            }
            return (int)mh$.invokeExact(hdc, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor GetClipRgn$descriptor() {
        return GetClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle GetClipRgn$handle() {
        return GetClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment GetClipRgn$address() {
        return GetClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int GetClipRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = GetClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMetaRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor GetMetaRgn$descriptor() {
        return GetMetaRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle GetMetaRgn$handle() {
        return GetMetaRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment GetMetaRgn$address() {
        return GetMetaRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int GetMetaRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = GetMetaRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static FunctionDescriptor GetCurrentObject$descriptor() {
        return GetCurrentObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static MethodHandle GetCurrentObject$handle() {
        return GetCurrentObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static MemorySegment GetCurrentObject$address() {
        return GetCurrentObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static MemorySegment GetCurrentObject(MemorySegment hdc, int type) {
        var mh$ = GetCurrentObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentObject", hdc, type);
            }
            return (MemorySegment)mh$.invokeExact(hdc, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentPositionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentPositionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetCurrentPositionEx$descriptor() {
        return GetCurrentPositionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetCurrentPositionEx$handle() {
        return GetCurrentPositionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MemorySegment GetCurrentPositionEx$address() {
        return GetCurrentPositionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetCurrentPositionEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetCurrentPositionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentPositionEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDeviceCaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDeviceCaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static FunctionDescriptor GetDeviceCaps$descriptor() {
        return GetDeviceCaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static MethodHandle GetDeviceCaps$handle() {
        return GetDeviceCaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static MemorySegment GetDeviceCaps$address() {
        return GetDeviceCaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static int GetDeviceCaps(MemorySegment hdc, int index) {
        var mh$ = GetDeviceCaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDeviceCaps", hdc, index);
            }
            return (int)mh$.invokeExact(hdc, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDIBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static FunctionDescriptor GetDIBits$descriptor() {
        return GetDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static MethodHandle GetDIBits$handle() {
        return GetDIBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static MemorySegment GetDIBits$address() {
        return GetDIBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static int GetDIBits(MemorySegment hdc, MemorySegment hbm, int start, int cLines, MemorySegment lpvBits, MemorySegment lpbmi, int usage) {
        var mh$ = GetDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDIBits", hdc, hbm, start, cLines, lpvBits, lpbmi, usage);
            }
            return (int)mh$.invokeExact(hdc, hbm, start, cLines, lpvBits, lpbmi, usage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFontData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFontData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static FunctionDescriptor GetFontData$descriptor() {
        return GetFontData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static MethodHandle GetFontData$handle() {
        return GetFontData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static MemorySegment GetFontData$address() {
        return GetFontData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static int GetFontData(MemorySegment hdc, int dwTable, int dwOffset, MemorySegment pvBuffer, int cjBuffer) {
        var mh$ = GetFontData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontData", hdc, dwTable, dwOffset, pvBuffer, cjBuffer);
            }
            return (int)mh$.invokeExact(hdc, dwTable, dwOffset, pvBuffer, cjBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphOutlineA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetGlyphOutlineA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static FunctionDescriptor GetGlyphOutlineA$descriptor() {
        return GetGlyphOutlineA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MethodHandle GetGlyphOutlineA$handle() {
        return GetGlyphOutlineA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MemorySegment GetGlyphOutlineA$address() {
        return GetGlyphOutlineA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static int GetGlyphOutlineA(MemorySegment hdc, int uChar, int fuFormat, MemorySegment lpgm, int cjBuffer, MemorySegment pvBuffer, MemorySegment lpmat2) {
        var mh$ = GetGlyphOutlineA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphOutlineA", hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
            }
            return (int)mh$.invokeExact(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphOutlineW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetGlyphOutlineW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static FunctionDescriptor GetGlyphOutlineW$descriptor() {
        return GetGlyphOutlineW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MethodHandle GetGlyphOutlineW$handle() {
        return GetGlyphOutlineW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MemorySegment GetGlyphOutlineW$address() {
        return GetGlyphOutlineW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static int GetGlyphOutlineW(MemorySegment hdc, int uChar, int fuFormat, MemorySegment lpgm, int cjBuffer, MemorySegment pvBuffer, MemorySegment lpmat2) {
        var mh$ = GetGlyphOutlineW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphOutlineW", hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
            }
            return (int)mh$.invokeExact(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGraphicsMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetGraphicsMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetGraphicsMode$descriptor() {
        return GetGraphicsMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static MethodHandle GetGraphicsMode$handle() {
        return GetGraphicsMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static MemorySegment GetGraphicsMode$address() {
        return GetGraphicsMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static int GetGraphicsMode(MemorySegment hdc) {
        var mh$ = GetGraphicsMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGraphicsMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMapMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMapMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetMapMode$descriptor() {
        return GetMapMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static MethodHandle GetMapMode$handle() {
        return GetMapMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static MemorySegment GetMapMode$address() {
        return GetMapMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static int GetMapMode(MemorySegment hdc) {
        var mh$ = GetMapMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMapMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileBitsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMetaFileBitsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetMetaFileBitsEx$descriptor() {
        return GetMetaFileBitsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static MethodHandle GetMetaFileBitsEx$handle() {
        return GetMetaFileBitsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static MemorySegment GetMetaFileBitsEx$address() {
        return GetMetaFileBitsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static int GetMetaFileBitsEx(MemorySegment hMF, int cbBuffer, MemorySegment lpData) {
        var mh$ = GetMetaFileBitsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileBitsEx", hMF, cbBuffer, lpData);
            }
            return (int)mh$.invokeExact(hMF, cbBuffer, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor GetMetaFileA$descriptor() {
        return GetMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static MethodHandle GetMetaFileA$handle() {
        return GetMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileA$address() {
        return GetMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileA(MemorySegment lpName) {
        var mh$ = GetMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileA", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetMetaFileW$descriptor() {
        return GetMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MethodHandle GetMetaFileW$handle() {
        return GetMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileW$address() {
        return GetMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileW(MemorySegment lpName) {
        var mh$ = GetMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileW", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNearestColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNearestColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor GetNearestColor$descriptor() {
        return GetNearestColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle GetNearestColor$handle() {
        return GetNearestColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment GetNearestColor$address() {
        return GetNearestColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static int GetNearestColor(MemorySegment hdc, int color) {
        var mh$ = GetNearestColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNearestColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNearestPaletteIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNearestPaletteIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static FunctionDescriptor GetNearestPaletteIndex$descriptor() {
        return GetNearestPaletteIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static MethodHandle GetNearestPaletteIndex$handle() {
        return GetNearestPaletteIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static MemorySegment GetNearestPaletteIndex$address() {
        return GetNearestPaletteIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static int GetNearestPaletteIndex(MemorySegment h, int color) {
        var mh$ = GetNearestPaletteIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNearestPaletteIndex", h, color);
            }
            return (int)mh$.invokeExact(h, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetObjectType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor GetObjectType$descriptor() {
        return GetObjectType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static MethodHandle GetObjectType$handle() {
        return GetObjectType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static MemorySegment GetObjectType$address() {
        return GetObjectType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static int GetObjectType(MemorySegment h) {
        var mh$ = GetObjectType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectType", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOutlineTextMetricsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetOutlineTextMetricsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static FunctionDescriptor GetOutlineTextMetricsA$descriptor() {
        return GetOutlineTextMetricsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static MethodHandle GetOutlineTextMetricsA$handle() {
        return GetOutlineTextMetricsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static MemorySegment GetOutlineTextMetricsA$address() {
        return GetOutlineTextMetricsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static int GetOutlineTextMetricsA(MemorySegment hdc, int cjCopy, MemorySegment potm) {
        var mh$ = GetOutlineTextMetricsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOutlineTextMetricsA", hdc, cjCopy, potm);
            }
            return (int)mh$.invokeExact(hdc, cjCopy, potm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOutlineTextMetricsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetOutlineTextMetricsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static FunctionDescriptor GetOutlineTextMetricsW$descriptor() {
        return GetOutlineTextMetricsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static MethodHandle GetOutlineTextMetricsW$handle() {
        return GetOutlineTextMetricsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static MemorySegment GetOutlineTextMetricsW$address() {
        return GetOutlineTextMetricsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static int GetOutlineTextMetricsW(MemorySegment hdc, int cjCopy, MemorySegment potm) {
        var mh$ = GetOutlineTextMetricsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOutlineTextMetricsW", hdc, cjCopy, potm);
            }
            return (int)mh$.invokeExact(hdc, cjCopy, potm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static FunctionDescriptor GetPaletteEntries$descriptor() {
        return GetPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MethodHandle GetPaletteEntries$handle() {
        return GetPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MemorySegment GetPaletteEntries$address() {
        return GetPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static int GetPaletteEntries(MemorySegment hpal, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = GetPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPaletteEntries", hpal, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hpal, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor GetPixel$descriptor() {
        return GetPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle GetPixel$handle() {
        return GetPixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment GetPixel$address() {
        return GetPixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static int GetPixel(MemorySegment hdc, int x, int y) {
        var mh$ = GetPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixel", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetPixelFormat$descriptor() {
        return GetPixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static MethodHandle GetPixelFormat$handle() {
        return GetPixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static MemorySegment GetPixelFormat$address() {
        return GetPixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static int GetPixelFormat(MemorySegment hdc) {
        var mh$ = GetPixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixelFormat", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPolyFillMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPolyFillMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetPolyFillMode$descriptor() {
        return GetPolyFillMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static MethodHandle GetPolyFillMode$handle() {
        return GetPolyFillMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static MemorySegment GetPolyFillMode$address() {
        return GetPolyFillMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static int GetPolyFillMode(MemorySegment hdc) {
        var mh$ = GetPolyFillMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPolyFillMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRasterizerCaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetRasterizerCaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static FunctionDescriptor GetRasterizerCaps$descriptor() {
        return GetRasterizerCaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static MethodHandle GetRasterizerCaps$handle() {
        return GetRasterizerCaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static MemorySegment GetRasterizerCaps$address() {
        return GetRasterizerCaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static int GetRasterizerCaps(MemorySegment lpraststat, int cjBytes) {
        var mh$ = GetRasterizerCaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRasterizerCaps", lpraststat, cjBytes);
            }
            return (int)mh$.invokeExact(lpraststat, cjBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRandomRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetRandomRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static FunctionDescriptor GetRandomRgn$descriptor() {
        return GetRandomRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static MethodHandle GetRandomRgn$handle() {
        return GetRandomRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static MemorySegment GetRandomRgn$address() {
        return GetRandomRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static int GetRandomRgn(MemorySegment hdc, MemorySegment hrgn, int i) {
        var mh$ = GetRandomRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRandomRgn", hdc, hrgn, i);
            }
            return (int)mh$.invokeExact(hdc, hrgn, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRegionData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetRegionData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static FunctionDescriptor GetRegionData$descriptor() {
        return GetRegionData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static MethodHandle GetRegionData$handle() {
        return GetRegionData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static MemorySegment GetRegionData$address() {
        return GetRegionData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static int GetRegionData(MemorySegment hrgn, int nCount, MemorySegment lpRgnData) {
        var mh$ = GetRegionData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRegionData", hrgn, nCount, lpRgnData);
            }
            return (int)mh$.invokeExact(hrgn, nCount, lpRgnData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRgnBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetRgnBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static FunctionDescriptor GetRgnBox$descriptor() {
        return GetRgnBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static MethodHandle GetRgnBox$handle() {
        return GetRgnBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static MemorySegment GetRgnBox$address() {
        return GetRgnBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static int GetRgnBox(MemorySegment hrgn, MemorySegment lprc) {
        var mh$ = GetRgnBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRgnBox", hrgn, lprc);
            }
            return (int)mh$.invokeExact(hrgn, lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStockObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetStockObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static FunctionDescriptor GetStockObject$descriptor() {
        return GetStockObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static MethodHandle GetStockObject$handle() {
        return GetStockObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static MemorySegment GetStockObject$address() {
        return GetStockObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static MemorySegment GetStockObject(int i) {
        var mh$ = GetStockObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStockObject", i);
            }
            return (MemorySegment)mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStretchBltMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetStretchBltMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetStretchBltMode$descriptor() {
        return GetStretchBltMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static MethodHandle GetStretchBltMode$handle() {
        return GetStretchBltMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static MemorySegment GetStretchBltMode$address() {
        return GetStretchBltMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static int GetStretchBltMode(MemorySegment hdc) {
        var mh$ = GetStretchBltMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStretchBltMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static FunctionDescriptor GetSystemPaletteEntries$descriptor() {
        return GetSystemPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MethodHandle GetSystemPaletteEntries$handle() {
        return GetSystemPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MemorySegment GetSystemPaletteEntries$address() {
        return GetSystemPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static int GetSystemPaletteEntries(MemorySegment hdc, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = GetSystemPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPaletteEntries", hdc, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemPaletteUse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemPaletteUse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetSystemPaletteUse$descriptor() {
        return GetSystemPaletteUse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static MethodHandle GetSystemPaletteUse$handle() {
        return GetSystemPaletteUse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static MemorySegment GetSystemPaletteUse$address() {
        return GetSystemPaletteUse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static int GetSystemPaletteUse(MemorySegment hdc) {
        var mh$ = GetSystemPaletteUse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPaletteUse", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextCharacterExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextCharacterExtra");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextCharacterExtra$descriptor() {
        return GetTextCharacterExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static MethodHandle GetTextCharacterExtra$handle() {
        return GetTextCharacterExtra.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static MemorySegment GetTextCharacterExtra$address() {
        return GetTextCharacterExtra.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static int GetTextCharacterExtra(MemorySegment hdc) {
        var mh$ = GetTextCharacterExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharacterExtra", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextAlign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextAlign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextAlign$descriptor() {
        return GetTextAlign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static MethodHandle GetTextAlign$handle() {
        return GetTextAlign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static MemorySegment GetTextAlign$address() {
        return GetTextAlign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static int GetTextAlign(MemorySegment hdc) {
        var mh$ = GetTextAlign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextAlign", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextColor$descriptor() {
        return GetTextColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static MethodHandle GetTextColor$handle() {
        return GetTextColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static MemorySegment GetTextColor$address() {
        return GetTextColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static int GetTextColor(MemorySegment hdc) {
        var mh$ = GetTextColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextExtentPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointA$descriptor() {
        return GetTextExtentPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MethodHandle GetTextExtentPointA$handle() {
        return GetTextExtentPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MemorySegment GetTextExtentPointA$address() {
        return GetTextExtentPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static int GetTextExtentPointA(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment lpsz) {
        var mh$ = GetTextExtentPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointA", hdc, lpString, c, lpsz);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextExtentPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointW$descriptor() {
        return GetTextExtentPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MethodHandle GetTextExtentPointW$handle() {
        return GetTextExtentPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MemorySegment GetTextExtentPointW$address() {
        return GetTextExtentPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static int GetTextExtentPointW(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment lpsz) {
        var mh$ = GetTextExtentPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointW", hdc, lpString, c, lpsz);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPoint32A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextExtentPoint32A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static FunctionDescriptor GetTextExtentPoint32A$descriptor() {
        return GetTextExtentPoint32A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MethodHandle GetTextExtentPoint32A$handle() {
        return GetTextExtentPoint32A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MemorySegment GetTextExtentPoint32A$address() {
        return GetTextExtentPoint32A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static int GetTextExtentPoint32A(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment psizl) {
        var mh$ = GetTextExtentPoint32A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPoint32A", hdc, lpString, c, psizl);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, psizl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPoint32W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextExtentPoint32W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static FunctionDescriptor GetTextExtentPoint32W$descriptor() {
        return GetTextExtentPoint32W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MethodHandle GetTextExtentPoint32W$handle() {
        return GetTextExtentPoint32W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MemorySegment GetTextExtentPoint32W$address() {
        return GetTextExtentPoint32W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static int GetTextExtentPoint32W(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment psizl) {
        var mh$ = GetTextExtentPoint32W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPoint32W", hdc, lpString, c, psizl);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, psizl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextExtentExPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointA$descriptor() {
        return GetTextExtentExPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointA$handle() {
        return GetTextExtentExPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MemorySegment GetTextExtentExPointA$address() {
        return GetTextExtentExPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointA(MemorySegment hdc, MemorySegment lpszString, int cchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointA", hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextExtentExPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointW$descriptor() {
        return GetTextExtentExPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointW$handle() {
        return GetTextExtentExPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MemorySegment GetTextExtentExPointW$address() {
        return GetTextExtentExPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointW(MemorySegment hdc, MemorySegment lpszString, int cchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointW", hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextCharset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextCharset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextCharset$descriptor() {
        return GetTextCharset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static MethodHandle GetTextCharset$handle() {
        return GetTextCharset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static MemorySegment GetTextCharset$address() {
        return GetTextCharset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static int GetTextCharset(MemorySegment hdc) {
        var mh$ = GetTextCharset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharset", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

