// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct IXMLDOMAttributeVtbl {
 *     HRESULT (*QueryInterface)(IXMLDOMAttribute *, const IID *const, void **) __attribute__((stdcall));
 *     ULONG (*AddRef)(IXMLDOMAttribute *) __attribute__((stdcall));
 *     ULONG (*Release)(IXMLDOMAttribute *) __attribute__((stdcall));
 *     HRESULT (*GetTypeInfoCount)(IXMLDOMAttribute *, UINT *) __attribute__((stdcall));
 *     HRESULT (*GetTypeInfo)(IXMLDOMAttribute *, UINT, LCID, ITypeInfo **) __attribute__((stdcall));
 *     HRESULT (*GetIDsOfNames)(IXMLDOMAttribute *, const IID *const, LPOLESTR *, UINT, LCID, DISPID *) __attribute__((stdcall));
 *     HRESULT (*Invoke)(IXMLDOMAttribute *, DISPID, const IID *const, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall));
 *     HRESULT (*get_nodeName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*get_nodeValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall));
 *     HRESULT (*put_nodeValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall));
 *     HRESULT (*get_nodeType)(IXMLDOMAttribute *, DOMNodeType *) __attribute__((stdcall));
 *     HRESULT (*get_parentNode)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*get_childNodes)(IXMLDOMAttribute *, IXMLDOMNodeList **) __attribute__((stdcall));
 *     HRESULT (*get_firstChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*get_lastChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*get_previousSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*get_nextSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*get_attributes)(IXMLDOMAttribute *, IXMLDOMNamedNodeMap **) __attribute__((stdcall));
 *     HRESULT (*insertBefore)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*replaceChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*removeChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*appendChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*hasChildNodes)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall));
 *     HRESULT (*get_ownerDocument)(IXMLDOMAttribute *, IXMLDOMDocument **) __attribute__((stdcall));
 *     HRESULT (*cloneNode)(IXMLDOMAttribute *, VARIANT_BOOL, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*get_nodeTypeString)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*get_text)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*put_text)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall));
 *     HRESULT (*get_specified)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall));
 *     HRESULT (*get_definition)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*get_nodeTypedValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall));
 *     HRESULT (*put_nodeTypedValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall));
 *     HRESULT (*get_dataType)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall));
 *     HRESULT (*put_dataType)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall));
 *     HRESULT (*get_xml)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*transformNode)(IXMLDOMAttribute *, IXMLDOMNode *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*selectNodes)(IXMLDOMAttribute *, BSTR, IXMLDOMNodeList **) __attribute__((stdcall));
 *     HRESULT (*selectSingleNode)(IXMLDOMAttribute *, BSTR, IXMLDOMNode **) __attribute__((stdcall));
 *     HRESULT (*get_parsed)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall));
 *     HRESULT (*get_namespaceURI)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*get_prefix)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*get_baseName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*transformNodeToObject)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT) __attribute__((stdcall));
 *     HRESULT (*get_name)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*get_value)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall));
 *     HRESULT (*put_value)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall));
 * }
 * }
 */
public class IXMLDOMAttributeVtbl {

    IXMLDOMAttributeVtbl() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        wgl_h.C_POINTER.withName("QueryInterface"),
        wgl_h.C_POINTER.withName("AddRef"),
        wgl_h.C_POINTER.withName("Release"),
        wgl_h.C_POINTER.withName("GetTypeInfoCount"),
        wgl_h.C_POINTER.withName("GetTypeInfo"),
        wgl_h.C_POINTER.withName("GetIDsOfNames"),
        wgl_h.C_POINTER.withName("Invoke"),
        wgl_h.C_POINTER.withName("get_nodeName"),
        wgl_h.C_POINTER.withName("get_nodeValue"),
        wgl_h.C_POINTER.withName("put_nodeValue"),
        wgl_h.C_POINTER.withName("get_nodeType"),
        wgl_h.C_POINTER.withName("get_parentNode"),
        wgl_h.C_POINTER.withName("get_childNodes"),
        wgl_h.C_POINTER.withName("get_firstChild"),
        wgl_h.C_POINTER.withName("get_lastChild"),
        wgl_h.C_POINTER.withName("get_previousSibling"),
        wgl_h.C_POINTER.withName("get_nextSibling"),
        wgl_h.C_POINTER.withName("get_attributes"),
        wgl_h.C_POINTER.withName("insertBefore"),
        wgl_h.C_POINTER.withName("replaceChild"),
        wgl_h.C_POINTER.withName("removeChild"),
        wgl_h.C_POINTER.withName("appendChild"),
        wgl_h.C_POINTER.withName("hasChildNodes"),
        wgl_h.C_POINTER.withName("get_ownerDocument"),
        wgl_h.C_POINTER.withName("cloneNode"),
        wgl_h.C_POINTER.withName("get_nodeTypeString"),
        wgl_h.C_POINTER.withName("get_text"),
        wgl_h.C_POINTER.withName("put_text"),
        wgl_h.C_POINTER.withName("get_specified"),
        wgl_h.C_POINTER.withName("get_definition"),
        wgl_h.C_POINTER.withName("get_nodeTypedValue"),
        wgl_h.C_POINTER.withName("put_nodeTypedValue"),
        wgl_h.C_POINTER.withName("get_dataType"),
        wgl_h.C_POINTER.withName("put_dataType"),
        wgl_h.C_POINTER.withName("get_xml"),
        wgl_h.C_POINTER.withName("transformNode"),
        wgl_h.C_POINTER.withName("selectNodes"),
        wgl_h.C_POINTER.withName("selectSingleNode"),
        wgl_h.C_POINTER.withName("get_parsed"),
        wgl_h.C_POINTER.withName("get_namespaceURI"),
        wgl_h.C_POINTER.withName("get_prefix"),
        wgl_h.C_POINTER.withName("get_baseName"),
        wgl_h.C_POINTER.withName("transformNodeToObject"),
        wgl_h.C_POINTER.withName("get_name"),
        wgl_h.C_POINTER.withName("get_value"),
        wgl_h.C_POINTER.withName("put_value")
    ).withName("IXMLDOMAttributeVtbl");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(IXMLDOMAttribute *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static class QueryInterface {

        QueryInterface() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(QueryInterface.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(QueryInterface.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout QueryInterface$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("QueryInterface"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(IXMLDOMAttribute *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout QueryInterface$layout() {
        return QueryInterface$LAYOUT;
    }

    private static final long QueryInterface$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(IXMLDOMAttribute *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static final long QueryInterface$offset() {
        return QueryInterface$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(IXMLDOMAttribute *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment QueryInterface(MemorySegment struct) {
        return struct.get(QueryInterface$LAYOUT, QueryInterface$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(IXMLDOMAttribute *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static void QueryInterface(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(QueryInterface$LAYOUT, QueryInterface$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ULONG (*AddRef)(IXMLDOMAttribute *) __attribute__((stdcall))
     * }
     */
    public static class AddRef {

        AddRef() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(AddRef.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddRef.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddRef$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddRef"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(IXMLDOMAttribute *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout AddRef$layout() {
        return AddRef$LAYOUT;
    }

    private static final long AddRef$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(IXMLDOMAttribute *) __attribute__((stdcall))
     * }
     */
    public static final long AddRef$offset() {
        return AddRef$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(IXMLDOMAttribute *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment AddRef(MemorySegment struct) {
        return struct.get(AddRef$LAYOUT, AddRef$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(IXMLDOMAttribute *) __attribute__((stdcall))
     * }
     */
    public static void AddRef(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddRef$LAYOUT, AddRef$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ULONG (*Release)(IXMLDOMAttribute *) __attribute__((stdcall))
     * }
     */
    public static class Release {

        Release() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(Release.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Release.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Release$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Release"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG (*Release)(IXMLDOMAttribute *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout Release$layout() {
        return Release$LAYOUT;
    }

    private static final long Release$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG (*Release)(IXMLDOMAttribute *) __attribute__((stdcall))
     * }
     */
    public static final long Release$offset() {
        return Release$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG (*Release)(IXMLDOMAttribute *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment Release(MemorySegment struct) {
        return struct.get(Release$LAYOUT, Release$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG (*Release)(IXMLDOMAttribute *) __attribute__((stdcall))
     * }
     */
    public static void Release(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Release$LAYOUT, Release$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetTypeInfoCount)(IXMLDOMAttribute *, UINT *) __attribute__((stdcall))
     * }
     */
    public static class GetTypeInfoCount {

        GetTypeInfoCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetTypeInfoCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTypeInfoCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTypeInfoCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTypeInfoCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeInfoCount)(IXMLDOMAttribute *, UINT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetTypeInfoCount$layout() {
        return GetTypeInfoCount$LAYOUT;
    }

    private static final long GetTypeInfoCount$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeInfoCount)(IXMLDOMAttribute *, UINT *) __attribute__((stdcall))
     * }
     */
    public static final long GetTypeInfoCount$offset() {
        return GetTypeInfoCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeInfoCount)(IXMLDOMAttribute *, UINT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetTypeInfoCount(MemorySegment struct) {
        return struct.get(GetTypeInfoCount$LAYOUT, GetTypeInfoCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeInfoCount)(IXMLDOMAttribute *, UINT *) __attribute__((stdcall))
     * }
     */
    public static void GetTypeInfoCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTypeInfoCount$LAYOUT, GetTypeInfoCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetTypeInfo)(IXMLDOMAttribute *, UINT, LCID, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static class GetTypeInfo {

        GetTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeInfo)(IXMLDOMAttribute *, UINT, LCID, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetTypeInfo$layout() {
        return GetTypeInfo$LAYOUT;
    }

    private static final long GetTypeInfo$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeInfo)(IXMLDOMAttribute *, UINT, LCID, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static final long GetTypeInfo$offset() {
        return GetTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeInfo)(IXMLDOMAttribute *, UINT, LCID, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetTypeInfo(MemorySegment struct) {
        return struct.get(GetTypeInfo$LAYOUT, GetTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeInfo)(IXMLDOMAttribute *, UINT, LCID, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static void GetTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTypeInfo$LAYOUT, GetTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(IXMLDOMAttribute *, const IID *const, LPOLESTR *, UINT, LCID, DISPID *) __attribute__((stdcall))
     * }
     */
    public static class GetIDsOfNames {

        GetIDsOfNames() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetIDsOfNames.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetIDsOfNames.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetIDsOfNames$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetIDsOfNames"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(IXMLDOMAttribute *, const IID *const, LPOLESTR *, UINT, LCID, DISPID *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetIDsOfNames$layout() {
        return GetIDsOfNames$LAYOUT;
    }

    private static final long GetIDsOfNames$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(IXMLDOMAttribute *, const IID *const, LPOLESTR *, UINT, LCID, DISPID *) __attribute__((stdcall))
     * }
     */
    public static final long GetIDsOfNames$offset() {
        return GetIDsOfNames$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(IXMLDOMAttribute *, const IID *const, LPOLESTR *, UINT, LCID, DISPID *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetIDsOfNames(MemorySegment struct) {
        return struct.get(GetIDsOfNames$LAYOUT, GetIDsOfNames$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(IXMLDOMAttribute *, const IID *const, LPOLESTR *, UINT, LCID, DISPID *) __attribute__((stdcall))
     * }
     */
    public static void GetIDsOfNames(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetIDsOfNames$LAYOUT, GetIDsOfNames$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*Invoke)(IXMLDOMAttribute *, DISPID, const IID *const, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static class Invoke {

        Invoke() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, short _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(Invoke.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Invoke.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, short _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Invoke$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Invoke"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(IXMLDOMAttribute *, DISPID, const IID *const, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout Invoke$layout() {
        return Invoke$LAYOUT;
    }

    private static final long Invoke$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(IXMLDOMAttribute *, DISPID, const IID *const, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static final long Invoke$offset() {
        return Invoke$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(IXMLDOMAttribute *, DISPID, const IID *const, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment Invoke(MemorySegment struct) {
        return struct.get(Invoke$LAYOUT, Invoke$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(IXMLDOMAttribute *, DISPID, const IID *const, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static void Invoke(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Invoke$LAYOUT, Invoke$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_nodeName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class get_nodeName {

        get_nodeName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_nodeName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_nodeName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_nodeName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_nodeName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_nodeName$layout() {
        return get_nodeName$LAYOUT;
    }

    private static final long get_nodeName$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long get_nodeName$offset() {
        return get_nodeName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_nodeName(MemorySegment struct) {
        return struct.get(get_nodeName$LAYOUT, get_nodeName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void get_nodeName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_nodeName$LAYOUT, get_nodeName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_nodeValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static class get_nodeValue {

        get_nodeValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_nodeValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_nodeValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_nodeValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_nodeValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_nodeValue$layout() {
        return get_nodeValue$LAYOUT;
    }

    private static final long get_nodeValue$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final long get_nodeValue$offset() {
        return get_nodeValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_nodeValue(MemorySegment struct) {
        return struct.get(get_nodeValue$LAYOUT, get_nodeValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static void get_nodeValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_nodeValue$LAYOUT, get_nodeValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*put_nodeValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static class put_nodeValue {

        put_nodeValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            tagVARIANT.layout()
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(put_nodeValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(put_nodeValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout put_nodeValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("put_nodeValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*put_nodeValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout put_nodeValue$layout() {
        return put_nodeValue$LAYOUT;
    }

    private static final long put_nodeValue$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*put_nodeValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static final long put_nodeValue$offset() {
        return put_nodeValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*put_nodeValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static MemorySegment put_nodeValue(MemorySegment struct) {
        return struct.get(put_nodeValue$LAYOUT, put_nodeValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*put_nodeValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static void put_nodeValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(put_nodeValue$LAYOUT, put_nodeValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_nodeType)(IXMLDOMAttribute *, DOMNodeType *) __attribute__((stdcall))
     * }
     */
    public static class get_nodeType {

        get_nodeType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_nodeType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_nodeType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_nodeType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_nodeType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeType)(IXMLDOMAttribute *, DOMNodeType *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_nodeType$layout() {
        return get_nodeType$LAYOUT;
    }

    private static final long get_nodeType$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeType)(IXMLDOMAttribute *, DOMNodeType *) __attribute__((stdcall))
     * }
     */
    public static final long get_nodeType$offset() {
        return get_nodeType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeType)(IXMLDOMAttribute *, DOMNodeType *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_nodeType(MemorySegment struct) {
        return struct.get(get_nodeType$LAYOUT, get_nodeType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeType)(IXMLDOMAttribute *, DOMNodeType *) __attribute__((stdcall))
     * }
     */
    public static void get_nodeType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_nodeType$LAYOUT, get_nodeType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_parentNode)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class get_parentNode {

        get_parentNode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_parentNode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_parentNode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_parentNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_parentNode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_parentNode)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_parentNode$layout() {
        return get_parentNode$LAYOUT;
    }

    private static final long get_parentNode$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_parentNode)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long get_parentNode$offset() {
        return get_parentNode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_parentNode)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_parentNode(MemorySegment struct) {
        return struct.get(get_parentNode$LAYOUT, get_parentNode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_parentNode)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void get_parentNode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_parentNode$LAYOUT, get_parentNode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_childNodes)(IXMLDOMAttribute *, IXMLDOMNodeList **) __attribute__((stdcall))
     * }
     */
    public static class get_childNodes {

        get_childNodes() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_childNodes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_childNodes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_childNodes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_childNodes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_childNodes)(IXMLDOMAttribute *, IXMLDOMNodeList **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_childNodes$layout() {
        return get_childNodes$LAYOUT;
    }

    private static final long get_childNodes$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_childNodes)(IXMLDOMAttribute *, IXMLDOMNodeList **) __attribute__((stdcall))
     * }
     */
    public static final long get_childNodes$offset() {
        return get_childNodes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_childNodes)(IXMLDOMAttribute *, IXMLDOMNodeList **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_childNodes(MemorySegment struct) {
        return struct.get(get_childNodes$LAYOUT, get_childNodes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_childNodes)(IXMLDOMAttribute *, IXMLDOMNodeList **) __attribute__((stdcall))
     * }
     */
    public static void get_childNodes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_childNodes$LAYOUT, get_childNodes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_firstChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class get_firstChild {

        get_firstChild() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_firstChild.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_firstChild.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_firstChild$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_firstChild"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_firstChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_firstChild$layout() {
        return get_firstChild$LAYOUT;
    }

    private static final long get_firstChild$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_firstChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long get_firstChild$offset() {
        return get_firstChild$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_firstChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_firstChild(MemorySegment struct) {
        return struct.get(get_firstChild$LAYOUT, get_firstChild$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_firstChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void get_firstChild(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_firstChild$LAYOUT, get_firstChild$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_lastChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class get_lastChild {

        get_lastChild() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_lastChild.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_lastChild.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_lastChild$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_lastChild"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_lastChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_lastChild$layout() {
        return get_lastChild$LAYOUT;
    }

    private static final long get_lastChild$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_lastChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long get_lastChild$offset() {
        return get_lastChild$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_lastChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_lastChild(MemorySegment struct) {
        return struct.get(get_lastChild$LAYOUT, get_lastChild$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_lastChild)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void get_lastChild(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_lastChild$LAYOUT, get_lastChild$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_previousSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class get_previousSibling {

        get_previousSibling() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_previousSibling.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_previousSibling.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_previousSibling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_previousSibling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_previousSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_previousSibling$layout() {
        return get_previousSibling$LAYOUT;
    }

    private static final long get_previousSibling$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_previousSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long get_previousSibling$offset() {
        return get_previousSibling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_previousSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_previousSibling(MemorySegment struct) {
        return struct.get(get_previousSibling$LAYOUT, get_previousSibling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_previousSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void get_previousSibling(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_previousSibling$LAYOUT, get_previousSibling$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_nextSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class get_nextSibling {

        get_nextSibling() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_nextSibling.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_nextSibling.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_nextSibling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_nextSibling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_nextSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_nextSibling$layout() {
        return get_nextSibling$LAYOUT;
    }

    private static final long get_nextSibling$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_nextSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long get_nextSibling$offset() {
        return get_nextSibling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nextSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_nextSibling(MemorySegment struct) {
        return struct.get(get_nextSibling$LAYOUT, get_nextSibling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nextSibling)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void get_nextSibling(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_nextSibling$LAYOUT, get_nextSibling$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_attributes)(IXMLDOMAttribute *, IXMLDOMNamedNodeMap **) __attribute__((stdcall))
     * }
     */
    public static class get_attributes {

        get_attributes() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_attributes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_attributes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_attributes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_attributes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_attributes)(IXMLDOMAttribute *, IXMLDOMNamedNodeMap **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_attributes$layout() {
        return get_attributes$LAYOUT;
    }

    private static final long get_attributes$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_attributes)(IXMLDOMAttribute *, IXMLDOMNamedNodeMap **) __attribute__((stdcall))
     * }
     */
    public static final long get_attributes$offset() {
        return get_attributes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_attributes)(IXMLDOMAttribute *, IXMLDOMNamedNodeMap **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_attributes(MemorySegment struct) {
        return struct.get(get_attributes$LAYOUT, get_attributes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_attributes)(IXMLDOMAttribute *, IXMLDOMNamedNodeMap **) __attribute__((stdcall))
     * }
     */
    public static void get_attributes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_attributes$LAYOUT, get_attributes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*insertBefore)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class insertBefore {

        insertBefore() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            tagVARIANT.layout(),
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(insertBefore.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(insertBefore.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout insertBefore$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("insertBefore"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*insertBefore)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout insertBefore$layout() {
        return insertBefore$LAYOUT;
    }

    private static final long insertBefore$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*insertBefore)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long insertBefore$offset() {
        return insertBefore$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*insertBefore)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment insertBefore(MemorySegment struct) {
        return struct.get(insertBefore$LAYOUT, insertBefore$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*insertBefore)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void insertBefore(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(insertBefore$LAYOUT, insertBefore$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*replaceChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class replaceChild {

        replaceChild() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(replaceChild.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(replaceChild.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout replaceChild$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("replaceChild"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*replaceChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout replaceChild$layout() {
        return replaceChild$LAYOUT;
    }

    private static final long replaceChild$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*replaceChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long replaceChild$offset() {
        return replaceChild$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*replaceChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment replaceChild(MemorySegment struct) {
        return struct.get(replaceChild$LAYOUT, replaceChild$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*replaceChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void replaceChild(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(replaceChild$LAYOUT, replaceChild$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*removeChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class removeChild {

        removeChild() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(removeChild.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(removeChild.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout removeChild$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("removeChild"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*removeChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout removeChild$layout() {
        return removeChild$LAYOUT;
    }

    private static final long removeChild$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*removeChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long removeChild$offset() {
        return removeChild$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*removeChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment removeChild(MemorySegment struct) {
        return struct.get(removeChild$LAYOUT, removeChild$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*removeChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void removeChild(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(removeChild$LAYOUT, removeChild$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*appendChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class appendChild {

        appendChild() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(appendChild.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(appendChild.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout appendChild$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("appendChild"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*appendChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout appendChild$layout() {
        return appendChild$LAYOUT;
    }

    private static final long appendChild$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*appendChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long appendChild$offset() {
        return appendChild$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*appendChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment appendChild(MemorySegment struct) {
        return struct.get(appendChild$LAYOUT, appendChild$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*appendChild)(IXMLDOMAttribute *, IXMLDOMNode *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void appendChild(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(appendChild$LAYOUT, appendChild$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*hasChildNodes)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static class hasChildNodes {

        hasChildNodes() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(hasChildNodes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(hasChildNodes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout hasChildNodes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("hasChildNodes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*hasChildNodes)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout hasChildNodes$layout() {
        return hasChildNodes$LAYOUT;
    }

    private static final long hasChildNodes$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*hasChildNodes)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static final long hasChildNodes$offset() {
        return hasChildNodes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*hasChildNodes)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment hasChildNodes(MemorySegment struct) {
        return struct.get(hasChildNodes$LAYOUT, hasChildNodes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*hasChildNodes)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static void hasChildNodes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(hasChildNodes$LAYOUT, hasChildNodes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_ownerDocument)(IXMLDOMAttribute *, IXMLDOMDocument **) __attribute__((stdcall))
     * }
     */
    public static class get_ownerDocument {

        get_ownerDocument() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_ownerDocument.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_ownerDocument.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_ownerDocument$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_ownerDocument"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_ownerDocument)(IXMLDOMAttribute *, IXMLDOMDocument **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_ownerDocument$layout() {
        return get_ownerDocument$LAYOUT;
    }

    private static final long get_ownerDocument$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_ownerDocument)(IXMLDOMAttribute *, IXMLDOMDocument **) __attribute__((stdcall))
     * }
     */
    public static final long get_ownerDocument$offset() {
        return get_ownerDocument$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_ownerDocument)(IXMLDOMAttribute *, IXMLDOMDocument **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_ownerDocument(MemorySegment struct) {
        return struct.get(get_ownerDocument$LAYOUT, get_ownerDocument$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_ownerDocument)(IXMLDOMAttribute *, IXMLDOMDocument **) __attribute__((stdcall))
     * }
     */
    public static void get_ownerDocument(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_ownerDocument$LAYOUT, get_ownerDocument$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*cloneNode)(IXMLDOMAttribute *, VARIANT_BOOL, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class cloneNode {

        cloneNode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, short _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(cloneNode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(cloneNode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, short _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout cloneNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cloneNode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*cloneNode)(IXMLDOMAttribute *, VARIANT_BOOL, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout cloneNode$layout() {
        return cloneNode$LAYOUT;
    }

    private static final long cloneNode$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*cloneNode)(IXMLDOMAttribute *, VARIANT_BOOL, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long cloneNode$offset() {
        return cloneNode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*cloneNode)(IXMLDOMAttribute *, VARIANT_BOOL, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment cloneNode(MemorySegment struct) {
        return struct.get(cloneNode$LAYOUT, cloneNode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*cloneNode)(IXMLDOMAttribute *, VARIANT_BOOL, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void cloneNode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cloneNode$LAYOUT, cloneNode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_nodeTypeString)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class get_nodeTypeString {

        get_nodeTypeString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_nodeTypeString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_nodeTypeString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_nodeTypeString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_nodeTypeString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeTypeString)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_nodeTypeString$layout() {
        return get_nodeTypeString$LAYOUT;
    }

    private static final long get_nodeTypeString$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeTypeString)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long get_nodeTypeString$offset() {
        return get_nodeTypeString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeTypeString)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_nodeTypeString(MemorySegment struct) {
        return struct.get(get_nodeTypeString$LAYOUT, get_nodeTypeString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeTypeString)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void get_nodeTypeString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_nodeTypeString$LAYOUT, get_nodeTypeString$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_text)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class get_text {

        get_text() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_text.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_text.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_text$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_text"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_text)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_text$layout() {
        return get_text$LAYOUT;
    }

    private static final long get_text$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_text)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long get_text$offset() {
        return get_text$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_text)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_text(MemorySegment struct) {
        return struct.get(get_text$LAYOUT, get_text$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_text)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void get_text(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_text$LAYOUT, get_text$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*put_text)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall))
     * }
     */
    public static class put_text {

        put_text() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(put_text.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(put_text.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout put_text$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("put_text"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*put_text)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout put_text$layout() {
        return put_text$LAYOUT;
    }

    private static final long put_text$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*put_text)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall))
     * }
     */
    public static final long put_text$offset() {
        return put_text$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*put_text)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall))
     * }
     */
    public static MemorySegment put_text(MemorySegment struct) {
        return struct.get(put_text$LAYOUT, put_text$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*put_text)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall))
     * }
     */
    public static void put_text(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(put_text$LAYOUT, put_text$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_specified)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static class get_specified {

        get_specified() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_specified.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_specified.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_specified$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_specified"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_specified)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_specified$layout() {
        return get_specified$LAYOUT;
    }

    private static final long get_specified$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_specified)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static final long get_specified$offset() {
        return get_specified$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_specified)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_specified(MemorySegment struct) {
        return struct.get(get_specified$LAYOUT, get_specified$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_specified)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static void get_specified(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_specified$LAYOUT, get_specified$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_definition)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class get_definition {

        get_definition() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_definition.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_definition.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_definition$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_definition"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_definition)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_definition$layout() {
        return get_definition$LAYOUT;
    }

    private static final long get_definition$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_definition)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long get_definition$offset() {
        return get_definition$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_definition)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_definition(MemorySegment struct) {
        return struct.get(get_definition$LAYOUT, get_definition$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_definition)(IXMLDOMAttribute *, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void get_definition(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_definition$LAYOUT, get_definition$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_nodeTypedValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static class get_nodeTypedValue {

        get_nodeTypedValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_nodeTypedValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_nodeTypedValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_nodeTypedValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_nodeTypedValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeTypedValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_nodeTypedValue$layout() {
        return get_nodeTypedValue$LAYOUT;
    }

    private static final long get_nodeTypedValue$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeTypedValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final long get_nodeTypedValue$offset() {
        return get_nodeTypedValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeTypedValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_nodeTypedValue(MemorySegment struct) {
        return struct.get(get_nodeTypedValue$LAYOUT, get_nodeTypedValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_nodeTypedValue)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static void get_nodeTypedValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_nodeTypedValue$LAYOUT, get_nodeTypedValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*put_nodeTypedValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static class put_nodeTypedValue {

        put_nodeTypedValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            tagVARIANT.layout()
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(put_nodeTypedValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(put_nodeTypedValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout put_nodeTypedValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("put_nodeTypedValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*put_nodeTypedValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout put_nodeTypedValue$layout() {
        return put_nodeTypedValue$LAYOUT;
    }

    private static final long put_nodeTypedValue$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*put_nodeTypedValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static final long put_nodeTypedValue$offset() {
        return put_nodeTypedValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*put_nodeTypedValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static MemorySegment put_nodeTypedValue(MemorySegment struct) {
        return struct.get(put_nodeTypedValue$LAYOUT, put_nodeTypedValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*put_nodeTypedValue)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static void put_nodeTypedValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(put_nodeTypedValue$LAYOUT, put_nodeTypedValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_dataType)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static class get_dataType {

        get_dataType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_dataType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_dataType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_dataType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_dataType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_dataType)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_dataType$layout() {
        return get_dataType$LAYOUT;
    }

    private static final long get_dataType$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_dataType)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final long get_dataType$offset() {
        return get_dataType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_dataType)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_dataType(MemorySegment struct) {
        return struct.get(get_dataType$LAYOUT, get_dataType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_dataType)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static void get_dataType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_dataType$LAYOUT, get_dataType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*put_dataType)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall))
     * }
     */
    public static class put_dataType {

        put_dataType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(put_dataType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(put_dataType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout put_dataType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("put_dataType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*put_dataType)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout put_dataType$layout() {
        return put_dataType$LAYOUT;
    }

    private static final long put_dataType$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*put_dataType)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall))
     * }
     */
    public static final long put_dataType$offset() {
        return put_dataType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*put_dataType)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall))
     * }
     */
    public static MemorySegment put_dataType(MemorySegment struct) {
        return struct.get(put_dataType$LAYOUT, put_dataType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*put_dataType)(IXMLDOMAttribute *, BSTR) __attribute__((stdcall))
     * }
     */
    public static void put_dataType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(put_dataType$LAYOUT, put_dataType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_xml)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class get_xml {

        get_xml() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_xml.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_xml.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_xml$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_xml"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_xml)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_xml$layout() {
        return get_xml$LAYOUT;
    }

    private static final long get_xml$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_xml)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long get_xml$offset() {
        return get_xml$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_xml)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_xml(MemorySegment struct) {
        return struct.get(get_xml$LAYOUT, get_xml$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_xml)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void get_xml(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_xml$LAYOUT, get_xml$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*transformNode)(IXMLDOMAttribute *, IXMLDOMNode *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class transformNode {

        transformNode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(transformNode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(transformNode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout transformNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("transformNode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*transformNode)(IXMLDOMAttribute *, IXMLDOMNode *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout transformNode$layout() {
        return transformNode$LAYOUT;
    }

    private static final long transformNode$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*transformNode)(IXMLDOMAttribute *, IXMLDOMNode *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long transformNode$offset() {
        return transformNode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*transformNode)(IXMLDOMAttribute *, IXMLDOMNode *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment transformNode(MemorySegment struct) {
        return struct.get(transformNode$LAYOUT, transformNode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*transformNode)(IXMLDOMAttribute *, IXMLDOMNode *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void transformNode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(transformNode$LAYOUT, transformNode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*selectNodes)(IXMLDOMAttribute *, BSTR, IXMLDOMNodeList **) __attribute__((stdcall))
     * }
     */
    public static class selectNodes {

        selectNodes() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(selectNodes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(selectNodes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout selectNodes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("selectNodes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*selectNodes)(IXMLDOMAttribute *, BSTR, IXMLDOMNodeList **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout selectNodes$layout() {
        return selectNodes$LAYOUT;
    }

    private static final long selectNodes$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*selectNodes)(IXMLDOMAttribute *, BSTR, IXMLDOMNodeList **) __attribute__((stdcall))
     * }
     */
    public static final long selectNodes$offset() {
        return selectNodes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*selectNodes)(IXMLDOMAttribute *, BSTR, IXMLDOMNodeList **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment selectNodes(MemorySegment struct) {
        return struct.get(selectNodes$LAYOUT, selectNodes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*selectNodes)(IXMLDOMAttribute *, BSTR, IXMLDOMNodeList **) __attribute__((stdcall))
     * }
     */
    public static void selectNodes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(selectNodes$LAYOUT, selectNodes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*selectSingleNode)(IXMLDOMAttribute *, BSTR, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static class selectSingleNode {

        selectSingleNode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(selectSingleNode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(selectSingleNode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout selectSingleNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("selectSingleNode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*selectSingleNode)(IXMLDOMAttribute *, BSTR, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout selectSingleNode$layout() {
        return selectSingleNode$LAYOUT;
    }

    private static final long selectSingleNode$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*selectSingleNode)(IXMLDOMAttribute *, BSTR, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static final long selectSingleNode$offset() {
        return selectSingleNode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*selectSingleNode)(IXMLDOMAttribute *, BSTR, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment selectSingleNode(MemorySegment struct) {
        return struct.get(selectSingleNode$LAYOUT, selectSingleNode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*selectSingleNode)(IXMLDOMAttribute *, BSTR, IXMLDOMNode **) __attribute__((stdcall))
     * }
     */
    public static void selectSingleNode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(selectSingleNode$LAYOUT, selectSingleNode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_parsed)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static class get_parsed {

        get_parsed() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_parsed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_parsed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_parsed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_parsed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_parsed)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_parsed$layout() {
        return get_parsed$LAYOUT;
    }

    private static final long get_parsed$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_parsed)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static final long get_parsed$offset() {
        return get_parsed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_parsed)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_parsed(MemorySegment struct) {
        return struct.get(get_parsed$LAYOUT, get_parsed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_parsed)(IXMLDOMAttribute *, VARIANT_BOOL *) __attribute__((stdcall))
     * }
     */
    public static void get_parsed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_parsed$LAYOUT, get_parsed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_namespaceURI)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class get_namespaceURI {

        get_namespaceURI() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_namespaceURI.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_namespaceURI.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_namespaceURI$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_namespaceURI"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_namespaceURI)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_namespaceURI$layout() {
        return get_namespaceURI$LAYOUT;
    }

    private static final long get_namespaceURI$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_namespaceURI)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long get_namespaceURI$offset() {
        return get_namespaceURI$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_namespaceURI)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_namespaceURI(MemorySegment struct) {
        return struct.get(get_namespaceURI$LAYOUT, get_namespaceURI$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_namespaceURI)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void get_namespaceURI(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_namespaceURI$LAYOUT, get_namespaceURI$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_prefix)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class get_prefix {

        get_prefix() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_prefix.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_prefix.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_prefix$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_prefix"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_prefix)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_prefix$layout() {
        return get_prefix$LAYOUT;
    }

    private static final long get_prefix$OFFSET = 320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_prefix)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long get_prefix$offset() {
        return get_prefix$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_prefix)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_prefix(MemorySegment struct) {
        return struct.get(get_prefix$LAYOUT, get_prefix$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_prefix)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void get_prefix(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_prefix$LAYOUT, get_prefix$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_baseName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class get_baseName {

        get_baseName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_baseName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_baseName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_baseName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_baseName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_baseName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_baseName$layout() {
        return get_baseName$LAYOUT;
    }

    private static final long get_baseName$OFFSET = 328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_baseName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long get_baseName$offset() {
        return get_baseName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_baseName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_baseName(MemorySegment struct) {
        return struct.get(get_baseName$LAYOUT, get_baseName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_baseName)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void get_baseName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_baseName$LAYOUT, get_baseName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*transformNodeToObject)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static class transformNodeToObject {

        transformNodeToObject() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            tagVARIANT.layout()
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(transformNodeToObject.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(transformNodeToObject.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout transformNodeToObject$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("transformNodeToObject"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*transformNodeToObject)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout transformNodeToObject$layout() {
        return transformNodeToObject$LAYOUT;
    }

    private static final long transformNodeToObject$OFFSET = 336;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*transformNodeToObject)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static final long transformNodeToObject$offset() {
        return transformNodeToObject$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*transformNodeToObject)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static MemorySegment transformNodeToObject(MemorySegment struct) {
        return struct.get(transformNodeToObject$LAYOUT, transformNodeToObject$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*transformNodeToObject)(IXMLDOMAttribute *, IXMLDOMNode *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static void transformNodeToObject(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(transformNodeToObject$LAYOUT, transformNodeToObject$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_name)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class get_name {

        get_name() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_name.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_name.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_name)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_name$layout() {
        return get_name$LAYOUT;
    }

    private static final long get_name$OFFSET = 344;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_name)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long get_name$offset() {
        return get_name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_name)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_name(MemorySegment struct) {
        return struct.get(get_name$LAYOUT, get_name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_name)(IXMLDOMAttribute *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void get_name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_name$LAYOUT, get_name$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*get_value)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static class get_value {

        get_value() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(get_value.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_value.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_value$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_value"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*get_value)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout get_value$layout() {
        return get_value$LAYOUT;
    }

    private static final long get_value$OFFSET = 352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*get_value)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static final long get_value$offset() {
        return get_value$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*get_value)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment get_value(MemorySegment struct) {
        return struct.get(get_value$LAYOUT, get_value$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*get_value)(IXMLDOMAttribute *, VARIANT *) __attribute__((stdcall))
     * }
     */
    public static void get_value(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_value$LAYOUT, get_value$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*put_value)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static class put_value {

        put_value() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            tagVARIANT.layout()
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(put_value.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(put_value.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout put_value$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("put_value"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*put_value)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout put_value$layout() {
        return put_value$LAYOUT;
    }

    private static final long put_value$OFFSET = 360;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*put_value)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static final long put_value$offset() {
        return put_value$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*put_value)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static MemorySegment put_value(MemorySegment struct) {
        return struct.get(put_value$LAYOUT, put_value$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*put_value)(IXMLDOMAttribute *, VARIANT) __attribute__((stdcall))
     * }
     */
    public static void put_value(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(put_value$LAYOUT, put_value$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

