// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class wgl_h_23 extends wgl_h_24 {

    wgl_h_23() {
        // Should not be called directly
    }

    private static class GetTextCharsetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextCharsetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetTextCharsetInfo$descriptor() {
        return GetTextCharsetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetTextCharsetInfo$handle() {
        return GetTextCharsetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetTextCharsetInfo$address() {
        return GetTextCharsetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static int GetTextCharsetInfo(MemorySegment hdc, MemorySegment lpSig, int dwFlags) {
        var mh$ = GetTextCharsetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharsetInfo", hdc, lpSig, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpSig, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateCharsetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TranslateCharsetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor TranslateCharsetInfo$descriptor() {
        return TranslateCharsetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static MethodHandle TranslateCharsetInfo$handle() {
        return TranslateCharsetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static MemorySegment TranslateCharsetInfo$address() {
        return TranslateCharsetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static int TranslateCharsetInfo(MemorySegment lpSrc, MemorySegment lpCs, int dwFlags) {
        var mh$ = TranslateCharsetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateCharsetInfo", lpSrc, lpCs, dwFlags);
            }
            return (int)mh$.invokeExact(lpSrc, lpCs, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFontLanguageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFontLanguageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetFontLanguageInfo$descriptor() {
        return GetFontLanguageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static MethodHandle GetFontLanguageInfo$handle() {
        return GetFontLanguageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static MemorySegment GetFontLanguageInfo$address() {
        return GetFontLanguageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static int GetFontLanguageInfo(MemorySegment hdc) {
        var mh$ = GetFontLanguageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontLanguageInfo", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharacterPlacementA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharacterPlacementA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetCharacterPlacementA$descriptor() {
        return GetCharacterPlacementA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetCharacterPlacementA$handle() {
        return GetCharacterPlacementA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetCharacterPlacementA$address() {
        return GetCharacterPlacementA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static int GetCharacterPlacementA(MemorySegment hdc, MemorySegment lpString, int nCount, int nMexExtent, MemorySegment lpResults, int dwFlags) {
        var mh$ = GetCharacterPlacementA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharacterPlacementA", hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharacterPlacementW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharacterPlacementW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetCharacterPlacementW$descriptor() {
        return GetCharacterPlacementW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetCharacterPlacementW$handle() {
        return GetCharacterPlacementW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetCharacterPlacementW$address() {
        return GetCharacterPlacementW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static int GetCharacterPlacementW(MemorySegment hdc, MemorySegment lpString, int nCount, int nMexExtent, MemorySegment lpResults, int dwFlags) {
        var mh$ = GetCharacterPlacementW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharacterPlacementW", hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWCRANGE {
     *     WCHAR wcLow;
     *     USHORT cGlyphs;
     * } *PWCRANGE
     * }
     */
    public static final AddressLayout PWCRANGE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWCRANGE {
     *     WCHAR wcLow;
     *     USHORT cGlyphs;
     * } *LPWCRANGE
     * }
     */
    public static final AddressLayout LPWCRANGE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGLYPHSET {
     *     DWORD cbThis;
     *     DWORD flAccel;
     *     DWORD cGlyphsSupported;
     *     DWORD cRanges;
     *     WCRANGE ranges[1];
     * } *PGLYPHSET
     * }
     */
    public static final AddressLayout PGLYPHSET = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGLYPHSET {
     *     DWORD cbThis;
     *     DWORD flAccel;
     *     DWORD cGlyphsSupported;
     *     DWORD cRanges;
     *     WCRANGE ranges[1];
     * } *LPGLYPHSET
     * }
     */
    public static final AddressLayout LPGLYPHSET = wgl_h.C_POINTER;

    private static class GetFontUnicodeRanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFontUnicodeRanges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static FunctionDescriptor GetFontUnicodeRanges$descriptor() {
        return GetFontUnicodeRanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static MethodHandle GetFontUnicodeRanges$handle() {
        return GetFontUnicodeRanges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static MemorySegment GetFontUnicodeRanges$address() {
        return GetFontUnicodeRanges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static int GetFontUnicodeRanges(MemorySegment hdc, MemorySegment lpgs) {
        var mh$ = GetFontUnicodeRanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontUnicodeRanges", hdc, lpgs);
            }
            return (int)mh$.invokeExact(hdc, lpgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphIndicesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetGlyphIndicesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static FunctionDescriptor GetGlyphIndicesA$descriptor() {
        return GetGlyphIndicesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MethodHandle GetGlyphIndicesA$handle() {
        return GetGlyphIndicesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MemorySegment GetGlyphIndicesA$address() {
        return GetGlyphIndicesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static int GetGlyphIndicesA(MemorySegment hdc, MemorySegment lpstr, int c, MemorySegment pgi, int fl) {
        var mh$ = GetGlyphIndicesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphIndicesA", hdc, lpstr, c, pgi, fl);
            }
            return (int)mh$.invokeExact(hdc, lpstr, c, pgi, fl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphIndicesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetGlyphIndicesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static FunctionDescriptor GetGlyphIndicesW$descriptor() {
        return GetGlyphIndicesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MethodHandle GetGlyphIndicesW$handle() {
        return GetGlyphIndicesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MemorySegment GetGlyphIndicesW$address() {
        return GetGlyphIndicesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static int GetGlyphIndicesW(MemorySegment hdc, MemorySegment lpstr, int c, MemorySegment pgi, int fl) {
        var mh$ = GetGlyphIndicesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphIndicesW", hdc, lpstr, c, pgi, fl);
            }
            return (int)mh$.invokeExact(hdc, lpstr, c, pgi, fl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextExtentPointI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointI$descriptor() {
        return GetTextExtentPointI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static MethodHandle GetTextExtentPointI$handle() {
        return GetTextExtentPointI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static MemorySegment GetTextExtentPointI$address() {
        return GetTextExtentPointI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static int GetTextExtentPointI(MemorySegment hdc, MemorySegment pgiIn, int cgi, MemorySegment psize) {
        var mh$ = GetTextExtentPointI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointI", hdc, pgiIn, cgi, psize);
            }
            return (int)mh$.invokeExact(hdc, pgiIn, cgi, psize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextExtentExPointI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointI$descriptor() {
        return GetTextExtentExPointI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointI$handle() {
        return GetTextExtentExPointI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MemorySegment GetTextExtentExPointI$address() {
        return GetTextExtentExPointI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointI(MemorySegment hdc, MemorySegment lpwszString, int cwchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointI", hdc, lpwszString, cwchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpwszString, cwchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharWidthI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static FunctionDescriptor GetCharWidthI$descriptor() {
        return GetCharWidthI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static MethodHandle GetCharWidthI$handle() {
        return GetCharWidthI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static MemorySegment GetCharWidthI$address() {
        return GetCharWidthI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static int GetCharWidthI(MemorySegment hdc, int giFirst, int cgi, MemorySegment pgi, MemorySegment piWidths) {
        var mh$ = GetCharWidthI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthI", hdc, giFirst, cgi, pgi, piWidths);
            }
            return (int)mh$.invokeExact(hdc, giFirst, cgi, pgi, piWidths);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCharABCWidthsI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsI$descriptor() {
        return GetCharABCWidthsI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static MethodHandle GetCharABCWidthsI$handle() {
        return GetCharABCWidthsI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static MemorySegment GetCharABCWidthsI$address() {
        return GetCharABCWidthsI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static int GetCharABCWidthsI(MemorySegment hdc, int giFirst, int cgi, MemorySegment pgi, MemorySegment pabc) {
        var mh$ = GetCharABCWidthsI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsI", hdc, giFirst, cgi, pgi, pabc);
            }
            return (int)mh$.invokeExact(hdc, giFirst, cgi, pgi, pabc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDESIGNVECTOR {
     *     DWORD dvReserved;
     *     DWORD dvNumAxes;
     *     LONG dvValues[16];
     * } *PDESIGNVECTOR
     * }
     */
    public static final AddressLayout PDESIGNVECTOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDESIGNVECTOR {
     *     DWORD dvReserved;
     *     DWORD dvNumAxes;
     *     LONG dvValues[16];
     * } *LPDESIGNVECTOR
     * }
     */
    public static final AddressLayout LPDESIGNVECTOR = wgl_h.C_POINTER;

    private static class AddFontResourceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddFontResourceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static FunctionDescriptor AddFontResourceExA$descriptor() {
        return AddFontResourceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MethodHandle AddFontResourceExA$handle() {
        return AddFontResourceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MemorySegment AddFontResourceExA$address() {
        return AddFontResourceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static int AddFontResourceExA(MemorySegment name, int fl, MemorySegment res) {
        var mh$ = AddFontResourceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceExA", name, fl, res);
            }
            return (int)mh$.invokeExact(name, fl, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontResourceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddFontResourceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static FunctionDescriptor AddFontResourceExW$descriptor() {
        return AddFontResourceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MethodHandle AddFontResourceExW$handle() {
        return AddFontResourceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MemorySegment AddFontResourceExW$address() {
        return AddFontResourceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static int AddFontResourceExW(MemorySegment name, int fl, MemorySegment res) {
        var mh$ = AddFontResourceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceExW", name, fl, res);
            }
            return (int)mh$.invokeExact(name, fl, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveFontResourceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceExA$descriptor() {
        return RemoveFontResourceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MethodHandle RemoveFontResourceExA$handle() {
        return RemoveFontResourceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MemorySegment RemoveFontResourceExA$address() {
        return RemoveFontResourceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static int RemoveFontResourceExA(MemorySegment name, int fl, MemorySegment pdv) {
        var mh$ = RemoveFontResourceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceExA", name, fl, pdv);
            }
            return (int)mh$.invokeExact(name, fl, pdv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveFontResourceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceExW$descriptor() {
        return RemoveFontResourceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MethodHandle RemoveFontResourceExW$handle() {
        return RemoveFontResourceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MemorySegment RemoveFontResourceExW$address() {
        return RemoveFontResourceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static int RemoveFontResourceExW(MemorySegment name, int fl, MemorySegment pdv) {
        var mh$ = RemoveFontResourceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceExW", name, fl, pdv);
            }
            return (int)mh$.invokeExact(name, fl, pdv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontMemResourceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddFontMemResourceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static FunctionDescriptor AddFontMemResourceEx$descriptor() {
        return AddFontMemResourceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static MethodHandle AddFontMemResourceEx$handle() {
        return AddFontMemResourceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static MemorySegment AddFontMemResourceEx$address() {
        return AddFontMemResourceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static MemorySegment AddFontMemResourceEx(MemorySegment pFileView, int cjSize, MemorySegment pvResrved, MemorySegment pNumFonts) {
        var mh$ = AddFontMemResourceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontMemResourceEx", pFileView, cjSize, pvResrved, pNumFonts);
            }
            return (MemorySegment)mh$.invokeExact(pFileView, cjSize, pvResrved, pNumFonts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontMemResourceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveFontMemResourceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static FunctionDescriptor RemoveFontMemResourceEx$descriptor() {
        return RemoveFontMemResourceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static MethodHandle RemoveFontMemResourceEx$handle() {
        return RemoveFontMemResourceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static MemorySegment RemoveFontMemResourceEx$address() {
        return RemoveFontMemResourceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static int RemoveFontMemResourceEx(MemorySegment h) {
        var mh$ = RemoveFontMemResourceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontMemResourceEx", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOA {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     BYTE axAxisName[16];
     * } *PAXISINFOA
     * }
     */
    public static final AddressLayout PAXISINFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOA {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     BYTE axAxisName[16];
     * } *LPAXISINFOA
     * }
     */
    public static final AddressLayout LPAXISINFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOW {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     WCHAR axAxisName[16];
     * } *PAXISINFOW
     * }
     */
    public static final AddressLayout PAXISINFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOW {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     WCHAR axAxisName[16];
     * } *LPAXISINFOW
     * }
     */
    public static final AddressLayout LPAXISINFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PAXISINFOA PAXISINFO
     * }
     */
    public static final AddressLayout PAXISINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPAXISINFOA LPAXISINFO
     * }
     */
    public static final AddressLayout LPAXISINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTA {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOA axlAxisInfo[16];
     * } *PAXESLISTA
     * }
     */
    public static final AddressLayout PAXESLISTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTA {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOA axlAxisInfo[16];
     * } *LPAXESLISTA
     * }
     */
    public static final AddressLayout LPAXESLISTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTW {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOW axlAxisInfo[16];
     * } *PAXESLISTW
     * }
     */
    public static final AddressLayout PAXESLISTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTW {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOW axlAxisInfo[16];
     * } *LPAXESLISTW
     * }
     */
    public static final AddressLayout LPAXESLISTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PAXESLISTA PAXESLIST
     * }
     */
    public static final AddressLayout PAXESLIST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPAXESLISTA LPAXESLIST
     * }
     */
    public static final AddressLayout LPAXESLIST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVA {
     *     ENUMLOGFONTEXA elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *PENUMLOGFONTEXDVA
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDVA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVA {
     *     ENUMLOGFONTEXA elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *LPENUMLOGFONTEXDVA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDVA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVW {
     *     ENUMLOGFONTEXW elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *PENUMLOGFONTEXDVW
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDVW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVW {
     *     ENUMLOGFONTEXW elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *LPENUMLOGFONTEXDVW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDVW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDV = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDV = wgl_h.C_POINTER;

    private static class CreateFontIndirectExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFontIndirectExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectExA$descriptor() {
        return CreateFontIndirectExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static MethodHandle CreateFontIndirectExA$handle() {
        return CreateFontIndirectExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static MemorySegment CreateFontIndirectExA$address() {
        return CreateFontIndirectExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static MemorySegment CreateFontIndirectExA(MemorySegment x0) {
        var mh$ = CreateFontIndirectExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectExA", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFontIndirectExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectExW$descriptor() {
        return CreateFontIndirectExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static MethodHandle CreateFontIndirectExW$handle() {
        return CreateFontIndirectExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static MemorySegment CreateFontIndirectExW$address() {
        return CreateFontIndirectExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static MemorySegment CreateFontIndirectExW(MemorySegment x0) {
        var mh$ = CreateFontIndirectExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectExW", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICA {
     *     NEWTEXTMETRICEXA etmNewTextMetricEx;
     *     AXESLISTA etmAxesList;
     * } *PENUMTEXTMETRICA
     * }
     */
    public static final AddressLayout PENUMTEXTMETRICA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICA {
     *     NEWTEXTMETRICEXA etmNewTextMetricEx;
     *     AXESLISTA etmAxesList;
     * } *LPENUMTEXTMETRICA
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRICA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICW {
     *     NEWTEXTMETRICEXW etmNewTextMetricEx;
     *     AXESLISTW etmAxesList;
     * } *PENUMTEXTMETRICW
     * }
     */
    public static final AddressLayout PENUMTEXTMETRICW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICW {
     *     NEWTEXTMETRICEXW etmNewTextMetricEx;
     *     AXESLISTW etmAxesList;
     * } *LPENUMTEXTMETRICW
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRICW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PENUMTEXTMETRICA PENUMTEXTMETRIC
     * }
     */
    public static final AddressLayout PENUMTEXTMETRIC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRIC = wgl_h.C_POINTER;

    private static class GetViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetViewportExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetViewportExtEx$descriptor() {
        return GetViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetViewportExtEx$handle() {
        return GetViewportExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetViewportExtEx$address() {
        return GetViewportExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetViewportExtEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetViewportExtEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetViewportOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static FunctionDescriptor GetViewportOrgEx$descriptor() {
        return GetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MethodHandle GetViewportOrgEx$handle() {
        return GetViewportOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MemorySegment GetViewportOrgEx$address() {
        return GetViewportOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static int GetViewportOrgEx(MemorySegment hdc, MemorySegment lppoint) {
        var mh$ = GetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetViewportOrgEx", hdc, lppoint);
            }
            return (int)mh$.invokeExact(hdc, lppoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWindowExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetWindowExtEx$descriptor() {
        return GetWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetWindowExtEx$handle() {
        return GetWindowExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetWindowExtEx$address() {
        return GetWindowExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetWindowExtEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowExtEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWindowOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static FunctionDescriptor GetWindowOrgEx$descriptor() {
        return GetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MethodHandle GetWindowOrgEx$handle() {
        return GetWindowOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MemorySegment GetWindowOrgEx$address() {
        return GetWindowOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static int GetWindowOrgEx(MemorySegment hdc, MemorySegment lppoint) {
        var mh$ = GetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowOrgEx", hdc, lppoint);
            }
            return (int)mh$.invokeExact(hdc, lppoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectClipRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IntersectClipRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor IntersectClipRect$descriptor() {
        return IntersectClipRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle IntersectClipRect$handle() {
        return IntersectClipRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment IntersectClipRect$address() {
        return IntersectClipRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int IntersectClipRect(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = IntersectClipRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectClipRect", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvertRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InvertRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor InvertRgn$descriptor() {
        return InvertRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle InvertRgn$handle() {
        return InvertRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment InvertRgn$address() {
        return InvertRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int InvertRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = InvertRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvertRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LineDDA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LineDDA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static FunctionDescriptor LineDDA$descriptor() {
        return LineDDA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static MethodHandle LineDDA$handle() {
        return LineDDA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static MemorySegment LineDDA$address() {
        return LineDDA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static int LineDDA(int xStart, int yStart, int xEnd, int yEnd, MemorySegment lpProc, long data) {
        var mh$ = LineDDA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LineDDA", xStart, yStart, xEnd, yEnd, lpProc, data);
            }
            return (int)mh$.invokeExact(xStart, yStart, xEnd, yEnd, lpProc, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LineTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LineTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor LineTo$descriptor() {
        return LineTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle LineTo$handle() {
        return LineTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment LineTo$address() {
        return LineTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static int LineTo(MemorySegment hdc, int x, int y) {
        var mh$ = LineTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LineTo", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MaskBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MaskBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static FunctionDescriptor MaskBlt$descriptor() {
        return MaskBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static MethodHandle MaskBlt$handle() {
        return MaskBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static MemorySegment MaskBlt$address() {
        return MaskBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static int MaskBlt(MemorySegment hdcDest, int xDest, int yDest, int width, int height, MemorySegment hdcSrc, int xSrc, int ySrc, MemorySegment hbmMask, int xMask, int yMask, int rop) {
        var mh$ = MaskBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MaskBlt", hdcDest, xDest, yDest, width, height, hdcSrc, xSrc, ySrc, hbmMask, xMask, yMask, rop);
            }
            return (int)mh$.invokeExact(hdcDest, xDest, yDest, width, height, hdcSrc, xSrc, ySrc, hbmMask, xMask, yMask, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlgBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PlgBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static FunctionDescriptor PlgBlt$descriptor() {
        return PlgBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static MethodHandle PlgBlt$handle() {
        return PlgBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static MemorySegment PlgBlt$address() {
        return PlgBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static int PlgBlt(MemorySegment hdcDest, MemorySegment lpPoint, MemorySegment hdcSrc, int xSrc, int ySrc, int width, int height, MemorySegment hbmMask, int xMask, int yMask) {
        var mh$ = PlgBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlgBlt", hdcDest, lpPoint, hdcSrc, xSrc, ySrc, width, height, hbmMask, xMask, yMask);
            }
            return (int)mh$.invokeExact(hdcDest, lpPoint, hdcSrc, xSrc, ySrc, width, height, hbmMask, xMask, yMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OffsetClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor OffsetClipRgn$descriptor() {
        return OffsetClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle OffsetClipRgn$handle() {
        return OffsetClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment OffsetClipRgn$address() {
        return OffsetClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static int OffsetClipRgn(MemorySegment hdc, int x, int y) {
        var mh$ = OffsetClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetClipRgn", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OffsetRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static FunctionDescriptor OffsetRgn$descriptor() {
        return OffsetRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static MethodHandle OffsetRgn$handle() {
        return OffsetRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static MemorySegment OffsetRgn$address() {
        return OffsetRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static int OffsetRgn(MemorySegment hrgn, int x, int y) {
        var mh$ = OffsetRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetRgn", hrgn, x, y);
            }
            return (int)mh$.invokeExact(hrgn, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PatBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PatBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static FunctionDescriptor PatBlt$descriptor() {
        return PatBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static MethodHandle PatBlt$handle() {
        return PatBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static MemorySegment PatBlt$address() {
        return PatBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static int PatBlt(MemorySegment hdc, int x, int y, int w, int h, int rop) {
        var mh$ = PatBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PatBlt", hdc, x, y, w, h, rop);
            }
            return (int)mh$.invokeExact(hdc, x, y, w, h, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Pie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Pie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static FunctionDescriptor Pie$descriptor() {
        return Pie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MethodHandle Pie$handle() {
        return Pie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MemorySegment Pie$address() {
        return Pie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static int Pie(MemorySegment hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2) {
        var mh$ = Pie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Pie", hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PlayMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor PlayMetaFile$descriptor() {
        return PlayMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static MethodHandle PlayMetaFile$handle() {
        return PlayMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static MemorySegment PlayMetaFile$address() {
        return PlayMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static int PlayMetaFile(MemorySegment hdc, MemorySegment hmf) {
        var mh$ = PlayMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayMetaFile", hdc, hmf);
            }
            return (int)mh$.invokeExact(hdc, hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PaintRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PaintRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor PaintRgn$descriptor() {
        return PaintRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle PaintRgn$handle() {
        return PaintRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment PaintRgn$address() {
        return PaintRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int PaintRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = PaintRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PaintRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PolyPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static FunctionDescriptor PolyPolygon$descriptor() {
        return PolyPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static MethodHandle PolyPolygon$handle() {
        return PolyPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static MemorySegment PolyPolygon$address() {
        return PolyPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static int PolyPolygon(MemorySegment hdc, MemorySegment apt, MemorySegment asz, int csz) {
        var mh$ = PolyPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyPolygon", hdc, apt, asz, csz);
            }
            return (int)mh$.invokeExact(hdc, apt, asz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PtInRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PtInRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static FunctionDescriptor PtInRegion$descriptor() {
        return PtInRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static MethodHandle PtInRegion$handle() {
        return PtInRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static MemorySegment PtInRegion$address() {
        return PtInRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static int PtInRegion(MemorySegment hrgn, int x, int y) {
        var mh$ = PtInRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PtInRegion", hrgn, x, y);
            }
            return (int)mh$.invokeExact(hrgn, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PtVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PtVisible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor PtVisible$descriptor() {
        return PtVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle PtVisible$handle() {
        return PtVisible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment PtVisible$address() {
        return PtVisible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static int PtVisible(MemorySegment hdc, int x, int y) {
        var mh$ = PtVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PtVisible", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RectInRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RectInRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor RectInRegion$descriptor() {
        return RectInRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static MethodHandle RectInRegion$handle() {
        return RectInRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static MemorySegment RectInRegion$address() {
        return RectInRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static int RectInRegion(MemorySegment hrgn, MemorySegment lprect) {
        var mh$ = RectInRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RectInRegion", hrgn, lprect);
            }
            return (int)mh$.invokeExact(hrgn, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RectVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RectVisible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor RectVisible$descriptor() {
        return RectVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static MethodHandle RectVisible$handle() {
        return RectVisible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static MemorySegment RectVisible$address() {
        return RectVisible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static int RectVisible(MemorySegment hdc, MemorySegment lprect) {
        var mh$ = RectVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RectVisible", hdc, lprect);
            }
            return (int)mh$.invokeExact(hdc, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Rectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Rectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor Rectangle$descriptor() {
        return Rectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle Rectangle$handle() {
        return Rectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment Rectangle$address() {
        return Rectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int Rectangle(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = Rectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Rectangle", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestoreDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RestoreDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static FunctionDescriptor RestoreDC$descriptor() {
        return RestoreDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static MethodHandle RestoreDC$handle() {
        return RestoreDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static MemorySegment RestoreDC$address() {
        return RestoreDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static int RestoreDC(MemorySegment hdc, int nSavedDC) {
        var mh$ = RestoreDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestoreDC", hdc, nSavedDC);
            }
            return (int)mh$.invokeExact(hdc, nSavedDC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetDCA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ResetDCA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static FunctionDescriptor ResetDCA$descriptor() {
        return ResetDCA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static MethodHandle ResetDCA$handle() {
        return ResetDCA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static MemorySegment ResetDCA$address() {
        return ResetDCA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static MemorySegment ResetDCA(MemorySegment hdc, MemorySegment lpdm) {
        var mh$ = ResetDCA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetDCA", hdc, lpdm);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetDCW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ResetDCW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static FunctionDescriptor ResetDCW$descriptor() {
        return ResetDCW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static MethodHandle ResetDCW$handle() {
        return ResetDCW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static MemorySegment ResetDCW$address() {
        return ResetDCW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static MemorySegment ResetDCW(MemorySegment hdc, MemorySegment lpdm) {
        var mh$ = ResetDCW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetDCW", hdc, lpdm);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RealizePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RealizePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static FunctionDescriptor RealizePalette$descriptor() {
        return RealizePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static MethodHandle RealizePalette$handle() {
        return RealizePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static MemorySegment RealizePalette$address() {
        return RealizePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static int RealizePalette(MemorySegment hdc) {
        var mh$ = RealizePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RealizePalette", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveFontResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceA$descriptor() {
        return RemoveFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle RemoveFontResourceA$handle() {
        return RemoveFontResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment RemoveFontResourceA$address() {
        return RemoveFontResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static int RemoveFontResourceA(MemorySegment lpFileName) {
        var mh$ = RemoveFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveFontResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceW$descriptor() {
        return RemoveFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle RemoveFontResourceW$handle() {
        return RemoveFontResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment RemoveFontResourceW$address() {
        return RemoveFontResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static int RemoveFontResourceW(MemorySegment lpFileName) {
        var mh$ = RemoveFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoundRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RoundRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static FunctionDescriptor RoundRect$descriptor() {
        return RoundRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static MethodHandle RoundRect$handle() {
        return RoundRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static MemorySegment RoundRect$address() {
        return RoundRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static int RoundRect(MemorySegment hdc, int left, int top, int right, int bottom, int width, int height) {
        var mh$ = RoundRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoundRect", hdc, left, top, right, bottom, width, height);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResizePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ResizePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static FunctionDescriptor ResizePalette$descriptor() {
        return ResizePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static MethodHandle ResizePalette$handle() {
        return ResizePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static MemorySegment ResizePalette$address() {
        return ResizePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static int ResizePalette(MemorySegment hpal, int n) {
        var mh$ = ResizePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResizePalette", hpal, n);
            }
            return (int)mh$.invokeExact(hpal, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SaveDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SaveDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor SaveDC$descriptor() {
        return SaveDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static MethodHandle SaveDC$handle() {
        return SaveDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static MemorySegment SaveDC$address() {
        return SaveDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static int SaveDC(MemorySegment hdc) {
        var mh$ = SaveDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SaveDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SelectClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor SelectClipRgn$descriptor() {
        return SelectClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle SelectClipRgn$handle() {
        return SelectClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment SelectClipRgn$address() {
        return SelectClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int SelectClipRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = SelectClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectClipRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtSelectClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExtSelectClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static FunctionDescriptor ExtSelectClipRgn$descriptor() {
        return ExtSelectClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static MethodHandle ExtSelectClipRgn$handle() {
        return ExtSelectClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static MemorySegment ExtSelectClipRgn$address() {
        return ExtSelectClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static int ExtSelectClipRgn(MemorySegment hdc, MemorySegment hrgn, int mode) {
        var mh$ = ExtSelectClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtSelectClipRgn", hdc, hrgn, mode);
            }
            return (int)mh$.invokeExact(hdc, hrgn, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMetaRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMetaRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static FunctionDescriptor SetMetaRgn$descriptor() {
        return SetMetaRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static MethodHandle SetMetaRgn$handle() {
        return SetMetaRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static MemorySegment SetMetaRgn$address() {
        return SetMetaRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static int SetMetaRgn(MemorySegment hdc) {
        var mh$ = SetMetaRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMetaRgn", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SelectObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor SelectObject$descriptor() {
        return SelectObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static MethodHandle SelectObject$handle() {
        return SelectObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static MemorySegment SelectObject$address() {
        return SelectObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static MemorySegment SelectObject(MemorySegment hdc, MemorySegment h) {
        var mh$ = SelectObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectObject", hdc, h);
            }
            return (MemorySegment)mh$.invokeExact(hdc, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SelectPalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static FunctionDescriptor SelectPalette$descriptor() {
        return SelectPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static MethodHandle SelectPalette$handle() {
        return SelectPalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static MemorySegment SelectPalette$address() {
        return SelectPalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static MemorySegment SelectPalette(MemorySegment hdc, MemorySegment hPal, int bForceBkgd) {
        var mh$ = SelectPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectPalette", hdc, hPal, bForceBkgd);
            }
            return (MemorySegment)mh$.invokeExact(hdc, hPal, bForceBkgd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBkColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetBkColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetBkColor$descriptor() {
        return SetBkColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetBkColor$handle() {
        return SetBkColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetBkColor$address() {
        return SetBkColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetBkColor(MemorySegment hdc, int color) {
        var mh$ = SetBkColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBkColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDCBrushColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDCBrushColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetDCBrushColor$descriptor() {
        return SetDCBrushColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetDCBrushColor$handle() {
        return SetDCBrushColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetDCBrushColor$address() {
        return SetDCBrushColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetDCBrushColor(MemorySegment hdc, int color) {
        var mh$ = SetDCBrushColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDCBrushColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDCPenColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDCPenColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetDCPenColor$descriptor() {
        return SetDCPenColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetDCPenColor$handle() {
        return SetDCPenColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetDCPenColor$address() {
        return SetDCPenColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetDCPenColor(MemorySegment hdc, int color) {
        var mh$ = SetDCPenColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDCPenColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBkMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetBkMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetBkMode$descriptor() {
        return SetBkMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetBkMode$handle() {
        return SetBkMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetBkMode$address() {
        return SetBkMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static int SetBkMode(MemorySegment hdc, int mode) {
        var mh$ = SetBkMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBkMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBitmapBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetBitmapBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static FunctionDescriptor SetBitmapBits$descriptor() {
        return SetBitmapBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static MethodHandle SetBitmapBits$handle() {
        return SetBitmapBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static MemorySegment SetBitmapBits$address() {
        return SetBitmapBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static int SetBitmapBits(MemorySegment hbm, int cb, MemorySegment pvBits) {
        var mh$ = SetBitmapBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBitmapBits", hbm, cb, pvBits);
            }
            return (int)mh$.invokeExact(hbm, cb, pvBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBoundsRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetBoundsRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static FunctionDescriptor SetBoundsRect$descriptor() {
        return SetBoundsRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MethodHandle SetBoundsRect$handle() {
        return SetBoundsRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MemorySegment SetBoundsRect$address() {
        return SetBoundsRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static int SetBoundsRect(MemorySegment hdc, MemorySegment lprect, int flags) {
        var mh$ = SetBoundsRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBoundsRect", hdc, lprect, flags);
            }
            return (int)mh$.invokeExact(hdc, lprect, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDIBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static FunctionDescriptor SetDIBits$descriptor() {
        return SetDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MethodHandle SetDIBits$handle() {
        return SetDIBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MemorySegment SetDIBits$address() {
        return SetDIBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static int SetDIBits(MemorySegment hdc, MemorySegment hbm, int start, int cLines, MemorySegment lpBits, MemorySegment lpbmi, int ColorUse) {
        var mh$ = SetDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBits", hdc, hbm, start, cLines, lpBits, lpbmi, ColorUse);
            }
            return (int)mh$.invokeExact(hdc, hbm, start, cLines, lpBits, lpbmi, ColorUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBitsToDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDIBitsToDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static FunctionDescriptor SetDIBitsToDevice$descriptor() {
        return SetDIBitsToDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MethodHandle SetDIBitsToDevice$handle() {
        return SetDIBitsToDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MemorySegment SetDIBitsToDevice$address() {
        return SetDIBitsToDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static int SetDIBitsToDevice(MemorySegment hdc, int xDest, int yDest, int w, int h, int xSrc, int ySrc, int StartScan, int cLines, MemorySegment lpvBits, MemorySegment lpbmi, int ColorUse) {
        var mh$ = SetDIBitsToDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBitsToDevice", hdc, xDest, yDest, w, h, xSrc, ySrc, StartScan, cLines, lpvBits, lpbmi, ColorUse);
            }
            return (int)mh$.invokeExact(hdc, xDest, yDest, w, h, xSrc, ySrc, StartScan, cLines, lpvBits, lpbmi, ColorUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMapperFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMapperFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static FunctionDescriptor SetMapperFlags$descriptor() {
        return SetMapperFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static MethodHandle SetMapperFlags$handle() {
        return SetMapperFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static MemorySegment SetMapperFlags$address() {
        return SetMapperFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static int SetMapperFlags(MemorySegment hdc, int flags) {
        var mh$ = SetMapperFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMapperFlags", hdc, flags);
            }
            return (int)mh$.invokeExact(hdc, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetGraphicsMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetGraphicsMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static FunctionDescriptor SetGraphicsMode$descriptor() {
        return SetGraphicsMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static MethodHandle SetGraphicsMode$handle() {
        return SetGraphicsMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static MemorySegment SetGraphicsMode$address() {
        return SetGraphicsMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static int SetGraphicsMode(MemorySegment hdc, int iMode) {
        var mh$ = SetGraphicsMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetGraphicsMode", hdc, iMode);
            }
            return (int)mh$.invokeExact(hdc, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMapMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMapMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static FunctionDescriptor SetMapMode$descriptor() {
        return SetMapMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static MethodHandle SetMapMode$handle() {
        return SetMapMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static MemorySegment SetMapMode$address() {
        return SetMapMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static int SetMapMode(MemorySegment hdc, int iMode) {
        var mh$ = SetMapMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMapMode", hdc, iMode);
            }
            return (int)mh$.invokeExact(hdc, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static FunctionDescriptor SetLayout$descriptor() {
        return SetLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static MethodHandle SetLayout$handle() {
        return SetLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static MemorySegment SetLayout$address() {
        return SetLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static int SetLayout(MemorySegment hdc, int l) {
        var mh$ = SetLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLayout", hdc, l);
            }
            return (int)mh$.invokeExact(hdc, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetLayout$descriptor() {
        return GetLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static MethodHandle GetLayout$handle() {
        return GetLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static MemorySegment GetLayout$address() {
        return GetLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static int GetLayout(MemorySegment hdc) {
        var mh$ = GetLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLayout", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMetaFileBitsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMetaFileBitsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static FunctionDescriptor SetMetaFileBitsEx$descriptor() {
        return SetMetaFileBitsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static MethodHandle SetMetaFileBitsEx$handle() {
        return SetMetaFileBitsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static MemorySegment SetMetaFileBitsEx$address() {
        return SetMetaFileBitsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static MemorySegment SetMetaFileBitsEx(int cbBuffer, MemorySegment lpData) {
        var mh$ = SetMetaFileBitsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMetaFileBitsEx", cbBuffer, lpData);
            }
            return (MemorySegment)mh$.invokeExact(cbBuffer, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static FunctionDescriptor SetPaletteEntries$descriptor() {
        return SetPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static MethodHandle SetPaletteEntries$handle() {
        return SetPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static MemorySegment SetPaletteEntries$address() {
        return SetPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static int SetPaletteEntries(MemorySegment hpal, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = SetPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPaletteEntries", hpal, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hpal, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetPixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetPixel$descriptor() {
        return SetPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle SetPixel$handle() {
        return SetPixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MemorySegment SetPixel$address() {
        return SetPixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int SetPixel(MemorySegment hdc, int x, int y, int color) {
        var mh$ = SetPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixel", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixelV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetPixelV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetPixelV$descriptor() {
        return SetPixelV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle SetPixelV$handle() {
        return SetPixelV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MemorySegment SetPixelV$address() {
        return SetPixelV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int SetPixelV(MemorySegment hdc, int x, int y, int color) {
        var mh$ = SetPixelV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixelV", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetPixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor SetPixelFormat$descriptor() {
        return SetPixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle SetPixelFormat$handle() {
        return SetPixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MemorySegment SetPixelFormat$address() {
        return SetPixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int SetPixelFormat(MemorySegment hdc, int format, MemorySegment ppfd) {
        var mh$ = SetPixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixelFormat", hdc, format, ppfd);
            }
            return (int)mh$.invokeExact(hdc, format, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPolyFillMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetPolyFillMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetPolyFillMode$descriptor() {
        return SetPolyFillMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetPolyFillMode$handle() {
        return SetPolyFillMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetPolyFillMode$address() {
        return SetPolyFillMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static int SetPolyFillMode(MemorySegment hdc, int mode) {
        var mh$ = SetPolyFillMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPolyFillMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StretchBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StretchBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static FunctionDescriptor StretchBlt$descriptor() {
        return StretchBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static MethodHandle StretchBlt$handle() {
        return StretchBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static MemorySegment StretchBlt$address() {
        return StretchBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static int StretchBlt(MemorySegment hdcDest, int xDest, int yDest, int wDest, int hDest, MemorySegment hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, int rop) {
        var mh$ = StretchBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StretchBlt", hdcDest, xDest, yDest, wDest, hDest, hdcSrc, xSrc, ySrc, wSrc, hSrc, rop);
            }
            return (int)mh$.invokeExact(hdcDest, xDest, yDest, wDest, hDest, hdcSrc, xSrc, ySrc, wSrc, hSrc, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetRectRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor SetRectRgn$descriptor() {
        return SetRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle SetRectRgn$handle() {
        return SetRectRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment SetRectRgn$address() {
        return SetRectRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static int SetRectRgn(MemorySegment hrgn, int left, int top, int right, int bottom) {
        var mh$ = SetRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetRectRgn", hrgn, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hrgn, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StretchDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StretchDIBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static FunctionDescriptor StretchDIBits$descriptor() {
        return StretchDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static MethodHandle StretchDIBits$handle() {
        return StretchDIBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static MemorySegment StretchDIBits$address() {
        return StretchDIBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static int StretchDIBits(MemorySegment hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, MemorySegment lpBits, MemorySegment lpbmi, int iUsage, int rop) {
        var mh$ = StretchDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StretchDIBits", hdc, xDest, yDest, DestWidth, DestHeight, xSrc, ySrc, SrcWidth, SrcHeight, lpBits, lpbmi, iUsage, rop);
            }
            return (int)mh$.invokeExact(hdc, xDest, yDest, DestWidth, DestHeight, xSrc, ySrc, SrcWidth, SrcHeight, lpBits, lpbmi, iUsage, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetROP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetROP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static FunctionDescriptor SetROP2$descriptor() {
        return SetROP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static MethodHandle SetROP2$handle() {
        return SetROP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static MemorySegment SetROP2$address() {
        return SetROP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static int SetROP2(MemorySegment hdc, int rop2) {
        var mh$ = SetROP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetROP2", hdc, rop2);
            }
            return (int)mh$.invokeExact(hdc, rop2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetStretchBltMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetStretchBltMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetStretchBltMode$descriptor() {
        return SetStretchBltMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetStretchBltMode$handle() {
        return SetStretchBltMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetStretchBltMode$address() {
        return SetStretchBltMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static int SetStretchBltMode(MemorySegment hdc, int mode) {
        var mh$ = SetStretchBltMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetStretchBltMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemPaletteUse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSystemPaletteUse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static FunctionDescriptor SetSystemPaletteUse$descriptor() {
        return SetSystemPaletteUse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static MethodHandle SetSystemPaletteUse$handle() {
        return SetSystemPaletteUse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static MemorySegment SetSystemPaletteUse$address() {
        return SetSystemPaletteUse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static int SetSystemPaletteUse(MemorySegment hdc, int use) {
        var mh$ = SetSystemPaletteUse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemPaletteUse", hdc, use);
            }
            return (int)mh$.invokeExact(hdc, use);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextCharacterExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetTextCharacterExtra");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static FunctionDescriptor SetTextCharacterExtra$descriptor() {
        return SetTextCharacterExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static MethodHandle SetTextCharacterExtra$handle() {
        return SetTextCharacterExtra.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static MemorySegment SetTextCharacterExtra$address() {
        return SetTextCharacterExtra.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static int SetTextCharacterExtra(MemorySegment hdc, int extra) {
        var mh$ = SetTextCharacterExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextCharacterExtra", hdc, extra);
            }
            return (int)mh$.invokeExact(hdc, extra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetTextColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetTextColor$descriptor() {
        return SetTextColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetTextColor$handle() {
        return SetTextColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetTextColor$address() {
        return SetTextColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetTextColor(MemorySegment hdc, int color) {
        var mh$ = SetTextColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextAlign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetTextAlign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static FunctionDescriptor SetTextAlign$descriptor() {
        return SetTextAlign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static MethodHandle SetTextAlign$handle() {
        return SetTextAlign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static MemorySegment SetTextAlign$address() {
        return SetTextAlign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static int SetTextAlign(MemorySegment hdc, int align) {
        var mh$ = SetTextAlign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextAlign", hdc, align);
            }
            return (int)mh$.invokeExact(hdc, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextJustification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetTextJustification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static FunctionDescriptor SetTextJustification$descriptor() {
        return SetTextJustification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static MethodHandle SetTextJustification$handle() {
        return SetTextJustification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static MemorySegment SetTextJustification$address() {
        return SetTextJustification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static int SetTextJustification(MemorySegment hdc, int extra, int count) {
        var mh$ = SetTextJustification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextJustification", hdc, extra, count);
            }
            return (int)mh$.invokeExact(hdc, extra, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UpdateColors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static FunctionDescriptor UpdateColors$descriptor() {
        return UpdateColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static MethodHandle UpdateColors$handle() {
        return UpdateColors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static MemorySegment UpdateColors$address() {
        return UpdateColors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static int UpdateColors(MemorySegment hdc) {
        var mh$ = UpdateColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateColors", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef USHORT COLOR16
     * }
     */
    public static final OfShort COLOR16 = wgl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct _TRIVERTEX {
     *     LONG x;
     *     LONG y;
     *     COLOR16 Red;
     *     COLOR16 Green;
     *     COLOR16 Blue;
     *     COLOR16 Alpha;
     * } *PTRIVERTEX
     * }
     */
    public static final AddressLayout PTRIVERTEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRIVERTEX {
     *     LONG x;
     *     LONG y;
     *     COLOR16 Red;
     *     COLOR16 Green;
     *     COLOR16 Blue;
     *     COLOR16 Alpha;
     * } *LPTRIVERTEX
     * }
     */
    public static final AddressLayout LPTRIVERTEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_TRIANGLE {
     *     ULONG Vertex1;
     *     ULONG Vertex2;
     *     ULONG Vertex3;
     * } *PGRADIENT_TRIANGLE
     * }
     */
    public static final AddressLayout PGRADIENT_TRIANGLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_TRIANGLE {
     *     ULONG Vertex1;
     *     ULONG Vertex2;
     *     ULONG Vertex3;
     * } *LPGRADIENT_TRIANGLE
     * }
     */
    public static final AddressLayout LPGRADIENT_TRIANGLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_RECT {
     *     ULONG UpperLeft;
     *     ULONG LowerRight;
     * } *PGRADIENT_RECT
     * }
     */
    public static final AddressLayout PGRADIENT_RECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_RECT {
     *     ULONG UpperLeft;
     *     ULONG LowerRight;
     * } *LPGRADIENT_RECT
     * }
     */
    public static final AddressLayout LPGRADIENT_RECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BLENDFUNCTION {
     *     BYTE BlendOp;
     *     BYTE BlendFlags;
     *     BYTE SourceConstantAlpha;
     *     BYTE AlphaFormat;
     * } *PBLENDFUNCTION
     * }
     */
    public static final AddressLayout PBLENDFUNCTION = wgl_h.C_POINTER;

    private static class AlphaBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            _BLENDFUNCTION.layout()
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AlphaBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static FunctionDescriptor AlphaBlend$descriptor() {
        return AlphaBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MethodHandle AlphaBlend$handle() {
        return AlphaBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MemorySegment AlphaBlend$address() {
        return AlphaBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static int AlphaBlend(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, MemorySegment ftn) {
        var mh$ = AlphaBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AlphaBlend", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransparentBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TransparentBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static FunctionDescriptor TransparentBlt$descriptor() {
        return TransparentBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MethodHandle TransparentBlt$handle() {
        return TransparentBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MemorySegment TransparentBlt$address() {
        return TransparentBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static int TransparentBlt(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, int crTransparent) {
        var mh$ = TransparentBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransparentBlt", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GradientFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GradientFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static FunctionDescriptor GradientFill$descriptor() {
        return GradientFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static MethodHandle GradientFill$handle() {
        return GradientFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static MemorySegment GradientFill$address() {
        return GradientFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static int GradientFill(MemorySegment hdc, MemorySegment pVertex, int nVertex, MemorySegment pMesh, int nMesh, int ulMode) {
        var mh$ = GradientFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GradientFill", hdc, pVertex, nVertex, pMesh, nMesh, ulMode);
            }
            return (int)mh$.invokeExact(hdc, pVertex, nVertex, pMesh, nMesh, ulMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiAlphaBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            _BLENDFUNCTION.layout()
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GdiAlphaBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static FunctionDescriptor GdiAlphaBlend$descriptor() {
        return GdiAlphaBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MethodHandle GdiAlphaBlend$handle() {
        return GdiAlphaBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MemorySegment GdiAlphaBlend$address() {
        return GdiAlphaBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static int GdiAlphaBlend(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, MemorySegment ftn) {
        var mh$ = GdiAlphaBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiAlphaBlend", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiTransparentBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GdiTransparentBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static FunctionDescriptor GdiTransparentBlt$descriptor() {
        return GdiTransparentBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MethodHandle GdiTransparentBlt$handle() {
        return GdiTransparentBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MemorySegment GdiTransparentBlt$address() {
        return GdiTransparentBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static int GdiTransparentBlt(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, int crTransparent) {
        var mh$ = GdiTransparentBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiTransparentBlt", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiGradientFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GdiGradientFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static FunctionDescriptor GdiGradientFill$descriptor() {
        return GdiGradientFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static MethodHandle GdiGradientFill$handle() {
        return GdiGradientFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static MemorySegment GdiGradientFill$address() {
        return GdiGradientFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static int GdiGradientFill(MemorySegment hdc, MemorySegment pVertex, int nVertex, MemorySegment pMesh, int nCount, int ulMode) {
        var mh$ = GdiGradientFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiGradientFill", hdc, pVertex, nVertex, pMesh, nCount, ulMode);
            }
            return (int)mh$.invokeExact(hdc, pVertex, nVertex, pMesh, nCount, ulMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayMetaFileRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PlayMetaFileRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static FunctionDescriptor PlayMetaFileRecord$descriptor() {
        return PlayMetaFileRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static MethodHandle PlayMetaFileRecord$handle() {
        return PlayMetaFileRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static MemorySegment PlayMetaFileRecord$address() {
        return PlayMetaFileRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static int PlayMetaFileRecord(MemorySegment hdc, MemorySegment lpHandleTable, MemorySegment lpMR, int noObjs) {
        var mh$ = PlayMetaFileRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayMetaFileRecord", hdc, lpHandleTable, lpMR, noObjs);
            }
            return (int)mh$.invokeExact(hdc, lpHandleTable, lpMR, noObjs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumMetaFile$descriptor() {
        return EnumMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumMetaFile$handle() {
        return EnumMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static MemorySegment EnumMetaFile$address() {
        return EnumMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static int EnumMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment proc, long param) {
        var mh$ = EnumMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumMetaFile", hdc, hmf, proc, param);
            }
            return (int)mh$.invokeExact(hdc, hmf, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseEnhMetaFile$descriptor() {
        return CloseEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static MethodHandle CloseEnhMetaFile$handle() {
        return CloseEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseEnhMetaFile$address() {
        return CloseEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseEnhMetaFile(MemorySegment hdc) {
        var mh$ = CloseEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseEnhMetaFile", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyEnhMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor CopyEnhMetaFileA$descriptor() {
        return CopyEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle CopyEnhMetaFileA$handle() {
        return CopyEnhMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileA$address() {
        return CopyEnhMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileA(MemorySegment hEnh, MemorySegment lpFileName) {
        var mh$ = CopyEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyEnhMetaFileA", hEnh, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(hEnh, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyEnhMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor CopyEnhMetaFileW$descriptor() {
        return CopyEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle CopyEnhMetaFileW$handle() {
        return CopyEnhMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileW$address() {
        return CopyEnhMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileW(MemorySegment hEnh, MemorySegment lpFileName) {
        var mh$ = CopyEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyEnhMetaFileW", hEnh, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(hEnh, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateEnhMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static FunctionDescriptor CreateEnhMetaFileA$descriptor() {
        return CreateEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static MethodHandle CreateEnhMetaFileA$handle() {
        return CreateEnhMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileA$address() {
        return CreateEnhMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileA(MemorySegment hdc, MemorySegment lpFilename, MemorySegment lprc, MemorySegment lpDesc) {
        var mh$ = CreateEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEnhMetaFileA", hdc, lpFilename, lprc, lpDesc);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpFilename, lprc, lpDesc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateEnhMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static FunctionDescriptor CreateEnhMetaFileW$descriptor() {
        return CreateEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static MethodHandle CreateEnhMetaFileW$handle() {
        return CreateEnhMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileW$address() {
        return CreateEnhMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileW(MemorySegment hdc, MemorySegment lpFilename, MemorySegment lprc, MemorySegment lpDesc) {
        var mh$ = CreateEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEnhMetaFileW", hdc, lpFilename, lprc, lpDesc);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpFilename, lprc, lpDesc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor DeleteEnhMetaFile$descriptor() {
        return DeleteEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static MethodHandle DeleteEnhMetaFile$handle() {
        return DeleteEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static MemorySegment DeleteEnhMetaFile$address() {
        return DeleteEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static int DeleteEnhMetaFile(MemorySegment hmf) {
        var mh$ = DeleteEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteEnhMetaFile", hmf);
            }
            return (int)mh$.invokeExact(hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static FunctionDescriptor EnumEnhMetaFile$descriptor() {
        return EnumEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static MethodHandle EnumEnhMetaFile$handle() {
        return EnumEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static MemorySegment EnumEnhMetaFile$address() {
        return EnumEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static int EnumEnhMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment proc, MemorySegment param, MemorySegment lpRect) {
        var mh$ = EnumEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumEnhMetaFile", hdc, hmf, proc, param, lpRect);
            }
            return (int)mh$.invokeExact(hdc, hmf, proc, param, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnhMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileA$descriptor() {
        return GetEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static MethodHandle GetEnhMetaFileA$handle() {
        return GetEnhMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileA$address() {
        return GetEnhMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileA(MemorySegment lpName) {
        var mh$ = GetEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileA", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnhMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileW$descriptor() {
        return GetEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MethodHandle GetEnhMetaFileW$handle() {
        return GetEnhMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileW$address() {
        return GetEnhMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileW(MemorySegment lpName) {
        var mh$ = GetEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileW", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnhMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileBits$descriptor() {
        return GetEnhMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static MethodHandle GetEnhMetaFileBits$handle() {
        return GetEnhMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static MemorySegment GetEnhMetaFileBits$address() {
        return GetEnhMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static int GetEnhMetaFileBits(MemorySegment hEMF, int nSize, MemorySegment lpData) {
        var mh$ = GetEnhMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileBits", hEMF, nSize, lpData);
            }
            return (int)mh$.invokeExact(hEMF, nSize, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileDescriptionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnhMetaFileDescriptionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileDescriptionA$descriptor() {
        return GetEnhMetaFileDescriptionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static MethodHandle GetEnhMetaFileDescriptionA$handle() {
        return GetEnhMetaFileDescriptionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static MemorySegment GetEnhMetaFileDescriptionA$address() {
        return GetEnhMetaFileDescriptionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static int GetEnhMetaFileDescriptionA(MemorySegment hemf, int cchBuffer, MemorySegment lpDescription) {
        var mh$ = GetEnhMetaFileDescriptionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileDescriptionA", hemf, cchBuffer, lpDescription);
            }
            return (int)mh$.invokeExact(hemf, cchBuffer, lpDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileDescriptionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnhMetaFileDescriptionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileDescriptionW$descriptor() {
        return GetEnhMetaFileDescriptionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static MethodHandle GetEnhMetaFileDescriptionW$handle() {
        return GetEnhMetaFileDescriptionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static MemorySegment GetEnhMetaFileDescriptionW$address() {
        return GetEnhMetaFileDescriptionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static int GetEnhMetaFileDescriptionW(MemorySegment hemf, int cchBuffer, MemorySegment lpDescription) {
        var mh$ = GetEnhMetaFileDescriptionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileDescriptionW", hemf, cchBuffer, lpDescription);
            }
            return (int)mh$.invokeExact(hemf, cchBuffer, lpDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnhMetaFileHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileHeader$descriptor() {
        return GetEnhMetaFileHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static MethodHandle GetEnhMetaFileHeader$handle() {
        return GetEnhMetaFileHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static MemorySegment GetEnhMetaFileHeader$address() {
        return GetEnhMetaFileHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static int GetEnhMetaFileHeader(MemorySegment hemf, int nSize, MemorySegment lpEnhMetaHeader) {
        var mh$ = GetEnhMetaFileHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileHeader", hemf, nSize, lpEnhMetaHeader);
            }
            return (int)mh$.invokeExact(hemf, nSize, lpEnhMetaHeader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFilePaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnhMetaFilePaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFilePaletteEntries$descriptor() {
        return GetEnhMetaFilePaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static MethodHandle GetEnhMetaFilePaletteEntries$handle() {
        return GetEnhMetaFilePaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static MemorySegment GetEnhMetaFilePaletteEntries$address() {
        return GetEnhMetaFilePaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static int GetEnhMetaFilePaletteEntries(MemorySegment hemf, int nNumEntries, MemorySegment lpPaletteEntries) {
        var mh$ = GetEnhMetaFilePaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFilePaletteEntries", hemf, nNumEntries, lpPaletteEntries);
            }
            return (int)mh$.invokeExact(hemf, nNumEntries, lpPaletteEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFilePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnhMetaFilePixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFilePixelFormat$descriptor() {
        return GetEnhMetaFilePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle GetEnhMetaFilePixelFormat$handle() {
        return GetEnhMetaFilePixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MemorySegment GetEnhMetaFilePixelFormat$address() {
        return GetEnhMetaFilePixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int GetEnhMetaFilePixelFormat(MemorySegment hemf, int cbBuffer, MemorySegment ppfd) {
        var mh$ = GetEnhMetaFilePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFilePixelFormat", hemf, cbBuffer, ppfd);
            }
            return (int)mh$.invokeExact(hemf, cbBuffer, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWinMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWinMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static FunctionDescriptor GetWinMetaFileBits$descriptor() {
        return GetWinMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static MethodHandle GetWinMetaFileBits$handle() {
        return GetWinMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static MemorySegment GetWinMetaFileBits$address() {
        return GetWinMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static int GetWinMetaFileBits(MemorySegment hemf, int cbData16, MemorySegment pData16, int iMapMode, MemorySegment hdcRef) {
        var mh$ = GetWinMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWinMetaFileBits", hemf, cbData16, pData16, iMapMode, hdcRef);
            }
            return (int)mh$.invokeExact(hemf, cbData16, pData16, iMapMode, hdcRef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PlayEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor PlayEnhMetaFile$descriptor() {
        return PlayEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static MethodHandle PlayEnhMetaFile$handle() {
        return PlayEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static MemorySegment PlayEnhMetaFile$address() {
        return PlayEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static int PlayEnhMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment lprect) {
        var mh$ = PlayEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayEnhMetaFile", hdc, hmf, lprect);
            }
            return (int)mh$.invokeExact(hdc, hmf, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayEnhMetaFileRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PlayEnhMetaFileRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static FunctionDescriptor PlayEnhMetaFileRecord$descriptor() {
        return PlayEnhMetaFileRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static MethodHandle PlayEnhMetaFileRecord$handle() {
        return PlayEnhMetaFileRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static MemorySegment PlayEnhMetaFileRecord$address() {
        return PlayEnhMetaFileRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static int PlayEnhMetaFileRecord(MemorySegment hdc, MemorySegment pht, MemorySegment pmr, int cht) {
        var mh$ = PlayEnhMetaFileRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayEnhMetaFileRecord", hdc, pht, pmr, cht);
            }
            return (int)mh$.invokeExact(hdc, pht, pmr, cht);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnhMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetEnhMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static FunctionDescriptor SetEnhMetaFileBits$descriptor() {
        return SetEnhMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static MethodHandle SetEnhMetaFileBits$handle() {
        return SetEnhMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static MemorySegment SetEnhMetaFileBits$address() {
        return SetEnhMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static MemorySegment SetEnhMetaFileBits(int nSize, MemorySegment pb) {
        var mh$ = SetEnhMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnhMetaFileBits", nSize, pb);
            }
            return (MemorySegment)mh$.invokeExact(nSize, pb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWinMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetWinMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static FunctionDescriptor SetWinMetaFileBits$descriptor() {
        return SetWinMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static MethodHandle SetWinMetaFileBits$handle() {
        return SetWinMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static MemorySegment SetWinMetaFileBits$address() {
        return SetWinMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static MemorySegment SetWinMetaFileBits(int nSize, MemorySegment lpMeta16Data, MemorySegment hdcRef, MemorySegment lpMFP) {
        var mh$ = SetWinMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWinMetaFileBits", nSize, lpMeta16Data, hdcRef, lpMFP);
            }
            return (MemorySegment)mh$.invokeExact(nSize, lpMeta16Data, hdcRef, lpMFP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiComment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GdiComment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static FunctionDescriptor GdiComment$descriptor() {
        return GdiComment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static MethodHandle GdiComment$handle() {
        return GdiComment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static MemorySegment GdiComment$address() {
        return GdiComment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static int GdiComment(MemorySegment hdc, int nSize, MemorySegment lpData) {
        var mh$ = GdiComment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiComment", hdc, nSize, lpData);
            }
            return (int)mh$.invokeExact(hdc, nSize, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextMetricsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextMetricsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static FunctionDescriptor GetTextMetricsA$descriptor() {
        return GetTextMetricsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static MethodHandle GetTextMetricsA$handle() {
        return GetTextMetricsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static MemorySegment GetTextMetricsA$address() {
        return GetTextMetricsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static int GetTextMetricsA(MemorySegment hdc, MemorySegment lptm) {
        var mh$ = GetTextMetricsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextMetricsA", hdc, lptm);
            }
            return (int)mh$.invokeExact(hdc, lptm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextMetricsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextMetricsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static FunctionDescriptor GetTextMetricsW$descriptor() {
        return GetTextMetricsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static MethodHandle GetTextMetricsW$handle() {
        return GetTextMetricsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static MemorySegment GetTextMetricsW$address() {
        return GetTextMetricsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static int GetTextMetricsW(MemorySegment hdc, MemorySegment lptm) {
        var mh$ = GetTextMetricsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextMetricsW", hdc, lptm);
            }
            return (int)mh$.invokeExact(hdc, lptm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDIBSECTION {
     *     BITMAP dsBm;
     *     BITMAPINFOHEADER dsBmih;
     *     DWORD dsBitfields[3];
     *     HANDLE dshSection;
     *     DWORD dsOffset;
     * } *LPDIBSECTION
     * }
     */
    public static final AddressLayout LPDIBSECTION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDIBSECTION {
     *     BITMAP dsBm;
     *     BITMAPINFOHEADER dsBmih;
     *     DWORD dsBitfields[3];
     *     HANDLE dshSection;
     *     DWORD dsOffset;
     * } *PDIBSECTION
     * }
     */
    public static final AddressLayout PDIBSECTION = wgl_h.C_POINTER;

    private static class AngleArc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AngleArc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static FunctionDescriptor AngleArc$descriptor() {
        return AngleArc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static MethodHandle AngleArc$handle() {
        return AngleArc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static MemorySegment AngleArc$address() {
        return AngleArc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static int AngleArc(MemorySegment hdc, int x, int y, int r, float StartAngle, float SweepAngle) {
        var mh$ = AngleArc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AngleArc", hdc, x, y, r, StartAngle, SweepAngle);
            }
            return (int)mh$.invokeExact(hdc, x, y, r, StartAngle, SweepAngle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyPolyline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PolyPolyline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static FunctionDescriptor PolyPolyline$descriptor() {
        return PolyPolyline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static MethodHandle PolyPolyline$handle() {
        return PolyPolyline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static MemorySegment PolyPolyline$address() {
        return PolyPolyline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static int PolyPolyline(MemorySegment hdc, MemorySegment apt, MemorySegment asz, int csz) {
        var mh$ = PolyPolyline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyPolyline", hdc, apt, asz, csz);
            }
            return (int)mh$.invokeExact(hdc, apt, asz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWorldTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static FunctionDescriptor GetWorldTransform$descriptor() {
        return GetWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static MethodHandle GetWorldTransform$handle() {
        return GetWorldTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static MemorySegment GetWorldTransform$address() {
        return GetWorldTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static int GetWorldTransform(MemorySegment hdc, MemorySegment lpxf) {
        var mh$ = GetWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWorldTransform", hdc, lpxf);
            }
            return (int)mh$.invokeExact(hdc, lpxf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetWorldTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static FunctionDescriptor SetWorldTransform$descriptor() {
        return SetWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static MethodHandle SetWorldTransform$handle() {
        return SetWorldTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static MemorySegment SetWorldTransform$address() {
        return SetWorldTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static int SetWorldTransform(MemorySegment hdc, MemorySegment lpxf) {
        var mh$ = SetWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWorldTransform", hdc, lpxf);
            }
            return (int)mh$.invokeExact(hdc, lpxf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModifyWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ModifyWorldTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static FunctionDescriptor ModifyWorldTransform$descriptor() {
        return ModifyWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static MethodHandle ModifyWorldTransform$handle() {
        return ModifyWorldTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static MemorySegment ModifyWorldTransform$address() {
        return ModifyWorldTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static int ModifyWorldTransform(MemorySegment hdc, MemorySegment lpxf, int mode) {
        var mh$ = ModifyWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModifyWorldTransform", hdc, lpxf, mode);
            }
            return (int)mh$.invokeExact(hdc, lpxf, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CombineTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CombineTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static FunctionDescriptor CombineTransform$descriptor() {
        return CombineTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static MethodHandle CombineTransform$handle() {
        return CombineTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static MemorySegment CombineTransform$address() {
        return CombineTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static int CombineTransform(MemorySegment lpxfOut, MemorySegment lpxf1, MemorySegment lpxf2) {
        var mh$ = CombineTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CombineTransform", lpxfOut, lpxf1, lpxf2);
            }
            return (int)mh$.invokeExact(lpxfOut, lpxf1, lpxf2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDIBSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static FunctionDescriptor CreateDIBSection$descriptor() {
        return CreateDIBSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static MethodHandle CreateDIBSection$handle() {
        return CreateDIBSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static MemorySegment CreateDIBSection$address() {
        return CreateDIBSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static MemorySegment CreateDIBSection(MemorySegment hdc, MemorySegment pbmi, int usage, MemorySegment ppvBits, MemorySegment hSection, int offset) {
        var mh$ = CreateDIBSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBSection", hdc, pbmi, usage, ppvBits, hSection, offset);
            }
            return (MemorySegment)mh$.invokeExact(hdc, pbmi, usage, ppvBits, hSection, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDIBColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDIBColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static FunctionDescriptor GetDIBColorTable$descriptor() {
        return GetDIBColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static MethodHandle GetDIBColorTable$handle() {
        return GetDIBColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static MemorySegment GetDIBColorTable$address() {
        return GetDIBColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static int GetDIBColorTable(MemorySegment hdc, int iStart, int cEntries, MemorySegment prgbq) {
        var mh$ = GetDIBColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDIBColorTable", hdc, iStart, cEntries, prgbq);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, prgbq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDIBColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static FunctionDescriptor SetDIBColorTable$descriptor() {
        return SetDIBColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static MethodHandle SetDIBColorTable$handle() {
        return SetDIBColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static MemorySegment SetDIBColorTable$address() {
        return SetDIBColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static int SetDIBColorTable(MemorySegment hdc, int iStart, int cEntries, MemorySegment prgbq) {
        var mh$ = SetDIBColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBColorTable", hdc, iStart, cEntries, prgbq);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, prgbq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORADJUSTMENT {
     *     WORD caSize;
     *     WORD caFlags;
     *     WORD caIlluminantIndex;
     *     WORD caRedGamma;
     *     WORD caGreenGamma;
     *     WORD caBlueGamma;
     *     WORD caReferenceBlack;
     *     WORD caReferenceWhite;
     *     SHORT caContrast;
     *     SHORT caBrightness;
     *     SHORT caColorfulness;
     *     SHORT caRedGreenTint;
     * } *PCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout PCOLORADJUSTMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORADJUSTMENT {
     *     WORD caSize;
     *     WORD caFlags;
     *     WORD caIlluminantIndex;
     *     WORD caRedGamma;
     *     WORD caGreenGamma;
     *     WORD caBlueGamma;
     *     WORD caReferenceBlack;
     *     WORD caReferenceWhite;
     *     SHORT caContrast;
     *     SHORT caBrightness;
     *     SHORT caColorfulness;
     *     SHORT caRedGreenTint;
     * } *LPCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout LPCOLORADJUSTMENT = wgl_h.C_POINTER;

    private static class SetColorAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetColorAdjustment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static FunctionDescriptor SetColorAdjustment$descriptor() {
        return SetColorAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static MethodHandle SetColorAdjustment$handle() {
        return SetColorAdjustment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static MemorySegment SetColorAdjustment$address() {
        return SetColorAdjustment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static int SetColorAdjustment(MemorySegment hdc, MemorySegment lpca) {
        var mh$ = SetColorAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetColorAdjustment", hdc, lpca);
            }
            return (int)mh$.invokeExact(hdc, lpca);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColorAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetColorAdjustment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static FunctionDescriptor GetColorAdjustment$descriptor() {
        return GetColorAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static MethodHandle GetColorAdjustment$handle() {
        return GetColorAdjustment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static MemorySegment GetColorAdjustment$address() {
        return GetColorAdjustment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static int GetColorAdjustment(MemorySegment hdc, MemorySegment lpca) {
        var mh$ = GetColorAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColorAdjustment", hdc, lpca);
            }
            return (int)mh$.invokeExact(hdc, lpca);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHalftonePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateHalftonePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static FunctionDescriptor CreateHalftonePalette$descriptor() {
        return CreateHalftonePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static MethodHandle CreateHalftonePalette$handle() {
        return CreateHalftonePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static MemorySegment CreateHalftonePalette$address() {
        return CreateHalftonePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static MemorySegment CreateHalftonePalette(MemorySegment hdc) {
        var mh$ = CreateHalftonePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHalftonePalette", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DOCINFOA {
     *     int cbSize;
     *     LPCSTR lpszDocName;
     *     LPCSTR lpszOutput;
     *     LPCSTR lpszDatatype;
     *     DWORD fwType;
     * } *LPDOCINFOA
     * }
     */
    public static final AddressLayout LPDOCINFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DOCINFOW {
     *     int cbSize;
     *     LPCWSTR lpszDocName;
     *     LPCWSTR lpszOutput;
     *     LPCWSTR lpszDatatype;
     *     DWORD fwType;
     * } *LPDOCINFOW
     * }
     */
    public static final AddressLayout LPDOCINFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDOCINFOA LPDOCINFO
     * }
     */
    public static final AddressLayout LPDOCINFO = wgl_h.C_POINTER;

    private static class StartDocA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StartDocA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static FunctionDescriptor StartDocA$descriptor() {
        return StartDocA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static MethodHandle StartDocA$handle() {
        return StartDocA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static MemorySegment StartDocA$address() {
        return StartDocA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static int StartDocA(MemorySegment hdc, MemorySegment lpdi) {
        var mh$ = StartDocA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartDocA", hdc, lpdi);
            }
            return (int)mh$.invokeExact(hdc, lpdi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartDocW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StartDocW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static FunctionDescriptor StartDocW$descriptor() {
        return StartDocW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static MethodHandle StartDocW$handle() {
        return StartDocW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static MemorySegment StartDocW$address() {
        return StartDocW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static int StartDocW(MemorySegment hdc, MemorySegment lpdi) {
        var mh$ = StartDocW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartDocW", hdc, lpdi);
            }
            return (int)mh$.invokeExact(hdc, lpdi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EndDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndDoc$descriptor() {
        return EndDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static MethodHandle EndDoc$handle() {
        return EndDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static MemorySegment EndDoc$address() {
        return EndDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static int EndDoc(MemorySegment hdc) {
        var mh$ = EndDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDoc", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartPage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StartPage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static FunctionDescriptor StartPage$descriptor() {
        return StartPage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static MethodHandle StartPage$handle() {
        return StartPage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static MemorySegment StartPage$address() {
        return StartPage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static int StartPage(MemorySegment hdc) {
        var mh$ = StartPage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartPage", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndPage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EndPage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndPage$descriptor() {
        return EndPage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static MethodHandle EndPage$handle() {
        return EndPage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static MemorySegment EndPage$address() {
        return EndPage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static int EndPage(MemorySegment hdc) {
        var mh$ = EndPage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndPage", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AbortDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static FunctionDescriptor AbortDoc$descriptor() {
        return AbortDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static MethodHandle AbortDoc$handle() {
        return AbortDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static MemorySegment AbortDoc$address() {
        return AbortDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static int AbortDoc(MemorySegment hdc) {
        var mh$ = AbortDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortDoc", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAbortProc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetAbortProc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static FunctionDescriptor SetAbortProc$descriptor() {
        return SetAbortProc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static MethodHandle SetAbortProc$handle() {
        return SetAbortProc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static MemorySegment SetAbortProc$address() {
        return SetAbortProc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static int SetAbortProc(MemorySegment hdc, MemorySegment proc) {
        var mh$ = SetAbortProc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAbortProc", hdc, proc);
            }
            return (int)mh$.invokeExact(hdc, proc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AbortPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor AbortPath$descriptor() {
        return AbortPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static MethodHandle AbortPath$handle() {
        return AbortPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static MemorySegment AbortPath$address() {
        return AbortPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static int AbortPath(MemorySegment hdc) {
        var mh$ = AbortPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ArcTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ArcTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static FunctionDescriptor ArcTo$descriptor() {
        return ArcTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MethodHandle ArcTo$handle() {
        return ArcTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MemorySegment ArcTo$address() {
        return ArcTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static int ArcTo(MemorySegment hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2) {
        var mh$ = ArcTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ArcTo", hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BeginPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor BeginPath$descriptor() {
        return BeginPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static MethodHandle BeginPath$handle() {
        return BeginPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static MemorySegment BeginPath$address() {
        return BeginPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static int BeginPath(MemorySegment hdc) {
        var mh$ = BeginPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseFigure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseFigure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseFigure$descriptor() {
        return CloseFigure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static MethodHandle CloseFigure$handle() {
        return CloseFigure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static MemorySegment CloseFigure$address() {
        return CloseFigure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static int CloseFigure(MemorySegment hdc) {
        var mh$ = CloseFigure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseFigure", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EndPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndPath$descriptor() {
        return EndPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static MethodHandle EndPath$handle() {
        return EndPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static MemorySegment EndPath$address() {
        return EndPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static int EndPath(MemorySegment hdc) {
        var mh$ = EndPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FillPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor FillPath$descriptor() {
        return FillPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static MethodHandle FillPath$handle() {
        return FillPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static MemorySegment FillPath$address() {
        return FillPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static int FillPath(MemorySegment hdc) {
        var mh$ = FillPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlattenPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FlattenPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor FlattenPath$descriptor() {
        return FlattenPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static MethodHandle FlattenPath$handle() {
        return FlattenPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static MemorySegment FlattenPath$address() {
        return FlattenPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static int FlattenPath(MemorySegment hdc) {
        var mh$ = FlattenPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlattenPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static FunctionDescriptor GetPath$descriptor() {
        return GetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static MethodHandle GetPath$handle() {
        return GetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static MemorySegment GetPath$address() {
        return GetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static int GetPath(MemorySegment hdc, MemorySegment apt, MemorySegment aj, int cpt) {
        var mh$ = GetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPath", hdc, apt, aj, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, aj, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PathToRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PathToRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static FunctionDescriptor PathToRegion$descriptor() {
        return PathToRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static MethodHandle PathToRegion$handle() {
        return PathToRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static MemorySegment PathToRegion$address() {
        return PathToRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static MemorySegment PathToRegion(MemorySegment hdc) {
        var mh$ = PathToRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PathToRegion", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyDraw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PolyDraw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static FunctionDescriptor PolyDraw$descriptor() {
        return PolyDraw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static MethodHandle PolyDraw$handle() {
        return PolyDraw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static MemorySegment PolyDraw$address() {
        return PolyDraw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static int PolyDraw(MemorySegment hdc, MemorySegment apt, MemorySegment aj, int cpt) {
        var mh$ = PolyDraw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyDraw", hdc, apt, aj, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, aj, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SelectClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SelectClipPath$descriptor() {
        return SelectClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SelectClipPath$handle() {
        return SelectClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SelectClipPath$address() {
        return SelectClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static int SelectClipPath(MemorySegment hdc, int mode) {
        var mh$ = SelectClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectClipPath", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetArcDirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetArcDirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static FunctionDescriptor SetArcDirection$descriptor() {
        return SetArcDirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static MethodHandle SetArcDirection$handle() {
        return SetArcDirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static MemorySegment SetArcDirection$address() {
        return SetArcDirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static int SetArcDirection(MemorySegment hdc, int dir) {
        var mh$ = SetArcDirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetArcDirection", hdc, dir);
            }
            return (int)mh$.invokeExact(hdc, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_FLOAT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMiterLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static FunctionDescriptor SetMiterLimit$descriptor() {
        return SetMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static MethodHandle SetMiterLimit$handle() {
        return SetMiterLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static MemorySegment SetMiterLimit$address() {
        return SetMiterLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static int SetMiterLimit(MemorySegment hdc, float limit, MemorySegment old) {
        var mh$ = SetMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMiterLimit", hdc, limit, old);
            }
            return (int)mh$.invokeExact(hdc, limit, old);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StrokeAndFillPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StrokeAndFillPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor StrokeAndFillPath$descriptor() {
        return StrokeAndFillPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static MethodHandle StrokeAndFillPath$handle() {
        return StrokeAndFillPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static MemorySegment StrokeAndFillPath$address() {
        return StrokeAndFillPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static int StrokeAndFillPath(MemorySegment hdc) {
        var mh$ = StrokeAndFillPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StrokeAndFillPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StrokePath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StrokePath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static FunctionDescriptor StrokePath$descriptor() {
        return StrokePath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static MethodHandle StrokePath$handle() {
        return StrokePath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static MemorySegment StrokePath$address() {
        return StrokePath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static int StrokePath(MemorySegment hdc) {
        var mh$ = StrokePath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StrokePath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WidenPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WidenPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor WidenPath$descriptor() {
        return WidenPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static MethodHandle WidenPath$handle() {
        return WidenPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static MemorySegment WidenPath$address() {
        return WidenPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static int WidenPath(MemorySegment hdc) {
        var mh$ = WidenPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WidenPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtCreatePen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExtCreatePen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static FunctionDescriptor ExtCreatePen$descriptor() {
        return ExtCreatePen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static MethodHandle ExtCreatePen$handle() {
        return ExtCreatePen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static MemorySegment ExtCreatePen$address() {
        return ExtCreatePen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static MemorySegment ExtCreatePen(int iPenStyle, int cWidth, MemorySegment plbrush, int cStyle, MemorySegment pstyle) {
        var mh$ = ExtCreatePen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtCreatePen", iPenStyle, cWidth, plbrush, cStyle, pstyle);
            }
            return (MemorySegment)mh$.invokeExact(iPenStyle, cWidth, plbrush, cStyle, pstyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMiterLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static FunctionDescriptor GetMiterLimit$descriptor() {
        return GetMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static MethodHandle GetMiterLimit$handle() {
        return GetMiterLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static MemorySegment GetMiterLimit$address() {
        return GetMiterLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static int GetMiterLimit(MemorySegment hdc, MemorySegment plimit) {
        var mh$ = GetMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMiterLimit", hdc, plimit);
            }
            return (int)mh$.invokeExact(hdc, plimit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetArcDirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetArcDirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetArcDirection$descriptor() {
        return GetArcDirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static MethodHandle GetArcDirection$handle() {
        return GetArcDirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static MemorySegment GetArcDirection$address() {
        return GetArcDirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static int GetArcDirection(MemorySegment hdc) {
        var mh$ = GetArcDirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetArcDirection", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetObjectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static FunctionDescriptor GetObjectA$descriptor() {
        return GetObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MethodHandle GetObjectA$handle() {
        return GetObjectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MemorySegment GetObjectA$address() {
        return GetObjectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static int GetObjectA(MemorySegment h, int c, MemorySegment pv) {
        var mh$ = GetObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectA", h, c, pv);
            }
            return (int)mh$.invokeExact(h, c, pv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetObjectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static FunctionDescriptor GetObjectW$descriptor() {
        return GetObjectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MethodHandle GetObjectW$handle() {
        return GetObjectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MemorySegment GetObjectW$address() {
        return GetObjectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static int GetObjectW(MemorySegment h, int c, MemorySegment pv) {
        var mh$ = GetObjectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectW", h, c, pv);
            }
            return (int)mh$.invokeExact(h, c, pv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveToEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MoveToEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor MoveToEx$descriptor() {
        return MoveToEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle MoveToEx$handle() {
        return MoveToEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment MoveToEx$address() {
        return MoveToEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int MoveToEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = MoveToEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveToEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TextOutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static FunctionDescriptor TextOutA$descriptor() {
        return TextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static MethodHandle TextOutA$handle() {
        return TextOutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static MemorySegment TextOutA$address() {
        return TextOutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static int TextOutA(MemorySegment hdc, int x, int y, MemorySegment lpString, int c) {
        var mh$ = TextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextOutA", hdc, x, y, lpString, c);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TextOutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static FunctionDescriptor TextOutW$descriptor() {
        return TextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static MethodHandle TextOutW$handle() {
        return TextOutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static MemorySegment TextOutW$address() {
        return TextOutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static int TextOutW(MemorySegment hdc, int x, int y, MemorySegment lpString, int c) {
        var mh$ = TextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextOutW", hdc, x, y, lpString, c);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtTextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExtTextOutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static FunctionDescriptor ExtTextOutA$descriptor() {
        return ExtTextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MethodHandle ExtTextOutA$handle() {
        return ExtTextOutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MemorySegment ExtTextOutA$address() {
        return ExtTextOutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static int ExtTextOutA(MemorySegment hdc, int x, int y, int options, MemorySegment lprect, MemorySegment lpString, int c, MemorySegment lpDx) {
        var mh$ = ExtTextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtTextOutA", hdc, x, y, options, lprect, lpString, c, lpDx);
            }
            return (int)mh$.invokeExact(hdc, x, y, options, lprect, lpString, c, lpDx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtTextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExtTextOutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static FunctionDescriptor ExtTextOutW$descriptor() {
        return ExtTextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MethodHandle ExtTextOutW$handle() {
        return ExtTextOutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MemorySegment ExtTextOutW$address() {
        return ExtTextOutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static int ExtTextOutW(MemorySegment hdc, int x, int y, int options, MemorySegment lprect, MemorySegment lpString, int c, MemorySegment lpDx) {
        var mh$ = ExtTextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtTextOutW", hdc, x, y, options, lprect, lpString, c, lpDx);
            }
            return (int)mh$.invokeExact(hdc, x, y, options, lprect, lpString, c, lpDx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyTextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PolyTextOutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static FunctionDescriptor PolyTextOutA$descriptor() {
        return PolyTextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static MethodHandle PolyTextOutA$handle() {
        return PolyTextOutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static MemorySegment PolyTextOutA$address() {
        return PolyTextOutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static int PolyTextOutA(MemorySegment hdc, MemorySegment ppt, int nstrings) {
        var mh$ = PolyTextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyTextOutA", hdc, ppt, nstrings);
            }
            return (int)mh$.invokeExact(hdc, ppt, nstrings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyTextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PolyTextOutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static FunctionDescriptor PolyTextOutW$descriptor() {
        return PolyTextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static MethodHandle PolyTextOutW$handle() {
        return PolyTextOutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static MemorySegment PolyTextOutW$address() {
        return PolyTextOutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static int PolyTextOutW(MemorySegment hdc, MemorySegment ppt, int nstrings) {
        var mh$ = PolyTextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyTextOutW", hdc, ppt, nstrings);
            }
            return (int)mh$.invokeExact(hdc, ppt, nstrings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePolygonRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePolygonRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static FunctionDescriptor CreatePolygonRgn$descriptor() {
        return CreatePolygonRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static MethodHandle CreatePolygonRgn$handle() {
        return CreatePolygonRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static MemorySegment CreatePolygonRgn$address() {
        return CreatePolygonRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static MemorySegment CreatePolygonRgn(MemorySegment pptl, int cPoint, int iMode) {
        var mh$ = CreatePolygonRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePolygonRgn", pptl, cPoint, iMode);
            }
            return (MemorySegment)mh$.invokeExact(pptl, cPoint, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DPtoLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DPtoLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static FunctionDescriptor DPtoLP$descriptor() {
        return DPtoLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MethodHandle DPtoLP$handle() {
        return DPtoLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MemorySegment DPtoLP$address() {
        return DPtoLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static int DPtoLP(MemorySegment hdc, MemorySegment lppt, int c) {
        var mh$ = DPtoLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DPtoLP", hdc, lppt, c);
            }
            return (int)mh$.invokeExact(hdc, lppt, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LPtoDP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LPtoDP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static FunctionDescriptor LPtoDP$descriptor() {
        return LPtoDP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MethodHandle LPtoDP$handle() {
        return LPtoDP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MemorySegment LPtoDP$address() {
        return LPtoDP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static int LPtoDP(MemorySegment hdc, MemorySegment lppt, int c) {
        var mh$ = LPtoDP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LPtoDP", hdc, lppt, c);
            }
            return (int)mh$.invokeExact(hdc, lppt, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Polygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Polygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static FunctionDescriptor Polygon$descriptor() {
        return Polygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MethodHandle Polygon$handle() {
        return Polygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MemorySegment Polygon$address() {
        return Polygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static int Polygon(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = Polygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Polygon", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Polyline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Polyline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static FunctionDescriptor Polyline$descriptor() {
        return Polyline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MethodHandle Polyline$handle() {
        return Polyline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MemorySegment Polyline$address() {
        return Polyline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static int Polyline(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = Polyline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Polyline", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyBezier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PolyBezier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolyBezier$descriptor() {
        return PolyBezier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolyBezier$handle() {
        return PolyBezier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MemorySegment PolyBezier$address() {
        return PolyBezier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolyBezier(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolyBezier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyBezier", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyBezierTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PolyBezierTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolyBezierTo$descriptor() {
        return PolyBezierTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolyBezierTo$handle() {
        return PolyBezierTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MemorySegment PolyBezierTo$address() {
        return PolyBezierTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolyBezierTo(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolyBezierTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyBezierTo", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolylineTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PolylineTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolylineTo$descriptor() {
        return PolylineTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolylineTo$handle() {
        return PolylineTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MemorySegment PolylineTo$address() {
        return PolylineTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolylineTo(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolylineTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolylineTo", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetViewportExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetViewportExtEx$descriptor() {
        return SetViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetViewportExtEx$handle() {
        return SetViewportExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MemorySegment SetViewportExtEx$address() {
        return SetViewportExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static int SetViewportExtEx(MemorySegment hdc, int x, int y, MemorySegment lpsz) {
        var mh$ = SetViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetViewportExtEx", hdc, x, y, lpsz);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetViewportOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetViewportOrgEx$descriptor() {
        return SetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetViewportOrgEx$handle() {
        return SetViewportOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment SetViewportOrgEx$address() {
        return SetViewportOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetViewportOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetViewportOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetWindowExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetWindowExtEx$descriptor() {
        return SetWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetWindowExtEx$handle() {
        return SetWindowExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MemorySegment SetWindowExtEx$address() {
        return SetWindowExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static int SetWindowExtEx(MemorySegment hdc, int x, int y, MemorySegment lpsz) {
        var mh$ = SetWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowExtEx", hdc, x, y, lpsz);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetWindowOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetWindowOrgEx$descriptor() {
        return SetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetWindowOrgEx$handle() {
        return SetWindowOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment SetWindowOrgEx$address() {
        return SetWindowOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetWindowOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OffsetViewportOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor OffsetViewportOrgEx$descriptor() {
        return OffsetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle OffsetViewportOrgEx$handle() {
        return OffsetViewportOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment OffsetViewportOrgEx$address() {
        return OffsetViewportOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int OffsetViewportOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = OffsetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetViewportOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OffsetWindowOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor OffsetWindowOrgEx$descriptor() {
        return OffsetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle OffsetWindowOrgEx$handle() {
        return OffsetWindowOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment OffsetWindowOrgEx$address() {
        return OffsetWindowOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int OffsetWindowOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = OffsetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetWindowOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScaleViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ScaleViewportExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor ScaleViewportExtEx$descriptor() {
        return ScaleViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MethodHandle ScaleViewportExtEx$handle() {
        return ScaleViewportExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MemorySegment ScaleViewportExtEx$address() {
        return ScaleViewportExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static int ScaleViewportExtEx(MemorySegment hdc, int xn, int dx, int yn, int yd, MemorySegment lpsz) {
        var mh$ = ScaleViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScaleViewportExtEx", hdc, xn, dx, yn, yd, lpsz);
            }
            return (int)mh$.invokeExact(hdc, xn, dx, yn, yd, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScaleWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ScaleWindowExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor ScaleWindowExtEx$descriptor() {
        return ScaleWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MethodHandle ScaleWindowExtEx$handle() {
        return ScaleWindowExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MemorySegment ScaleWindowExtEx$address() {
        return ScaleWindowExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static int ScaleWindowExtEx(MemorySegment hdc, int xn, int xd, int yn, int yd, MemorySegment lpsz) {
        var mh$ = ScaleWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScaleWindowExtEx", hdc, xn, xd, yn, yd, lpsz);
            }
            return (int)mh$.invokeExact(hdc, xn, xd, yn, yd, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBitmapDimensionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetBitmapDimensionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetBitmapDimensionEx$descriptor() {
        return SetBitmapDimensionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetBitmapDimensionEx$handle() {
        return SetBitmapDimensionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static MemorySegment SetBitmapDimensionEx$address() {
        return SetBitmapDimensionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static int SetBitmapDimensionEx(MemorySegment hbm, int w, int h, MemorySegment lpsz) {
        var mh$ = SetBitmapDimensionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBitmapDimensionEx", hbm, w, h, lpsz);
            }
            return (int)mh$.invokeExact(hbm, w, h, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetBrushOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetBrushOrgEx$descriptor() {
        return SetBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetBrushOrgEx$handle() {
        return SetBrushOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment SetBrushOrgEx$address() {
        return SetBrushOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetBrushOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBrushOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextFaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextFaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static FunctionDescriptor GetTextFaceA$descriptor() {
        return GetTextFaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static MethodHandle GetTextFaceA$handle() {
        return GetTextFaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static MemorySegment GetTextFaceA$address() {
        return GetTextFaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static int GetTextFaceA(MemorySegment hdc, int c, MemorySegment lpName) {
        var mh$ = GetTextFaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextFaceA", hdc, c, lpName);
            }
            return (int)mh$.invokeExact(hdc, c, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextFaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTextFaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetTextFaceW$descriptor() {
        return GetTextFaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static MethodHandle GetTextFaceW$handle() {
        return GetTextFaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static MemorySegment GetTextFaceW$address() {
        return GetTextFaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static int GetTextFaceW(MemorySegment hdc, int c, MemorySegment lpName) {
        var mh$ = GetTextFaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextFaceW", hdc, c, lpName);
            }
            return (int)mh$.invokeExact(hdc, c, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagKERNINGPAIR {
     *     WORD wFirst;
     *     WORD wSecond;
     *     int iKernAmount;
     * } *LPKERNINGPAIR
     * }
     */
    public static final AddressLayout LPKERNINGPAIR = wgl_h.C_POINTER;

    private static class GetKerningPairsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKerningPairsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static FunctionDescriptor GetKerningPairsA$descriptor() {
        return GetKerningPairsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MethodHandle GetKerningPairsA$handle() {
        return GetKerningPairsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MemorySegment GetKerningPairsA$address() {
        return GetKerningPairsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static int GetKerningPairsA(MemorySegment hdc, int nPairs, MemorySegment lpKernPair) {
        var mh$ = GetKerningPairsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKerningPairsA", hdc, nPairs, lpKernPair);
            }
            return (int)mh$.invokeExact(hdc, nPairs, lpKernPair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKerningPairsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKerningPairsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static FunctionDescriptor GetKerningPairsW$descriptor() {
        return GetKerningPairsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MethodHandle GetKerningPairsW$handle() {
        return GetKerningPairsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MemorySegment GetKerningPairsW$address() {
        return GetKerningPairsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static int GetKerningPairsW(MemorySegment hdc, int nPairs, MemorySegment lpKernPair) {
        var mh$ = GetKerningPairsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKerningPairsW", hdc, nPairs, lpKernPair);
            }
            return (int)mh$.invokeExact(hdc, nPairs, lpKernPair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDCOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetDCOrgEx$descriptor() {
        return GetDCOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetDCOrgEx$handle() {
        return GetDCOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MemorySegment GetDCOrgEx$address() {
        return GetDCOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetDCOrgEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetDCOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCOrgEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FixBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FixBrushOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static FunctionDescriptor FixBrushOrgEx$descriptor() {
        return FixBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static MethodHandle FixBrushOrgEx$handle() {
        return FixBrushOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static MemorySegment FixBrushOrgEx$address() {
        return FixBrushOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static int FixBrushOrgEx(MemorySegment hdc, int x, int y, MemorySegment ptl) {
        var mh$ = FixBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FixBrushOrgEx", hdc, x, y, ptl);
            }
            return (int)mh$.invokeExact(hdc, x, y, ptl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnrealizeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnrealizeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor UnrealizeObject$descriptor() {
        return UnrealizeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static MethodHandle UnrealizeObject$handle() {
        return UnrealizeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static MemorySegment UnrealizeObject$address() {
        return UnrealizeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static int UnrealizeObject(MemorySegment h) {
        var mh$ = UnrealizeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnrealizeObject", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GdiFlush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static FunctionDescriptor GdiFlush$descriptor() {
        return GdiFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static MethodHandle GdiFlush$handle() {
        return GdiFlush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static MemorySegment GdiFlush$address() {
        return GdiFlush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static int GdiFlush() {
        var mh$ = GdiFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiFlush");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiSetBatchLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GdiSetBatchLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static FunctionDescriptor GdiSetBatchLimit$descriptor() {
        return GdiSetBatchLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static MethodHandle GdiSetBatchLimit$handle() {
        return GdiSetBatchLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static MemorySegment GdiSetBatchLimit$address() {
        return GdiSetBatchLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static int GdiSetBatchLimit(int dw) {
        var mh$ = GdiSetBatchLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiSetBatchLimit", dw);
            }
            return (int)mh$.invokeExact(dw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiGetBatchLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GdiGetBatchLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static FunctionDescriptor GdiGetBatchLimit$descriptor() {
        return GdiGetBatchLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static MethodHandle GdiGetBatchLimit$handle() {
        return GdiGetBatchLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static MemorySegment GdiGetBatchLimit$address() {
        return GdiGetBatchLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static int GdiGetBatchLimit() {
        var mh$ = GdiGetBatchLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiGetBatchLimit");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetICMMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetICMMode$descriptor() {
        return SetICMMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetICMMode$handle() {
        return SetICMMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetICMMode$address() {
        return SetICMMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static int SetICMMode(MemorySegment hdc, int mode) {
        var mh$ = SetICMMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckColorsInGamut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CheckColorsInGamut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static FunctionDescriptor CheckColorsInGamut$descriptor() {
        return CheckColorsInGamut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static MethodHandle CheckColorsInGamut$handle() {
        return CheckColorsInGamut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static MemorySegment CheckColorsInGamut$address() {
        return CheckColorsInGamut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static int CheckColorsInGamut(MemorySegment hdc, MemorySegment lpRGBTriple, MemorySegment dlpBuffer, int nCount) {
        var mh$ = CheckColorsInGamut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckColorsInGamut", hdc, lpRGBTriple, dlpBuffer, nCount);
            }
            return (int)mh$.invokeExact(hdc, lpRGBTriple, dlpBuffer, nCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetColorSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetColorSpace$descriptor() {
        return GetColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static MethodHandle GetColorSpace$handle() {
        return GetColorSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static MemorySegment GetColorSpace$address() {
        return GetColorSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static MemorySegment GetColorSpace(MemorySegment hdc) {
        var mh$ = GetColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColorSpace", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogColorSpaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLogColorSpaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetLogColorSpaceA$descriptor() {
        return GetLogColorSpaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetLogColorSpaceA$handle() {
        return GetLogColorSpaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetLogColorSpaceA$address() {
        return GetLogColorSpaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static int GetLogColorSpaceA(MemorySegment hColorSpace, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetLogColorSpaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogColorSpaceA", hColorSpace, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(hColorSpace, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogColorSpaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLogColorSpaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetLogColorSpaceW$descriptor() {
        return GetLogColorSpaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetLogColorSpaceW$handle() {
        return GetLogColorSpaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetLogColorSpaceW$address() {
        return GetLogColorSpaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static int GetLogColorSpaceW(MemorySegment hColorSpace, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetLogColorSpaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogColorSpaceW", hColorSpace, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(hColorSpace, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateColorSpaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateColorSpaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static FunctionDescriptor CreateColorSpaceA$descriptor() {
        return CreateColorSpaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static MethodHandle CreateColorSpaceA$handle() {
        return CreateColorSpaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceA$address() {
        return CreateColorSpaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceA(MemorySegment lplcs) {
        var mh$ = CreateColorSpaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateColorSpaceA", lplcs);
            }
            return (MemorySegment)mh$.invokeExact(lplcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateColorSpaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateColorSpaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static FunctionDescriptor CreateColorSpaceW$descriptor() {
        return CreateColorSpaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static MethodHandle CreateColorSpaceW$handle() {
        return CreateColorSpaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceW$address() {
        return CreateColorSpaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceW(MemorySegment lplcs) {
        var mh$ = CreateColorSpaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateColorSpaceW", lplcs);
            }
            return (MemorySegment)mh$.invokeExact(lplcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetColorSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static FunctionDescriptor SetColorSpace$descriptor() {
        return SetColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static MethodHandle SetColorSpace$handle() {
        return SetColorSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static MemorySegment SetColorSpace$address() {
        return SetColorSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static MemorySegment SetColorSpace(MemorySegment hdc, MemorySegment hcs) {
        var mh$ = SetColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetColorSpace", hdc, hcs);
            }
            return (MemorySegment)mh$.invokeExact(hdc, hcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteColorSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static FunctionDescriptor DeleteColorSpace$descriptor() {
        return DeleteColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static MethodHandle DeleteColorSpace$handle() {
        return DeleteColorSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static MemorySegment DeleteColorSpace$address() {
        return DeleteColorSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static int DeleteColorSpace(MemorySegment hcs) {
        var mh$ = DeleteColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteColorSpace", hcs);
            }
            return (int)mh$.invokeExact(hcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetICMProfileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetICMProfileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static FunctionDescriptor GetICMProfileA$descriptor() {
        return GetICMProfileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static MethodHandle GetICMProfileA$handle() {
        return GetICMProfileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static MemorySegment GetICMProfileA$address() {
        return GetICMProfileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static int GetICMProfileA(MemorySegment hdc, MemorySegment pBufSize, MemorySegment pszFilename) {
        var mh$ = GetICMProfileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetICMProfileA", hdc, pBufSize, pszFilename);
            }
            return (int)mh$.invokeExact(hdc, pBufSize, pszFilename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetICMProfileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetICMProfileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static FunctionDescriptor GetICMProfileW$descriptor() {
        return GetICMProfileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static MethodHandle GetICMProfileW$handle() {
        return GetICMProfileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static MemorySegment GetICMProfileW$address() {
        return GetICMProfileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static int GetICMProfileW(MemorySegment hdc, MemorySegment pBufSize, MemorySegment pszFilename) {
        var mh$ = GetICMProfileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetICMProfileW", hdc, pBufSize, pszFilename);
            }
            return (int)mh$.invokeExact(hdc, pBufSize, pszFilename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMProfileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetICMProfileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static FunctionDescriptor SetICMProfileA$descriptor() {
        return SetICMProfileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static MethodHandle SetICMProfileA$handle() {
        return SetICMProfileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static MemorySegment SetICMProfileA$address() {
        return SetICMProfileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static int SetICMProfileA(MemorySegment hdc, MemorySegment lpFileName) {
        var mh$ = SetICMProfileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMProfileA", hdc, lpFileName);
            }
            return (int)mh$.invokeExact(hdc, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMProfileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetICMProfileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor SetICMProfileW$descriptor() {
        return SetICMProfileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static MethodHandle SetICMProfileW$handle() {
        return SetICMProfileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static MemorySegment SetICMProfileW$address() {
        return SetICMProfileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static int SetICMProfileW(MemorySegment hdc, MemorySegment lpFileName) {
        var mh$ = SetICMProfileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMProfileW", hdc, lpFileName);
            }
            return (int)mh$.invokeExact(hdc, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDeviceGammaRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDeviceGammaRamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static FunctionDescriptor GetDeviceGammaRamp$descriptor() {
        return GetDeviceGammaRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MethodHandle GetDeviceGammaRamp$handle() {
        return GetDeviceGammaRamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MemorySegment GetDeviceGammaRamp$address() {
        return GetDeviceGammaRamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static int GetDeviceGammaRamp(MemorySegment hdc, MemorySegment lpRamp) {
        var mh$ = GetDeviceGammaRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDeviceGammaRamp", hdc, lpRamp);
            }
            return (int)mh$.invokeExact(hdc, lpRamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDeviceGammaRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDeviceGammaRamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static FunctionDescriptor SetDeviceGammaRamp$descriptor() {
        return SetDeviceGammaRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MethodHandle SetDeviceGammaRamp$handle() {
        return SetDeviceGammaRamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MemorySegment SetDeviceGammaRamp$address() {
        return SetDeviceGammaRamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static int SetDeviceGammaRamp(MemorySegment hdc, MemorySegment lpRamp) {
        var mh$ = SetDeviceGammaRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDeviceGammaRamp", hdc, lpRamp);
            }
            return (int)mh$.invokeExact(hdc, lpRamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorMatchToTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ColorMatchToTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static FunctionDescriptor ColorMatchToTarget$descriptor() {
        return ColorMatchToTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static MethodHandle ColorMatchToTarget$handle() {
        return ColorMatchToTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static MemorySegment ColorMatchToTarget$address() {
        return ColorMatchToTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static int ColorMatchToTarget(MemorySegment hdc, MemorySegment hdcTarget, int action) {
        var mh$ = ColorMatchToTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorMatchToTarget", hdc, hdcTarget, action);
            }
            return (int)mh$.invokeExact(hdc, hdcTarget, action);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumICMProfilesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumICMProfilesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumICMProfilesA$descriptor() {
        return EnumICMProfilesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumICMProfilesA$handle() {
        return EnumICMProfilesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static MemorySegment EnumICMProfilesA$address() {
        return EnumICMProfilesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static int EnumICMProfilesA(MemorySegment hdc, MemorySegment proc, long param) {
        var mh$ = EnumICMProfilesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumICMProfilesA", hdc, proc, param);
            }
            return (int)mh$.invokeExact(hdc, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumICMProfilesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumICMProfilesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumICMProfilesW$descriptor() {
        return EnumICMProfilesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumICMProfilesW$handle() {
        return EnumICMProfilesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static MemorySegment EnumICMProfilesW$address() {
        return EnumICMProfilesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static int EnumICMProfilesW(MemorySegment hdc, MemorySegment proc, long param) {
        var mh$ = EnumICMProfilesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumICMProfilesW", hdc, proc, param);
            }
            return (int)mh$.invokeExact(hdc, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateICMRegKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UpdateICMRegKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static FunctionDescriptor UpdateICMRegKeyA$descriptor() {
        return UpdateICMRegKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static MethodHandle UpdateICMRegKeyA$handle() {
        return UpdateICMRegKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static MemorySegment UpdateICMRegKeyA$address() {
        return UpdateICMRegKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static int UpdateICMRegKeyA(int reserved, MemorySegment lpszCMID, MemorySegment lpszFileName, int command) {
        var mh$ = UpdateICMRegKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateICMRegKeyA", reserved, lpszCMID, lpszFileName, command);
            }
            return (int)mh$.invokeExact(reserved, lpszCMID, lpszFileName, command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateICMRegKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UpdateICMRegKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static FunctionDescriptor UpdateICMRegKeyW$descriptor() {
        return UpdateICMRegKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static MethodHandle UpdateICMRegKeyW$handle() {
        return UpdateICMRegKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static MemorySegment UpdateICMRegKeyW$address() {
        return UpdateICMRegKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static int UpdateICMRegKeyW(int reserved, MemorySegment lpszCMID, MemorySegment lpszFileName, int command) {
        var mh$ = UpdateICMRegKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateICMRegKeyW", reserved, lpszCMID, lpszFileName, command);
            }
            return (int)mh$.invokeExact(reserved, lpszCMID, lpszFileName, command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorCorrectPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ColorCorrectPalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static FunctionDescriptor ColorCorrectPalette$descriptor() {
        return ColorCorrectPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static MethodHandle ColorCorrectPalette$handle() {
        return ColorCorrectPalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static MemorySegment ColorCorrectPalette$address() {
        return ColorCorrectPalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static int ColorCorrectPalette(MemorySegment hdc, MemorySegment hPal, int deFirst, int num) {
        var mh$ = ColorCorrectPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorCorrectPalette", hdc, hPal, deFirst, num);
            }
            return (int)mh$.invokeExact(hdc, hPal, deFirst, num);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagEMR {
     *     DWORD iType;
     *     DWORD nSize;
     * } *PEMR
     * }
     */
    public static final AddressLayout PEMR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRTEXT {
     *     POINTL ptlReference;
     *     DWORD nChars;
     *     DWORD offString;
     *     DWORD fOptions;
     *     RECTL rcl;
     *     DWORD offDx;
     * } *PEMRTEXT
     * }
     */
    public static final AddressLayout PEMRTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRABORTPATH
     * }
     */
    public static final AddressLayout PEMRABORTPATH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRBEGINPATH
     * }
     */
    public static final AddressLayout PEMRBEGINPATH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRENDPATH
     * }
     */
    public static final AddressLayout PEMRENDPATH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRCLOSEFIGURE
     * }
     */
    public static final AddressLayout PEMRCLOSEFIGURE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRFLATTENPATH
     * }
     */
    public static final AddressLayout PEMRFLATTENPATH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRWIDENPATH
     * }
     */
    public static final AddressLayout PEMRWIDENPATH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRSETMETARGN
     * }
     */
    public static final AddressLayout PEMRSETMETARGN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRSAVEDC
     * }
     */
    public static final AddressLayout PEMRSAVEDC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRREALIZEPALETTE
     * }
     */
    public static final AddressLayout PEMRREALIZEPALETTE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSELECTCLIPPATH
     * }
     */
    public static final AddressLayout PEMRSELECTCLIPPATH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETBKMODE
     * }
     */
    public static final AddressLayout PEMRSETBKMODE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETMAPMODE
     * }
     */
    public static final AddressLayout PEMRSETMAPMODE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETLAYOUT
     * }
     */
    public static final AddressLayout PEMRSETLAYOUT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETPOLYFILLMODE
     * }
     */
    public static final AddressLayout PEMRSETPOLYFILLMODE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETROP2
     * }
     */
    public static final AddressLayout PEMRSETROP2 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETSTRETCHBLTMODE
     * }
     */
    public static final AddressLayout PEMRSETSTRETCHBLTMODE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETICMMODE
     * }
     */
    public static final AddressLayout PEMRSETICMMODE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETTEXTALIGN
     * }
     */
    public static final AddressLayout PEMRSETTEXTALIGN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETMITERLIMIT {
     *     EMR emr;
     *     FLOAT eMiterLimit;
     * } *PEMRSETMITERLIMIT
     * }
     */
    public static final AddressLayout PEMRSETMITERLIMIT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRRESTOREDC {
     *     EMR emr;
     *     LONG iRelative;
     * } *PEMRRESTOREDC
     * }
     */
    public static final AddressLayout PEMRRESTOREDC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETARCDIRECTION {
     *     EMR emr;
     *     DWORD iArcDirection;
     * } *PEMRSETARCDIRECTION
     * }
     */
    public static final AddressLayout PEMRSETARCDIRECTION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETMAPPERFLAGS {
     *     EMR emr;
     *     DWORD dwFlags;
     * } *PEMRSETMAPPERFLAGS
     * }
     */
    public static final AddressLayout PEMRSETMAPPERFLAGS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETTEXTCOLOR {
     *     EMR emr;
     *     COLORREF crColor;
     * } *PEMRSETBKCOLOR
     * }
     */
    public static final AddressLayout PEMRSETBKCOLOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETTEXTCOLOR {
     *     EMR emr;
     *     COLORREF crColor;
     * } *PEMRSETTEXTCOLOR
     * }
     */
    public static final AddressLayout PEMRSETTEXTCOLOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTOBJECT {
     *     EMR emr;
     *     DWORD ihObject;
     * } *PEMRSELECTOBJECT
     * }
     */
    public static final AddressLayout PEMRSELECTOBJECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTOBJECT {
     *     EMR emr;
     *     DWORD ihObject;
     * } *PEMRDELETEOBJECT
     * }
     */
    public static final AddressLayout PEMRDELETEOBJECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     * } *PEMRSELECTPALETTE
     * }
     */
    public static final AddressLayout PEMRSELECTPALETTE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRRESIZEPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     *     DWORD cEntries;
     * } *PEMRRESIZEPALETTE
     * }
     */
    public static final AddressLayout PEMRRESIZEPALETTE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETPALETTEENTRIES {
     *     EMR emr;
     *     DWORD ihPal;
     *     DWORD iStart;
     *     DWORD cEntries;
     *     PALETTEENTRY aPalEntries[1];
     * } *PEMRSETPALETTEENTRIES
     * }
     */
    public static final AddressLayout PEMRSETPALETTEENTRIES = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORADJUSTMENT {
     *     EMR emr;
     *     COLORADJUSTMENT ColorAdjustment;
     * } *PEMRSETCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout PEMRSETCOLORADJUSTMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGDICOMMENT {
     *     EMR emr;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGDICOMMENT
     * }
     */
    public static final AddressLayout PEMRGDICOMMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREOF {
     *     EMR emr;
     *     DWORD nPalEntries;
     *     DWORD offPalEntries;
     *     DWORD nSizeLast;
     * } *PEMREOF
     * }
     */
    public static final AddressLayout PEMREOF = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRLINETO {
     *     EMR emr;
     *     POINTL ptl;
     * } *PEMRLINETO
     * }
     */
    public static final AddressLayout PEMRLINETO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRLINETO {
     *     EMR emr;
     *     POINTL ptl;
     * } *PEMRMOVETOEX
     * }
     */
    public static final AddressLayout PEMRMOVETOEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMROFFSETCLIPRGN {
     *     EMR emr;
     *     POINTL ptlOffset;
     * } *PEMROFFSETCLIPRGN
     * }
     */
    public static final AddressLayout PEMROFFSETCLIPRGN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRFILLPATH
     * }
     */
    public static final AddressLayout PEMRFILLPATH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRSTROKEANDFILLPATH
     * }
     */
    public static final AddressLayout PEMRSTROKEANDFILLPATH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRSTROKEPATH
     * }
     */
    public static final AddressLayout PEMRSTROKEPATH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXCLUDECLIPRECT {
     *     EMR emr;
     *     RECTL rclClip;
     * } *PEMREXCLUDECLIPRECT
     * }
     */
    public static final AddressLayout PEMREXCLUDECLIPRECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXCLUDECLIPRECT {
     *     EMR emr;
     *     RECTL rclClip;
     * } *PEMRINTERSECTCLIPRECT
     * }
     */
    public static final AddressLayout PEMRINTERSECTCLIPRECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETVIEWPORTORGEX
     * }
     */
    public static final AddressLayout PEMRSETVIEWPORTORGEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETWINDOWORGEX
     * }
     */
    public static final AddressLayout PEMRSETWINDOWORGEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETBRUSHORGEX
     * }
     */
    public static final AddressLayout PEMRSETBRUSHORGEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTEXTEX {
     *     EMR emr;
     *     SIZEL szlExtent;
     * } *PEMRSETVIEWPORTEXTEX
     * }
     */
    public static final AddressLayout PEMRSETVIEWPORTEXTEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTEXTEX {
     *     EMR emr;
     *     SIZEL szlExtent;
     * } *PEMRSETWINDOWEXTEX
     * }
     */
    public static final AddressLayout PEMRSETWINDOWEXTEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSCALEVIEWPORTEXTEX {
     *     EMR emr;
     *     LONG xNum;
     *     LONG xDenom;
     *     LONG yNum;
     *     LONG yDenom;
     * } *PEMRSCALEVIEWPORTEXTEX
     * }
     */
    public static final AddressLayout PEMRSCALEVIEWPORTEXTEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSCALEVIEWPORTEXTEX {
     *     EMR emr;
     *     LONG xNum;
     *     LONG xDenom;
     *     LONG yNum;
     *     LONG yDenom;
     * } *PEMRSCALEWINDOWEXTEX
     * }
     */
    public static final AddressLayout PEMRSCALEWINDOWEXTEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETWORLDTRANSFORM {
     *     EMR emr;
     *     XFORM xform;
     * } *PEMRSETWORLDTRANSFORM
     * }
     */
    public static final AddressLayout PEMRSETWORLDTRANSFORM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRMODIFYWORLDTRANSFORM {
     *     EMR emr;
     *     XFORM xform;
     *     DWORD iMode;
     * } *PEMRMODIFYWORLDTRANSFORM
     * }
     */
    public static final AddressLayout PEMRMODIFYWORLDTRANSFORM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETPIXELV {
     *     EMR emr;
     *     POINTL ptlPixel;
     *     COLORREF crColor;
     * } *PEMRSETPIXELV
     * }
     */
    public static final AddressLayout PEMRSETPIXELV = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTFLOODFILL {
     *     EMR emr;
     *     POINTL ptlStart;
     *     COLORREF crColor;
     *     DWORD iMode;
     * } *PEMREXTFLOODFILL
     * }
     */
    public static final AddressLayout PEMREXTFLOODFILL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRELLIPSE {
     *     EMR emr;
     *     RECTL rclBox;
     * } *PEMRELLIPSE
     * }
     */
    public static final AddressLayout PEMRELLIPSE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRELLIPSE {
     *     EMR emr;
     *     RECTL rclBox;
     * } *PEMRRECTANGLE
     * }
     */
    public static final AddressLayout PEMRRECTANGLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRROUNDRECT {
     *     EMR emr;
     *     RECTL rclBox;
     *     SIZEL szlCorner;
     * } *PEMRROUNDRECT
     * }
     */
    public static final AddressLayout PEMRROUNDRECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRARC
     * }
     */
    public static final AddressLayout PEMRARC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRARCTO
     * }
     */
    public static final AddressLayout PEMRARCTO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRCHORD
     * }
     */
    public static final AddressLayout PEMRCHORD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRPIE
     * }
     */
    public static final AddressLayout PEMRPIE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRANGLEARC {
     *     EMR emr;
     *     POINTL ptlCenter;
     *     DWORD nRadius;
     *     FLOAT eStartAngle;
     *     FLOAT eSweepAngle;
     * } *PEMRANGLEARC
     * }
     */
    public static final AddressLayout PEMRANGLEARC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYLINE
     * }
     */
    public static final AddressLayout PEMRPOLYLINE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYBEZIER
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYGON
     * }
     */
    public static final AddressLayout PEMRPOLYGON = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYBEZIERTO
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIERTO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYLINETO
     * }
     */
    public static final AddressLayout PEMRPOLYLINETO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYLINE16
     * }
     */
    public static final AddressLayout PEMRPOLYLINE16 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYBEZIER16
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIER16 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYGON16
     * }
     */
    public static final AddressLayout PEMRPOLYGON16 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYBEZIERTO16
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIERTO16 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYLINETO16
     * }
     */
    public static final AddressLayout PEMRPOLYLINETO16 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYDRAW {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     *     BYTE abTypes[1];
     * } *PEMRPOLYDRAW
     * }
     */
    public static final AddressLayout PEMRPOLYDRAW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYDRAW16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     *     BYTE abTypes[1];
     * } *PEMRPOLYDRAW16
     * }
     */
    public static final AddressLayout PEMRPOLYDRAW16 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cptl;
     *     DWORD aPolyCounts[1];
     *     POINTL aptl[1];
     * } *PEMRPOLYPOLYLINE
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYLINE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cptl;
     *     DWORD aPolyCounts[1];
     *     POINTL aptl[1];
     * } *PEMRPOLYPOLYGON
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYGON = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cpts;
     *     DWORD aPolyCounts[1];
     *     POINTS apts[1];
     * } *PEMRPOLYPOLYLINE16
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYLINE16 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cpts;
     *     DWORD aPolyCounts[1];
     *     POINTS apts[1];
     * } *PEMRPOLYPOLYGON16
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYGON16 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRINVERTRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     BYTE RgnData[1];
     * } *PEMRINVERTRGN
     * }
     */
    public static final AddressLayout PEMRINVERTRGN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRINVERTRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     BYTE RgnData[1];
     * } *PEMRPAINTRGN
     * }
     */
    public static final AddressLayout PEMRPAINTRGN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     DWORD ihBrush;
     *     BYTE RgnData[1];
     * } *PEMRFILLRGN
     * }
     */
    public static final AddressLayout PEMRFILLRGN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFRAMERGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     DWORD ihBrush;
     *     SIZEL szlStroke;
     *     BYTE RgnData[1];
     * } *PEMRFRAMERGN
     * }
     */
    public static final AddressLayout PEMRFRAMERGN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTSELECTCLIPRGN {
     *     EMR emr;
     *     DWORD cbRgnData;
     *     DWORD iMode;
     *     BYTE RgnData[1];
     * } *PEMREXTSELECTCLIPRGN
     * }
     */
    public static final AddressLayout PEMREXTSELECTCLIPRGN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     EMRTEXT emrtext;
     * } *PEMREXTTEXTOUTA
     * }
     */
    public static final AddressLayout PEMREXTTEXTOUTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     EMRTEXT emrtext;
     * } *PEMREXTTEXTOUTW
     * }
     */
    public static final AddressLayout PEMREXTTEXTOUTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     LONG cStrings;
     *     EMRTEXT aemrtext[1];
     * } *PEMRPOLYTEXTOUTA
     * }
     */
    public static final AddressLayout PEMRPOLYTEXTOUTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     LONG cStrings;
     *     EMRTEXT aemrtext[1];
     * } *PEMRPOLYTEXTOUTW
     * }
     */
    public static final AddressLayout PEMRPOLYTEXTOUTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRBITBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     * } *PEMRBITBLT
     * }
     */
    public static final AddressLayout PEMRBITBLT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSTRETCHBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRSTRETCHBLT
     * }
     */
    public static final AddressLayout PEMRSTRETCHBLT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRMASKBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG xMask;
     *     LONG yMask;
     *     DWORD iUsageMask;
     *     DWORD offBmiMask;
     *     DWORD cbBmiMask;
     *     DWORD offBitsMask;
     *     DWORD cbBitsMask;
     * } *PEMRMASKBLT
     * }
     */
    public static final AddressLayout PEMRMASKBLT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPLGBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     POINTL aptlDest[3];
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG xMask;
     *     LONG yMask;
     *     DWORD iUsageMask;
     *     DWORD offBmiMask;
     *     DWORD cbBmiMask;
     *     DWORD offBitsMask;
     *     DWORD cbBitsMask;
     * } *PEMRPLGBLT
     * }
     */
    public static final AddressLayout PEMRPLGBLT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETDIBITSTODEVICE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     DWORD iUsageSrc;
     *     DWORD iStartScan;
     *     DWORD cScans;
     * } *PEMRSETDIBITSTODEVICE
     * }
     */
    public static final AddressLayout PEMRSETDIBITSTODEVICE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSTRETCHDIBITS {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     DWORD iUsageSrc;
     *     DWORD dwRop;
     *     LONG cxDest;
     *     LONG cyDest;
     * } *PEMRSTRETCHDIBITS
     * }
     */
    public static final AddressLayout PEMRSTRETCHDIBITS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTCREATEFONTINDIRECTW {
     *     EMR emr;
     *     DWORD ihFont;
     *     EXTLOGFONTW elfw;
     * } *PEMREXTCREATEFONTINDIRECTW
     * }
     */
    public static final AddressLayout PEMREXTCREATEFONTINDIRECTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     *     LOGPALETTE lgpl;
     * } *PEMRCREATEPALETTE
     * }
     */
    public static final AddressLayout PEMRCREATEPALETTE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEPEN {
     *     EMR emr;
     *     DWORD ihPen;
     *     LOGPEN lopn;
     * } *PEMRCREATEPEN
     * }
     */
    public static final AddressLayout PEMRCREATEPEN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTCREATEPEN {
     *     EMR emr;
     *     DWORD ihPen;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     *     EXTLOGPEN32 elp;
     * } *PEMREXTCREATEPEN
     * }
     */
    public static final AddressLayout PEMREXTCREATEPEN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEBRUSHINDIRECT {
     *     EMR emr;
     *     DWORD ihBrush;
     *     LOGBRUSH32 lb;
     * } *PEMRCREATEBRUSHINDIRECT
     * }
     */
    public static final AddressLayout PEMRCREATEBRUSHINDIRECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEMONOBRUSH {
     *     EMR emr;
     *     DWORD ihBrush;
     *     DWORD iUsage;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     * } *PEMRCREATEMONOBRUSH
     * }
     */
    public static final AddressLayout PEMRCREATEMONOBRUSH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEDIBPATTERNBRUSHPT {
     *     EMR emr;
     *     DWORD ihBrush;
     *     DWORD iUsage;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     * } *PEMRCREATEDIBPATTERNBRUSHPT
     * }
     */
    public static final AddressLayout PEMRCREATEDIBPATTERNBRUSHPT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFORMAT {
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD cbData;
     *     DWORD offData;
     * } *PEMRFORMAT
     * }
     */
    public static final AddressLayout PEMRFORMAT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGLSRECORD {
     *     EMR emr;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGLSRECORD
     * }
     */
    public static final AddressLayout PEMRGLSRECORD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGLSBOUNDEDRECORD {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGLSBOUNDEDRECORD
     * }
     */
    public static final AddressLayout PEMRGLSBOUNDEDRECORD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPIXELFORMAT {
     *     EMR emr;
     *     PIXELFORMATDESCRIPTOR pfd;
     * } *PEMRPIXELFORMAT
     * }
     */
    public static final AddressLayout PEMRPIXELFORMAT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATECOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     *     LOGCOLORSPACEA lcs;
     * } *PEMRCREATECOLORSPACE
     * }
     */
    public static final AddressLayout PEMRCREATECOLORSPACE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRSETCOLORSPACE
     * }
     */
    public static final AddressLayout PEMRSETCOLORSPACE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRSELECTCOLORSPACE
     * }
     */
    public static final AddressLayout PEMRSELECTCOLORSPACE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRDELETECOLORSPACE
     * }
     */
    public static final AddressLayout PEMRDELETECOLORSPACE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMREXTESCAPE
     * }
     */
    public static final AddressLayout PEMREXTESCAPE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMRDRAWESCAPE
     * }
     */
    public static final AddressLayout PEMRDRAWESCAPE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRNAMEDESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbDriver;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMRNAMEDESCAPE
     * }
     */
    public static final AddressLayout PEMRNAMEDESCAPE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILE
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILEA
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILEW
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATECOLORSPACEW {
     *     EMR emr;
     *     DWORD ihCS;
     *     LOGCOLORSPACEW lcs;
     *     DWORD dwFlags;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRCREATECOLORSPACEW
     * }
     */
    public static final AddressLayout PEMRCREATECOLORSPACEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORMATCHTOTARGET {
     *     EMR emr;
     *     DWORD dwAction;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRCOLORMATCHTOTARGET
     * }
     */
    public static final AddressLayout PEMRCOLORMATCHTOTARGET = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORCORRECTPALETTE {
     *     EMR emr;
     *     DWORD ihPalette;
     *     DWORD nFirstEntry;
     *     DWORD nPalEntries;
     *     DWORD nReserved;
     * } *PEMRCOLORCORRECTPALETTE
     * }
     */
    public static final AddressLayout PEMRCOLORCORRECTPALETTE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRALPHABLEND {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRALPHABLEND
     * }
     */
    public static final AddressLayout PEMRALPHABLEND = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGRADIENTFILL {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nVer;
     *     DWORD nTri;
     *     ULONG ulMode;
     *     TRIVERTEX Ver[1];
     * } *PEMRGRADIENTFILL
     * }
     */
    public static final AddressLayout PEMRGRADIENTFILL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRTRANSPARENTBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRTRANSPARENTBLT
     * }
     */
    public static final AddressLayout PEMRTRANSPARENTBLT = wgl_h.C_POINTER;

    private static class wglCopyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglCopyContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static FunctionDescriptor wglCopyContext$descriptor() {
        return wglCopyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static MethodHandle wglCopyContext$handle() {
        return wglCopyContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static MemorySegment wglCopyContext$address() {
        return wglCopyContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static int wglCopyContext(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wglCopyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCopyContext", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglCreateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static FunctionDescriptor wglCreateContext$descriptor() {
        return wglCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static MethodHandle wglCreateContext$handle() {
        return wglCreateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static MemorySegment wglCreateContext$address() {
        return wglCreateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static MemorySegment wglCreateContext(MemorySegment x0) {
        var mh$ = wglCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCreateContext", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglCreateLayerContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglCreateLayerContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static FunctionDescriptor wglCreateLayerContext$descriptor() {
        return wglCreateLayerContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static MethodHandle wglCreateLayerContext$handle() {
        return wglCreateLayerContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static MemorySegment wglCreateLayerContext$address() {
        return wglCreateLayerContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static MemorySegment wglCreateLayerContext(MemorySegment x0, int x1) {
        var mh$ = wglCreateLayerContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCreateLayerContext", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglDeleteContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglDeleteContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static FunctionDescriptor wglDeleteContext$descriptor() {
        return wglDeleteContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static MethodHandle wglDeleteContext$handle() {
        return wglDeleteContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static MemorySegment wglDeleteContext$address() {
        return wglDeleteContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static int wglDeleteContext(MemorySegment x0) {
        var mh$ = wglDeleteContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglDeleteContext", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetCurrentContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglGetCurrentContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static FunctionDescriptor wglGetCurrentContext$descriptor() {
        return wglGetCurrentContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static MethodHandle wglGetCurrentContext$handle() {
        return wglGetCurrentContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static MemorySegment wglGetCurrentContext$address() {
        return wglGetCurrentContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static MemorySegment wglGetCurrentContext() {
        var mh$ = wglGetCurrentContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetCurrentContext");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetCurrentDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglGetCurrentDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static FunctionDescriptor wglGetCurrentDC$descriptor() {
        return wglGetCurrentDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static MethodHandle wglGetCurrentDC$handle() {
        return wglGetCurrentDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static MemorySegment wglGetCurrentDC$address() {
        return wglGetCurrentDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static MemorySegment wglGetCurrentDC() {
        var mh$ = wglGetCurrentDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetCurrentDC");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglGetProcAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static FunctionDescriptor wglGetProcAddress$descriptor() {
        return wglGetProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static MethodHandle wglGetProcAddress$handle() {
        return wglGetProcAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static MemorySegment wglGetProcAddress$address() {
        return wglGetProcAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static MemorySegment wglGetProcAddress(MemorySegment x0) {
        var mh$ = wglGetProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetProcAddress", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglMakeCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglMakeCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static FunctionDescriptor wglMakeCurrent$descriptor() {
        return wglMakeCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static MethodHandle wglMakeCurrent$handle() {
        return wglMakeCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static MemorySegment wglMakeCurrent$address() {
        return wglMakeCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static int wglMakeCurrent(MemorySegment x0, MemorySegment x1) {
        var mh$ = wglMakeCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglMakeCurrent", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglShareLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglShareLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static FunctionDescriptor wglShareLists$descriptor() {
        return wglShareLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static MethodHandle wglShareLists$handle() {
        return wglShareLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static MemorySegment wglShareLists$address() {
        return wglShareLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static int wglShareLists(MemorySegment x0, MemorySegment x1) {
        var mh$ = wglShareLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglShareLists", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontBitmapsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglUseFontBitmapsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static FunctionDescriptor wglUseFontBitmapsA$descriptor() {
        return wglUseFontBitmapsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MethodHandle wglUseFontBitmapsA$handle() {
        return wglUseFontBitmapsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MemorySegment wglUseFontBitmapsA$address() {
        return wglUseFontBitmapsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static int wglUseFontBitmapsA(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = wglUseFontBitmapsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontBitmapsA", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontBitmapsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglUseFontBitmapsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static FunctionDescriptor wglUseFontBitmapsW$descriptor() {
        return wglUseFontBitmapsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MethodHandle wglUseFontBitmapsW$handle() {
        return wglUseFontBitmapsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MemorySegment wglUseFontBitmapsW$address() {
        return wglUseFontBitmapsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static int wglUseFontBitmapsW(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = wglUseFontBitmapsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontBitmapsW", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwapBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SwapBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static FunctionDescriptor SwapBuffers$descriptor() {
        return SwapBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static MethodHandle SwapBuffers$handle() {
        return SwapBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static MemorySegment SwapBuffers$address() {
        return SwapBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static int SwapBuffers(MemorySegment x0) {
        var mh$ = SwapBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwapBuffers", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _POINTFLOAT {
     *     FLOAT x;
     *     FLOAT y;
     * } *PPOINTFLOAT
     * }
     */
    public static final AddressLayout PPOINTFLOAT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICSFLOAT {
     *     FLOAT gmfBlackBoxX;
     *     FLOAT gmfBlackBoxY;
     *     POINTFLOAT gmfptGlyphOrigin;
     *     FLOAT gmfCellIncX;
     *     FLOAT gmfCellIncY;
     * } *PGLYPHMETRICSFLOAT
     * }
     */
    public static final AddressLayout PGLYPHMETRICSFLOAT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICSFLOAT {
     *     FLOAT gmfBlackBoxX;
     *     FLOAT gmfBlackBoxY;
     *     POINTFLOAT gmfptGlyphOrigin;
     *     FLOAT gmfCellIncX;
     *     FLOAT gmfCellIncY;
     * } *LPGLYPHMETRICSFLOAT
     * }
     */
    public static final AddressLayout LPGLYPHMETRICSFLOAT = wgl_h.C_POINTER;

    private static class wglUseFontOutlinesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglUseFontOutlinesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static FunctionDescriptor wglUseFontOutlinesA$descriptor() {
        return wglUseFontOutlinesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MethodHandle wglUseFontOutlinesA$handle() {
        return wglUseFontOutlinesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MemorySegment wglUseFontOutlinesA$address() {
        return wglUseFontOutlinesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static int wglUseFontOutlinesA(MemorySegment x0, int x1, int x2, int x3, float x4, float x5, int x6, MemorySegment x7) {
        var mh$ = wglUseFontOutlinesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontOutlinesA", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontOutlinesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglUseFontOutlinesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static FunctionDescriptor wglUseFontOutlinesW$descriptor() {
        return wglUseFontOutlinesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MethodHandle wglUseFontOutlinesW$handle() {
        return wglUseFontOutlinesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MemorySegment wglUseFontOutlinesW$address() {
        return wglUseFontOutlinesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static int wglUseFontOutlinesW(MemorySegment x0, int x1, int x2, int x3, float x4, float x5, int x6, MemorySegment x7) {
        var mh$ = wglUseFontOutlinesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontOutlinesW", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagLAYERPLANEDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerPlane;
     *     BYTE bReserved;
     *     COLORREF crTransparent;
     * } *PLAYERPLANEDESCRIPTOR
     * }
     */
    public static final AddressLayout PLAYERPLANEDESCRIPTOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLAYERPLANEDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerPlane;
     *     BYTE bReserved;
     *     COLORREF crTransparent;
     * } *LPLAYERPLANEDESCRIPTOR
     * }
     */
    public static final AddressLayout LPLAYERPLANEDESCRIPTOR = wgl_h.C_POINTER;

    private static class wglDescribeLayerPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglDescribeLayerPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static FunctionDescriptor wglDescribeLayerPlane$descriptor() {
        return wglDescribeLayerPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static MethodHandle wglDescribeLayerPlane$handle() {
        return wglDescribeLayerPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static MemorySegment wglDescribeLayerPlane$address() {
        return wglDescribeLayerPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static int wglDescribeLayerPlane(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglDescribeLayerPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglDescribeLayerPlane", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglSetLayerPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglSetLayerPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static FunctionDescriptor wglSetLayerPaletteEntries$descriptor() {
        return wglSetLayerPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static MethodHandle wglSetLayerPaletteEntries$handle() {
        return wglSetLayerPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static MemorySegment wglSetLayerPaletteEntries$address() {
        return wglSetLayerPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static int wglSetLayerPaletteEntries(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglSetLayerPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSetLayerPaletteEntries", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetLayerPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglGetLayerPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static FunctionDescriptor wglGetLayerPaletteEntries$descriptor() {
        return wglGetLayerPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static MethodHandle wglGetLayerPaletteEntries$handle() {
        return wglGetLayerPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static MemorySegment wglGetLayerPaletteEntries$address() {
        return wglGetLayerPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static int wglGetLayerPaletteEntries(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglGetLayerPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetLayerPaletteEntries", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglRealizeLayerPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglRealizeLayerPalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static FunctionDescriptor wglRealizeLayerPalette$descriptor() {
        return wglRealizeLayerPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static MethodHandle wglRealizeLayerPalette$handle() {
        return wglRealizeLayerPalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static MemorySegment wglRealizeLayerPalette$address() {
        return wglRealizeLayerPalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static int wglRealizeLayerPalette(MemorySegment x0, int x1, int x2) {
        var mh$ = wglRealizeLayerPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglRealizeLayerPalette", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglSwapLayerBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglSwapLayerBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static FunctionDescriptor wglSwapLayerBuffers$descriptor() {
        return wglSwapLayerBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static MethodHandle wglSwapLayerBuffers$handle() {
        return wglSwapLayerBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static MemorySegment wglSwapLayerBuffers$address() {
        return wglSwapLayerBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static int wglSwapLayerBuffers(MemorySegment x0, int x1) {
        var mh$ = wglSwapLayerBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSwapLayerBuffers", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WGLSWAP {
     *     HDC hdc;
     *     UINT uiFlags;
     * } *PWGLSWAP
     * }
     */
    public static final AddressLayout PWGLSWAP = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WGLSWAP {
     *     HDC hdc;
     *     UINT uiFlags;
     * } *LPWGLSWAP
     * }
     */
    public static final AddressLayout LPWGLSWAP = wgl_h.C_POINTER;

    private static class wglSwapMultipleBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wglSwapMultipleBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static FunctionDescriptor wglSwapMultipleBuffers$descriptor() {
        return wglSwapMultipleBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static MethodHandle wglSwapMultipleBuffers$handle() {
        return wglSwapMultipleBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static MemorySegment wglSwapMultipleBuffers$address() {
        return wglSwapMultipleBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static int wglSwapMultipleBuffers(int x0, MemorySegment x1) {
        var mh$ = wglSwapMultipleBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSwapMultipleBuffers", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef HANDLE HDWP
     * }
     */
    public static final AddressLayout HDWP = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID LPMENUTEMPLATEA
     * }
     */
    public static final AddressLayout LPMENUTEMPLATEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID LPMENUTEMPLATEW
     * }
     */
    public static final AddressLayout LPMENUTEMPLATEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMENUTEMPLATEA LPMENUTEMPLATE
     * }
     */
    public static final AddressLayout LPMENUTEMPLATE = wgl_h.C_POINTER;

    private static class wvsprintfA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wvsprintfA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static FunctionDescriptor wvsprintfA$descriptor() {
        return wvsprintfA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static MethodHandle wvsprintfA$handle() {
        return wvsprintfA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static MemorySegment wvsprintfA$address() {
        return wvsprintfA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static int wvsprintfA(MemorySegment x0, MemorySegment x1, MemorySegment arglist) {
        var mh$ = wvsprintfA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wvsprintfA", x0, x1, arglist);
            }
            return (int)mh$.invokeExact(x0, x1, arglist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wvsprintfW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("wvsprintfW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static FunctionDescriptor wvsprintfW$descriptor() {
        return wvsprintfW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static MethodHandle wvsprintfW$handle() {
        return wvsprintfW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static MemorySegment wvsprintfW$address() {
        return wvsprintfW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static int wvsprintfW(MemorySegment x0, MemorySegment x1, MemorySegment arglist) {
        var mh$ = wvsprintfW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wvsprintfW", x0, x1, arglist);
            }
            return (int)mh$.invokeExact(x0, x1, arglist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wsprintfA(LPSTR, LPCSTR, ...)
     * }
     */
    public static class wsprintfA {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                wgl_h.C_INT,
                wgl_h.C_POINTER,
                wgl_h.C_POINTER
            );
        private static final MemorySegment ADDR = wgl_h.findOrThrow("wsprintfA");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wsprintfA(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wsprintfA(LPSTR, LPCSTR, ...)
         * }
         */
        public static wsprintfA makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wsprintfA(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wsprintfA", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wsprintfW(LPWSTR, LPCWSTR, ...)
     * }
     */
    public static class wsprintfW {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                wgl_h.C_INT,
                wgl_h.C_POINTER,
                wgl_h.C_POINTER
            );
        private static final MemorySegment ADDR = wgl_h.findOrThrow("wsprintfW");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wsprintfW(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wsprintfW(LPWSTR, LPCWSTR, ...)
         * }
         */
        public static wsprintfW makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wsprintfW(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wsprintfW", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCBT_CREATEWNDA {
     *     struct tagCREATESTRUCTA *lpcs;
     *     HWND hwndInsertAfter;
     * } *LPCBT_CREATEWNDA
     * }
     */
    public static final AddressLayout LPCBT_CREATEWNDA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCBT_CREATEWNDW {
     *     struct tagCREATESTRUCTW *lpcs;
     *     HWND hwndInsertAfter;
     * } *LPCBT_CREATEWNDW
     * }
     */
    public static final AddressLayout LPCBT_CREATEWNDW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCBT_CREATEWNDA LPCBT_CREATEWND
     * }
     */
    public static final AddressLayout LPCBT_CREATEWND = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCBTACTIVATESTRUCT {
     *     BOOL fMouse;
     *     HWND hWndActive;
     * } *LPCBTACTIVATESTRUCT
     * }
     */
    public static final AddressLayout LPCBTACTIVATESTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWTSSESSION_NOTIFICATION {
     *     DWORD cbSize;
     *     DWORD dwSessionId;
     * } *PWTSSESSION_NOTIFICATION
     * }
     */
    public static final AddressLayout PWTSSESSION_NOTIFICATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     HWND hwnd;
     *     RECT rc;
     * } *LPSHELLHOOKINFO
     * }
     */
    public static final AddressLayout LPSHELLHOOKINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *PEVENTMSGMSG
     * }
     */
    public static final AddressLayout PEVENTMSGMSG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *NPEVENTMSGMSG
     * }
     */
    public static final AddressLayout NPEVENTMSGMSG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *LPEVENTMSGMSG
     * }
     */
    public static final AddressLayout LPEVENTMSGMSG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *PEVENTMSG
     * }
     */
    public static final AddressLayout PEVENTMSG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *NPEVENTMSG
     * }
     */
    public static final AddressLayout NPEVENTMSG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *LPEVENTMSG
     * }
     */
    public static final AddressLayout LPEVENTMSG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *PCWPSTRUCT
     * }
     */
    public static final AddressLayout PCWPSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *NPCWPSTRUCT
     * }
     */
    public static final AddressLayout NPCWPSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *LPCWPSTRUCT
     * }
     */
    public static final AddressLayout LPCWPSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *PCWPRETSTRUCT
     * }
     */
    public static final AddressLayout PCWPRETSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *NPCWPRETSTRUCT
     * }
     */
    public static final AddressLayout NPCWPRETSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *LPCWPRETSTRUCT
     * }
     */
    public static final AddressLayout LPCWPRETSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKBDLLHOOKSTRUCT {
     *     DWORD vkCode;
     *     DWORD scanCode;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPKBDLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPKBDLLHOOKSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKBDLLHOOKSTRUCT {
     *     DWORD vkCode;
     *     DWORD scanCode;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PKBDLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout PKBDLLHOOKSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSLLHOOKSTRUCT {
     *     POINT pt;
     *     DWORD mouseData;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMSLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPMSLLHOOKSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSLLHOOKSTRUCT {
     *     POINT pt;
     *     DWORD mouseData;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PMSLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout PMSLLHOOKSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *PDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout PDEBUGHOOKINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *NPDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout NPDEBUGHOOKINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *LPDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout LPDEBUGHOOKINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCT {
     *     POINT pt;
     *     HWND hwnd;
     *     UINT wHitTestCode;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMOUSEHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPMOUSEHOOKSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCT {
     *     POINT pt;
     *     HWND hwnd;
     *     UINT wHitTestCode;
     *     ULONG_PTR dwExtraInfo;
     * } *PMOUSEHOOKSTRUCT
     * }
     */
    public static final AddressLayout PMOUSEHOOKSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCTEX {
     *     DWORD mouseData;
     * } *LPMOUSEHOOKSTRUCTEX
     * }
     */
    public static final AddressLayout LPMOUSEHOOKSTRUCTEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCTEX {
     *     DWORD mouseData;
     * } *PMOUSEHOOKSTRUCTEX
     * }
     */
    public static final AddressLayout PMOUSEHOOKSTRUCTEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREHOOKSTRUCT {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     * } *LPHARDWAREHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPHARDWAREHOOKSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREHOOKSTRUCT {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     * } *PHARDWAREHOOKSTRUCT
     * }
     */
    public static final AddressLayout PHARDWAREHOOKSTRUCT = wgl_h.C_POINTER;

    private static class LoadKeyboardLayoutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadKeyboardLayoutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static FunctionDescriptor LoadKeyboardLayoutA$descriptor() {
        return LoadKeyboardLayoutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static MethodHandle LoadKeyboardLayoutA$handle() {
        return LoadKeyboardLayoutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutA$address() {
        return LoadKeyboardLayoutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutA(MemorySegment pwszKLID, int Flags) {
        var mh$ = LoadKeyboardLayoutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadKeyboardLayoutA", pwszKLID, Flags);
            }
            return (MemorySegment)mh$.invokeExact(pwszKLID, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadKeyboardLayoutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadKeyboardLayoutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static FunctionDescriptor LoadKeyboardLayoutW$descriptor() {
        return LoadKeyboardLayoutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static MethodHandle LoadKeyboardLayoutW$handle() {
        return LoadKeyboardLayoutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutW$address() {
        return LoadKeyboardLayoutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutW(MemorySegment pwszKLID, int Flags) {
        var mh$ = LoadKeyboardLayoutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadKeyboardLayoutW", pwszKLID, Flags);
            }
            return (MemorySegment)mh$.invokeExact(pwszKLID, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ActivateKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ActivateKeyboardLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static FunctionDescriptor ActivateKeyboardLayout$descriptor() {
        return ActivateKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static MethodHandle ActivateKeyboardLayout$handle() {
        return ActivateKeyboardLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static MemorySegment ActivateKeyboardLayout$address() {
        return ActivateKeyboardLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static MemorySegment ActivateKeyboardLayout(MemorySegment hkl, int Flags) {
        var mh$ = ActivateKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ActivateKeyboardLayout", hkl, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hkl, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToUnicodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ToUnicodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor ToUnicodeEx$descriptor() {
        return ToUnicodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static MethodHandle ToUnicodeEx$handle() {
        return ToUnicodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static MemorySegment ToUnicodeEx$address() {
        return ToUnicodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static int ToUnicodeEx(int wVirtKey, int wScanCode, MemorySegment lpKeyState, MemorySegment pwszBuff, int cchBuff, int wFlags, MemorySegment dwhkl) {
        var mh$ = ToUnicodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToUnicodeEx", wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags, dwhkl);
            }
            return (int)mh$.invokeExact(wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnloadKeyboardLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static FunctionDescriptor UnloadKeyboardLayout$descriptor() {
        return UnloadKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static MethodHandle UnloadKeyboardLayout$handle() {
        return UnloadKeyboardLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static MemorySegment UnloadKeyboardLayout$address() {
        return UnloadKeyboardLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static int UnloadKeyboardLayout(MemorySegment hkl) {
        var mh$ = UnloadKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadKeyboardLayout", hkl);
            }
            return (int)mh$.invokeExact(hkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKeyboardLayoutNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutNameA$descriptor() {
        return GetKeyboardLayoutNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static MethodHandle GetKeyboardLayoutNameA$handle() {
        return GetKeyboardLayoutNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static MemorySegment GetKeyboardLayoutNameA$address() {
        return GetKeyboardLayoutNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static int GetKeyboardLayoutNameA(MemorySegment pwszKLID) {
        var mh$ = GetKeyboardLayoutNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutNameA", pwszKLID);
            }
            return (int)mh$.invokeExact(pwszKLID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKeyboardLayoutNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutNameW$descriptor() {
        return GetKeyboardLayoutNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static MethodHandle GetKeyboardLayoutNameW$handle() {
        return GetKeyboardLayoutNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static MemorySegment GetKeyboardLayoutNameW$address() {
        return GetKeyboardLayoutNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static int GetKeyboardLayoutNameW(MemorySegment pwszKLID) {
        var mh$ = GetKeyboardLayoutNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutNameW", pwszKLID);
            }
            return (int)mh$.invokeExact(pwszKLID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKeyboardLayoutList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutList$descriptor() {
        return GetKeyboardLayoutList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static MethodHandle GetKeyboardLayoutList$handle() {
        return GetKeyboardLayoutList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static MemorySegment GetKeyboardLayoutList$address() {
        return GetKeyboardLayoutList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static int GetKeyboardLayoutList(int nBuff, MemorySegment lpList) {
        var mh$ = GetKeyboardLayoutList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutList", nBuff, lpList);
            }
            return (int)mh$.invokeExact(nBuff, lpList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKeyboardLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayout$descriptor() {
        return GetKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static MethodHandle GetKeyboardLayout$handle() {
        return GetKeyboardLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static MemorySegment GetKeyboardLayout$address() {
        return GetKeyboardLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static MemorySegment GetKeyboardLayout(int idThread) {
        var mh$ = GetKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayout", idThread);
            }
            return (MemorySegment)mh$.invokeExact(idThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEMOVEPOINT {
     *     int x;
     *     int y;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PMOUSEMOVEPOINT
     * }
     */
    public static final AddressLayout PMOUSEMOVEPOINT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEMOVEPOINT {
     *     int x;
     *     int y;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMOUSEMOVEPOINT
     * }
     */
    public static final AddressLayout LPMOUSEMOVEPOINT = wgl_h.C_POINTER;

    private static class GetMouseMovePointsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMouseMovePointsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static FunctionDescriptor GetMouseMovePointsEx$descriptor() {
        return GetMouseMovePointsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static MethodHandle GetMouseMovePointsEx$handle() {
        return GetMouseMovePointsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static MemorySegment GetMouseMovePointsEx$address() {
        return GetMouseMovePointsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static int GetMouseMovePointsEx(int cbSize, MemorySegment lppt, MemorySegment lpptBuf, int nBufPoints, int resolution) {
        var mh$ = GetMouseMovePointsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMouseMovePointsEx", cbSize, lppt, lpptBuf, nBufPoints, resolution);
            }
            return (int)mh$.invokeExact(cbSize, lppt, lpptBuf, nBufPoints, resolution);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDesktopA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateDesktopA$descriptor() {
        return CreateDesktopA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateDesktopA$handle() {
        return CreateDesktopA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopA$address() {
        return CreateDesktopA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopA(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateDesktopA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopA", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDesktopW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateDesktopW$descriptor() {
        return CreateDesktopW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateDesktopW$handle() {
        return CreateDesktopW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopW$address() {
        return CreateDesktopW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopW(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateDesktopW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopW", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDesktopExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static FunctionDescriptor CreateDesktopExA$descriptor() {
        return CreateDesktopExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MethodHandle CreateDesktopExA$handle() {
        return CreateDesktopExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExA$address() {
        return CreateDesktopExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExA(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa, int ulHeapSize, MemorySegment pvoid) {
        var mh$ = CreateDesktopExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopExA", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDesktopExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static FunctionDescriptor CreateDesktopExW$descriptor() {
        return CreateDesktopExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MethodHandle CreateDesktopExW$handle() {
        return CreateDesktopExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExW$address() {
        return CreateDesktopExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExW(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa, int ulHeapSize, MemorySegment pvoid) {
        var mh$ = CreateDesktopExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopExW", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenDesktopA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenDesktopA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenDesktopA$descriptor() {
        return OpenDesktopA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenDesktopA$handle() {
        return OpenDesktopA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopA$address() {
        return OpenDesktopA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopA(MemorySegment lpszDesktop, int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenDesktopA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenDesktopA", lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenDesktopW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenDesktopW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenDesktopW$descriptor() {
        return OpenDesktopW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenDesktopW$handle() {
        return OpenDesktopW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopW$address() {
        return OpenDesktopW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopW(MemorySegment lpszDesktop, int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenDesktopW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenDesktopW", lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenInputDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenInputDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenInputDesktop$descriptor() {
        return OpenInputDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenInputDesktop$handle() {
        return OpenInputDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenInputDesktop$address() {
        return OpenInputDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenInputDesktop(int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenInputDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenInputDesktop", dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumDesktopsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopsA$descriptor() {
        return EnumDesktopsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopsA$handle() {
        return EnumDesktopsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumDesktopsA$address() {
        return EnumDesktopsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumDesktopsA(MemorySegment hwinsta, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumDesktopsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopsA", hwinsta, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hwinsta, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumDesktopsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopsW$descriptor() {
        return EnumDesktopsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopsW$handle() {
        return EnumDesktopsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumDesktopsW$address() {
        return EnumDesktopsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumDesktopsW(MemorySegment hwinsta, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumDesktopsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopsW", hwinsta, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hwinsta, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumDesktopWindows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopWindows$descriptor() {
        return EnumDesktopWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopWindows$handle() {
        return EnumDesktopWindows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumDesktopWindows$address() {
        return EnumDesktopWindows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static int EnumDesktopWindows(MemorySegment hDesktop, MemorySegment lpfn, long lParam) {
        var mh$ = EnumDesktopWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopWindows", hDesktop, lpfn, lParam);
            }
            return (int)mh$.invokeExact(hDesktop, lpfn, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SwitchDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor SwitchDesktop$descriptor() {
        return SwitchDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle SwitchDesktop$handle() {
        return SwitchDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static MemorySegment SwitchDesktop$address() {
        return SwitchDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static int SwitchDesktop(MemorySegment hDesktop) {
        var mh$ = SwitchDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor SetThreadDesktop$descriptor() {
        return SetThreadDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle SetThreadDesktop$handle() {
        return SetThreadDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static MemorySegment SetThreadDesktop$address() {
        return SetThreadDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static int SetThreadDesktop(MemorySegment hDesktop) {
        var mh$ = SetThreadDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor CloseDesktop$descriptor() {
        return CloseDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle CloseDesktop$handle() {
        return CloseDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static MemorySegment CloseDesktop$address() {
        return CloseDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static int CloseDesktop(MemorySegment hDesktop) {
        var mh$ = CloseDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static FunctionDescriptor GetThreadDesktop$descriptor() {
        return GetThreadDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static MethodHandle GetThreadDesktop$handle() {
        return GetThreadDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static MemorySegment GetThreadDesktop$address() {
        return GetThreadDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static MemorySegment GetThreadDesktop(int dwThreadId) {
        var mh$ = GetThreadDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadDesktop", dwThreadId);
            }
            return (MemorySegment)mh$.invokeExact(dwThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowStationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateWindowStationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateWindowStationA$descriptor() {
        return CreateWindowStationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateWindowStationA$handle() {
        return CreateWindowStationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationA$address() {
        return CreateWindowStationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationA(MemorySegment lpwinsta, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateWindowStationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowStationA", lpwinsta, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpwinsta, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowStationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateWindowStationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateWindowStationW$descriptor() {
        return CreateWindowStationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateWindowStationW$handle() {
        return CreateWindowStationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationW$address() {
        return CreateWindowStationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationW(MemorySegment lpwinsta, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateWindowStationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowStationW", lpwinsta, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpwinsta, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWindowStationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenWindowStationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenWindowStationA$descriptor() {
        return OpenWindowStationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenWindowStationA$handle() {
        return OpenWindowStationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationA$address() {
        return OpenWindowStationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationA(MemorySegment lpszWinSta, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenWindowStationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWindowStationA", lpszWinSta, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszWinSta, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWindowStationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenWindowStationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenWindowStationW$descriptor() {
        return OpenWindowStationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenWindowStationW$handle() {
        return OpenWindowStationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationW$address() {
        return OpenWindowStationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationW(MemorySegment lpszWinSta, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenWindowStationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWindowStationW", lpszWinSta, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszWinSta, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumWindowStationsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumWindowStationsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumWindowStationsA$descriptor() {
        return EnumWindowStationsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumWindowStationsA$handle() {
        return EnumWindowStationsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumWindowStationsA$address() {
        return EnumWindowStationsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumWindowStationsA(MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumWindowStationsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumWindowStationsA", lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumWindowStationsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumWindowStationsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumWindowStationsW$descriptor() {
        return EnumWindowStationsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumWindowStationsW$handle() {
        return EnumWindowStationsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumWindowStationsW$address() {
        return EnumWindowStationsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumWindowStationsW(MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumWindowStationsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumWindowStationsW", lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseWindowStation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static FunctionDescriptor CloseWindowStation$descriptor() {
        return CloseWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MethodHandle CloseWindowStation$handle() {
        return CloseWindowStation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MemorySegment CloseWindowStation$address() {
        return CloseWindowStation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static int CloseWindowStation(MemorySegment hWinSta) {
        var mh$ = CloseWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseWindowStation", hWinSta);
            }
            return (int)mh$.invokeExact(hWinSta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessWindowStation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static FunctionDescriptor SetProcessWindowStation$descriptor() {
        return SetProcessWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MethodHandle SetProcessWindowStation$handle() {
        return SetProcessWindowStation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MemorySegment SetProcessWindowStation$address() {
        return SetProcessWindowStation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static int SetProcessWindowStation(MemorySegment hWinSta) {
        var mh$ = SetProcessWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessWindowStation", hWinSta);
            }
            return (int)mh$.invokeExact(hWinSta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessWindowStation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static FunctionDescriptor GetProcessWindowStation$descriptor() {
        return GetProcessWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static MethodHandle GetProcessWindowStation$handle() {
        return GetProcessWindowStation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static MemorySegment GetProcessWindowStation$address() {
        return GetProcessWindowStation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static MemorySegment GetProcessWindowStation() {
        var mh$ = GetProcessWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessWindowStation");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetUserObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static FunctionDescriptor SetUserObjectSecurity$descriptor() {
        return SetUserObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static MethodHandle SetUserObjectSecurity$handle() {
        return SetUserObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static MemorySegment SetUserObjectSecurity$address() {
        return SetUserObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static int SetUserObjectSecurity(MemorySegment hObj, MemorySegment pSIRequested, MemorySegment pSID) {
        var mh$ = SetUserObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserObjectSecurity", hObj, pSIRequested, pSID);
            }
            return (int)mh$.invokeExact(hObj, pSIRequested, pSID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetUserObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectSecurity$descriptor() {
        return GetUserObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectSecurity$handle() {
        return GetUserObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetUserObjectSecurity$address() {
        return GetUserObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectSecurity(MemorySegment hObj, MemorySegment pSIRequested, MemorySegment pSID, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectSecurity", hObj, pSIRequested, pSID, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, pSIRequested, pSID, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagUSEROBJECTFLAGS {
     *     BOOL fInherit;
     *     BOOL fReserved;
     *     DWORD dwFlags;
     * } *PUSEROBJECTFLAGS
     * }
     */
    public static final AddressLayout PUSEROBJECTFLAGS = wgl_h.C_POINTER;

    private static class GetUserObjectInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetUserObjectInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectInformationA$descriptor() {
        return GetUserObjectInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectInformationA$handle() {
        return GetUserObjectInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetUserObjectInformationA$address() {
        return GetUserObjectInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectInformationA(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectInformationA", hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserObjectInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetUserObjectInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectInformationW$descriptor() {
        return GetUserObjectInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectInformationW$handle() {
        return GetUserObjectInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetUserObjectInformationW$address() {
        return GetUserObjectInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectInformationW(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectInformationW", hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserObjectInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetUserObjectInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static FunctionDescriptor SetUserObjectInformationA$descriptor() {
        return SetUserObjectInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MethodHandle SetUserObjectInformationA$handle() {
        return SetUserObjectInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MemorySegment SetUserObjectInformationA$address() {
        return SetUserObjectInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static int SetUserObjectInformationA(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength) {
        var mh$ = SetUserObjectInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserObjectInformationA", hObj, nIndex, pvInfo, nLength);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserObjectInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetUserObjectInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static FunctionDescriptor SetUserObjectInformationW$descriptor() {
        return SetUserObjectInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MethodHandle SetUserObjectInformationW$handle() {
        return SetUserObjectInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MemorySegment SetUserObjectInformationW$address() {
        return SetUserObjectInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static int SetUserObjectInformationW(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength) {
        var mh$ = SetUserObjectInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserObjectInformationW", hObj, nIndex, pvInfo, nLength);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXA {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     *     HICON hIconSm;
     * } *PWNDCLASSEXA
     * }
     */
    public static final AddressLayout PWNDCLASSEXA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXA {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     *     HICON hIconSm;
     * } *NPWNDCLASSEXA
     * }
     */
    public static final AddressLayout NPWNDCLASSEXA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXA {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     *     HICON hIconSm;
     * } *LPWNDCLASSEXA
     * }
     */
    public static final AddressLayout LPWNDCLASSEXA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXW {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     *     HICON hIconSm;
     * } *PWNDCLASSEXW
     * }
     */
    public static final AddressLayout PWNDCLASSEXW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXW {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     *     HICON hIconSm;
     * } *NPWNDCLASSEXW
     * }
     */
    public static final AddressLayout NPWNDCLASSEXW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXW {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     *     HICON hIconSm;
     * } *LPWNDCLASSEXW
     * }
     */
    public static final AddressLayout LPWNDCLASSEXW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWNDCLASSEXA PWNDCLASSEX
     * }
     */
    public static final AddressLayout PWNDCLASSEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPWNDCLASSEXA NPWNDCLASSEX
     * }
     */
    public static final AddressLayout NPWNDCLASSEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWNDCLASSEXA LPWNDCLASSEX
     * }
     */
    public static final AddressLayout LPWNDCLASSEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSA {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     * } *PWNDCLASSA
     * }
     */
    public static final AddressLayout PWNDCLASSA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSA {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     * } *NPWNDCLASSA
     * }
     */
    public static final AddressLayout NPWNDCLASSA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSA {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     * } *LPWNDCLASSA
     * }
     */
    public static final AddressLayout LPWNDCLASSA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSW {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     * } *PWNDCLASSW
     * }
     */
    public static final AddressLayout PWNDCLASSW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSW {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     * } *NPWNDCLASSW
     * }
     */
    public static final AddressLayout NPWNDCLASSW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSW {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     * } *LPWNDCLASSW
     * }
     */
    public static final AddressLayout LPWNDCLASSW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWNDCLASSA PWNDCLASS
     * }
     */
    public static final AddressLayout PWNDCLASS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPWNDCLASSA NPWNDCLASS
     * }
     */
    public static final AddressLayout NPWNDCLASS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWNDCLASSA LPWNDCLASS
     * }
     */
    public static final AddressLayout LPWNDCLASS = wgl_h.C_POINTER;

    private static class IsHungAppWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsHungAppWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsHungAppWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor IsHungAppWindow$descriptor() {
        return IsHungAppWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsHungAppWindow(HWND hwnd)
     * }
     */
    public static MethodHandle IsHungAppWindow$handle() {
        return IsHungAppWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsHungAppWindow(HWND hwnd)
     * }
     */
    public static MemorySegment IsHungAppWindow$address() {
        return IsHungAppWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsHungAppWindow(HWND hwnd)
     * }
     */
    public static int IsHungAppWindow(MemorySegment hwnd) {
        var mh$ = IsHungAppWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsHungAppWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisableProcessWindowsGhosting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DisableProcessWindowsGhosting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DisableProcessWindowsGhosting()
     * }
     */
    public static FunctionDescriptor DisableProcessWindowsGhosting$descriptor() {
        return DisableProcessWindowsGhosting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DisableProcessWindowsGhosting()
     * }
     */
    public static MethodHandle DisableProcessWindowsGhosting$handle() {
        return DisableProcessWindowsGhosting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DisableProcessWindowsGhosting()
     * }
     */
    public static MemorySegment DisableProcessWindowsGhosting$address() {
        return DisableProcessWindowsGhosting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DisableProcessWindowsGhosting()
     * }
     */
    public static void DisableProcessWindowsGhosting() {
        var mh$ = DisableProcessWindowsGhosting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableProcessWindowsGhosting");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMSG {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     *     DWORD time;
     *     POINT pt;
     * } *PMSG
     * }
     */
    public static final AddressLayout PMSG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSG {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     *     DWORD time;
     *     POINT pt;
     * } *NPMSG
     * }
     */
    public static final AddressLayout NPMSG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSG {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     *     DWORD time;
     *     POINT pt;
     * } *LPMSG
     * }
     */
    public static final AddressLayout LPMSG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMINMAXINFO {
     *     POINT ptReserved;
     *     POINT ptMaxSize;
     *     POINT ptMaxPosition;
     *     POINT ptMinTrackSize;
     *     POINT ptMaxTrackSize;
     * } *PMINMAXINFO
     * }
     */
    public static final AddressLayout PMINMAXINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMINMAXINFO {
     *     POINT ptReserved;
     *     POINT ptMaxSize;
     *     POINT ptMaxPosition;
     *     POINT ptMinTrackSize;
     *     POINT ptMaxTrackSize;
     * } *LPMINMAXINFO
     * }
     */
    public static final AddressLayout LPMINMAXINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOPYDATASTRUCT {
     *     ULONG_PTR dwData;
     *     DWORD cbData;
     *     PVOID lpData;
     * } *PCOPYDATASTRUCT
     * }
     */
    public static final AddressLayout PCOPYDATASTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMDINEXTMENU {
     *     HMENU hmenuIn;
     *     HMENU hmenuNext;
     *     HWND hwndNext;
     * } *PMDINEXTMENU
     * }
     */
    public static final AddressLayout PMDINEXTMENU = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMDINEXTMENU {
     *     HMENU hmenuIn;
     *     HMENU hmenuNext;
     *     HWND hwndNext;
     * } *LPMDINEXTMENU
     * }
     */
    public static final AddressLayout LPMDINEXTMENU = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     GUID PowerSetting;
     *     DWORD DataLength;
     *     UCHAR Data[1];
     * } *PPOWERBROADCAST_SETTING
     * }
     */
    public static final AddressLayout PPOWERBROADCAST_SETTING = wgl_h.C_POINTER;

    private static class RegisterWindowMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterWindowMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor RegisterWindowMessageA$descriptor() {
        return RegisterWindowMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageA(LPCSTR lpString)
     * }
     */
    public static MethodHandle RegisterWindowMessageA$handle() {
        return RegisterWindowMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageA(LPCSTR lpString)
     * }
     */
    public static MemorySegment RegisterWindowMessageA$address() {
        return RegisterWindowMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RegisterWindowMessageA(LPCSTR lpString)
     * }
     */
    public static int RegisterWindowMessageA(MemorySegment lpString) {
        var mh$ = RegisterWindowMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterWindowMessageA", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterWindowMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterWindowMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor RegisterWindowMessageW$descriptor() {
        return RegisterWindowMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle RegisterWindowMessageW$handle() {
        return RegisterWindowMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment RegisterWindowMessageW$address() {
        return RegisterWindowMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RegisterWindowMessageW(LPCWSTR lpString)
     * }
     */
    public static int RegisterWindowMessageW(MemorySegment lpString) {
        var mh$ = RegisterWindowMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterWindowMessageW", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWINDOWPOS {
     *     HWND hwnd;
     *     HWND hwndInsertAfter;
     *     int x;
     *     int y;
     *     int cx;
     *     int cy;
     *     UINT flags;
     * } *LPWINDOWPOS
     * }
     */
    public static final AddressLayout LPWINDOWPOS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWINDOWPOS {
     *     HWND hwnd;
     *     HWND hwndInsertAfter;
     *     int x;
     *     int y;
     *     int cx;
     *     int cy;
     *     UINT flags;
     * } *PWINDOWPOS
     * }
     */
    public static final AddressLayout PWINDOWPOS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNCCALCSIZE_PARAMS {
     *     RECT rgrc[3];
     *     PWINDOWPOS lppos;
     * } *LPNCCALCSIZE_PARAMS
     * }
     */
    public static final AddressLayout LPNCCALCSIZE_PARAMS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTRACKMOUSEEVENT {
     *     DWORD cbSize;
     *     DWORD dwFlags;
     *     HWND hwndTrack;
     *     DWORD dwHoverTime;
     * } *LPTRACKMOUSEEVENT
     * }
     */
    public static final AddressLayout LPTRACKMOUSEEVENT = wgl_h.C_POINTER;

    private static class TrackMouseEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TrackMouseEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
     * }
     */
    public static FunctionDescriptor TrackMouseEvent$descriptor() {
        return TrackMouseEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
     * }
     */
    public static MethodHandle TrackMouseEvent$handle() {
        return TrackMouseEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
     * }
     */
    public static MemorySegment TrackMouseEvent$address() {
        return TrackMouseEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
     * }
     */
    public static int TrackMouseEvent(MemorySegment lpEventTrack) {
        var mh$ = TrackMouseEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrackMouseEvent", lpEventTrack);
            }
            return (int)mh$.invokeExact(lpEventTrack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawEdge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawEdge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags)
     * }
     */
    public static FunctionDescriptor DrawEdge$descriptor() {
        return DrawEdge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags)
     * }
     */
    public static MethodHandle DrawEdge$handle() {
        return DrawEdge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags)
     * }
     */
    public static MemorySegment DrawEdge$address() {
        return DrawEdge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags)
     * }
     */
    public static int DrawEdge(MemorySegment hdc, MemorySegment qrc, int edge, int grfFlags) {
        var mh$ = DrawEdge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawEdge", hdc, qrc, edge, grfFlags);
            }
            return (int)mh$.invokeExact(hdc, qrc, edge, grfFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawFrameControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawFrameControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT)
     * }
     */
    public static FunctionDescriptor DrawFrameControl$descriptor() {
        return DrawFrameControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT)
     * }
     */
    public static MethodHandle DrawFrameControl$handle() {
        return DrawFrameControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT)
     * }
     */
    public static MemorySegment DrawFrameControl$address() {
        return DrawFrameControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT)
     * }
     */
    public static int DrawFrameControl(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = DrawFrameControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawFrameControl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCaption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawCaption");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawCaption(HWND hwnd, HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static FunctionDescriptor DrawCaption$descriptor() {
        return DrawCaption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawCaption(HWND hwnd, HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MethodHandle DrawCaption$handle() {
        return DrawCaption.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawCaption(HWND hwnd, HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MemorySegment DrawCaption$address() {
        return DrawCaption.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawCaption(HWND hwnd, HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static int DrawCaption(MemorySegment hwnd, MemorySegment hdc, MemorySegment lprect, int flags) {
        var mh$ = DrawCaption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCaption", hwnd, hdc, lprect, flags);
            }
            return (int)mh$.invokeExact(hwnd, hdc, lprect, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawAnimatedRects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawAnimatedRects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawAnimatedRects(HWND hwnd, int idAni, const RECT *lprcFrom, const RECT *lprcTo)
     * }
     */
    public static FunctionDescriptor DrawAnimatedRects$descriptor() {
        return DrawAnimatedRects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawAnimatedRects(HWND hwnd, int idAni, const RECT *lprcFrom, const RECT *lprcTo)
     * }
     */
    public static MethodHandle DrawAnimatedRects$handle() {
        return DrawAnimatedRects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawAnimatedRects(HWND hwnd, int idAni, const RECT *lprcFrom, const RECT *lprcTo)
     * }
     */
    public static MemorySegment DrawAnimatedRects$address() {
        return DrawAnimatedRects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawAnimatedRects(HWND hwnd, int idAni, const RECT *lprcFrom, const RECT *lprcTo)
     * }
     */
    public static int DrawAnimatedRects(MemorySegment hwnd, int idAni, MemorySegment lprcFrom, MemorySegment lprcTo) {
        var mh$ = DrawAnimatedRects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawAnimatedRects", hwnd, idAni, lprcFrom, lprcTo);
            }
            return (int)mh$.invokeExact(hwnd, idAni, lprcFrom, lprcTo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagACCEL {
     *     BYTE fVirt;
     *     WORD key;
     *     WORD cmd;
     * } *LPACCEL
     * }
     */
    public static final AddressLayout LPACCEL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPAINTSTRUCT {
     *     HDC hdc;
     *     BOOL fErase;
     *     RECT rcPaint;
     *     BOOL fRestore;
     *     BOOL fIncUpdate;
     *     BYTE rgbReserved[32];
     * } *PPAINTSTRUCT
     * }
     */
    public static final AddressLayout PPAINTSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPAINTSTRUCT {
     *     HDC hdc;
     *     BOOL fErase;
     *     RECT rcPaint;
     *     BOOL fRestore;
     *     BOOL fIncUpdate;
     *     BYTE rgbReserved[32];
     * } *NPPAINTSTRUCT
     * }
     */
    public static final AddressLayout NPPAINTSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPAINTSTRUCT {
     *     HDC hdc;
     *     BOOL fErase;
     *     RECT rcPaint;
     *     BOOL fRestore;
     *     BOOL fIncUpdate;
     *     BYTE rgbReserved[32];
     * } *LPPAINTSTRUCT
     * }
     */
    public static final AddressLayout LPPAINTSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCREATESTRUCTA {
     *     LPVOID lpCreateParams;
     *     HINSTANCE hInstance;
     *     HMENU hMenu;
     *     HWND hwndParent;
     *     int cy;
     *     int cx;
     *     int y;
     *     int x;
     *     LONG style;
     *     LPCSTR lpszName;
     *     LPCSTR lpszClass;
     *     DWORD dwExStyle;
     * } *LPCREATESTRUCTA
     * }
     */
    public static final AddressLayout LPCREATESTRUCTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCREATESTRUCTW {
     *     LPVOID lpCreateParams;
     *     HINSTANCE hInstance;
     *     HMENU hMenu;
     *     HWND hwndParent;
     *     int cy;
     *     int cx;
     *     int y;
     *     int x;
     *     LONG style;
     *     LPCWSTR lpszName;
     *     LPCWSTR lpszClass;
     *     DWORD dwExStyle;
     * } *LPCREATESTRUCTW
     * }
     */
    public static final AddressLayout LPCREATESTRUCTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCREATESTRUCTA LPCREATESTRUCT
     * }
     */
    public static final AddressLayout LPCREATESTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WINDOWPLACEMENT *PWINDOWPLACEMENT
     * }
     */
    public static final AddressLayout PWINDOWPLACEMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WINDOWPLACEMENT *LPWINDOWPLACEMENT
     * }
     */
    public static final AddressLayout LPWINDOWPLACEMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NMHDR *LPNMHDR
     * }
     */
    public static final AddressLayout LPNMHDR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLESTRUCT {
     *     DWORD styleOld;
     *     DWORD styleNew;
     * } *LPSTYLESTRUCT
     * }
     */
    public static final AddressLayout LPSTYLESTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMEASUREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemWidth;
     *     UINT itemHeight;
     *     ULONG_PTR itemData;
     * } *PMEASUREITEMSTRUCT
     * }
     */
    public static final AddressLayout PMEASUREITEMSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMEASUREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemWidth;
     *     UINT itemHeight;
     *     ULONG_PTR itemData;
     * } *LPMEASUREITEMSTRUCT
     * }
     */
    public static final AddressLayout LPMEASUREITEMSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDRAWITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemAction;
     *     UINT itemState;
     *     HWND hwndItem;
     *     HDC hDC;
     *     RECT rcItem;
     *     ULONG_PTR itemData;
     * } *PDRAWITEMSTRUCT
     * }
     */
    public static final AddressLayout PDRAWITEMSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDRAWITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemAction;
     *     UINT itemState;
     *     HWND hwndItem;
     *     HDC hDC;
     *     RECT rcItem;
     *     ULONG_PTR itemData;
     * } *LPDRAWITEMSTRUCT
     * }
     */
    public static final AddressLayout LPDRAWITEMSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDELETEITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     HWND hwndItem;
     *     ULONG_PTR itemData;
     * } *PDELETEITEMSTRUCT
     * }
     */
    public static final AddressLayout PDELETEITEMSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDELETEITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     HWND hwndItem;
     *     ULONG_PTR itemData;
     * } *LPDELETEITEMSTRUCT
     * }
     */
    public static final AddressLayout LPDELETEITEMSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPAREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     HWND hwndItem;
     *     UINT itemID1;
     *     ULONG_PTR itemData1;
     *     UINT itemID2;
     *     ULONG_PTR itemData2;
     *     DWORD dwLocaleId;
     * } *PCOMPAREITEMSTRUCT
     * }
     */
    public static final AddressLayout PCOMPAREITEMSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPAREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     HWND hwndItem;
     *     UINT itemID1;
     *     ULONG_PTR itemData1;
     *     UINT itemID2;
     *     ULONG_PTR itemData2;
     *     DWORD dwLocaleId;
     * } *LPCOMPAREITEMSTRUCT
     * }
     */
    public static final AddressLayout LPCOMPAREITEMSTRUCT = wgl_h.C_POINTER;

    private static class GetMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static FunctionDescriptor GetMessageA$descriptor() {
        return GetMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static MethodHandle GetMessageA$handle() {
        return GetMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static MemorySegment GetMessageA$address() {
        return GetMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static int GetMessageA(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax) {
        var mh$ = GetMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageA", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static FunctionDescriptor GetMessageW$descriptor() {
        return GetMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static MethodHandle GetMessageW$handle() {
        return GetMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static MemorySegment GetMessageW$address() {
        return GetMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static int GetMessageW(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax) {
        var mh$ = GetMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageW", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TranslateMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TranslateMessage(const MSG *lpMsg)
     * }
     */
    public static FunctionDescriptor TranslateMessage$descriptor() {
        return TranslateMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TranslateMessage(const MSG *lpMsg)
     * }
     */
    public static MethodHandle TranslateMessage$handle() {
        return TranslateMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TranslateMessage(const MSG *lpMsg)
     * }
     */
    public static MemorySegment TranslateMessage$address() {
        return TranslateMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TranslateMessage(const MSG *lpMsg)
     * }
     */
    public static int TranslateMessage(MemorySegment lpMsg) {
        var mh$ = TranslateMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateMessage", lpMsg);
            }
            return (int)mh$.invokeExact(lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DispatchMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DispatchMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageA(const MSG *lpMsg)
     * }
     */
    public static FunctionDescriptor DispatchMessageA$descriptor() {
        return DispatchMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageA(const MSG *lpMsg)
     * }
     */
    public static MethodHandle DispatchMessageA$handle() {
        return DispatchMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageA(const MSG *lpMsg)
     * }
     */
    public static MemorySegment DispatchMessageA$address() {
        return DispatchMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DispatchMessageA(const MSG *lpMsg)
     * }
     */
    public static long DispatchMessageA(MemorySegment lpMsg) {
        var mh$ = DispatchMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DispatchMessageA", lpMsg);
            }
            return (long)mh$.invokeExact(lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DispatchMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DispatchMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageW(const MSG *lpMsg)
     * }
     */
    public static FunctionDescriptor DispatchMessageW$descriptor() {
        return DispatchMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageW(const MSG *lpMsg)
     * }
     */
    public static MethodHandle DispatchMessageW$handle() {
        return DispatchMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageW(const MSG *lpMsg)
     * }
     */
    public static MemorySegment DispatchMessageW$address() {
        return DispatchMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DispatchMessageW(const MSG *lpMsg)
     * }
     */
    public static long DispatchMessageW(MemorySegment lpMsg) {
        var mh$ = DispatchMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DispatchMessageW", lpMsg);
            }
            return (long)mh$.invokeExact(lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMessageQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMessageQueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMessageQueue(int cMessagesMax)
     * }
     */
    public static FunctionDescriptor SetMessageQueue$descriptor() {
        return SetMessageQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMessageQueue(int cMessagesMax)
     * }
     */
    public static MethodHandle SetMessageQueue$handle() {
        return SetMessageQueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMessageQueue(int cMessagesMax)
     * }
     */
    public static MemorySegment SetMessageQueue$address() {
        return SetMessageQueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMessageQueue(int cMessagesMax)
     * }
     */
    public static int SetMessageQueue(int cMessagesMax) {
        var mh$ = SetMessageQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMessageQueue", cMessagesMax);
            }
            return (int)mh$.invokeExact(cMessagesMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PeekMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static FunctionDescriptor PeekMessageA$descriptor() {
        return PeekMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static MethodHandle PeekMessageA$handle() {
        return PeekMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static MemorySegment PeekMessageA$address() {
        return PeekMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static int PeekMessageA(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax, int wRemoveMsg) {
        var mh$ = PeekMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekMessageA", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PeekMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static FunctionDescriptor PeekMessageW$descriptor() {
        return PeekMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static MethodHandle PeekMessageW$handle() {
        return PeekMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static MemorySegment PeekMessageW$address() {
        return PeekMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static int PeekMessageW(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax, int wRemoveMsg) {
        var mh$ = PeekMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekMessageW", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterHotKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterHotKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk)
     * }
     */
    public static FunctionDescriptor RegisterHotKey$descriptor() {
        return RegisterHotKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk)
     * }
     */
    public static MethodHandle RegisterHotKey$handle() {
        return RegisterHotKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk)
     * }
     */
    public static MemorySegment RegisterHotKey$address() {
        return RegisterHotKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk)
     * }
     */
    public static int RegisterHotKey(MemorySegment hWnd, int id, int fsModifiers, int vk) {
        var mh$ = RegisterHotKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterHotKey", hWnd, id, fsModifiers, vk);
            }
            return (int)mh$.invokeExact(hWnd, id, fsModifiers, vk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterHotKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterHotKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterHotKey(HWND hWnd, int id)
     * }
     */
    public static FunctionDescriptor UnregisterHotKey$descriptor() {
        return UnregisterHotKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterHotKey(HWND hWnd, int id)
     * }
     */
    public static MethodHandle UnregisterHotKey$handle() {
        return UnregisterHotKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterHotKey(HWND hWnd, int id)
     * }
     */
    public static MemorySegment UnregisterHotKey$address() {
        return UnregisterHotKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterHotKey(HWND hWnd, int id)
     * }
     */
    public static int UnregisterHotKey(MemorySegment hWnd, int id) {
        var mh$ = UnregisterHotKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterHotKey", hWnd, id);
            }
            return (int)mh$.invokeExact(hWnd, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExitWindowsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExitWindowsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExitWindowsEx(UINT uFlags, DWORD dwReason)
     * }
     */
    public static FunctionDescriptor ExitWindowsEx$descriptor() {
        return ExitWindowsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExitWindowsEx(UINT uFlags, DWORD dwReason)
     * }
     */
    public static MethodHandle ExitWindowsEx$handle() {
        return ExitWindowsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExitWindowsEx(UINT uFlags, DWORD dwReason)
     * }
     */
    public static MemorySegment ExitWindowsEx$address() {
        return ExitWindowsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExitWindowsEx(UINT uFlags, DWORD dwReason)
     * }
     */
    public static int ExitWindowsEx(int uFlags, int dwReason) {
        var mh$ = ExitWindowsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExitWindowsEx", uFlags, dwReason);
            }
            return (int)mh$.invokeExact(uFlags, dwReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwapMouseButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SwapMouseButton");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwapMouseButton(BOOL fSwap)
     * }
     */
    public static FunctionDescriptor SwapMouseButton$descriptor() {
        return SwapMouseButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwapMouseButton(BOOL fSwap)
     * }
     */
    public static MethodHandle SwapMouseButton$handle() {
        return SwapMouseButton.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SwapMouseButton(BOOL fSwap)
     * }
     */
    public static MemorySegment SwapMouseButton$address() {
        return SwapMouseButton.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SwapMouseButton(BOOL fSwap)
     * }
     */
    public static int SwapMouseButton(int fSwap) {
        var mh$ = SwapMouseButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwapMouseButton", fSwap);
            }
            return (int)mh$.invokeExact(fSwap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessagePos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMessagePos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetMessagePos()
     * }
     */
    public static FunctionDescriptor GetMessagePos$descriptor() {
        return GetMessagePos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetMessagePos()
     * }
     */
    public static MethodHandle GetMessagePos$handle() {
        return GetMessagePos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetMessagePos()
     * }
     */
    public static MemorySegment GetMessagePos$address() {
        return GetMessagePos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetMessagePos()
     * }
     */
    public static int GetMessagePos() {
        var mh$ = GetMessagePos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessagePos");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessageTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMessageTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetMessageTime()
     * }
     */
    public static FunctionDescriptor GetMessageTime$descriptor() {
        return GetMessageTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetMessageTime()
     * }
     */
    public static MethodHandle GetMessageTime$handle() {
        return GetMessageTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG GetMessageTime()
     * }
     */
    public static MemorySegment GetMessageTime$address() {
        return GetMessageTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG GetMessageTime()
     * }
     */
    public static int GetMessageTime() {
        var mh$ = GetMessageTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageTime");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessageExtraInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMessageExtraInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPARAM GetMessageExtraInfo()
     * }
     */
    public static FunctionDescriptor GetMessageExtraInfo$descriptor() {
        return GetMessageExtraInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPARAM GetMessageExtraInfo()
     * }
     */
    public static MethodHandle GetMessageExtraInfo$handle() {
        return GetMessageExtraInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPARAM GetMessageExtraInfo()
     * }
     */
    public static MemorySegment GetMessageExtraInfo$address() {
        return GetMessageExtraInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPARAM GetMessageExtraInfo()
     * }
     */
    public static long GetMessageExtraInfo() {
        var mh$ = GetMessageExtraInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageExtraInfo");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUnpredictedMessagePos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetUnpredictedMessagePos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetUnpredictedMessagePos()
     * }
     */
    public static FunctionDescriptor GetUnpredictedMessagePos$descriptor() {
        return GetUnpredictedMessagePos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetUnpredictedMessagePos()
     * }
     */
    public static MethodHandle GetUnpredictedMessagePos$handle() {
        return GetUnpredictedMessagePos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetUnpredictedMessagePos()
     * }
     */
    public static MemorySegment GetUnpredictedMessagePos$address() {
        return GetUnpredictedMessagePos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetUnpredictedMessagePos()
     * }
     */
    public static int GetUnpredictedMessagePos() {
        var mh$ = GetUnpredictedMessagePos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUnpredictedMessagePos");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64Message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsWow64Message");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWow64Message()
     * }
     */
    public static FunctionDescriptor IsWow64Message$descriptor() {
        return IsWow64Message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWow64Message()
     * }
     */
    public static MethodHandle IsWow64Message$handle() {
        return IsWow64Message.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWow64Message()
     * }
     */
    public static MemorySegment IsWow64Message$address() {
        return IsWow64Message.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWow64Message()
     * }
     */
    public static int IsWow64Message() {
        var mh$ = IsWow64Message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64Message");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMessageExtraInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMessageExtraInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPARAM SetMessageExtraInfo(LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SetMessageExtraInfo$descriptor() {
        return SetMessageExtraInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPARAM SetMessageExtraInfo(LPARAM lParam)
     * }
     */
    public static MethodHandle SetMessageExtraInfo$handle() {
        return SetMessageExtraInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPARAM SetMessageExtraInfo(LPARAM lParam)
     * }
     */
    public static MemorySegment SetMessageExtraInfo$address() {
        return SetMessageExtraInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPARAM SetMessageExtraInfo(LPARAM lParam)
     * }
     */
    public static long SetMessageExtraInfo(long lParam) {
        var mh$ = SetMessageExtraInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMessageExtraInfo", lParam);
            }
            return (long)mh$.invokeExact(lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SendMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendMessageA$descriptor() {
        return SendMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendMessageA$handle() {
        return SendMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendMessageA$address() {
        return SendMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendMessageA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageA", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SendMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendMessageW$descriptor() {
        return SendMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendMessageW$handle() {
        return SendMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendMessageW$address() {
        return SendMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendMessageW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageW", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageTimeoutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SendMessageTimeoutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static FunctionDescriptor SendMessageTimeoutA$descriptor() {
        return SendMessageTimeoutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static MethodHandle SendMessageTimeoutA$handle() {
        return SendMessageTimeoutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static MemorySegment SendMessageTimeoutA$address() {
        return SendMessageTimeoutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static long SendMessageTimeoutA(MemorySegment hWnd, int Msg, long wParam, long lParam, int fuFlags, int uTimeout, MemorySegment lpdwResult) {
        var mh$ = SendMessageTimeoutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageTimeoutA", hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageTimeoutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SendMessageTimeoutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static FunctionDescriptor SendMessageTimeoutW$descriptor() {
        return SendMessageTimeoutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static MethodHandle SendMessageTimeoutW$handle() {
        return SendMessageTimeoutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static MemorySegment SendMessageTimeoutW$address() {
        return SendMessageTimeoutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static long SendMessageTimeoutW(MemorySegment hWnd, int Msg, long wParam, long lParam, int fuFlags, int uTimeout, MemorySegment lpdwResult) {
        var mh$ = SendMessageTimeoutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageTimeoutW", hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendNotifyMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SendNotifyMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendNotifyMessageA$descriptor() {
        return SendNotifyMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendNotifyMessageA$handle() {
        return SendNotifyMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendNotifyMessageA$address() {
        return SendNotifyMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int SendNotifyMessageA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendNotifyMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendNotifyMessageA", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendNotifyMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SendNotifyMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendNotifyMessageW$descriptor() {
        return SendNotifyMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendNotifyMessageW$handle() {
        return SendNotifyMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendNotifyMessageW$address() {
        return SendNotifyMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int SendNotifyMessageW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendNotifyMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendNotifyMessageW", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageCallbackA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SendMessageCallbackA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor SendMessageCallbackA$descriptor() {
        return SendMessageCallbackA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle SendMessageCallbackA$handle() {
        return SendMessageCallbackA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static MemorySegment SendMessageCallbackA$address() {
        return SendMessageCallbackA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static int SendMessageCallbackA(MemorySegment hWnd, int Msg, long wParam, long lParam, MemorySegment lpResultCallBack, long dwData) {
        var mh$ = SendMessageCallbackA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageCallbackA", hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageCallbackW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SendMessageCallbackW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor SendMessageCallbackW$descriptor() {
        return SendMessageCallbackW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle SendMessageCallbackW$handle() {
        return SendMessageCallbackW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static MemorySegment SendMessageCallbackW$address() {
        return SendMessageCallbackW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static int SendMessageCallbackW(MemorySegment hWnd, int Msg, long wParam, long lParam, MemorySegment lpResultCallBack, long dwData) {
        var mh$ = SendMessageCallbackW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageCallbackW", hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     UINT cbSize;
     *     HDESK hdesk;
     *     HWND hwnd;
     *     LUID luid;
     * } *PBSMINFO
     * }
     */
    public static final AddressLayout PBSMINFO = wgl_h.C_POINTER;

    private static class BroadcastSystemMessageExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BroadcastSystemMessageExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageExA$descriptor() {
        return BroadcastSystemMessageExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static MethodHandle BroadcastSystemMessageExA$handle() {
        return BroadcastSystemMessageExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static MemorySegment BroadcastSystemMessageExA$address() {
        return BroadcastSystemMessageExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static int BroadcastSystemMessageExA(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam, MemorySegment pbsmInfo) {
        var mh$ = BroadcastSystemMessageExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageExA", flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BroadcastSystemMessageExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BroadcastSystemMessageExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageExW$descriptor() {
        return BroadcastSystemMessageExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static MethodHandle BroadcastSystemMessageExW$handle() {
        return BroadcastSystemMessageExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static MemorySegment BroadcastSystemMessageExW$address() {
        return BroadcastSystemMessageExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static int BroadcastSystemMessageExW(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam, MemorySegment pbsmInfo) {
        var mh$ = BroadcastSystemMessageExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageExW", flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BroadcastSystemMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BroadcastSystemMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageA$descriptor() {
        return BroadcastSystemMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle BroadcastSystemMessageA$handle() {
        return BroadcastSystemMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment BroadcastSystemMessageA$address() {
        return BroadcastSystemMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int BroadcastSystemMessageA(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam) {
        var mh$ = BroadcastSystemMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageA", flags, lpInfo, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BroadcastSystemMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BroadcastSystemMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageW$descriptor() {
        return BroadcastSystemMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle BroadcastSystemMessageW$handle() {
        return BroadcastSystemMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment BroadcastSystemMessageW$address() {
        return BroadcastSystemMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int BroadcastSystemMessageW(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam) {
        var mh$ = BroadcastSystemMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageW", flags, lpInfo, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PVOID HDEVNOTIFY
     * }
     */
    public static final AddressLayout HDEVNOTIFY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HDEVNOTIFY *PHDEVNOTIFY
     * }
     */
    public static final AddressLayout PHDEVNOTIFY = wgl_h.C_POINTER;

    private static class RegisterDeviceNotificationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterDeviceNotificationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterDeviceNotificationA$descriptor() {
        return RegisterDeviceNotificationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterDeviceNotificationA$handle() {
        return RegisterDeviceNotificationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterDeviceNotificationA$address() {
        return RegisterDeviceNotificationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterDeviceNotificationA(MemorySegment hRecipient, MemorySegment NotificationFilter, int Flags) {
        var mh$ = RegisterDeviceNotificationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterDeviceNotificationA", hRecipient, NotificationFilter, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, NotificationFilter, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterDeviceNotificationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterDeviceNotificationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterDeviceNotificationW$descriptor() {
        return RegisterDeviceNotificationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterDeviceNotificationW$handle() {
        return RegisterDeviceNotificationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterDeviceNotificationW$address() {
        return RegisterDeviceNotificationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterDeviceNotificationW(MemorySegment hRecipient, MemorySegment NotificationFilter, int Flags) {
        var mh$ = RegisterDeviceNotificationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterDeviceNotificationW", hRecipient, NotificationFilter, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, NotificationFilter, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterDeviceNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterDeviceNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterDeviceNotification(HDEVNOTIFY Handle)
     * }
     */
    public static FunctionDescriptor UnregisterDeviceNotification$descriptor() {
        return UnregisterDeviceNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterDeviceNotification(HDEVNOTIFY Handle)
     * }
     */
    public static MethodHandle UnregisterDeviceNotification$handle() {
        return UnregisterDeviceNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterDeviceNotification(HDEVNOTIFY Handle)
     * }
     */
    public static MemorySegment UnregisterDeviceNotification$address() {
        return UnregisterDeviceNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterDeviceNotification(HDEVNOTIFY Handle)
     * }
     */
    public static int UnregisterDeviceNotification(MemorySegment Handle) {
        var mh$ = UnregisterDeviceNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterDeviceNotification", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PVOID HPOWERNOTIFY
     * }
     */
    public static final AddressLayout HPOWERNOTIFY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HPOWERNOTIFY *PHPOWERNOTIFY
     * }
     */
    public static final AddressLayout PHPOWERNOTIFY = wgl_h.C_POINTER;

    private static class RegisterPowerSettingNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterPowerSettingNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterPowerSettingNotification$descriptor() {
        return RegisterPowerSettingNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterPowerSettingNotification$handle() {
        return RegisterPowerSettingNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterPowerSettingNotification$address() {
        return RegisterPowerSettingNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterPowerSettingNotification(MemorySegment hRecipient, MemorySegment PowerSettingGuid, int Flags) {
        var mh$ = RegisterPowerSettingNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterPowerSettingNotification", hRecipient, PowerSettingGuid, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, PowerSettingGuid, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterPowerSettingNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterPowerSettingNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterPowerSettingNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static FunctionDescriptor UnregisterPowerSettingNotification$descriptor() {
        return UnregisterPowerSettingNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterPowerSettingNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static MethodHandle UnregisterPowerSettingNotification$handle() {
        return UnregisterPowerSettingNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterPowerSettingNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static MemorySegment UnregisterPowerSettingNotification$address() {
        return UnregisterPowerSettingNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterPowerSettingNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static int UnregisterPowerSettingNotification(MemorySegment Handle) {
        var mh$ = UnregisterPowerSettingNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterPowerSettingNotification", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterSuspendResumeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterSuspendResumeNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterSuspendResumeNotification$descriptor() {
        return RegisterSuspendResumeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterSuspendResumeNotification$handle() {
        return RegisterSuspendResumeNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterSuspendResumeNotification$address() {
        return RegisterSuspendResumeNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterSuspendResumeNotification(MemorySegment hRecipient, int Flags) {
        var mh$ = RegisterSuspendResumeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterSuspendResumeNotification", hRecipient, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterSuspendResumeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterSuspendResumeNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static FunctionDescriptor UnregisterSuspendResumeNotification$descriptor() {
        return UnregisterSuspendResumeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static MethodHandle UnregisterSuspendResumeNotification$handle() {
        return UnregisterSuspendResumeNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static MemorySegment UnregisterSuspendResumeNotification$address() {
        return UnregisterSuspendResumeNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static int UnregisterSuspendResumeNotification(MemorySegment Handle) {
        var mh$ = UnregisterSuspendResumeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterSuspendResumeNotification", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PostMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostMessageA$descriptor() {
        return PostMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostMessageA$handle() {
        return PostMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment PostMessageA$address() {
        return PostMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostMessageA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = PostMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostMessageA", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PostMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostMessageW$descriptor() {
        return PostMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostMessageW$handle() {
        return PostMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment PostMessageW$address() {
        return PostMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostMessageW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = PostMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostMessageW", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostThreadMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PostThreadMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostThreadMessageA$descriptor() {
        return PostThreadMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostThreadMessageA$handle() {
        return PostThreadMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment PostThreadMessageA$address() {
        return PostThreadMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostThreadMessageA(int idThread, int Msg, long wParam, long lParam) {
        var mh$ = PostThreadMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostThreadMessageA", idThread, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(idThread, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostThreadMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PostThreadMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostThreadMessageW$descriptor() {
        return PostThreadMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostThreadMessageW$handle() {
        return PostThreadMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment PostThreadMessageW$address() {
        return PostThreadMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostThreadMessageW(int idThread, int Msg, long wParam, long lParam) {
        var mh$ = PostThreadMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostThreadMessageW", idThread, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(idThread, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachThreadInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AttachThreadInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach)
     * }
     */
    public static FunctionDescriptor AttachThreadInput$descriptor() {
        return AttachThreadInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach)
     * }
     */
    public static MethodHandle AttachThreadInput$handle() {
        return AttachThreadInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach)
     * }
     */
    public static MemorySegment AttachThreadInput$address() {
        return AttachThreadInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach)
     * }
     */
    public static int AttachThreadInput(int idAttach, int idAttachTo, int fAttach) {
        var mh$ = AttachThreadInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachThreadInput", idAttach, idAttachTo, fAttach);
            }
            return (int)mh$.invokeExact(idAttach, idAttachTo, fAttach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplyMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReplyMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplyMessage(LRESULT lResult)
     * }
     */
    public static FunctionDescriptor ReplyMessage$descriptor() {
        return ReplyMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplyMessage(LRESULT lResult)
     * }
     */
    public static MethodHandle ReplyMessage$handle() {
        return ReplyMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplyMessage(LRESULT lResult)
     * }
     */
    public static MemorySegment ReplyMessage$address() {
        return ReplyMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplyMessage(LRESULT lResult)
     * }
     */
    public static int ReplyMessage(long lResult) {
        var mh$ = ReplyMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplyMessage", lResult);
            }
            return (int)mh$.invokeExact(lResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitMessage()
     * }
     */
    public static FunctionDescriptor WaitMessage$descriptor() {
        return WaitMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitMessage()
     * }
     */
    public static MethodHandle WaitMessage$handle() {
        return WaitMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitMessage()
     * }
     */
    public static MemorySegment WaitMessage$address() {
        return WaitMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitMessage()
     * }
     */
    public static int WaitMessage() {
        var mh$ = WaitMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitMessage");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForInputIdle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitForInputIdle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForInputIdle$descriptor() {
        return WaitForInputIdle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForInputIdle$handle() {
        return WaitForInputIdle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForInputIdle$address() {
        return WaitForInputIdle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForInputIdle(MemorySegment hProcess, int dwMilliseconds) {
        var mh$ = WaitForInputIdle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForInputIdle", hProcess, dwMilliseconds);
            }
            return (int)mh$.invokeExact(hProcess, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefWindowProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DefWindowProcA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefWindowProcA$descriptor() {
        return DefWindowProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefWindowProcA$handle() {
        return DefWindowProcA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefWindowProcA$address() {
        return DefWindowProcA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefWindowProcA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = DefWindowProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefWindowProcA", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefWindowProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DefWindowProcW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefWindowProcW$descriptor() {
        return DefWindowProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefWindowProcW$handle() {
        return DefWindowProcW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefWindowProcW$address() {
        return DefWindowProcW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefWindowProcW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = DefWindowProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefWindowProcW", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostQuitMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PostQuitMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PostQuitMessage(int nExitCode)
     * }
     */
    public static FunctionDescriptor PostQuitMessage$descriptor() {
        return PostQuitMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PostQuitMessage(int nExitCode)
     * }
     */
    public static MethodHandle PostQuitMessage$handle() {
        return PostQuitMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PostQuitMessage(int nExitCode)
     * }
     */
    public static MemorySegment PostQuitMessage$address() {
        return PostQuitMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PostQuitMessage(int nExitCode)
     * }
     */
    public static void PostQuitMessage(int nExitCode) {
        var mh$ = PostQuitMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostQuitMessage", nExitCode);
            }
            mh$.invokeExact(nExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallWindowProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CallWindowProcA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CallWindowProcA$descriptor() {
        return CallWindowProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle CallWindowProcA$handle() {
        return CallWindowProcA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment CallWindowProcA$address() {
        return CallWindowProcA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long CallWindowProcA(MemorySegment lpPrevWndFunc, MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = CallWindowProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallWindowProcA", lpPrevWndFunc, hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallWindowProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CallWindowProcW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CallWindowProcW$descriptor() {
        return CallWindowProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle CallWindowProcW$handle() {
        return CallWindowProcW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment CallWindowProcW$address() {
        return CallWindowProcW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long CallWindowProcW(MemorySegment lpPrevWndFunc, MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = CallWindowProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallWindowProcW", lpPrevWndFunc, hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InSendMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InSendMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InSendMessage()
     * }
     */
    public static FunctionDescriptor InSendMessage$descriptor() {
        return InSendMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InSendMessage()
     * }
     */
    public static MethodHandle InSendMessage$handle() {
        return InSendMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InSendMessage()
     * }
     */
    public static MemorySegment InSendMessage$address() {
        return InSendMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InSendMessage()
     * }
     */
    public static int InSendMessage() {
        var mh$ = InSendMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InSendMessage");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InSendMessageEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InSendMessageEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD InSendMessageEx(LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor InSendMessageEx$descriptor() {
        return InSendMessageEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD InSendMessageEx(LPVOID lpReserved)
     * }
     */
    public static MethodHandle InSendMessageEx$handle() {
        return InSendMessageEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD InSendMessageEx(LPVOID lpReserved)
     * }
     */
    public static MemorySegment InSendMessageEx$address() {
        return InSendMessageEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD InSendMessageEx(LPVOID lpReserved)
     * }
     */
    public static int InSendMessageEx(MemorySegment lpReserved) {
        var mh$ = InSendMessageEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InSendMessageEx", lpReserved);
            }
            return (int)mh$.invokeExact(lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDoubleClickTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDoubleClickTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDoubleClickTime()
     * }
     */
    public static FunctionDescriptor GetDoubleClickTime$descriptor() {
        return GetDoubleClickTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDoubleClickTime()
     * }
     */
    public static MethodHandle GetDoubleClickTime$handle() {
        return GetDoubleClickTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDoubleClickTime()
     * }
     */
    public static MemorySegment GetDoubleClickTime$address() {
        return GetDoubleClickTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDoubleClickTime()
     * }
     */
    public static int GetDoubleClickTime() {
        var mh$ = GetDoubleClickTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDoubleClickTime");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDoubleClickTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDoubleClickTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDoubleClickTime(UINT)
     * }
     */
    public static FunctionDescriptor SetDoubleClickTime$descriptor() {
        return SetDoubleClickTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDoubleClickTime(UINT)
     * }
     */
    public static MethodHandle SetDoubleClickTime$handle() {
        return SetDoubleClickTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDoubleClickTime(UINT)
     * }
     */
    public static MemorySegment SetDoubleClickTime$address() {
        return SetDoubleClickTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDoubleClickTime(UINT)
     * }
     */
    public static int SetDoubleClickTime(int x0) {
        var mh$ = SetDoubleClickTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDoubleClickTime", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterClassA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassA(const WNDCLASSA *lpWndClass)
     * }
     */
    public static FunctionDescriptor RegisterClassA$descriptor() {
        return RegisterClassA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassA(const WNDCLASSA *lpWndClass)
     * }
     */
    public static MethodHandle RegisterClassA$handle() {
        return RegisterClassA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM RegisterClassA(const WNDCLASSA *lpWndClass)
     * }
     */
    public static MemorySegment RegisterClassA$address() {
        return RegisterClassA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM RegisterClassA(const WNDCLASSA *lpWndClass)
     * }
     */
    public static short RegisterClassA(MemorySegment lpWndClass) {
        var mh$ = RegisterClassA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassA", lpWndClass);
            }
            return (short)mh$.invokeExact(lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterClassW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassW(const WNDCLASSW *lpWndClass)
     * }
     */
    public static FunctionDescriptor RegisterClassW$descriptor() {
        return RegisterClassW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassW(const WNDCLASSW *lpWndClass)
     * }
     */
    public static MethodHandle RegisterClassW$handle() {
        return RegisterClassW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM RegisterClassW(const WNDCLASSW *lpWndClass)
     * }
     */
    public static MemorySegment RegisterClassW$address() {
        return RegisterClassW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM RegisterClassW(const WNDCLASSW *lpWndClass)
     * }
     */
    public static short RegisterClassW(MemorySegment lpWndClass) {
        var mh$ = RegisterClassW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassW", lpWndClass);
            }
            return (short)mh$.invokeExact(lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterClassA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterClassA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static FunctionDescriptor UnregisterClassA$descriptor() {
        return UnregisterClassA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static MethodHandle UnregisterClassA$handle() {
        return UnregisterClassA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static MemorySegment UnregisterClassA$address() {
        return UnregisterClassA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static int UnregisterClassA(MemorySegment lpClassName, MemorySegment hInstance) {
        var mh$ = UnregisterClassA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterClassA", lpClassName, hInstance);
            }
            return (int)mh$.invokeExact(lpClassName, hInstance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterClassW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterClassW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static FunctionDescriptor UnregisterClassW$descriptor() {
        return UnregisterClassW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static MethodHandle UnregisterClassW$handle() {
        return UnregisterClassW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static MemorySegment UnregisterClassW$address() {
        return UnregisterClassW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static int UnregisterClassW(MemorySegment lpClassName, MemorySegment hInstance) {
        var mh$ = UnregisterClassW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterClassW", lpClassName, hInstance);
            }
            return (int)mh$.invokeExact(lpClassName, hInstance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClassInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass)
     * }
     */
    public static FunctionDescriptor GetClassInfoA$descriptor() {
        return GetClassInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass)
     * }
     */
    public static MethodHandle GetClassInfoA$handle() {
        return GetClassInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass)
     * }
     */
    public static MemorySegment GetClassInfoA$address() {
        return GetClassInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass)
     * }
     */
    public static int GetClassInfoA(MemorySegment hInstance, MemorySegment lpClassName, MemorySegment lpWndClass) {
        var mh$ = GetClassInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoA", hInstance, lpClassName, lpWndClass);
            }
            return (int)mh$.invokeExact(hInstance, lpClassName, lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClassInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass)
     * }
     */
    public static FunctionDescriptor GetClassInfoW$descriptor() {
        return GetClassInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass)
     * }
     */
    public static MethodHandle GetClassInfoW$handle() {
        return GetClassInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass)
     * }
     */
    public static MemorySegment GetClassInfoW$address() {
        return GetClassInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass)
     * }
     */
    public static int GetClassInfoW(MemorySegment hInstance, MemorySegment lpClassName, MemorySegment lpWndClass) {
        var mh$ = GetClassInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoW", hInstance, lpClassName, lpWndClass);
            }
            return (int)mh$.invokeExact(hInstance, lpClassName, lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterClassExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassExA(const WNDCLASSEXA *)
     * }
     */
    public static FunctionDescriptor RegisterClassExA$descriptor() {
        return RegisterClassExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassExA(const WNDCLASSEXA *)
     * }
     */
    public static MethodHandle RegisterClassExA$handle() {
        return RegisterClassExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM RegisterClassExA(const WNDCLASSEXA *)
     * }
     */
    public static MemorySegment RegisterClassExA$address() {
        return RegisterClassExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM RegisterClassExA(const WNDCLASSEXA *)
     * }
     */
    public static short RegisterClassExA(MemorySegment x0) {
        var mh$ = RegisterClassExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassExA", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterClassExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassExW(const WNDCLASSEXW *)
     * }
     */
    public static FunctionDescriptor RegisterClassExW$descriptor() {
        return RegisterClassExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassExW(const WNDCLASSEXW *)
     * }
     */
    public static MethodHandle RegisterClassExW$handle() {
        return RegisterClassExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM RegisterClassExW(const WNDCLASSEXW *)
     * }
     */
    public static MemorySegment RegisterClassExW$address() {
        return RegisterClassExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM RegisterClassExW(const WNDCLASSEXW *)
     * }
     */
    public static short RegisterClassExW(MemorySegment x0) {
        var mh$ = RegisterClassExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassExW", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClassInfoExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx)
     * }
     */
    public static FunctionDescriptor GetClassInfoExA$descriptor() {
        return GetClassInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx)
     * }
     */
    public static MethodHandle GetClassInfoExA$handle() {
        return GetClassInfoExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx)
     * }
     */
    public static MemorySegment GetClassInfoExA$address() {
        return GetClassInfoExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx)
     * }
     */
    public static int GetClassInfoExA(MemorySegment hInstance, MemorySegment lpszClass, MemorySegment lpwcx) {
        var mh$ = GetClassInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoExA", hInstance, lpszClass, lpwcx);
            }
            return (int)mh$.invokeExact(hInstance, lpszClass, lpwcx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClassInfoExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx)
     * }
     */
    public static FunctionDescriptor GetClassInfoExW$descriptor() {
        return GetClassInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx)
     * }
     */
    public static MethodHandle GetClassInfoExW$handle() {
        return GetClassInfoExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx)
     * }
     */
    public static MemorySegment GetClassInfoExW$address() {
        return GetClassInfoExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx)
     * }
     */
    public static int GetClassInfoExW(MemorySegment hInstance, MemorySegment lpszClass, MemorySegment lpwcx) {
        var mh$ = GetClassInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoExW", hInstance, lpszClass, lpwcx);
            }
            return (int)mh$.invokeExact(hInstance, lpszClass, lpwcx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateWindowExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static FunctionDescriptor CreateWindowExA$descriptor() {
        return CreateWindowExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MethodHandle CreateWindowExA$handle() {
        return CreateWindowExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MemorySegment CreateWindowExA$address() {
        return CreateWindowExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MemorySegment CreateWindowExA(int dwExStyle, MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hMenu, MemorySegment hInstance, MemorySegment lpParam) {
        var mh$ = CreateWindowExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowExA", dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
            }
            return (MemorySegment)mh$.invokeExact(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateWindowExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static FunctionDescriptor CreateWindowExW$descriptor() {
        return CreateWindowExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MethodHandle CreateWindowExW$handle() {
        return CreateWindowExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MemorySegment CreateWindowExW$address() {
        return CreateWindowExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MemorySegment CreateWindowExW(int dwExStyle, MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hMenu, MemorySegment hInstance, MemorySegment lpParam) {
        var mh$ = CreateWindowExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowExW", dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
            }
            return (MemorySegment)mh$.invokeExact(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindow$descriptor() {
        return IsWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindow(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindow$handle() {
        return IsWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWindow(HWND hWnd)
     * }
     */
    public static MemorySegment IsWindow$address() {
        return IsWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWindow(HWND hWnd)
     * }
     */
    public static int IsWindow(MemorySegment hWnd) {
        var mh$ = IsWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsMenu(HMENU hMenu)
     * }
     */
    public static FunctionDescriptor IsMenu$descriptor() {
        return IsMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsMenu(HMENU hMenu)
     * }
     */
    public static MethodHandle IsMenu$handle() {
        return IsMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsMenu(HMENU hMenu)
     * }
     */
    public static MemorySegment IsMenu$address() {
        return IsMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsMenu(HMENU hMenu)
     * }
     */
    public static int IsMenu(MemorySegment hMenu) {
        var mh$ = IsMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMenu", hMenu);
            }
            return (int)mh$.invokeExact(hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsChild {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsChild");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsChild(HWND hWndParent, HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsChild$descriptor() {
        return IsChild.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsChild(HWND hWndParent, HWND hWnd)
     * }
     */
    public static MethodHandle IsChild$handle() {
        return IsChild.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsChild(HWND hWndParent, HWND hWnd)
     * }
     */
    public static MemorySegment IsChild$address() {
        return IsChild.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsChild(HWND hWndParent, HWND hWnd)
     * }
     */
    public static int IsChild(MemorySegment hWndParent, MemorySegment hWnd) {
        var mh$ = IsChild.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsChild", hWndParent, hWnd);
            }
            return (int)mh$.invokeExact(hWndParent, hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DestroyWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor DestroyWindow$descriptor() {
        return DestroyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyWindow(HWND hWnd)
     * }
     */
    public static MethodHandle DestroyWindow$handle() {
        return DestroyWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DestroyWindow(HWND hWnd)
     * }
     */
    public static MemorySegment DestroyWindow$address() {
        return DestroyWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DestroyWindow(HWND hWnd)
     * }
     */
    public static int DestroyWindow(MemorySegment hWnd) {
        var mh$ = DestroyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ShowWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowWindow(HWND hWnd, int nCmdShow)
     * }
     */
    public static FunctionDescriptor ShowWindow$descriptor() {
        return ShowWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowWindow(HWND hWnd, int nCmdShow)
     * }
     */
    public static MethodHandle ShowWindow$handle() {
        return ShowWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ShowWindow(HWND hWnd, int nCmdShow)
     * }
     */
    public static MemorySegment ShowWindow$address() {
        return ShowWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ShowWindow(HWND hWnd, int nCmdShow)
     * }
     */
    public static int ShowWindow(MemorySegment hWnd, int nCmdShow) {
        var mh$ = ShowWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowWindow", hWnd, nCmdShow);
            }
            return (int)mh$.invokeExact(hWnd, nCmdShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AnimateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor AnimateWindow$descriptor() {
        return AnimateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags)
     * }
     */
    public static MethodHandle AnimateWindow$handle() {
        return AnimateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags)
     * }
     */
    public static MemorySegment AnimateWindow$address() {
        return AnimateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags)
     * }
     */
    public static int AnimateWindow(MemorySegment hWnd, int dwTime, int dwFlags) {
        var mh$ = AnimateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimateWindow", hWnd, dwTime, dwFlags);
            }
            return (int)mh$.invokeExact(hWnd, dwTime, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateLayeredWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UpdateLayeredWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor UpdateLayeredWindow$descriptor() {
        return UpdateLayeredWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
     * }
     */
    public static MethodHandle UpdateLayeredWindow$handle() {
        return UpdateLayeredWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
     * }
     */
    public static MemorySegment UpdateLayeredWindow$address() {
        return UpdateLayeredWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
     * }
     */
    public static int UpdateLayeredWindow(MemorySegment hWnd, MemorySegment hdcDst, MemorySegment pptDst, MemorySegment psize, MemorySegment hdcSrc, MemorySegment pptSrc, int crKey, MemorySegment pblend, int dwFlags) {
        var mh$ = UpdateLayeredWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateLayeredWindow", hWnd, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags);
            }
            return (int)mh$.invokeExact(hWnd, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagUPDATELAYEREDWINDOWINFO {
     *     DWORD cbSize;
     *     HDC hdcDst;
     *     const POINT *pptDst;
     *     const SIZE *psize;
     *     HDC hdcSrc;
     *     const POINT *pptSrc;
     *     COLORREF crKey;
     *     const BLENDFUNCTION *pblend;
     *     DWORD dwFlags;
     *     const RECT *prcDirty;
     * } *PUPDATELAYEREDWINDOWINFO
     * }
     */
    public static final AddressLayout PUPDATELAYEREDWINDOWINFO = wgl_h.C_POINTER;

    private static class UpdateLayeredWindowIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UpdateLayeredWindowIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO *pULWInfo)
     * }
     */
    public static FunctionDescriptor UpdateLayeredWindowIndirect$descriptor() {
        return UpdateLayeredWindowIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO *pULWInfo)
     * }
     */
    public static MethodHandle UpdateLayeredWindowIndirect$handle() {
        return UpdateLayeredWindowIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO *pULWInfo)
     * }
     */
    public static MemorySegment UpdateLayeredWindowIndirect$address() {
        return UpdateLayeredWindowIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO *pULWInfo)
     * }
     */
    public static int UpdateLayeredWindowIndirect(MemorySegment hWnd, MemorySegment pULWInfo) {
        var mh$ = UpdateLayeredWindowIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateLayeredWindowIndirect", hWnd, pULWInfo);
            }
            return (int)mh$.invokeExact(hWnd, pULWInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLayeredWindowAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLayeredWindowAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLayeredWindowAttributes(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor GetLayeredWindowAttributes$descriptor() {
        return GetLayeredWindowAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLayeredWindowAttributes(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle GetLayeredWindowAttributes$handle() {
        return GetLayeredWindowAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLayeredWindowAttributes(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment GetLayeredWindowAttributes$address() {
        return GetLayeredWindowAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLayeredWindowAttributes(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
     * }
     */
    public static int GetLayeredWindowAttributes(MemorySegment hwnd, MemorySegment pcrKey, MemorySegment pbAlpha, MemorySegment pdwFlags) {
        var mh$ = GetLayeredWindowAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLayeredWindowAttributes", hwnd, pcrKey, pbAlpha, pdwFlags);
            }
            return (int)mh$.invokeExact(hwnd, pcrKey, pbAlpha, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrintWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PrintWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)
     * }
     */
    public static FunctionDescriptor PrintWindow$descriptor() {
        return PrintWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)
     * }
     */
    public static MethodHandle PrintWindow$handle() {
        return PrintWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)
     * }
     */
    public static MemorySegment PrintWindow$address() {
        return PrintWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)
     * }
     */
    public static int PrintWindow(MemorySegment hwnd, MemorySegment hdcBlt, int nFlags) {
        var mh$ = PrintWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrintWindow", hwnd, hdcBlt, nFlags);
            }
            return (int)mh$.invokeExact(hwnd, hdcBlt, nFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLayeredWindowAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_CHAR,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetLayeredWindowAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetLayeredWindowAttributes$descriptor() {
        return SetLayeredWindowAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetLayeredWindowAttributes$handle() {
        return SetLayeredWindowAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetLayeredWindowAttributes$address() {
        return SetLayeredWindowAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
     * }
     */
    public static int SetLayeredWindowAttributes(MemorySegment hwnd, int crKey, byte bAlpha, int dwFlags) {
        var mh$ = SetLayeredWindowAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLayeredWindowAttributes", hwnd, crKey, bAlpha, dwFlags);
            }
            return (int)mh$.invokeExact(hwnd, crKey, bAlpha, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowWindowAsync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ShowWindowAsync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowWindowAsync(HWND hWnd, int nCmdShow)
     * }
     */
    public static FunctionDescriptor ShowWindowAsync$descriptor() {
        return ShowWindowAsync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowWindowAsync(HWND hWnd, int nCmdShow)
     * }
     */
    public static MethodHandle ShowWindowAsync$handle() {
        return ShowWindowAsync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ShowWindowAsync(HWND hWnd, int nCmdShow)
     * }
     */
    public static MemorySegment ShowWindowAsync$address() {
        return ShowWindowAsync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ShowWindowAsync(HWND hWnd, int nCmdShow)
     * }
     */
    public static int ShowWindowAsync(MemorySegment hWnd, int nCmdShow) {
        var mh$ = ShowWindowAsync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowWindowAsync", hWnd, nCmdShow);
            }
            return (int)mh$.invokeExact(hWnd, nCmdShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlashWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FlashWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlashWindow(HWND hWnd, BOOL bInvert)
     * }
     */
    public static FunctionDescriptor FlashWindow$descriptor() {
        return FlashWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlashWindow(HWND hWnd, BOOL bInvert)
     * }
     */
    public static MethodHandle FlashWindow$handle() {
        return FlashWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlashWindow(HWND hWnd, BOOL bInvert)
     * }
     */
    public static MemorySegment FlashWindow$address() {
        return FlashWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlashWindow(HWND hWnd, BOOL bInvert)
     * }
     */
    public static int FlashWindow(MemorySegment hWnd, int bInvert) {
        var mh$ = FlashWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlashWindow", hWnd, bInvert);
            }
            return (int)mh$.invokeExact(hWnd, bInvert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     UINT cbSize;
     *     HWND hwnd;
     *     DWORD dwFlags;
     *     UINT uCount;
     *     DWORD dwTimeout;
     * } *PFLASHWINFO
     * }
     */
    public static final AddressLayout PFLASHWINFO = wgl_h.C_POINTER;

    private static class FlashWindowEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FlashWindowEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlashWindowEx(PFLASHWINFO pfwi)
     * }
     */
    public static FunctionDescriptor FlashWindowEx$descriptor() {
        return FlashWindowEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlashWindowEx(PFLASHWINFO pfwi)
     * }
     */
    public static MethodHandle FlashWindowEx$handle() {
        return FlashWindowEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlashWindowEx(PFLASHWINFO pfwi)
     * }
     */
    public static MemorySegment FlashWindowEx$address() {
        return FlashWindowEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlashWindowEx(PFLASHWINFO pfwi)
     * }
     */
    public static int FlashWindowEx(MemorySegment pfwi) {
        var mh$ = FlashWindowEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlashWindowEx", pfwi);
            }
            return (int)mh$.invokeExact(pfwi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowOwnedPopups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ShowOwnedPopups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowOwnedPopups(HWND hWnd, BOOL fShow)
     * }
     */
    public static FunctionDescriptor ShowOwnedPopups$descriptor() {
        return ShowOwnedPopups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowOwnedPopups(HWND hWnd, BOOL fShow)
     * }
     */
    public static MethodHandle ShowOwnedPopups$handle() {
        return ShowOwnedPopups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ShowOwnedPopups(HWND hWnd, BOOL fShow)
     * }
     */
    public static MemorySegment ShowOwnedPopups$address() {
        return ShowOwnedPopups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ShowOwnedPopups(HWND hWnd, BOOL fShow)
     * }
     */
    public static int ShowOwnedPopups(MemorySegment hWnd, int fShow) {
        var mh$ = ShowOwnedPopups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowOwnedPopups", hWnd, fShow);
            }
            return (int)mh$.invokeExact(hWnd, fShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenIcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenIcon(HWND hWnd)
     * }
     */
    public static FunctionDescriptor OpenIcon$descriptor() {
        return OpenIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenIcon(HWND hWnd)
     * }
     */
    public static MethodHandle OpenIcon$handle() {
        return OpenIcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OpenIcon(HWND hWnd)
     * }
     */
    public static MemorySegment OpenIcon$address() {
        return OpenIcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OpenIcon(HWND hWnd)
     * }
     */
    public static int OpenIcon(MemorySegment hWnd) {
        var mh$ = OpenIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenIcon", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor CloseWindow$descriptor() {
        return CloseWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseWindow(HWND hWnd)
     * }
     */
    public static MethodHandle CloseWindow$handle() {
        return CloseWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseWindow(HWND hWnd)
     * }
     */
    public static MemorySegment CloseWindow$address() {
        return CloseWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseWindow(HWND hWnd)
     * }
     */
    public static int CloseWindow(MemorySegment hWnd) {
        var mh$ = CloseWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MoveWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
     * }
     */
    public static FunctionDescriptor MoveWindow$descriptor() {
        return MoveWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
     * }
     */
    public static MethodHandle MoveWindow$handle() {
        return MoveWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
     * }
     */
    public static MemorySegment MoveWindow$address() {
        return MoveWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
     * }
     */
    public static int MoveWindow(MemorySegment hWnd, int X, int Y, int nWidth, int nHeight, int bRepaint) {
        var mh$ = MoveWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveWindow", hWnd, X, Y, nWidth, nHeight, bRepaint);
            }
            return (int)mh$.invokeExact(hWnd, X, Y, nWidth, nHeight, bRepaint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor SetWindowPos$descriptor() {
        return SetWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle SetWindowPos$handle() {
        return SetWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MemorySegment SetWindowPos$address() {
        return SetWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
     * }
     */
    public static int SetWindowPos(MemorySegment hWnd, MemorySegment hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags) {
        var mh$ = SetWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowPos", hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
            }
            return (int)mh$.invokeExact(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowPlacement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWindowPlacement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static FunctionDescriptor GetWindowPlacement$descriptor() {
        return GetWindowPlacement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static MethodHandle GetWindowPlacement$handle() {
        return GetWindowPlacement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static MemorySegment GetWindowPlacement$address() {
        return GetWindowPlacement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static int GetWindowPlacement(MemorySegment hWnd, MemorySegment lpwndpl) {
        var mh$ = GetWindowPlacement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowPlacement", hWnd, lpwndpl);
            }
            return (int)mh$.invokeExact(hWnd, lpwndpl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowPlacement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetWindowPlacement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static FunctionDescriptor SetWindowPlacement$descriptor() {
        return SetWindowPlacement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static MethodHandle SetWindowPlacement$handle() {
        return SetWindowPlacement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static MemorySegment SetWindowPlacement$address() {
        return SetWindowPlacement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static int SetWindowPlacement(MemorySegment hWnd, MemorySegment lpwndpl) {
        var mh$ = SetWindowPlacement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowPlacement", hWnd, lpwndpl);
            }
            return (int)mh$.invokeExact(hWnd, lpwndpl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowDisplayAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWindowDisplayAffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowDisplayAffinity(HWND hWnd, DWORD *pdwAffinity)
     * }
     */
    public static FunctionDescriptor GetWindowDisplayAffinity$descriptor() {
        return GetWindowDisplayAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowDisplayAffinity(HWND hWnd, DWORD *pdwAffinity)
     * }
     */
    public static MethodHandle GetWindowDisplayAffinity$handle() {
        return GetWindowDisplayAffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowDisplayAffinity(HWND hWnd, DWORD *pdwAffinity)
     * }
     */
    public static MemorySegment GetWindowDisplayAffinity$address() {
        return GetWindowDisplayAffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowDisplayAffinity(HWND hWnd, DWORD *pdwAffinity)
     * }
     */
    public static int GetWindowDisplayAffinity(MemorySegment hWnd, MemorySegment pdwAffinity) {
        var mh$ = GetWindowDisplayAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowDisplayAffinity", hWnd, pdwAffinity);
            }
            return (int)mh$.invokeExact(hWnd, pdwAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowDisplayAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetWindowDisplayAffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity)
     * }
     */
    public static FunctionDescriptor SetWindowDisplayAffinity$descriptor() {
        return SetWindowDisplayAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity)
     * }
     */
    public static MethodHandle SetWindowDisplayAffinity$handle() {
        return SetWindowDisplayAffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity)
     * }
     */
    public static MemorySegment SetWindowDisplayAffinity$address() {
        return SetWindowDisplayAffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity)
     * }
     */
    public static int SetWindowDisplayAffinity(MemorySegment hWnd, int dwAffinity) {
        var mh$ = SetWindowDisplayAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowDisplayAffinity", hWnd, dwAffinity);
            }
            return (int)mh$.invokeExact(hWnd, dwAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginDeferWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BeginDeferWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDWP BeginDeferWindowPos(int nNumWindows)
     * }
     */
    public static FunctionDescriptor BeginDeferWindowPos$descriptor() {
        return BeginDeferWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDWP BeginDeferWindowPos(int nNumWindows)
     * }
     */
    public static MethodHandle BeginDeferWindowPos$handle() {
        return BeginDeferWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDWP BeginDeferWindowPos(int nNumWindows)
     * }
     */
    public static MemorySegment BeginDeferWindowPos$address() {
        return BeginDeferWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDWP BeginDeferWindowPos(int nNumWindows)
     * }
     */
    public static MemorySegment BeginDeferWindowPos(int nNumWindows) {
        var mh$ = BeginDeferWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginDeferWindowPos", nNumWindows);
            }
            return (MemorySegment)mh$.invokeExact(nNumWindows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeferWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeferWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DeferWindowPos$descriptor() {
        return DeferWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle DeferWindowPos$handle() {
        return DeferWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MemorySegment DeferWindowPos$address() {
        return DeferWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MemorySegment DeferWindowPos(MemorySegment hWinPosInfo, MemorySegment hWnd, MemorySegment hWndInsertAfter, int x, int y, int cx, int cy, int uFlags) {
        var mh$ = DeferWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeferWindowPos", hWinPosInfo, hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
            }
            return (MemorySegment)mh$.invokeExact(hWinPosInfo, hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDeferWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EndDeferWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndDeferWindowPos(HDWP hWinPosInfo)
     * }
     */
    public static FunctionDescriptor EndDeferWindowPos$descriptor() {
        return EndDeferWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndDeferWindowPos(HDWP hWinPosInfo)
     * }
     */
    public static MethodHandle EndDeferWindowPos$handle() {
        return EndDeferWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndDeferWindowPos(HDWP hWinPosInfo)
     * }
     */
    public static MemorySegment EndDeferWindowPos$address() {
        return EndDeferWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndDeferWindowPos(HDWP hWinPosInfo)
     * }
     */
    public static int EndDeferWindowPos(MemorySegment hWinPosInfo) {
        var mh$ = EndDeferWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDeferWindowPos", hWinPosInfo);
            }
            return (int)mh$.invokeExact(hWinPosInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsWindowVisible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindowVisible(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindowVisible$descriptor() {
        return IsWindowVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindowVisible(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindowVisible$handle() {
        return IsWindowVisible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWindowVisible(HWND hWnd)
     * }
     */
    public static MemorySegment IsWindowVisible$address() {
        return IsWindowVisible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWindowVisible(HWND hWnd)
     * }
     */
    public static int IsWindowVisible(MemorySegment hWnd) {
        var mh$ = IsWindowVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowVisible", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsIconic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsIconic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsIconic(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsIconic$descriptor() {
        return IsIconic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsIconic(HWND hWnd)
     * }
     */
    public static MethodHandle IsIconic$handle() {
        return IsIconic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsIconic(HWND hWnd)
     * }
     */
    public static MemorySegment IsIconic$address() {
        return IsIconic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsIconic(HWND hWnd)
     * }
     */
    public static int IsIconic(MemorySegment hWnd) {
        var mh$ = IsIconic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsIconic", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnyPopup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AnyPopup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AnyPopup()
     * }
     */
    public static FunctionDescriptor AnyPopup$descriptor() {
        return AnyPopup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AnyPopup()
     * }
     */
    public static MethodHandle AnyPopup$handle() {
        return AnyPopup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AnyPopup()
     * }
     */
    public static MemorySegment AnyPopup$address() {
        return AnyPopup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AnyPopup()
     * }
     */
    public static int AnyPopup() {
        var mh$ = AnyPopup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnyPopup");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BringWindowToTop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BringWindowToTop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BringWindowToTop(HWND hWnd)
     * }
     */
    public static FunctionDescriptor BringWindowToTop$descriptor() {
        return BringWindowToTop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BringWindowToTop(HWND hWnd)
     * }
     */
    public static MethodHandle BringWindowToTop$handle() {
        return BringWindowToTop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BringWindowToTop(HWND hWnd)
     * }
     */
    public static MemorySegment BringWindowToTop$address() {
        return BringWindowToTop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BringWindowToTop(HWND hWnd)
     * }
     */
    public static int BringWindowToTop(MemorySegment hWnd) {
        var mh$ = BringWindowToTop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BringWindowToTop", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsZoomed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsZoomed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsZoomed(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsZoomed$descriptor() {
        return IsZoomed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsZoomed(HWND hWnd)
     * }
     */
    public static MethodHandle IsZoomed$handle() {
        return IsZoomed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsZoomed(HWND hWnd)
     * }
     */
    public static MemorySegment IsZoomed$address() {
        return IsZoomed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsZoomed(HWND hWnd)
     * }
     */
    public static int IsZoomed(MemorySegment hWnd) {
        var mh$ = IsZoomed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsZoomed", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef DLGTEMPLATE *LPDLGTEMPLATEA
     * }
     */
    public static final AddressLayout LPDLGTEMPLATEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGTEMPLATE *LPDLGTEMPLATEW
     * }
     */
    public static final AddressLayout LPDLGTEMPLATEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDLGTEMPLATEA LPDLGTEMPLATE
     * }
     */
    public static final AddressLayout LPDLGTEMPLATE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const DLGTEMPLATE *LPCDLGTEMPLATEA
     * }
     */
    public static final AddressLayout LPCDLGTEMPLATEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const DLGTEMPLATE *LPCDLGTEMPLATEW
     * }
     */
    public static final AddressLayout LPCDLGTEMPLATEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE
     * }
     */
    public static final AddressLayout LPCDLGTEMPLATE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA
     * }
     */
    public static final AddressLayout PDLGITEMTEMPLATEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW
     * }
     */
    public static final AddressLayout PDLGITEMTEMPLATEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE
     * }
     */
    public static final AddressLayout PDLGITEMTEMPLATE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA
     * }
     */
    public static final AddressLayout LPDLGITEMTEMPLATEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW
     * }
     */
    public static final AddressLayout LPDLGITEMTEMPLATEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE
     * }
     */
    public static final AddressLayout LPDLGITEMTEMPLATE = wgl_h.C_POINTER;

    private static class CreateDialogParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDialogParamA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogParamA$descriptor() {
        return CreateDialogParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogParamA$handle() {
        return CreateDialogParamA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogParamA$address() {
        return CreateDialogParamA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogParamA(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogParamA", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDialogParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDialogParamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogParamW$descriptor() {
        return CreateDialogParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogParamW$handle() {
        return CreateDialogParamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogParamW$address() {
        return CreateDialogParamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogParamW(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogParamW", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDialogIndirectParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDialogIndirectParamA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogIndirectParamA$descriptor() {
        return CreateDialogIndirectParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogIndirectParamA$handle() {
        return CreateDialogIndirectParamA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogIndirectParamA$address() {
        return CreateDialogIndirectParamA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogIndirectParamA(MemorySegment hInstance, MemorySegment lpTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogIndirectParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogIndirectParamA", hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDialogIndirectParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDialogIndirectParamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogIndirectParamW$descriptor() {
        return CreateDialogIndirectParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogIndirectParamW$handle() {
        return CreateDialogIndirectParamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogIndirectParamW$address() {
        return CreateDialogIndirectParamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogIndirectParamW(MemorySegment hInstance, MemorySegment lpTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogIndirectParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogIndirectParamW", hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DialogBoxParamA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxParamA$descriptor() {
        return DialogBoxParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxParamA$handle() {
        return DialogBoxParamA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment DialogBoxParamA$address() {
        return DialogBoxParamA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxParamA(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxParamA", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DialogBoxParamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxParamW$descriptor() {
        return DialogBoxParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxParamW$handle() {
        return DialogBoxParamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment DialogBoxParamW$address() {
        return DialogBoxParamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxParamW(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxParamW", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxIndirectParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DialogBoxIndirectParamA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxIndirectParamA$descriptor() {
        return DialogBoxIndirectParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxIndirectParamA$handle() {
        return DialogBoxIndirectParamA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment DialogBoxIndirectParamA$address() {
        return DialogBoxIndirectParamA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxIndirectParamA(MemorySegment hInstance, MemorySegment hDialogTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxIndirectParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxIndirectParamA", hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxIndirectParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DialogBoxIndirectParamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxIndirectParamW$descriptor() {
        return DialogBoxIndirectParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxIndirectParamW$handle() {
        return DialogBoxIndirectParamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment DialogBoxIndirectParamW$address() {
        return DialogBoxIndirectParamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxIndirectParamW(MemorySegment hInstance, MemorySegment hDialogTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxIndirectParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxIndirectParamW", hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EndDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndDialog(HWND hDlg, INT_PTR nResult)
     * }
     */
    public static FunctionDescriptor EndDialog$descriptor() {
        return EndDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndDialog(HWND hDlg, INT_PTR nResult)
     * }
     */
    public static MethodHandle EndDialog$handle() {
        return EndDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndDialog(HWND hDlg, INT_PTR nResult)
     * }
     */
    public static MemorySegment EndDialog$address() {
        return EndDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndDialog(HWND hDlg, INT_PTR nResult)
     * }
     */
    public static int EndDialog(MemorySegment hDlg, long nResult) {
        var mh$ = EndDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDialog", hDlg, nResult);
            }
            return (int)mh$.invokeExact(hDlg, nResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDlgItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetDlgItem(HWND hDlg, int nIDDlgItem)
     * }
     */
    public static FunctionDescriptor GetDlgItem$descriptor() {
        return GetDlgItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetDlgItem(HWND hDlg, int nIDDlgItem)
     * }
     */
    public static MethodHandle GetDlgItem$handle() {
        return GetDlgItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetDlgItem(HWND hDlg, int nIDDlgItem)
     * }
     */
    public static MemorySegment GetDlgItem$address() {
        return GetDlgItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetDlgItem(HWND hDlg, int nIDDlgItem)
     * }
     */
    public static MemorySegment GetDlgItem(MemorySegment hDlg, int nIDDlgItem) {
        var mh$ = GetDlgItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItem", hDlg, nIDDlgItem);
            }
            return (MemorySegment)mh$.invokeExact(hDlg, nIDDlgItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDlgItemInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDlgItemInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
     * }
     */
    public static FunctionDescriptor SetDlgItemInt$descriptor() {
        return SetDlgItemInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
     * }
     */
    public static MethodHandle SetDlgItemInt$handle() {
        return SetDlgItemInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
     * }
     */
    public static MemorySegment SetDlgItemInt$address() {
        return SetDlgItemInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
     * }
     */
    public static int SetDlgItemInt(MemorySegment hDlg, int nIDDlgItem, int uValue, int bSigned) {
        var mh$ = SetDlgItemInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDlgItemInt", hDlg, nIDDlgItem, uValue, bSigned);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, uValue, bSigned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItemInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDlgItemInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
     * }
     */
    public static FunctionDescriptor GetDlgItemInt$descriptor() {
        return GetDlgItemInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
     * }
     */
    public static MethodHandle GetDlgItemInt$handle() {
        return GetDlgItemInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
     * }
     */
    public static MemorySegment GetDlgItemInt$address() {
        return GetDlgItemInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
     * }
     */
    public static int GetDlgItemInt(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpTranslated, int bSigned) {
        var mh$ = GetDlgItemInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItemInt", hDlg, nIDDlgItem, lpTranslated, bSigned);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpTranslated, bSigned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDlgItemTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDlgItemTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor SetDlgItemTextA$descriptor() {
        return SetDlgItemTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString)
     * }
     */
    public static MethodHandle SetDlgItemTextA$handle() {
        return SetDlgItemTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString)
     * }
     */
    public static MemorySegment SetDlgItemTextA$address() {
        return SetDlgItemTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString)
     * }
     */
    public static int SetDlgItemTextA(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString) {
        var mh$ = SetDlgItemTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDlgItemTextA", hDlg, nIDDlgItem, lpString);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDlgItemTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDlgItemTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor SetDlgItemTextW$descriptor() {
        return SetDlgItemTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
     * }
     */
    public static MethodHandle SetDlgItemTextW$handle() {
        return SetDlgItemTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
     * }
     */
    public static MemorySegment SetDlgItemTextW$address() {
        return SetDlgItemTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
     * }
     */
    public static int SetDlgItemTextW(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString) {
        var mh$ = SetDlgItemTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDlgItemTextW", hDlg, nIDDlgItem, lpString);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItemTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDlgItemTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax)
     * }
     */
    public static FunctionDescriptor GetDlgItemTextA$descriptor() {
        return GetDlgItemTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax)
     * }
     */
    public static MethodHandle GetDlgItemTextA$handle() {
        return GetDlgItemTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax)
     * }
     */
    public static MemorySegment GetDlgItemTextA$address() {
        return GetDlgItemTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax)
     * }
     */
    public static int GetDlgItemTextA(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString, int cchMax) {
        var mh$ = GetDlgItemTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItemTextA", hDlg, nIDDlgItem, lpString, cchMax);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString, cchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItemTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDlgItemTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
     * }
     */
    public static FunctionDescriptor GetDlgItemTextW$descriptor() {
        return GetDlgItemTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
     * }
     */
    public static MethodHandle GetDlgItemTextW$handle() {
        return GetDlgItemTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
     * }
     */
    public static MemorySegment GetDlgItemTextW$address() {
        return GetDlgItemTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
     * }
     */
    public static int GetDlgItemTextW(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString, int cchMax) {
        var mh$ = GetDlgItemTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItemTextW", hDlg, nIDDlgItem, lpString, cchMax);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString, cchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckDlgButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CheckDlgButton");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck)
     * }
     */
    public static FunctionDescriptor CheckDlgButton$descriptor() {
        return CheckDlgButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck)
     * }
     */
    public static MethodHandle CheckDlgButton$handle() {
        return CheckDlgButton.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck)
     * }
     */
    public static MemorySegment CheckDlgButton$address() {
        return CheckDlgButton.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck)
     * }
     */
    public static int CheckDlgButton(MemorySegment hDlg, int nIDButton, int uCheck) {
        var mh$ = CheckDlgButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckDlgButton", hDlg, nIDButton, uCheck);
            }
            return (int)mh$.invokeExact(hDlg, nIDButton, uCheck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckRadioButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CheckRadioButton");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
     * }
     */
    public static FunctionDescriptor CheckRadioButton$descriptor() {
        return CheckRadioButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
     * }
     */
    public static MethodHandle CheckRadioButton$handle() {
        return CheckRadioButton.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
     * }
     */
    public static MemorySegment CheckRadioButton$address() {
        return CheckRadioButton.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
     * }
     */
    public static int CheckRadioButton(MemorySegment hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton) {
        var mh$ = CheckRadioButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckRadioButton", hDlg, nIDFirstButton, nIDLastButton, nIDCheckButton);
            }
            return (int)mh$.invokeExact(hDlg, nIDFirstButton, nIDLastButton, nIDCheckButton);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDlgButtonChecked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsDlgButtonChecked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT IsDlgButtonChecked(HWND hDlg, int nIDButton)
     * }
     */
    public static FunctionDescriptor IsDlgButtonChecked$descriptor() {
        return IsDlgButtonChecked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT IsDlgButtonChecked(HWND hDlg, int nIDButton)
     * }
     */
    public static MethodHandle IsDlgButtonChecked$handle() {
        return IsDlgButtonChecked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT IsDlgButtonChecked(HWND hDlg, int nIDButton)
     * }
     */
    public static MemorySegment IsDlgButtonChecked$address() {
        return IsDlgButtonChecked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT IsDlgButtonChecked(HWND hDlg, int nIDButton)
     * }
     */
    public static int IsDlgButtonChecked(MemorySegment hDlg, int nIDButton) {
        var mh$ = IsDlgButtonChecked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDlgButtonChecked", hDlg, nIDButton);
            }
            return (int)mh$.invokeExact(hDlg, nIDButton);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendDlgItemMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SendDlgItemMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendDlgItemMessageA$descriptor() {
        return SendDlgItemMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendDlgItemMessageA$handle() {
        return SendDlgItemMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendDlgItemMessageA$address() {
        return SendDlgItemMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendDlgItemMessageA(MemorySegment hDlg, int nIDDlgItem, int Msg, long wParam, long lParam) {
        var mh$ = SendDlgItemMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendDlgItemMessageA", hDlg, nIDDlgItem, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, nIDDlgItem, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendDlgItemMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SendDlgItemMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendDlgItemMessageW$descriptor() {
        return SendDlgItemMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendDlgItemMessageW$handle() {
        return SendDlgItemMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment SendDlgItemMessageW$address() {
        return SendDlgItemMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendDlgItemMessageW(MemorySegment hDlg, int nIDDlgItem, int Msg, long wParam, long lParam) {
        var mh$ = SendDlgItemMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendDlgItemMessageW", hDlg, nIDDlgItem, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, nIDDlgItem, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNextDlgGroupItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNextDlgGroupItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static FunctionDescriptor GetNextDlgGroupItem$descriptor() {
        return GetNextDlgGroupItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MethodHandle GetNextDlgGroupItem$handle() {
        return GetNextDlgGroupItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MemorySegment GetNextDlgGroupItem$address() {
        return GetNextDlgGroupItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MemorySegment GetNextDlgGroupItem(MemorySegment hDlg, MemorySegment hCtl, int bPrevious) {
        var mh$ = GetNextDlgGroupItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNextDlgGroupItem", hDlg, hCtl, bPrevious);
            }
            return (MemorySegment)mh$.invokeExact(hDlg, hCtl, bPrevious);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNextDlgTabItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNextDlgTabItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static FunctionDescriptor GetNextDlgTabItem$descriptor() {
        return GetNextDlgTabItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MethodHandle GetNextDlgTabItem$handle() {
        return GetNextDlgTabItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MemorySegment GetNextDlgTabItem$address() {
        return GetNextDlgTabItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MemorySegment GetNextDlgTabItem(MemorySegment hDlg, MemorySegment hCtl, int bPrevious) {
        var mh$ = GetNextDlgTabItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNextDlgTabItem", hDlg, hCtl, bPrevious);
            }
            return (MemorySegment)mh$.invokeExact(hDlg, hCtl, bPrevious);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgCtrlID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDlgCtrlID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDlgCtrlID(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetDlgCtrlID$descriptor() {
        return GetDlgCtrlID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDlgCtrlID(HWND hWnd)
     * }
     */
    public static MethodHandle GetDlgCtrlID$handle() {
        return GetDlgCtrlID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDlgCtrlID(HWND hWnd)
     * }
     */
    public static MemorySegment GetDlgCtrlID$address() {
        return GetDlgCtrlID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDlgCtrlID(HWND hWnd)
     * }
     */
    public static int GetDlgCtrlID(MemorySegment hWnd) {
        var mh$ = GetDlgCtrlID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgCtrlID", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDialogBaseUnits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDialogBaseUnits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long GetDialogBaseUnits()
     * }
     */
    public static FunctionDescriptor GetDialogBaseUnits$descriptor() {
        return GetDialogBaseUnits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long GetDialogBaseUnits()
     * }
     */
    public static MethodHandle GetDialogBaseUnits$handle() {
        return GetDialogBaseUnits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long GetDialogBaseUnits()
     * }
     */
    public static MemorySegment GetDialogBaseUnits$address() {
        return GetDialogBaseUnits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long GetDialogBaseUnits()
     * }
     */
    public static int GetDialogBaseUnits() {
        var mh$ = GetDialogBaseUnits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDialogBaseUnits");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefDlgProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DefDlgProcA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefDlgProcA$descriptor() {
        return DefDlgProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefDlgProcA$handle() {
        return DefDlgProcA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefDlgProcA$address() {
        return DefDlgProcA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefDlgProcA(MemorySegment hDlg, int Msg, long wParam, long lParam) {
        var mh$ = DefDlgProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefDlgProcA", hDlg, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefDlgProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DefDlgProcW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefDlgProcW$descriptor() {
        return DefDlgProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefDlgProcW$handle() {
        return DefDlgProcW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MemorySegment DefDlgProcW$address() {
        return DefDlgProcW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefDlgProcW(MemorySegment hDlg, int Msg, long wParam, long lParam) {
        var mh$ = DefDlgProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefDlgProcW", hDlg, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int DCDC_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DEFAULT = 0
     * }
     */
    public static int DCDC_DEFAULT() {
        return DCDC_DEFAULT;
    }
    private static final int DCDC_DISABLE_FONT_UPDATE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_FONT_UPDATE = 1
     * }
     */
    public static int DCDC_DISABLE_FONT_UPDATE() {
        return DCDC_DISABLE_FONT_UPDATE;
    }
    private static final int DCDC_DISABLE_RELAYOUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_RELAYOUT = 2
     * }
     */
    public static int DCDC_DISABLE_RELAYOUT() {
        return DCDC_DISABLE_RELAYOUT;
    }

    private static class SetDialogControlDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDialogControlDpiChangeBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDialogControlDpiChangeBehavior(HWND hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static FunctionDescriptor SetDialogControlDpiChangeBehavior$descriptor() {
        return SetDialogControlDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDialogControlDpiChangeBehavior(HWND hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static MethodHandle SetDialogControlDpiChangeBehavior$handle() {
        return SetDialogControlDpiChangeBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDialogControlDpiChangeBehavior(HWND hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static MemorySegment SetDialogControlDpiChangeBehavior$address() {
        return SetDialogControlDpiChangeBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDialogControlDpiChangeBehavior(HWND hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static int SetDialogControlDpiChangeBehavior(MemorySegment hWnd, int mask, int values) {
        var mh$ = SetDialogControlDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDialogControlDpiChangeBehavior", hWnd, mask, values);
            }
            return (int)mh$.invokeExact(hWnd, mask, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDialogControlDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDialogControlDpiChangeBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetDialogControlDpiChangeBehavior$descriptor() {
        return GetDialogControlDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(HWND hWnd)
     * }
     */
    public static MethodHandle GetDialogControlDpiChangeBehavior$handle() {
        return GetDialogControlDpiChangeBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(HWND hWnd)
     * }
     */
    public static MemorySegment GetDialogControlDpiChangeBehavior$address() {
        return GetDialogControlDpiChangeBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(HWND hWnd)
     * }
     */
    public static int GetDialogControlDpiChangeBehavior(MemorySegment hWnd) {
        var mh$ = GetDialogControlDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDialogControlDpiChangeBehavior", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int DDC_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DEFAULT = 0
     * }
     */
    public static int DDC_DEFAULT() {
        return DDC_DEFAULT;
    }
    private static final int DDC_DISABLE_ALL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_ALL = 1
     * }
     */
    public static int DDC_DISABLE_ALL() {
        return DDC_DISABLE_ALL;
    }
    private static final int DDC_DISABLE_RESIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_RESIZE = 2
     * }
     */
    public static int DDC_DISABLE_RESIZE() {
        return DDC_DISABLE_RESIZE;
    }
    private static final int DDC_DISABLE_CONTROL_RELAYOUT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_CONTROL_RELAYOUT = 4
     * }
     */
    public static int DDC_DISABLE_CONTROL_RELAYOUT() {
        return DDC_DISABLE_CONTROL_RELAYOUT;
    }

    private static class SetDialogDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDialogDpiChangeBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static FunctionDescriptor SetDialogDpiChangeBehavior$descriptor() {
        return SetDialogDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static MethodHandle SetDialogDpiChangeBehavior$handle() {
        return SetDialogDpiChangeBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static MemorySegment SetDialogDpiChangeBehavior$address() {
        return SetDialogDpiChangeBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static int SetDialogDpiChangeBehavior(MemorySegment hDlg, int mask, int values) {
        var mh$ = SetDialogDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDialogDpiChangeBehavior", hDlg, mask, values);
            }
            return (int)mh$.invokeExact(hDlg, mask, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDialogDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDialogDpiChangeBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(HWND hDlg)
     * }
     */
    public static FunctionDescriptor GetDialogDpiChangeBehavior$descriptor() {
        return GetDialogDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(HWND hDlg)
     * }
     */
    public static MethodHandle GetDialogDpiChangeBehavior$handle() {
        return GetDialogDpiChangeBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(HWND hDlg)
     * }
     */
    public static MemorySegment GetDialogDpiChangeBehavior$address() {
        return GetDialogDpiChangeBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(HWND hDlg)
     * }
     */
    public static int GetDialogDpiChangeBehavior(MemorySegment hDlg) {
        var mh$ = GetDialogDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDialogDpiChangeBehavior", hDlg);
            }
            return (int)mh$.invokeExact(hDlg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallMsgFilterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CallMsgFilterA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterA(LPMSG lpMsg, int nCode)
     * }
     */
    public static FunctionDescriptor CallMsgFilterA$descriptor() {
        return CallMsgFilterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterA(LPMSG lpMsg, int nCode)
     * }
     */
    public static MethodHandle CallMsgFilterA$handle() {
        return CallMsgFilterA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterA(LPMSG lpMsg, int nCode)
     * }
     */
    public static MemorySegment CallMsgFilterA$address() {
        return CallMsgFilterA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallMsgFilterA(LPMSG lpMsg, int nCode)
     * }
     */
    public static int CallMsgFilterA(MemorySegment lpMsg, int nCode) {
        var mh$ = CallMsgFilterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallMsgFilterA", lpMsg, nCode);
            }
            return (int)mh$.invokeExact(lpMsg, nCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallMsgFilterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CallMsgFilterW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterW(LPMSG lpMsg, int nCode)
     * }
     */
    public static FunctionDescriptor CallMsgFilterW$descriptor() {
        return CallMsgFilterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterW(LPMSG lpMsg, int nCode)
     * }
     */
    public static MethodHandle CallMsgFilterW$handle() {
        return CallMsgFilterW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterW(LPMSG lpMsg, int nCode)
     * }
     */
    public static MemorySegment CallMsgFilterW$address() {
        return CallMsgFilterW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallMsgFilterW(LPMSG lpMsg, int nCode)
     * }
     */
    public static int CallMsgFilterW(MemorySegment lpMsg, int nCode) {
        var mh$ = CallMsgFilterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallMsgFilterW", lpMsg, nCode);
            }
            return (int)mh$.invokeExact(lpMsg, nCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenClipboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenClipboard(HWND hWndNewOwner)
     * }
     */
    public static FunctionDescriptor OpenClipboard$descriptor() {
        return OpenClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenClipboard(HWND hWndNewOwner)
     * }
     */
    public static MethodHandle OpenClipboard$handle() {
        return OpenClipboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OpenClipboard(HWND hWndNewOwner)
     * }
     */
    public static MemorySegment OpenClipboard$address() {
        return OpenClipboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OpenClipboard(HWND hWndNewOwner)
     * }
     */
    public static int OpenClipboard(MemorySegment hWndNewOwner) {
        var mh$ = OpenClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenClipboard", hWndNewOwner);
            }
            return (int)mh$.invokeExact(hWndNewOwner);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseClipboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseClipboard()
     * }
     */
    public static FunctionDescriptor CloseClipboard$descriptor() {
        return CloseClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseClipboard()
     * }
     */
    public static MethodHandle CloseClipboard$handle() {
        return CloseClipboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseClipboard()
     * }
     */
    public static MemorySegment CloseClipboard$address() {
        return CloseClipboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseClipboard()
     * }
     */
    public static int CloseClipboard() {
        var mh$ = CloseClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseClipboard");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardSequenceNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClipboardSequenceNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetClipboardSequenceNumber()
     * }
     */
    public static FunctionDescriptor GetClipboardSequenceNumber$descriptor() {
        return GetClipboardSequenceNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetClipboardSequenceNumber()
     * }
     */
    public static MethodHandle GetClipboardSequenceNumber$handle() {
        return GetClipboardSequenceNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetClipboardSequenceNumber()
     * }
     */
    public static MemorySegment GetClipboardSequenceNumber$address() {
        return GetClipboardSequenceNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetClipboardSequenceNumber()
     * }
     */
    public static int GetClipboardSequenceNumber() {
        var mh$ = GetClipboardSequenceNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardSequenceNumber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardOwner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClipboardOwner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetClipboardOwner()
     * }
     */
    public static FunctionDescriptor GetClipboardOwner$descriptor() {
        return GetClipboardOwner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetClipboardOwner()
     * }
     */
    public static MethodHandle GetClipboardOwner$handle() {
        return GetClipboardOwner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetClipboardOwner()
     * }
     */
    public static MemorySegment GetClipboardOwner$address() {
        return GetClipboardOwner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetClipboardOwner()
     * }
     */
    public static MemorySegment GetClipboardOwner() {
        var mh$ = GetClipboardOwner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardOwner");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClipboardViewer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetClipboardViewer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetClipboardViewer(HWND hWndNewViewer)
     * }
     */
    public static FunctionDescriptor SetClipboardViewer$descriptor() {
        return SetClipboardViewer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetClipboardViewer(HWND hWndNewViewer)
     * }
     */
    public static MethodHandle SetClipboardViewer$handle() {
        return SetClipboardViewer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND SetClipboardViewer(HWND hWndNewViewer)
     * }
     */
    public static MemorySegment SetClipboardViewer$address() {
        return SetClipboardViewer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND SetClipboardViewer(HWND hWndNewViewer)
     * }
     */
    public static MemorySegment SetClipboardViewer(MemorySegment hWndNewViewer) {
        var mh$ = SetClipboardViewer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClipboardViewer", hWndNewViewer);
            }
            return (MemorySegment)mh$.invokeExact(hWndNewViewer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardViewer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClipboardViewer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetClipboardViewer()
     * }
     */
    public static FunctionDescriptor GetClipboardViewer$descriptor() {
        return GetClipboardViewer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetClipboardViewer()
     * }
     */
    public static MethodHandle GetClipboardViewer$handle() {
        return GetClipboardViewer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetClipboardViewer()
     * }
     */
    public static MemorySegment GetClipboardViewer$address() {
        return GetClipboardViewer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetClipboardViewer()
     * }
     */
    public static MemorySegment GetClipboardViewer() {
        var mh$ = GetClipboardViewer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardViewer");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeClipboardChain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChangeClipboardChain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
     * }
     */
    public static FunctionDescriptor ChangeClipboardChain$descriptor() {
        return ChangeClipboardChain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
     * }
     */
    public static MethodHandle ChangeClipboardChain$handle() {
        return ChangeClipboardChain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
     * }
     */
    public static MemorySegment ChangeClipboardChain$address() {
        return ChangeClipboardChain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
     * }
     */
    public static int ChangeClipboardChain(MemorySegment hWndRemove, MemorySegment hWndNewNext) {
        var mh$ = ChangeClipboardChain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeClipboardChain", hWndRemove, hWndNewNext);
            }
            return (int)mh$.invokeExact(hWndRemove, hWndNewNext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClipboardData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetClipboardData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE SetClipboardData(UINT uFormat, HANDLE hMem)
     * }
     */
    public static FunctionDescriptor SetClipboardData$descriptor() {
        return SetClipboardData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE SetClipboardData(UINT uFormat, HANDLE hMem)
     * }
     */
    public static MethodHandle SetClipboardData$handle() {
        return SetClipboardData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE SetClipboardData(UINT uFormat, HANDLE hMem)
     * }
     */
    public static MemorySegment SetClipboardData$address() {
        return SetClipboardData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE SetClipboardData(UINT uFormat, HANDLE hMem)
     * }
     */
    public static MemorySegment SetClipboardData(int uFormat, MemorySegment hMem) {
        var mh$ = SetClipboardData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClipboardData", uFormat, hMem);
            }
            return (MemorySegment)mh$.invokeExact(uFormat, hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClipboardData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetClipboardData(UINT uFormat)
     * }
     */
    public static FunctionDescriptor GetClipboardData$descriptor() {
        return GetClipboardData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetClipboardData(UINT uFormat)
     * }
     */
    public static MethodHandle GetClipboardData$handle() {
        return GetClipboardData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetClipboardData(UINT uFormat)
     * }
     */
    public static MemorySegment GetClipboardData$address() {
        return GetClipboardData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetClipboardData(UINT uFormat)
     * }
     */
    public static MemorySegment GetClipboardData(int uFormat) {
        var mh$ = GetClipboardData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardData", uFormat);
            }
            return (MemorySegment)mh$.invokeExact(uFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClipboardFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterClipboardFormatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatA(LPCSTR lpszFormat)
     * }
     */
    public static FunctionDescriptor RegisterClipboardFormatA$descriptor() {
        return RegisterClipboardFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatA(LPCSTR lpszFormat)
     * }
     */
    public static MethodHandle RegisterClipboardFormatA$handle() {
        return RegisterClipboardFormatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatA(LPCSTR lpszFormat)
     * }
     */
    public static MemorySegment RegisterClipboardFormatA$address() {
        return RegisterClipboardFormatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatA(LPCSTR lpszFormat)
     * }
     */
    public static int RegisterClipboardFormatA(MemorySegment lpszFormat) {
        var mh$ = RegisterClipboardFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClipboardFormatA", lpszFormat);
            }
            return (int)mh$.invokeExact(lpszFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClipboardFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterClipboardFormatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatW(LPCWSTR lpszFormat)
     * }
     */
    public static FunctionDescriptor RegisterClipboardFormatW$descriptor() {
        return RegisterClipboardFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatW(LPCWSTR lpszFormat)
     * }
     */
    public static MethodHandle RegisterClipboardFormatW$handle() {
        return RegisterClipboardFormatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatW(LPCWSTR lpszFormat)
     * }
     */
    public static MemorySegment RegisterClipboardFormatW$address() {
        return RegisterClipboardFormatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatW(LPCWSTR lpszFormat)
     * }
     */
    public static int RegisterClipboardFormatW(MemorySegment lpszFormat) {
        var mh$ = RegisterClipboardFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClipboardFormatW", lpszFormat);
            }
            return (int)mh$.invokeExact(lpszFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CountClipboardFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CountClipboardFormats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CountClipboardFormats()
     * }
     */
    public static FunctionDescriptor CountClipboardFormats$descriptor() {
        return CountClipboardFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CountClipboardFormats()
     * }
     */
    public static MethodHandle CountClipboardFormats$handle() {
        return CountClipboardFormats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CountClipboardFormats()
     * }
     */
    public static MemorySegment CountClipboardFormats$address() {
        return CountClipboardFormats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CountClipboardFormats()
     * }
     */
    public static int CountClipboardFormats() {
        var mh$ = CountClipboardFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CountClipboardFormats");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumClipboardFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumClipboardFormats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT EnumClipboardFormats(UINT format)
     * }
     */
    public static FunctionDescriptor EnumClipboardFormats$descriptor() {
        return EnumClipboardFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT EnumClipboardFormats(UINT format)
     * }
     */
    public static MethodHandle EnumClipboardFormats$handle() {
        return EnumClipboardFormats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT EnumClipboardFormats(UINT format)
     * }
     */
    public static MemorySegment EnumClipboardFormats$address() {
        return EnumClipboardFormats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT EnumClipboardFormats(UINT format)
     * }
     */
    public static int EnumClipboardFormats(int format) {
        var mh$ = EnumClipboardFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumClipboardFormats", format);
            }
            return (int)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardFormatNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClipboardFormatNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static FunctionDescriptor GetClipboardFormatNameA$descriptor() {
        return GetClipboardFormatNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static MethodHandle GetClipboardFormatNameA$handle() {
        return GetClipboardFormatNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static MemorySegment GetClipboardFormatNameA$address() {
        return GetClipboardFormatNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static int GetClipboardFormatNameA(int format, MemorySegment lpszFormatName, int cchMaxCount) {
        var mh$ = GetClipboardFormatNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardFormatNameA", format, lpszFormatName, cchMaxCount);
            }
            return (int)mh$.invokeExact(format, lpszFormatName, cchMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardFormatNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetClipboardFormatNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static FunctionDescriptor GetClipboardFormatNameW$descriptor() {
        return GetClipboardFormatNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static MethodHandle GetClipboardFormatNameW$handle() {
        return GetClipboardFormatNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static MemorySegment GetClipboardFormatNameW$address() {
        return GetClipboardFormatNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static int GetClipboardFormatNameW(int format, MemorySegment lpszFormatName, int cchMaxCount) {
        var mh$ = GetClipboardFormatNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardFormatNameW", format, lpszFormatName, cchMaxCount);
            }
            return (int)mh$.invokeExact(format, lpszFormatName, cchMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EmptyClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EmptyClipboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EmptyClipboard()
     * }
     */
    public static FunctionDescriptor EmptyClipboard$descriptor() {
        return EmptyClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EmptyClipboard()
     * }
     */
    public static MethodHandle EmptyClipboard$handle() {
        return EmptyClipboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EmptyClipboard()
     * }
     */
    public static MemorySegment EmptyClipboard$address() {
        return EmptyClipboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EmptyClipboard()
     * }
     */
    public static int EmptyClipboard() {
        var mh$ = EmptyClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EmptyClipboard");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsClipboardFormatAvailable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsClipboardFormatAvailable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsClipboardFormatAvailable(UINT format)
     * }
     */
    public static FunctionDescriptor IsClipboardFormatAvailable$descriptor() {
        return IsClipboardFormatAvailable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsClipboardFormatAvailable(UINT format)
     * }
     */
    public static MethodHandle IsClipboardFormatAvailable$handle() {
        return IsClipboardFormatAvailable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsClipboardFormatAvailable(UINT format)
     * }
     */
    public static MemorySegment IsClipboardFormatAvailable$address() {
        return IsClipboardFormatAvailable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsClipboardFormatAvailable(UINT format)
     * }
     */
    public static int IsClipboardFormatAvailable(int format) {
        var mh$ = IsClipboardFormatAvailable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsClipboardFormatAvailable", format);
            }
            return (int)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPriorityClipboardFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPriorityClipboardFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats)
     * }
     */
    public static FunctionDescriptor GetPriorityClipboardFormat$descriptor() {
        return GetPriorityClipboardFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats)
     * }
     */
    public static MethodHandle GetPriorityClipboardFormat$handle() {
        return GetPriorityClipboardFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats)
     * }
     */
    public static MemorySegment GetPriorityClipboardFormat$address() {
        return GetPriorityClipboardFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats)
     * }
     */
    public static int GetPriorityClipboardFormat(MemorySegment paFormatPriorityList, int cFormats) {
        var mh$ = GetPriorityClipboardFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPriorityClipboardFormat", paFormatPriorityList, cFormats);
            }
            return (int)mh$.invokeExact(paFormatPriorityList, cFormats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOpenClipboardWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetOpenClipboardWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetOpenClipboardWindow()
     * }
     */
    public static FunctionDescriptor GetOpenClipboardWindow$descriptor() {
        return GetOpenClipboardWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetOpenClipboardWindow()
     * }
     */
    public static MethodHandle GetOpenClipboardWindow$handle() {
        return GetOpenClipboardWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetOpenClipboardWindow()
     * }
     */
    public static MemorySegment GetOpenClipboardWindow$address() {
        return GetOpenClipboardWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetOpenClipboardWindow()
     * }
     */
    public static MemorySegment GetOpenClipboardWindow() {
        var mh$ = GetOpenClipboardWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOpenClipboardWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddClipboardFormatListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddClipboardFormatListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddClipboardFormatListener(HWND hwnd)
     * }
     */
    public static FunctionDescriptor AddClipboardFormatListener$descriptor() {
        return AddClipboardFormatListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddClipboardFormatListener(HWND hwnd)
     * }
     */
    public static MethodHandle AddClipboardFormatListener$handle() {
        return AddClipboardFormatListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddClipboardFormatListener(HWND hwnd)
     * }
     */
    public static MemorySegment AddClipboardFormatListener$address() {
        return AddClipboardFormatListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddClipboardFormatListener(HWND hwnd)
     * }
     */
    public static int AddClipboardFormatListener(MemorySegment hwnd) {
        var mh$ = AddClipboardFormatListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddClipboardFormatListener", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveClipboardFormatListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveClipboardFormatListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveClipboardFormatListener(HWND hwnd)
     * }
     */
    public static FunctionDescriptor RemoveClipboardFormatListener$descriptor() {
        return RemoveClipboardFormatListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveClipboardFormatListener(HWND hwnd)
     * }
     */
    public static MethodHandle RemoveClipboardFormatListener$handle() {
        return RemoveClipboardFormatListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveClipboardFormatListener(HWND hwnd)
     * }
     */
    public static MemorySegment RemoveClipboardFormatListener$address() {
        return RemoveClipboardFormatListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveClipboardFormatListener(HWND hwnd)
     * }
     */
    public static int RemoveClipboardFormatListener(MemorySegment hwnd) {
        var mh$ = RemoveClipboardFormatListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveClipboardFormatListener", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUpdatedClipboardFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetUpdatedClipboardFormats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut)
     * }
     */
    public static FunctionDescriptor GetUpdatedClipboardFormats$descriptor() {
        return GetUpdatedClipboardFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut)
     * }
     */
    public static MethodHandle GetUpdatedClipboardFormats$handle() {
        return GetUpdatedClipboardFormats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut)
     * }
     */
    public static MemorySegment GetUpdatedClipboardFormats$address() {
        return GetUpdatedClipboardFormats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut)
     * }
     */
    public static int GetUpdatedClipboardFormats(MemorySegment lpuiFormats, int cFormats, MemorySegment pcFormatsOut) {
        var mh$ = GetUpdatedClipboardFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUpdatedClipboardFormats", lpuiFormats, cFormats, pcFormatsOut);
            }
            return (int)mh$.invokeExact(lpuiFormats, cFormats, pcFormatsOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharToOemA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static FunctionDescriptor CharToOemA$descriptor() {
        return CharToOemA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static MethodHandle CharToOemA$handle() {
        return CharToOemA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CharToOemA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static MemorySegment CharToOemA$address() {
        return CharToOemA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CharToOemA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static int CharToOemA(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = CharToOemA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemA", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharToOemW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemW(LPCWSTR pSrc, LPSTR pDst)
     * }
     */
    public static FunctionDescriptor CharToOemW$descriptor() {
        return CharToOemW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemW(LPCWSTR pSrc, LPSTR pDst)
     * }
     */
    public static MethodHandle CharToOemW$handle() {
        return CharToOemW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CharToOemW(LPCWSTR pSrc, LPSTR pDst)
     * }
     */
    public static MemorySegment CharToOemW$address() {
        return CharToOemW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CharToOemW(LPCWSTR pSrc, LPSTR pDst)
     * }
     */
    public static int CharToOemW(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = CharToOemW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemW", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OemToCharA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static FunctionDescriptor OemToCharA$descriptor() {
        return OemToCharA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static MethodHandle OemToCharA$handle() {
        return OemToCharA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OemToCharA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static MemorySegment OemToCharA$address() {
        return OemToCharA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OemToCharA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static int OemToCharA(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = OemToCharA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharA", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OemToCharW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharW(LPCSTR pSrc, LPWSTR pDst)
     * }
     */
    public static FunctionDescriptor OemToCharW$descriptor() {
        return OemToCharW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharW(LPCSTR pSrc, LPWSTR pDst)
     * }
     */
    public static MethodHandle OemToCharW$handle() {
        return OemToCharW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OemToCharW(LPCSTR pSrc, LPWSTR pDst)
     * }
     */
    public static MemorySegment OemToCharW$address() {
        return OemToCharW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OemToCharW(LPCSTR pSrc, LPWSTR pDst)
     * }
     */
    public static int OemToCharW(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = OemToCharW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharW", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharToOemBuffA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor CharToOemBuffA$descriptor() {
        return CharToOemBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle CharToOemBuffA$handle() {
        return CharToOemBuffA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MemorySegment CharToOemBuffA$address() {
        return CharToOemBuffA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int CharToOemBuffA(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = CharToOemBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemBuffA", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharToOemBuffW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor CharToOemBuffW$descriptor() {
        return CharToOemBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle CharToOemBuffW$handle() {
        return CharToOemBuffW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MemorySegment CharToOemBuffW$address() {
        return CharToOemBuffW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int CharToOemBuffW(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = CharToOemBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemBuffW", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OemToCharBuffA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor OemToCharBuffA$descriptor() {
        return OemToCharBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle OemToCharBuffA$handle() {
        return OemToCharBuffA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MemorySegment OemToCharBuffA$address() {
        return OemToCharBuffA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int OemToCharBuffA(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = OemToCharBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharBuffA", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OemToCharBuffW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor OemToCharBuffW$descriptor() {
        return OemToCharBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle OemToCharBuffW$handle() {
        return OemToCharBuffW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MemorySegment OemToCharBuffW$address() {
        return OemToCharBuffW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int OemToCharBuffW(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = OemToCharBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharBuffW", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharUpperA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharUpperA(LPSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharUpperA$descriptor() {
        return CharUpperA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharUpperA(LPSTR lpsz)
     * }
     */
    public static MethodHandle CharUpperA$handle() {
        return CharUpperA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharUpperA(LPSTR lpsz)
     * }
     */
    public static MemorySegment CharUpperA$address() {
        return CharUpperA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharUpperA(LPSTR lpsz)
     * }
     */
    public static MemorySegment CharUpperA(MemorySegment lpsz) {
        var mh$ = CharUpperA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperA", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharUpperW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharUpperW(LPWSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharUpperW$descriptor() {
        return CharUpperW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharUpperW(LPWSTR lpsz)
     * }
     */
    public static MethodHandle CharUpperW$handle() {
        return CharUpperW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR CharUpperW(LPWSTR lpsz)
     * }
     */
    public static MemorySegment CharUpperW$address() {
        return CharUpperW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR CharUpperW(LPWSTR lpsz)
     * }
     */
    public static MemorySegment CharUpperW(MemorySegment lpsz) {
        var mh$ = CharUpperW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperW", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharUpperBuffA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharUpperBuffA$descriptor() {
        return CharUpperBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharUpperBuffA$handle() {
        return CharUpperBuffA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static MemorySegment CharUpperBuffA$address() {
        return CharUpperBuffA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CharUpperBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharUpperBuffA(MemorySegment lpsz, int cchLength) {
        var mh$ = CharUpperBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperBuffA", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharUpperBuffW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharUpperBuffW$descriptor() {
        return CharUpperBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharUpperBuffW$handle() {
        return CharUpperBuffW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static MemorySegment CharUpperBuffW$address() {
        return CharUpperBuffW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CharUpperBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharUpperBuffW(MemorySegment lpsz, int cchLength) {
        var mh$ = CharUpperBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperBuffW", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharLowerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharLowerA(LPSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharLowerA$descriptor() {
        return CharLowerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharLowerA(LPSTR lpsz)
     * }
     */
    public static MethodHandle CharLowerA$handle() {
        return CharLowerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharLowerA(LPSTR lpsz)
     * }
     */
    public static MemorySegment CharLowerA$address() {
        return CharLowerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharLowerA(LPSTR lpsz)
     * }
     */
    public static MemorySegment CharLowerA(MemorySegment lpsz) {
        var mh$ = CharLowerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerA", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharLowerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharLowerW(LPWSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharLowerW$descriptor() {
        return CharLowerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharLowerW(LPWSTR lpsz)
     * }
     */
    public static MethodHandle CharLowerW$handle() {
        return CharLowerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR CharLowerW(LPWSTR lpsz)
     * }
     */
    public static MemorySegment CharLowerW$address() {
        return CharLowerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR CharLowerW(LPWSTR lpsz)
     * }
     */
    public static MemorySegment CharLowerW(MemorySegment lpsz) {
        var mh$ = CharLowerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerW", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharLowerBuffA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharLowerBuffA$descriptor() {
        return CharLowerBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharLowerBuffA$handle() {
        return CharLowerBuffA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static MemorySegment CharLowerBuffA$address() {
        return CharLowerBuffA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CharLowerBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharLowerBuffA(MemorySegment lpsz, int cchLength) {
        var mh$ = CharLowerBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerBuffA", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharLowerBuffW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharLowerBuffW$descriptor() {
        return CharLowerBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharLowerBuffW$handle() {
        return CharLowerBuffW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static MemorySegment CharLowerBuffW$address() {
        return CharLowerBuffW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CharLowerBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharLowerBuffW(MemorySegment lpsz, int cchLength) {
        var mh$ = CharLowerBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerBuffW", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharNextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharNextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharNextA(LPCSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharNextA$descriptor() {
        return CharNextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharNextA(LPCSTR lpsz)
     * }
     */
    public static MethodHandle CharNextA$handle() {
        return CharNextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharNextA(LPCSTR lpsz)
     * }
     */
    public static MemorySegment CharNextA$address() {
        return CharNextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharNextA(LPCSTR lpsz)
     * }
     */
    public static MemorySegment CharNextA(MemorySegment lpsz) {
        var mh$ = CharNextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharNextA", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharNextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharNextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharNextW(LPCWSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharNextW$descriptor() {
        return CharNextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharNextW(LPCWSTR lpsz)
     * }
     */
    public static MethodHandle CharNextW$handle() {
        return CharNextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR CharNextW(LPCWSTR lpsz)
     * }
     */
    public static MemorySegment CharNextW$address() {
        return CharNextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR CharNextW(LPCWSTR lpsz)
     * }
     */
    public static MemorySegment CharNextW(MemorySegment lpsz) {
        var mh$ = CharNextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharNextW", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharPrevA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharPrevA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent)
     * }
     */
    public static FunctionDescriptor CharPrevA$descriptor() {
        return CharPrevA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent)
     * }
     */
    public static MethodHandle CharPrevA$handle() {
        return CharPrevA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent)
     * }
     */
    public static MemorySegment CharPrevA$address() {
        return CharPrevA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent)
     * }
     */
    public static MemorySegment CharPrevA(MemorySegment lpszStart, MemorySegment lpszCurrent) {
        var mh$ = CharPrevA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharPrevA", lpszStart, lpszCurrent);
            }
            return (MemorySegment)mh$.invokeExact(lpszStart, lpszCurrent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharPrevW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharPrevW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
     * }
     */
    public static FunctionDescriptor CharPrevW$descriptor() {
        return CharPrevW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
     * }
     */
    public static MethodHandle CharPrevW$handle() {
        return CharPrevW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
     * }
     */
    public static MemorySegment CharPrevW$address() {
        return CharPrevW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
     * }
     */
    public static MemorySegment CharPrevW(MemorySegment lpszStart, MemorySegment lpszCurrent) {
        var mh$ = CharPrevW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharPrevW", lpszStart, lpszCurrent);
            }
            return (MemorySegment)mh$.invokeExact(lpszStart, lpszCurrent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharNextExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharNextExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CharNextExA$descriptor() {
        return CharNextExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MethodHandle CharNextExA$handle() {
        return CharNextExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MemorySegment CharNextExA$address() {
        return CharNextExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MemorySegment CharNextExA(short CodePage, MemorySegment lpCurrentChar, int dwFlags) {
        var mh$ = CharNextExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharNextExA", CodePage, lpCurrentChar, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(CodePage, lpCurrentChar, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharPrevExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CharPrevExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CharPrevExA$descriptor() {
        return CharPrevExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MethodHandle CharPrevExA$handle() {
        return CharPrevExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MemorySegment CharPrevExA$address() {
        return CharPrevExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MemorySegment CharPrevExA(short CodePage, MemorySegment lpStart, MemorySegment lpCurrentChar, int dwFlags) {
        var mh$ = CharPrevExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharPrevExA", CodePage, lpStart, lpCurrentChar, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(CodePage, lpStart, lpCurrentChar, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsCharAlphaA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaA$descriptor() {
        return IsCharAlphaA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaA$handle() {
        return IsCharAlphaA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaA(CHAR ch)
     * }
     */
    public static MemorySegment IsCharAlphaA$address() {
        return IsCharAlphaA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaA(CHAR ch)
     * }
     */
    public static int IsCharAlphaA(byte ch) {
        var mh$ = IsCharAlphaA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsCharAlphaW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaW$descriptor() {
        return IsCharAlphaW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaW$handle() {
        return IsCharAlphaW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaW(WCHAR ch)
     * }
     */
    public static MemorySegment IsCharAlphaW$address() {
        return IsCharAlphaW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaW(WCHAR ch)
     * }
     */
    public static int IsCharAlphaW(short ch) {
        var mh$ = IsCharAlphaW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaNumericA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsCharAlphaNumericA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaNumericA$descriptor() {
        return IsCharAlphaNumericA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaNumericA$handle() {
        return IsCharAlphaNumericA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericA(CHAR ch)
     * }
     */
    public static MemorySegment IsCharAlphaNumericA$address() {
        return IsCharAlphaNumericA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericA(CHAR ch)
     * }
     */
    public static int IsCharAlphaNumericA(byte ch) {
        var mh$ = IsCharAlphaNumericA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaNumericA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaNumericW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsCharAlphaNumericW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaNumericW$descriptor() {
        return IsCharAlphaNumericW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaNumericW$handle() {
        return IsCharAlphaNumericW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericW(WCHAR ch)
     * }
     */
    public static MemorySegment IsCharAlphaNumericW$address() {
        return IsCharAlphaNumericW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericW(WCHAR ch)
     * }
     */
    public static int IsCharAlphaNumericW(short ch) {
        var mh$ = IsCharAlphaNumericW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaNumericW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharUpperA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsCharUpperA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharUpperA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharUpperA$descriptor() {
        return IsCharUpperA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharUpperA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharUpperA$handle() {
        return IsCharUpperA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharUpperA(CHAR ch)
     * }
     */
    public static MemorySegment IsCharUpperA$address() {
        return IsCharUpperA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharUpperA(CHAR ch)
     * }
     */
    public static int IsCharUpperA(byte ch) {
        var mh$ = IsCharUpperA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharUpperA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharUpperW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsCharUpperW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharUpperW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharUpperW$descriptor() {
        return IsCharUpperW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharUpperW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharUpperW$handle() {
        return IsCharUpperW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharUpperW(WCHAR ch)
     * }
     */
    public static MemorySegment IsCharUpperW$address() {
        return IsCharUpperW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharUpperW(WCHAR ch)
     * }
     */
    public static int IsCharUpperW(short ch) {
        var mh$ = IsCharUpperW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharUpperW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharLowerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsCharLowerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharLowerA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharLowerA$descriptor() {
        return IsCharLowerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharLowerA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharLowerA$handle() {
        return IsCharLowerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharLowerA(CHAR ch)
     * }
     */
    public static MemorySegment IsCharLowerA$address() {
        return IsCharLowerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharLowerA(CHAR ch)
     * }
     */
    public static int IsCharLowerA(byte ch) {
        var mh$ = IsCharLowerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharLowerA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharLowerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsCharLowerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharLowerW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharLowerW$descriptor() {
        return IsCharLowerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharLowerW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharLowerW$handle() {
        return IsCharLowerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsCharLowerW(WCHAR ch)
     * }
     */
    public static MemorySegment IsCharLowerW$address() {
        return IsCharLowerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsCharLowerW(WCHAR ch)
     * }
     */
    public static int IsCharLowerW(short ch) {
        var mh$ = IsCharLowerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharLowerW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFocus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFocus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetFocus(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetFocus$descriptor() {
        return SetFocus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetFocus(HWND hWnd)
     * }
     */
    public static MethodHandle SetFocus$handle() {
        return SetFocus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND SetFocus(HWND hWnd)
     * }
     */
    public static MemorySegment SetFocus$address() {
        return SetFocus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND SetFocus(HWND hWnd)
     * }
     */
    public static MemorySegment SetFocus(MemorySegment hWnd) {
        var mh$ = SetFocus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFocus", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetActiveWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetActiveWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetActiveWindow()
     * }
     */
    public static FunctionDescriptor GetActiveWindow$descriptor() {
        return GetActiveWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetActiveWindow()
     * }
     */
    public static MethodHandle GetActiveWindow$handle() {
        return GetActiveWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetActiveWindow()
     * }
     */
    public static MemorySegment GetActiveWindow$address() {
        return GetActiveWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetActiveWindow()
     * }
     */
    public static MemorySegment GetActiveWindow() {
        var mh$ = GetActiveWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetActiveWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFocus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFocus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetFocus()
     * }
     */
    public static FunctionDescriptor GetFocus$descriptor() {
        return GetFocus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetFocus()
     * }
     */
    public static MethodHandle GetFocus$handle() {
        return GetFocus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetFocus()
     * }
     */
    public static MemorySegment GetFocus$address() {
        return GetFocus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetFocus()
     * }
     */
    public static MemorySegment GetFocus() {
        var mh$ = GetFocus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFocus");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKBCodePage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKBCodePage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetKBCodePage()
     * }
     */
    public static FunctionDescriptor GetKBCodePage$descriptor() {
        return GetKBCodePage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetKBCodePage()
     * }
     */
    public static MethodHandle GetKBCodePage$handle() {
        return GetKBCodePage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetKBCodePage()
     * }
     */
    public static MemorySegment GetKBCodePage$address() {
        return GetKBCodePage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetKBCodePage()
     * }
     */
    public static int GetKBCodePage() {
        var mh$ = GetKBCodePage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKBCodePage");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKeyState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT GetKeyState(int nVirtKey)
     * }
     */
    public static FunctionDescriptor GetKeyState$descriptor() {
        return GetKeyState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT GetKeyState(int nVirtKey)
     * }
     */
    public static MethodHandle GetKeyState$handle() {
        return GetKeyState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT GetKeyState(int nVirtKey)
     * }
     */
    public static MemorySegment GetKeyState$address() {
        return GetKeyState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT GetKeyState(int nVirtKey)
     * }
     */
    public static short GetKeyState(int nVirtKey) {
        var mh$ = GetKeyState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyState", nVirtKey);
            }
            return (short)mh$.invokeExact(nVirtKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAsyncKeyState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetAsyncKeyState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT GetAsyncKeyState(int vKey)
     * }
     */
    public static FunctionDescriptor GetAsyncKeyState$descriptor() {
        return GetAsyncKeyState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT GetAsyncKeyState(int vKey)
     * }
     */
    public static MethodHandle GetAsyncKeyState$handle() {
        return GetAsyncKeyState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT GetAsyncKeyState(int vKey)
     * }
     */
    public static MemorySegment GetAsyncKeyState$address() {
        return GetAsyncKeyState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT GetAsyncKeyState(int vKey)
     * }
     */
    public static short GetAsyncKeyState(int vKey) {
        var mh$ = GetAsyncKeyState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAsyncKeyState", vKey);
            }
            return (short)mh$.invokeExact(vKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKeyboardState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKeyboardState(PBYTE lpKeyState)
     * }
     */
    public static FunctionDescriptor GetKeyboardState$descriptor() {
        return GetKeyboardState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKeyboardState(PBYTE lpKeyState)
     * }
     */
    public static MethodHandle GetKeyboardState$handle() {
        return GetKeyboardState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetKeyboardState(PBYTE lpKeyState)
     * }
     */
    public static MemorySegment GetKeyboardState$address() {
        return GetKeyboardState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetKeyboardState(PBYTE lpKeyState)
     * }
     */
    public static int GetKeyboardState(MemorySegment lpKeyState) {
        var mh$ = GetKeyboardState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardState", lpKeyState);
            }
            return (int)mh$.invokeExact(lpKeyState);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetKeyboardState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetKeyboardState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetKeyboardState(LPBYTE lpKeyState)
     * }
     */
    public static FunctionDescriptor SetKeyboardState$descriptor() {
        return SetKeyboardState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetKeyboardState(LPBYTE lpKeyState)
     * }
     */
    public static MethodHandle SetKeyboardState$handle() {
        return SetKeyboardState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetKeyboardState(LPBYTE lpKeyState)
     * }
     */
    public static MemorySegment SetKeyboardState$address() {
        return SetKeyboardState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetKeyboardState(LPBYTE lpKeyState)
     * }
     */
    public static int SetKeyboardState(MemorySegment lpKeyState) {
        var mh$ = SetKeyboardState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetKeyboardState", lpKeyState);
            }
            return (int)mh$.invokeExact(lpKeyState);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyNameTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKeyNameTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize)
     * }
     */
    public static FunctionDescriptor GetKeyNameTextA$descriptor() {
        return GetKeyNameTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize)
     * }
     */
    public static MethodHandle GetKeyNameTextA$handle() {
        return GetKeyNameTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize)
     * }
     */
    public static MemorySegment GetKeyNameTextA$address() {
        return GetKeyNameTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize)
     * }
     */
    public static int GetKeyNameTextA(int lParam, MemorySegment lpString, int cchSize) {
        var mh$ = GetKeyNameTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyNameTextA", lParam, lpString, cchSize);
            }
            return (int)mh$.invokeExact(lParam, lpString, cchSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyNameTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKeyNameTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize)
     * }
     */
    public static FunctionDescriptor GetKeyNameTextW$descriptor() {
        return GetKeyNameTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize)
     * }
     */
    public static MethodHandle GetKeyNameTextW$handle() {
        return GetKeyNameTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize)
     * }
     */
    public static MemorySegment GetKeyNameTextW$address() {
        return GetKeyNameTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize)
     * }
     */
    public static int GetKeyNameTextW(int lParam, MemorySegment lpString, int cchSize) {
        var mh$ = GetKeyNameTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyNameTextW", lParam, lpString, cchSize);
            }
            return (int)mh$.invokeExact(lParam, lpString, cchSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKeyboardType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyboardType(int nTypeFlag)
     * }
     */
    public static FunctionDescriptor GetKeyboardType$descriptor() {
        return GetKeyboardType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyboardType(int nTypeFlag)
     * }
     */
    public static MethodHandle GetKeyboardType$handle() {
        return GetKeyboardType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetKeyboardType(int nTypeFlag)
     * }
     */
    public static MemorySegment GetKeyboardType$address() {
        return GetKeyboardType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetKeyboardType(int nTypeFlag)
     * }
     */
    public static int GetKeyboardType(int nTypeFlag) {
        var mh$ = GetKeyboardType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardType", nTypeFlag);
            }
            return (int)mh$.invokeExact(nTypeFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToAscii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ToAscii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags)
     * }
     */
    public static FunctionDescriptor ToAscii$descriptor() {
        return ToAscii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags)
     * }
     */
    public static MethodHandle ToAscii$handle() {
        return ToAscii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags)
     * }
     */
    public static MemorySegment ToAscii$address() {
        return ToAscii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags)
     * }
     */
    public static int ToAscii(int uVirtKey, int uScanCode, MemorySegment lpKeyState, MemorySegment lpChar, int uFlags) {
        var mh$ = ToAscii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToAscii", uVirtKey, uScanCode, lpKeyState, lpChar, uFlags);
            }
            return (int)mh$.invokeExact(uVirtKey, uScanCode, lpKeyState, lpChar, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToAsciiEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ToAsciiEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor ToAsciiEx$descriptor() {
        return ToAsciiEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl)
     * }
     */
    public static MethodHandle ToAsciiEx$handle() {
        return ToAsciiEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl)
     * }
     */
    public static MemorySegment ToAsciiEx$address() {
        return ToAsciiEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl)
     * }
     */
    public static int ToAsciiEx(int uVirtKey, int uScanCode, MemorySegment lpKeyState, MemorySegment lpChar, int uFlags, MemorySegment dwhkl) {
        var mh$ = ToAsciiEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToAsciiEx", uVirtKey, uScanCode, lpKeyState, lpChar, uFlags, dwhkl);
            }
            return (int)mh$.invokeExact(uVirtKey, uScanCode, lpKeyState, lpChar, uFlags, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ToUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags)
     * }
     */
    public static FunctionDescriptor ToUnicode$descriptor() {
        return ToUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags)
     * }
     */
    public static MethodHandle ToUnicode$handle() {
        return ToUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags)
     * }
     */
    public static MemorySegment ToUnicode$address() {
        return ToUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags)
     * }
     */
    public static int ToUnicode(int wVirtKey, int wScanCode, MemorySegment lpKeyState, MemorySegment pwszBuff, int cchBuff, int wFlags) {
        var mh$ = ToUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToUnicode", wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags);
            }
            return (int)mh$.invokeExact(wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemKeyScan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OemKeyScan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OemKeyScan(WORD wOemChar)
     * }
     */
    public static FunctionDescriptor OemKeyScan$descriptor() {
        return OemKeyScan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OemKeyScan(WORD wOemChar)
     * }
     */
    public static MethodHandle OemKeyScan$handle() {
        return OemKeyScan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD OemKeyScan(WORD wOemChar)
     * }
     */
    public static MemorySegment OemKeyScan$address() {
        return OemKeyScan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD OemKeyScan(WORD wOemChar)
     * }
     */
    public static int OemKeyScan(short wOemChar) {
        var mh$ = OemKeyScan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemKeyScan", wOemChar);
            }
            return (int)mh$.invokeExact(wOemChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VkKeyScanA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanA(CHAR ch)
     * }
     */
    public static FunctionDescriptor VkKeyScanA$descriptor() {
        return VkKeyScanA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanA(CHAR ch)
     * }
     */
    public static MethodHandle VkKeyScanA$handle() {
        return VkKeyScanA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT VkKeyScanA(CHAR ch)
     * }
     */
    public static MemorySegment VkKeyScanA$address() {
        return VkKeyScanA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanA(CHAR ch)
     * }
     */
    public static short VkKeyScanA(byte ch) {
        var mh$ = VkKeyScanA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanA", ch);
            }
            return (short)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VkKeyScanW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor VkKeyScanW$descriptor() {
        return VkKeyScanW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanW(WCHAR ch)
     * }
     */
    public static MethodHandle VkKeyScanW$handle() {
        return VkKeyScanW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT VkKeyScanW(WCHAR ch)
     * }
     */
    public static MemorySegment VkKeyScanW$address() {
        return VkKeyScanW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanW(WCHAR ch)
     * }
     */
    public static short VkKeyScanW(short ch) {
        var mh$ = VkKeyScanW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanW", ch);
            }
            return (short)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_CHAR,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VkKeyScanExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExA(CHAR ch, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor VkKeyScanExA$descriptor() {
        return VkKeyScanExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExA(CHAR ch, HKL dwhkl)
     * }
     */
    public static MethodHandle VkKeyScanExA$handle() {
        return VkKeyScanExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExA(CHAR ch, HKL dwhkl)
     * }
     */
    public static MemorySegment VkKeyScanExA$address() {
        return VkKeyScanExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanExA(CHAR ch, HKL dwhkl)
     * }
     */
    public static short VkKeyScanExA(byte ch, MemorySegment dwhkl) {
        var mh$ = VkKeyScanExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanExA", ch, dwhkl);
            }
            return (short)mh$.invokeExact(ch, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VkKeyScanExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExW(WCHAR ch, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor VkKeyScanExW$descriptor() {
        return VkKeyScanExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExW(WCHAR ch, HKL dwhkl)
     * }
     */
    public static MethodHandle VkKeyScanExW$handle() {
        return VkKeyScanExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExW(WCHAR ch, HKL dwhkl)
     * }
     */
    public static MemorySegment VkKeyScanExW$address() {
        return VkKeyScanExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanExW(WCHAR ch, HKL dwhkl)
     * }
     */
    public static short VkKeyScanExW(short ch, MemorySegment dwhkl) {
        var mh$ = VkKeyScanExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanExW", ch, dwhkl);
            }
            return (short)mh$.invokeExact(ch, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class keybd_event {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_CHAR,
            wgl_h.C_CHAR,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("keybd_event");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
     * }
     */
    public static FunctionDescriptor keybd_event$descriptor() {
        return keybd_event.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
     * }
     */
    public static MethodHandle keybd_event$handle() {
        return keybd_event.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
     * }
     */
    public static MemorySegment keybd_event$address() {
        return keybd_event.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
     * }
     */
    public static void keybd_event(byte bVk, byte bScan, int dwFlags, long dwExtraInfo) {
        var mh$ = keybd_event.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("keybd_event", bVk, bScan, dwFlags, dwExtraInfo);
            }
            mh$.invokeExact(bVk, bScan, dwFlags, dwExtraInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mouse_event {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("mouse_event");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
     * }
     */
    public static FunctionDescriptor mouse_event$descriptor() {
        return mouse_event.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
     * }
     */
    public static MethodHandle mouse_event$handle() {
        return mouse_event.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
     * }
     */
    public static MemorySegment mouse_event$address() {
        return mouse_event.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
     * }
     */
    public static void mouse_event(int dwFlags, int dx, int dy, int dwData, long dwExtraInfo) {
        var mh$ = mouse_event.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mouse_event", dwFlags, dx, dy, dwData, dwExtraInfo);
            }
            mh$.invokeExact(dwFlags, dx, dy, dwData, dwExtraInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEINPUT {
     *     LONG dx;
     *     LONG dy;
     *     DWORD mouseData;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PMOUSEINPUT
     * }
     */
    public static final AddressLayout PMOUSEINPUT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEINPUT {
     *     LONG dx;
     *     LONG dy;
     *     DWORD mouseData;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMOUSEINPUT
     * }
     */
    public static final AddressLayout LPMOUSEINPUT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKEYBDINPUT {
     *     WORD wVk;
     *     WORD wScan;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PKEYBDINPUT
     * }
     */
    public static final AddressLayout PKEYBDINPUT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKEYBDINPUT {
     *     WORD wVk;
     *     WORD wScan;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPKEYBDINPUT
     * }
     */
    public static final AddressLayout LPKEYBDINPUT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREINPUT {
     *     DWORD uMsg;
     *     WORD wParamL;
     *     WORD wParamH;
     * } *PHARDWAREINPUT
     * }
     */
    public static final AddressLayout PHARDWAREINPUT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREINPUT {
     *     DWORD uMsg;
     *     WORD wParamL;
     *     WORD wParamH;
     * } *LPHARDWAREINPUT
     * }
     */
    public static final AddressLayout LPHARDWAREINPUT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagINPUT {
     *     DWORD type;
     *     union {
     *         MOUSEINPUT mi;
     *         KEYBDINPUT ki;
     *         HARDWAREINPUT hi;
     *     };
     * } *PINPUT
     * }
     */
    public static final AddressLayout PINPUT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagINPUT {
     *     DWORD type;
     *     union {
     *         MOUSEINPUT mi;
     *         KEYBDINPUT ki;
     *         HARDWAREINPUT hi;
     *     };
     * } *LPINPUT
     * }
     */
    public static final AddressLayout LPINPUT = wgl_h.C_POINTER;

    private static class SendInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SendInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SendInput(UINT cInputs, LPINPUT pInputs, int cbSize)
     * }
     */
    public static FunctionDescriptor SendInput$descriptor() {
        return SendInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SendInput(UINT cInputs, LPINPUT pInputs, int cbSize)
     * }
     */
    public static MethodHandle SendInput$handle() {
        return SendInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SendInput(UINT cInputs, LPINPUT pInputs, int cbSize)
     * }
     */
    public static MemorySegment SendInput$address() {
        return SendInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SendInput(UINT cInputs, LPINPUT pInputs, int cbSize)
     * }
     */
    public static int SendInput(int cInputs, MemorySegment pInputs, int cbSize) {
        var mh$ = SendInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendInput", cInputs, pInputs, cbSize);
            }
            return (int)mh$.invokeExact(cInputs, pInputs, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HTOUCHINPUT__ {
     *     int unused;
     * } *HTOUCHINPUT
     * }
     */
    public static final AddressLayout HTOUCHINPUT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTOUCHINPUT {
     *     LONG x;
     *     LONG y;
     *     HANDLE hSource;
     *     DWORD dwID;
     *     DWORD dwFlags;
     *     DWORD dwMask;
     *     DWORD dwTime;
     *     ULONG_PTR dwExtraInfo;
     *     DWORD cxContact;
     *     DWORD cyContact;
     * } *PTOUCHINPUT
     * }
     */
    public static final AddressLayout PTOUCHINPUT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const TOUCHINPUT *PCTOUCHINPUT
     * }
     */
    public static final AddressLayout PCTOUCHINPUT = wgl_h.C_POINTER;

    private static class GetTouchInputInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTouchInputInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
     * }
     */
    public static FunctionDescriptor GetTouchInputInfo$descriptor() {
        return GetTouchInputInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
     * }
     */
    public static MethodHandle GetTouchInputInfo$handle() {
        return GetTouchInputInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
     * }
     */
    public static MemorySegment GetTouchInputInfo$address() {
        return GetTouchInputInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
     * }
     */
    public static int GetTouchInputInfo(MemorySegment hTouchInput, int cInputs, MemorySegment pInputs, int cbSize) {
        var mh$ = GetTouchInputInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTouchInputInfo", hTouchInput, cInputs, pInputs, cbSize);
            }
            return (int)mh$.invokeExact(hTouchInput, cInputs, pInputs, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseTouchInputHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseTouchInputHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
     * }
     */
    public static FunctionDescriptor CloseTouchInputHandle$descriptor() {
        return CloseTouchInputHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
     * }
     */
    public static MethodHandle CloseTouchInputHandle$handle() {
        return CloseTouchInputHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
     * }
     */
    public static MemorySegment CloseTouchInputHandle$address() {
        return CloseTouchInputHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
     * }
     */
    public static int CloseTouchInputHandle(MemorySegment hTouchInput) {
        var mh$ = CloseTouchInputHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseTouchInputHandle", hTouchInput);
            }
            return (int)mh$.invokeExact(hTouchInput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterTouchWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterTouchWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterTouchWindow(HWND hwnd, ULONG ulFlags)
     * }
     */
    public static FunctionDescriptor RegisterTouchWindow$descriptor() {
        return RegisterTouchWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterTouchWindow(HWND hwnd, ULONG ulFlags)
     * }
     */
    public static MethodHandle RegisterTouchWindow$handle() {
        return RegisterTouchWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterTouchWindow(HWND hwnd, ULONG ulFlags)
     * }
     */
    public static MemorySegment RegisterTouchWindow$address() {
        return RegisterTouchWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterTouchWindow(HWND hwnd, ULONG ulFlags)
     * }
     */
    public static int RegisterTouchWindow(MemorySegment hwnd, int ulFlags) {
        var mh$ = RegisterTouchWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterTouchWindow", hwnd, ulFlags);
            }
            return (int)mh$.invokeExact(hwnd, ulFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterTouchWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterTouchWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterTouchWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor UnregisterTouchWindow$descriptor() {
        return UnregisterTouchWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterTouchWindow(HWND hwnd)
     * }
     */
    public static MethodHandle UnregisterTouchWindow$handle() {
        return UnregisterTouchWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterTouchWindow(HWND hwnd)
     * }
     */
    public static MemorySegment UnregisterTouchWindow$address() {
        return UnregisterTouchWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterTouchWindow(HWND hwnd)
     * }
     */
    public static int UnregisterTouchWindow(MemorySegment hwnd) {
        var mh$ = UnregisterTouchWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterTouchWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTouchWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsTouchWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTouchWindow(HWND hwnd, PULONG pulFlags)
     * }
     */
    public static FunctionDescriptor IsTouchWindow$descriptor() {
        return IsTouchWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTouchWindow(HWND hwnd, PULONG pulFlags)
     * }
     */
    public static MethodHandle IsTouchWindow$handle() {
        return IsTouchWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsTouchWindow(HWND hwnd, PULONG pulFlags)
     * }
     */
    public static MemorySegment IsTouchWindow$address() {
        return IsTouchWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsTouchWindow(HWND hwnd, PULONG pulFlags)
     * }
     */
    public static int IsTouchWindow(MemorySegment hwnd, MemorySegment pulFlags) {
        var mh$ = IsTouchWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTouchWindow", hwnd, pulFlags);
            }
            return (int)mh$.invokeExact(hwnd, pulFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PT_POINTER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_POINTER = 1
     * }
     */
    public static int PT_POINTER() {
        return PT_POINTER;
    }
    private static final int PT_TOUCH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_TOUCH = 2
     * }
     */
    public static int PT_TOUCH() {
        return PT_TOUCH;
    }
    private static final int PT_PEN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_PEN = 3
     * }
     */
    public static int PT_PEN() {
        return PT_PEN;
    }
    private static final int PT_MOUSE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_MOUSE = 4
     * }
     */
    public static int PT_MOUSE() {
        return PT_MOUSE;
    }
    private static final int PT_TOUCHPAD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_TOUCHPAD = 5
     * }
     */
    public static int PT_TOUCHPAD() {
        return PT_TOUCHPAD;
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD POINTER_INPUT_TYPE
     * }
     */
    public static final OfInt POINTER_INPUT_TYPE = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef UINT32 POINTER_FLAGS
     * }
     */
    public static final OfInt POINTER_FLAGS = wgl_h.C_INT;
    private static final int POINTER_CHANGE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_NONE = 0
     * }
     */
    public static int POINTER_CHANGE_NONE() {
        return POINTER_CHANGE_NONE;
    }
    private static final int POINTER_CHANGE_FIRSTBUTTON_DOWN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIRSTBUTTON_DOWN = 1
     * }
     */
    public static int POINTER_CHANGE_FIRSTBUTTON_DOWN() {
        return POINTER_CHANGE_FIRSTBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_FIRSTBUTTON_UP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIRSTBUTTON_UP = 2
     * }
     */
    public static int POINTER_CHANGE_FIRSTBUTTON_UP() {
        return POINTER_CHANGE_FIRSTBUTTON_UP;
    }
    private static final int POINTER_CHANGE_SECONDBUTTON_DOWN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_SECONDBUTTON_DOWN = 3
     * }
     */
    public static int POINTER_CHANGE_SECONDBUTTON_DOWN() {
        return POINTER_CHANGE_SECONDBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_SECONDBUTTON_UP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_SECONDBUTTON_UP = 4
     * }
     */
    public static int POINTER_CHANGE_SECONDBUTTON_UP() {
        return POINTER_CHANGE_SECONDBUTTON_UP;
    }
    private static final int POINTER_CHANGE_THIRDBUTTON_DOWN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_THIRDBUTTON_DOWN = 5
     * }
     */
    public static int POINTER_CHANGE_THIRDBUTTON_DOWN() {
        return POINTER_CHANGE_THIRDBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_THIRDBUTTON_UP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_THIRDBUTTON_UP = 6
     * }
     */
    public static int POINTER_CHANGE_THIRDBUTTON_UP() {
        return POINTER_CHANGE_THIRDBUTTON_UP;
    }
    private static final int POINTER_CHANGE_FOURTHBUTTON_DOWN = (int)7L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FOURTHBUTTON_DOWN = 7
     * }
     */
    public static int POINTER_CHANGE_FOURTHBUTTON_DOWN() {
        return POINTER_CHANGE_FOURTHBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_FOURTHBUTTON_UP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FOURTHBUTTON_UP = 8
     * }
     */
    public static int POINTER_CHANGE_FOURTHBUTTON_UP() {
        return POINTER_CHANGE_FOURTHBUTTON_UP;
    }
    private static final int POINTER_CHANGE_FIFTHBUTTON_DOWN = (int)9L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIFTHBUTTON_DOWN = 9
     * }
     */
    public static int POINTER_CHANGE_FIFTHBUTTON_DOWN() {
        return POINTER_CHANGE_FIFTHBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_FIFTHBUTTON_UP = (int)10L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIFTHBUTTON_UP = 10
     * }
     */
    public static int POINTER_CHANGE_FIFTHBUTTON_UP() {
        return POINTER_CHANGE_FIFTHBUTTON_UP;
    }
    /**
     * {@snippet lang=c :
     * typedef UINT32 TOUCH_FLAGS
     * }
     */
    public static final OfInt TOUCH_FLAGS = wgl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef UINT32 TOUCH_MASK
     * }
     */
    public static final OfInt TOUCH_MASK = wgl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef UINT32 PEN_FLAGS
     * }
     */
    public static final OfInt PEN_FLAGS = wgl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef UINT32 PEN_MASK
     * }
     */
    public static final OfInt PEN_MASK = wgl_h.C_INT;
    private static final int POINTER_FEEDBACK_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POINTER_FEEDBACK_DEFAULT = 1
     * }
     */
    public static int POINTER_FEEDBACK_DEFAULT() {
        return POINTER_FEEDBACK_DEFAULT;
    }
    private static final int POINTER_FEEDBACK_INDIRECT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POINTER_FEEDBACK_INDIRECT = 2
     * }
     */
    public static int POINTER_FEEDBACK_INDIRECT() {
        return POINTER_FEEDBACK_INDIRECT;
    }
    private static final int POINTER_FEEDBACK_NONE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POINTER_FEEDBACK_NONE = 3
     * }
     */
    public static int POINTER_FEEDBACK_NONE() {
        return POINTER_FEEDBACK_NONE;
    }

    private static class InitializeTouchInjection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeTouchInjection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeTouchInjection(UINT32 maxCount, DWORD dwMode)
     * }
     */
    public static FunctionDescriptor InitializeTouchInjection$descriptor() {
        return InitializeTouchInjection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeTouchInjection(UINT32 maxCount, DWORD dwMode)
     * }
     */
    public static MethodHandle InitializeTouchInjection$handle() {
        return InitializeTouchInjection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeTouchInjection(UINT32 maxCount, DWORD dwMode)
     * }
     */
    public static MemorySegment InitializeTouchInjection$address() {
        return InitializeTouchInjection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeTouchInjection(UINT32 maxCount, DWORD dwMode)
     * }
     */
    public static int InitializeTouchInjection(int maxCount, int dwMode) {
        var mh$ = InitializeTouchInjection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeTouchInjection", maxCount, dwMode);
            }
            return (int)mh$.invokeExact(maxCount, dwMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InjectTouchInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InjectTouchInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO *contacts)
     * }
     */
    public static FunctionDescriptor InjectTouchInput$descriptor() {
        return InjectTouchInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO *contacts)
     * }
     */
    public static MethodHandle InjectTouchInput$handle() {
        return InjectTouchInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO *contacts)
     * }
     */
    public static MemorySegment InjectTouchInput$address() {
        return InjectTouchInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO *contacts)
     * }
     */
    public static int InjectTouchInput(int count, MemorySegment contacts) {
        var mh$ = InjectTouchInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InjectTouchInput", count, contacts);
            }
            return (int)mh$.invokeExact(count, contacts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagUSAGE_PROPERTIES {
     *     USHORT level;
     *     USHORT page;
     *     USHORT usage;
     *     INT32 logicalMinimum;
     *     INT32 logicalMaximum;
     *     USHORT unit;
     *     USHORT exponent;
     *     BYTE count;
     *     INT32 physicalMinimum;
     *     INT32 physicalMaximum;
     * } *PUSAGE_PROPERTIES
     * }
     */
    public static final AddressLayout PUSAGE_PROPERTIES = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTER_TYPE_INFO {
     *     POINTER_INPUT_TYPE type;
     *     union {
     *         POINTER_TOUCH_INFO touchInfo;
     *         POINTER_PEN_INFO penInfo;
     *     };
     * } *PPOINTER_TYPE_INFO
     * }
     */
    public static final AddressLayout PPOINTER_TYPE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagINPUT_INJECTION_VALUE {
     *     USHORT page;
     *     USHORT usage;
     *     INT32 value;
     *     USHORT index;
     * } *PINPUT_INJECTION_VALUE
     * }
     */
    public static final AddressLayout PINPUT_INJECTION_VALUE = wgl_h.C_POINTER;

    private static class GetPointerType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType)
     * }
     */
    public static FunctionDescriptor GetPointerType$descriptor() {
        return GetPointerType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType)
     * }
     */
    public static MethodHandle GetPointerType$handle() {
        return GetPointerType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType)
     * }
     */
    public static MemorySegment GetPointerType$address() {
        return GetPointerType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType)
     * }
     */
    public static int GetPointerType(int pointerId, MemorySegment pointerType) {
        var mh$ = GetPointerType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerType", pointerId, pointerType);
            }
            return (int)mh$.invokeExact(pointerId, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerCursorId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerCursorId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId)
     * }
     */
    public static FunctionDescriptor GetPointerCursorId$descriptor() {
        return GetPointerCursorId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId)
     * }
     */
    public static MethodHandle GetPointerCursorId$handle() {
        return GetPointerCursorId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId)
     * }
     */
    public static MemorySegment GetPointerCursorId$address() {
        return GetPointerCursorId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId)
     * }
     */
    public static int GetPointerCursorId(int pointerId, MemorySegment cursorId) {
        var mh$ = GetPointerCursorId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerCursorId", pointerId, cursorId);
            }
            return (int)mh$.invokeExact(pointerId, cursorId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerInfo$descriptor() {
        return GetPointerInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerInfo$handle() {
        return GetPointerInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo)
     * }
     */
    public static MemorySegment GetPointerInfo$address() {
        return GetPointerInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerInfo(int pointerId, MemorySegment pointerInfo) {
        var mh$ = GetPointerInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerInfo", pointerId, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerInfoHistory$descriptor() {
        return GetPointerInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerInfoHistory$handle() {
        return GetPointerInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MemorySegment GetPointerInfoHistory$address() {
        return GetPointerInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerInfo) {
        var mh$ = GetPointerInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerInfoHistory", pointerId, entriesCount, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerFrameInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameInfo$descriptor() {
        return GetPointerFrameInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerFrameInfo$handle() {
        return GetPointerFrameInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MemorySegment GetPointerFrameInfo$address() {
        return GetPointerFrameInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerFrameInfo(int pointerId, MemorySegment pointerCount, MemorySegment pointerInfo) {
        var mh$ = GetPointerFrameInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameInfo", pointerId, pointerCount, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerCount, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerFrameInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameInfoHistory$descriptor() {
        return GetPointerFrameInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerFrameInfoHistory$handle() {
        return GetPointerFrameInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MemorySegment GetPointerFrameInfoHistory$address() {
        return GetPointerFrameInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerFrameInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerCount, MemorySegment pointerInfo) {
        var mh$ = GetPointerFrameInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameInfoHistory", pointerId, entriesCount, pointerCount, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerCount, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerTouchInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerTouchInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerTouchInfo$descriptor() {
        return GetPointerTouchInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerTouchInfo$handle() {
        return GetPointerTouchInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MemorySegment GetPointerTouchInfo$address() {
        return GetPointerTouchInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerTouchInfo(int pointerId, MemorySegment touchInfo) {
        var mh$ = GetPointerTouchInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerTouchInfo", pointerId, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerTouchInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerTouchInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerTouchInfoHistory$descriptor() {
        return GetPointerTouchInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerTouchInfoHistory$handle() {
        return GetPointerTouchInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MemorySegment GetPointerTouchInfoHistory$address() {
        return GetPointerTouchInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerTouchInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment touchInfo) {
        var mh$ = GetPointerTouchInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerTouchInfoHistory", pointerId, entriesCount, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameTouchInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerFrameTouchInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameTouchInfo$descriptor() {
        return GetPointerFrameTouchInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerFrameTouchInfo$handle() {
        return GetPointerFrameTouchInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MemorySegment GetPointerFrameTouchInfo$address() {
        return GetPointerFrameTouchInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerFrameTouchInfo(int pointerId, MemorySegment pointerCount, MemorySegment touchInfo) {
        var mh$ = GetPointerFrameTouchInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameTouchInfo", pointerId, pointerCount, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerCount, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameTouchInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerFrameTouchInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameTouchInfoHistory$descriptor() {
        return GetPointerFrameTouchInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerFrameTouchInfoHistory$handle() {
        return GetPointerFrameTouchInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MemorySegment GetPointerFrameTouchInfoHistory$address() {
        return GetPointerFrameTouchInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerFrameTouchInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerCount, MemorySegment touchInfo) {
        var mh$ = GetPointerFrameTouchInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameTouchInfoHistory", pointerId, entriesCount, pointerCount, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerCount, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerPenInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerPenInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerPenInfo$descriptor() {
        return GetPointerPenInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerPenInfo$handle() {
        return GetPointerPenInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MemorySegment GetPointerPenInfo$address() {
        return GetPointerPenInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerPenInfo(int pointerId, MemorySegment penInfo) {
        var mh$ = GetPointerPenInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerPenInfo", pointerId, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerPenInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerPenInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerPenInfoHistory$descriptor() {
        return GetPointerPenInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerPenInfoHistory$handle() {
        return GetPointerPenInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MemorySegment GetPointerPenInfoHistory$address() {
        return GetPointerPenInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerPenInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment penInfo) {
        var mh$ = GetPointerPenInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerPenInfoHistory", pointerId, entriesCount, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFramePenInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerFramePenInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFramePenInfo$descriptor() {
        return GetPointerFramePenInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerFramePenInfo$handle() {
        return GetPointerFramePenInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MemorySegment GetPointerFramePenInfo$address() {
        return GetPointerFramePenInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerFramePenInfo(int pointerId, MemorySegment pointerCount, MemorySegment penInfo) {
        var mh$ = GetPointerFramePenInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFramePenInfo", pointerId, pointerCount, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerCount, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFramePenInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerFramePenInfoHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFramePenInfoHistory$descriptor() {
        return GetPointerFramePenInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerFramePenInfoHistory$handle() {
        return GetPointerFramePenInfoHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MemorySegment GetPointerFramePenInfoHistory$address() {
        return GetPointerFramePenInfoHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerFramePenInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerCount, MemorySegment penInfo) {
        var mh$ = GetPointerFramePenInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFramePenInfoHistory", pointerId, entriesCount, pointerCount, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerCount, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SkipPointerFrameMessages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SkipPointerFrameMessages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SkipPointerFrameMessages(UINT32 pointerId)
     * }
     */
    public static FunctionDescriptor SkipPointerFrameMessages$descriptor() {
        return SkipPointerFrameMessages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SkipPointerFrameMessages(UINT32 pointerId)
     * }
     */
    public static MethodHandle SkipPointerFrameMessages$handle() {
        return SkipPointerFrameMessages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SkipPointerFrameMessages(UINT32 pointerId)
     * }
     */
    public static MemorySegment SkipPointerFrameMessages$address() {
        return SkipPointerFrameMessages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SkipPointerFrameMessages(UINT32 pointerId)
     * }
     */
    public static int SkipPointerFrameMessages(int pointerId) {
        var mh$ = SkipPointerFrameMessages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SkipPointerFrameMessages", pointerId);
            }
            return (int)mh$.invokeExact(pointerId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterPointerInputTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterPointerInputTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static FunctionDescriptor RegisterPointerInputTarget$descriptor() {
        return RegisterPointerInputTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MethodHandle RegisterPointerInputTarget$handle() {
        return RegisterPointerInputTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MemorySegment RegisterPointerInputTarget$address() {
        return RegisterPointerInputTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static int RegisterPointerInputTarget(MemorySegment hwnd, int pointerType) {
        var mh$ = RegisterPointerInputTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterPointerInputTarget", hwnd, pointerType);
            }
            return (int)mh$.invokeExact(hwnd, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterPointerInputTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterPointerInputTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static FunctionDescriptor UnregisterPointerInputTarget$descriptor() {
        return UnregisterPointerInputTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MethodHandle UnregisterPointerInputTarget$handle() {
        return UnregisterPointerInputTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MemorySegment UnregisterPointerInputTarget$address() {
        return UnregisterPointerInputTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static int UnregisterPointerInputTarget(MemorySegment hwnd, int pointerType) {
        var mh$ = UnregisterPointerInputTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterPointerInputTarget", hwnd, pointerType);
            }
            return (int)mh$.invokeExact(hwnd, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterPointerInputTargetEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterPointerInputTargetEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve)
     * }
     */
    public static FunctionDescriptor RegisterPointerInputTargetEx$descriptor() {
        return RegisterPointerInputTargetEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve)
     * }
     */
    public static MethodHandle RegisterPointerInputTargetEx$handle() {
        return RegisterPointerInputTargetEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve)
     * }
     */
    public static MemorySegment RegisterPointerInputTargetEx$address() {
        return RegisterPointerInputTargetEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve)
     * }
     */
    public static int RegisterPointerInputTargetEx(MemorySegment hwnd, int pointerType, int fObserve) {
        var mh$ = RegisterPointerInputTargetEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterPointerInputTargetEx", hwnd, pointerType, fObserve);
            }
            return (int)mh$.invokeExact(hwnd, pointerType, fObserve);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterPointerInputTargetEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterPointerInputTargetEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static FunctionDescriptor UnregisterPointerInputTargetEx$descriptor() {
        return UnregisterPointerInputTargetEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MethodHandle UnregisterPointerInputTargetEx$handle() {
        return UnregisterPointerInputTargetEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MemorySegment UnregisterPointerInputTargetEx$address() {
        return UnregisterPointerInputTargetEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static int UnregisterPointerInputTargetEx(MemorySegment hwnd, int pointerType) {
        var mh$ = UnregisterPointerInputTargetEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterPointerInputTargetEx", hwnd, pointerType);
            }
            return (int)mh$.invokeExact(hwnd, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HSYNTHETICPOINTERDEVICE__ {
     *     int unused;
     * } *HSYNTHETICPOINTERDEVICE
     * }
     */
    public static final AddressLayout HSYNTHETICPOINTERDEVICE = wgl_h.C_POINTER;

    private static class CreateSyntheticPointerDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateSyntheticPointerDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode)
     * }
     */
    public static FunctionDescriptor CreateSyntheticPointerDevice$descriptor() {
        return CreateSyntheticPointerDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode)
     * }
     */
    public static MethodHandle CreateSyntheticPointerDevice$handle() {
        return CreateSyntheticPointerDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode)
     * }
     */
    public static MemorySegment CreateSyntheticPointerDevice$address() {
        return CreateSyntheticPointerDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode)
     * }
     */
    public static MemorySegment CreateSyntheticPointerDevice(int pointerType, int maxCount, int mode) {
        var mh$ = CreateSyntheticPointerDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSyntheticPointerDevice", pointerType, maxCount, mode);
            }
            return (MemorySegment)mh$.invokeExact(pointerType, maxCount, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InjectSyntheticPointerInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InjectSyntheticPointerInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO *pointerInfo, UINT32 count)
     * }
     */
    public static FunctionDescriptor InjectSyntheticPointerInput$descriptor() {
        return InjectSyntheticPointerInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO *pointerInfo, UINT32 count)
     * }
     */
    public static MethodHandle InjectSyntheticPointerInput$handle() {
        return InjectSyntheticPointerInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO *pointerInfo, UINT32 count)
     * }
     */
    public static MemorySegment InjectSyntheticPointerInput$address() {
        return InjectSyntheticPointerInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO *pointerInfo, UINT32 count)
     * }
     */
    public static int InjectSyntheticPointerInput(MemorySegment device, MemorySegment pointerInfo, int count) {
        var mh$ = InjectSyntheticPointerInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InjectSyntheticPointerInput", device, pointerInfo, count);
            }
            return (int)mh$.invokeExact(device, pointerInfo, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroySyntheticPointerDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DestroySyntheticPointerDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device)
     * }
     */
    public static FunctionDescriptor DestroySyntheticPointerDevice$descriptor() {
        return DestroySyntheticPointerDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device)
     * }
     */
    public static MethodHandle DestroySyntheticPointerDevice$handle() {
        return DestroySyntheticPointerDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device)
     * }
     */
    public static MemorySegment DestroySyntheticPointerDevice$address() {
        return DestroySyntheticPointerDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device)
     * }
     */
    public static void DestroySyntheticPointerDevice(MemorySegment device) {
        var mh$ = DestroySyntheticPointerDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroySyntheticPointerDevice", device);
            }
            mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableMouseInPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnableMouseInPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointer(BOOL fEnable)
     * }
     */
    public static FunctionDescriptor EnableMouseInPointer$descriptor() {
        return EnableMouseInPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointer(BOOL fEnable)
     * }
     */
    public static MethodHandle EnableMouseInPointer$handle() {
        return EnableMouseInPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointer(BOOL fEnable)
     * }
     */
    public static MemorySegment EnableMouseInPointer$address() {
        return EnableMouseInPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnableMouseInPointer(BOOL fEnable)
     * }
     */
    public static int EnableMouseInPointer(int fEnable) {
        var mh$ = EnableMouseInPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableMouseInPointer", fEnable);
            }
            return (int)mh$.invokeExact(fEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMouseInPointerEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsMouseInPointerEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsMouseInPointerEnabled()
     * }
     */
    public static FunctionDescriptor IsMouseInPointerEnabled$descriptor() {
        return IsMouseInPointerEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsMouseInPointerEnabled()
     * }
     */
    public static MethodHandle IsMouseInPointerEnabled$handle() {
        return IsMouseInPointerEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsMouseInPointerEnabled()
     * }
     */
    public static MemorySegment IsMouseInPointerEnabled$address() {
        return IsMouseInPointerEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsMouseInPointerEnabled()
     * }
     */
    public static int IsMouseInPointerEnabled() {
        var mh$ = IsMouseInPointerEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMouseInPointerEnabled");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableMouseInPointerForThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnableMouseInPointerForThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointerForThread()
     * }
     */
    public static FunctionDescriptor EnableMouseInPointerForThread$descriptor() {
        return EnableMouseInPointerForThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointerForThread()
     * }
     */
    public static MethodHandle EnableMouseInPointerForThread$handle() {
        return EnableMouseInPointerForThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointerForThread()
     * }
     */
    public static MemorySegment EnableMouseInPointerForThread$address() {
        return EnableMouseInPointerForThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnableMouseInPointerForThread()
     * }
     */
    public static int EnableMouseInPointerForThread() {
        var mh$ = EnableMouseInPointerForThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableMouseInPointerForThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterTouchHitTestingWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterTouchHitTestingWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterTouchHitTestingWindow(HWND hwnd, ULONG value)
     * }
     */
    public static FunctionDescriptor RegisterTouchHitTestingWindow$descriptor() {
        return RegisterTouchHitTestingWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterTouchHitTestingWindow(HWND hwnd, ULONG value)
     * }
     */
    public static MethodHandle RegisterTouchHitTestingWindow$handle() {
        return RegisterTouchHitTestingWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterTouchHitTestingWindow(HWND hwnd, ULONG value)
     * }
     */
    public static MemorySegment RegisterTouchHitTestingWindow$address() {
        return RegisterTouchHitTestingWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterTouchHitTestingWindow(HWND hwnd, ULONG value)
     * }
     */
    public static int RegisterTouchHitTestingWindow(MemorySegment hwnd, int value) {
        var mh$ = RegisterTouchHitTestingWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterTouchHitTestingWindow", hwnd, value);
            }
            return (int)mh$.invokeExact(hwnd, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION {
     *     UINT16 score;
     *     POINT adjustedPoint;
     * } *PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION
     * }
     */
    public static final AddressLayout PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTOUCH_HIT_TESTING_INPUT {
     *     UINT32 pointerId;
     *     POINT point;
     *     RECT boundingBox;
     *     RECT nonOccludedBoundingBox;
     *     UINT32 orientation;
     * } *PTOUCH_HIT_TESTING_INPUT
     * }
     */
    public static final AddressLayout PTOUCH_HIT_TESTING_INPUT = wgl_h.C_POINTER;

    private static class EvaluateProximityToRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EvaluateProximityToRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToRect(const RECT *controlBoundingBox, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static FunctionDescriptor EvaluateProximityToRect$descriptor() {
        return EvaluateProximityToRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToRect(const RECT *controlBoundingBox, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MethodHandle EvaluateProximityToRect$handle() {
        return EvaluateProximityToRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToRect(const RECT *controlBoundingBox, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MemorySegment EvaluateProximityToRect$address() {
        return EvaluateProximityToRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EvaluateProximityToRect(const RECT *controlBoundingBox, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static int EvaluateProximityToRect(MemorySegment controlBoundingBox, MemorySegment pHitTestingInput, MemorySegment pProximityEval) {
        var mh$ = EvaluateProximityToRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EvaluateProximityToRect", controlBoundingBox, pHitTestingInput, pProximityEval);
            }
            return (int)mh$.invokeExact(controlBoundingBox, pHitTestingInput, pProximityEval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EvaluateProximityToPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EvaluateProximityToPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToPolygon(UINT32 numVertices, const POINT *controlPolygon, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static FunctionDescriptor EvaluateProximityToPolygon$descriptor() {
        return EvaluateProximityToPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToPolygon(UINT32 numVertices, const POINT *controlPolygon, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MethodHandle EvaluateProximityToPolygon$handle() {
        return EvaluateProximityToPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToPolygon(UINT32 numVertices, const POINT *controlPolygon, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MemorySegment EvaluateProximityToPolygon$address() {
        return EvaluateProximityToPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EvaluateProximityToPolygon(UINT32 numVertices, const POINT *controlPolygon, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static int EvaluateProximityToPolygon(int numVertices, MemorySegment controlPolygon, MemorySegment pHitTestingInput, MemorySegment pProximityEval) {
        var mh$ = EvaluateProximityToPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EvaluateProximityToPolygon", numVertices, controlPolygon, pHitTestingInput, pProximityEval);
            }
            return (int)mh$.invokeExact(numVertices, controlPolygon, pHitTestingInput, pProximityEval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PackTouchHitTestingProximityEvaluation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PackTouchHitTestingProximityEvaluation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static FunctionDescriptor PackTouchHitTestingProximityEvaluation$descriptor() {
        return PackTouchHitTestingProximityEvaluation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MethodHandle PackTouchHitTestingProximityEvaluation$handle() {
        return PackTouchHitTestingProximityEvaluation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MemorySegment PackTouchHitTestingProximityEvaluation$address() {
        return PackTouchHitTestingProximityEvaluation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static long PackTouchHitTestingProximityEvaluation(MemorySegment pHitTestingInput, MemorySegment pProximityEval) {
        var mh$ = PackTouchHitTestingProximityEvaluation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PackTouchHitTestingProximityEvaluation", pHitTestingInput, pProximityEval);
            }
            return (long)mh$.invokeExact(pHitTestingInput, pProximityEval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FEEDBACK_TOUCH_CONTACTVISUALIZATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1
     * }
     */
    public static int FEEDBACK_TOUCH_CONTACTVISUALIZATION() {
        return FEEDBACK_TOUCH_CONTACTVISUALIZATION;
    }
    private static final int FEEDBACK_PEN_BARRELVISUALIZATION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_BARRELVISUALIZATION = 2
     * }
     */
    public static int FEEDBACK_PEN_BARRELVISUALIZATION() {
        return FEEDBACK_PEN_BARRELVISUALIZATION;
    }
    private static final int FEEDBACK_PEN_TAP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_TAP = 3
     * }
     */
    public static int FEEDBACK_PEN_TAP() {
        return FEEDBACK_PEN_TAP;
    }
    private static final int FEEDBACK_PEN_DOUBLETAP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_DOUBLETAP = 4
     * }
     */
    public static int FEEDBACK_PEN_DOUBLETAP() {
        return FEEDBACK_PEN_DOUBLETAP;
    }
    private static final int FEEDBACK_PEN_PRESSANDHOLD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_PRESSANDHOLD = 5
     * }
     */
    public static int FEEDBACK_PEN_PRESSANDHOLD() {
        return FEEDBACK_PEN_PRESSANDHOLD;
    }
    private static final int FEEDBACK_PEN_RIGHTTAP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_RIGHTTAP = 6
     * }
     */
    public static int FEEDBACK_PEN_RIGHTTAP() {
        return FEEDBACK_PEN_RIGHTTAP;
    }
    private static final int FEEDBACK_TOUCH_TAP = (int)7L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_TAP = 7
     * }
     */
    public static int FEEDBACK_TOUCH_TAP() {
        return FEEDBACK_TOUCH_TAP;
    }
    private static final int FEEDBACK_TOUCH_DOUBLETAP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_DOUBLETAP = 8
     * }
     */
    public static int FEEDBACK_TOUCH_DOUBLETAP() {
        return FEEDBACK_TOUCH_DOUBLETAP;
    }
    private static final int FEEDBACK_TOUCH_PRESSANDHOLD = (int)9L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_PRESSANDHOLD = 9
     * }
     */
    public static int FEEDBACK_TOUCH_PRESSANDHOLD() {
        return FEEDBACK_TOUCH_PRESSANDHOLD;
    }
    private static final int FEEDBACK_TOUCH_RIGHTTAP = (int)10L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_RIGHTTAP = 10
     * }
     */
    public static int FEEDBACK_TOUCH_RIGHTTAP() {
        return FEEDBACK_TOUCH_RIGHTTAP;
    }
    private static final int FEEDBACK_GESTURE_PRESSANDTAP = (int)11L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_GESTURE_PRESSANDTAP = 11
     * }
     */
    public static int FEEDBACK_GESTURE_PRESSANDTAP() {
        return FEEDBACK_GESTURE_PRESSANDTAP;
    }
    private static final int FEEDBACK_MAX = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_MAX = -1
     * }
     */
    public static int FEEDBACK_MAX() {
        return FEEDBACK_MAX;
    }

    private static class GetWindowFeedbackSetting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWindowFeedbackSetting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 *pSize, void *config)
     * }
     */
    public static FunctionDescriptor GetWindowFeedbackSetting$descriptor() {
        return GetWindowFeedbackSetting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 *pSize, void *config)
     * }
     */
    public static MethodHandle GetWindowFeedbackSetting$handle() {
        return GetWindowFeedbackSetting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 *pSize, void *config)
     * }
     */
    public static MemorySegment GetWindowFeedbackSetting$address() {
        return GetWindowFeedbackSetting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 *pSize, void *config)
     * }
     */
    public static int GetWindowFeedbackSetting(MemorySegment hwnd, int feedback, int dwFlags, MemorySegment pSize, MemorySegment config) {
        var mh$ = GetWindowFeedbackSetting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowFeedbackSetting", hwnd, feedback, dwFlags, pSize, config);
            }
            return (int)mh$.invokeExact(hwnd, feedback, dwFlags, pSize, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowFeedbackSetting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetWindowFeedbackSetting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void *configuration)
     * }
     */
    public static FunctionDescriptor SetWindowFeedbackSetting$descriptor() {
        return SetWindowFeedbackSetting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void *configuration)
     * }
     */
    public static MethodHandle SetWindowFeedbackSetting$handle() {
        return SetWindowFeedbackSetting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void *configuration)
     * }
     */
    public static MemorySegment SetWindowFeedbackSetting$address() {
        return SetWindowFeedbackSetting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void *configuration)
     * }
     */
    public static int SetWindowFeedbackSetting(MemorySegment hwnd, int feedback, int dwFlags, int size, MemorySegment configuration) {
        var mh$ = SetWindowFeedbackSetting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowFeedbackSetting", hwnd, feedback, dwFlags, size, configuration);
            }
            return (int)mh$.invokeExact(hwnd, feedback, dwFlags, size, configuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerInputTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPointerInputTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform)
     * }
     */
    public static FunctionDescriptor GetPointerInputTransform$descriptor() {
        return GetPointerInputTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform)
     * }
     */
    public static MethodHandle GetPointerInputTransform$handle() {
        return GetPointerInputTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform)
     * }
     */
    public static MemorySegment GetPointerInputTransform$address() {
        return GetPointerInputTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform)
     * }
     */
    public static int GetPointerInputTransform(int pointerId, int historyCount, MemorySegment inputTransform) {
        var mh$ = GetPointerInputTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerInputTransform", pointerId, historyCount, inputTransform);
            }
            return (int)mh$.invokeExact(pointerId, historyCount, inputTransform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagLASTINPUTINFO {
     *     UINT cbSize;
     *     DWORD dwTime;
     * } *PLASTINPUTINFO
     * }
     */
    public static final AddressLayout PLASTINPUTINFO = wgl_h.C_POINTER;

    private static class GetLastInputInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLastInputInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLastInputInfo(PLASTINPUTINFO plii)
     * }
     */
    public static FunctionDescriptor GetLastInputInfo$descriptor() {
        return GetLastInputInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLastInputInfo(PLASTINPUTINFO plii)
     * }
     */
    public static MethodHandle GetLastInputInfo$handle() {
        return GetLastInputInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLastInputInfo(PLASTINPUTINFO plii)
     * }
     */
    public static MemorySegment GetLastInputInfo$address() {
        return GetLastInputInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLastInputInfo(PLASTINPUTINFO plii)
     * }
     */
    public static int GetLastInputInfo(MemorySegment plii) {
        var mh$ = GetLastInputInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastInputInfo", plii);
            }
            return (int)mh$.invokeExact(plii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapVirtualKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyA(UINT uCode, UINT uMapType)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyA$descriptor() {
        return MapVirtualKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyA(UINT uCode, UINT uMapType)
     * }
     */
    public static MethodHandle MapVirtualKeyA$handle() {
        return MapVirtualKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyA(UINT uCode, UINT uMapType)
     * }
     */
    public static MemorySegment MapVirtualKeyA$address() {
        return MapVirtualKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyA(UINT uCode, UINT uMapType)
     * }
     */
    public static int MapVirtualKeyA(int uCode, int uMapType) {
        var mh$ = MapVirtualKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyA", uCode, uMapType);
            }
            return (int)mh$.invokeExact(uCode, uMapType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapVirtualKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyW(UINT uCode, UINT uMapType)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyW$descriptor() {
        return MapVirtualKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyW(UINT uCode, UINT uMapType)
     * }
     */
    public static MethodHandle MapVirtualKeyW$handle() {
        return MapVirtualKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyW(UINT uCode, UINT uMapType)
     * }
     */
    public static MemorySegment MapVirtualKeyW$address() {
        return MapVirtualKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyW(UINT uCode, UINT uMapType)
     * }
     */
    public static int MapVirtualKeyW(int uCode, int uMapType) {
        var mh$ = MapVirtualKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyW", uCode, uMapType);
            }
            return (int)mh$.invokeExact(uCode, uMapType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapVirtualKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyExA$descriptor() {
        return MapVirtualKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static MethodHandle MapVirtualKeyExA$handle() {
        return MapVirtualKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static MemorySegment MapVirtualKeyExA$address() {
        return MapVirtualKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static int MapVirtualKeyExA(int uCode, int uMapType, MemorySegment dwhkl) {
        var mh$ = MapVirtualKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyExA", uCode, uMapType, dwhkl);
            }
            return (int)mh$.invokeExact(uCode, uMapType, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapVirtualKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyExW$descriptor() {
        return MapVirtualKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static MethodHandle MapVirtualKeyExW$handle() {
        return MapVirtualKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static MemorySegment MapVirtualKeyExW$address() {
        return MapVirtualKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static int MapVirtualKeyExW(int uCode, int uMapType, MemorySegment dwhkl) {
        var mh$ = MapVirtualKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyExW", uCode, uMapType, dwhkl);
            }
            return (int)mh$.invokeExact(uCode, uMapType, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetInputState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetInputState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetInputState()
     * }
     */
    public static FunctionDescriptor GetInputState$descriptor() {
        return GetInputState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetInputState()
     * }
     */
    public static MethodHandle GetInputState$handle() {
        return GetInputState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetInputState()
     * }
     */
    public static MemorySegment GetInputState$address() {
        return GetInputState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetInputState()
     * }
     */
    public static int GetInputState() {
        var mh$ = GetInputState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetInputState");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueueStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetQueueStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetQueueStatus(UINT flags)
     * }
     */
    public static FunctionDescriptor GetQueueStatus$descriptor() {
        return GetQueueStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetQueueStatus(UINT flags)
     * }
     */
    public static MethodHandle GetQueueStatus$handle() {
        return GetQueueStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetQueueStatus(UINT flags)
     * }
     */
    public static MemorySegment GetQueueStatus$address() {
        return GetQueueStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetQueueStatus(UINT flags)
     * }
     */
    public static int GetQueueStatus(int flags) {
        var mh$ = GetQueueStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueueStatus", flags);
            }
            return (int)mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCapture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCapture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetCapture()
     * }
     */
    public static FunctionDescriptor GetCapture$descriptor() {
        return GetCapture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetCapture()
     * }
     */
    public static MethodHandle GetCapture$handle() {
        return GetCapture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetCapture()
     * }
     */
    public static MemorySegment GetCapture$address() {
        return GetCapture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetCapture()
     * }
     */
    public static MemorySegment GetCapture() {
        var mh$ = GetCapture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCapture");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCapture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetCapture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetCapture(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetCapture$descriptor() {
        return SetCapture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetCapture(HWND hWnd)
     * }
     */
    public static MethodHandle SetCapture$handle() {
        return SetCapture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND SetCapture(HWND hWnd)
     * }
     */
    public static MemorySegment SetCapture$address() {
        return SetCapture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND SetCapture(HWND hWnd)
     * }
     */
    public static MemorySegment SetCapture(MemorySegment hWnd) {
        var mh$ = SetCapture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCapture", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseCapture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReleaseCapture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReleaseCapture()
     * }
     */
    public static FunctionDescriptor ReleaseCapture$descriptor() {
        return ReleaseCapture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReleaseCapture()
     * }
     */
    public static MethodHandle ReleaseCapture$handle() {
        return ReleaseCapture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReleaseCapture()
     * }
     */
    public static MemorySegment ReleaseCapture$address() {
        return ReleaseCapture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReleaseCapture()
     * }
     */
    public static int ReleaseCapture() {
        var mh$ = ReleaseCapture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseCapture");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MsgWaitForMultipleObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MsgWaitForMultipleObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
     * }
     */
    public static FunctionDescriptor MsgWaitForMultipleObjects$descriptor() {
        return MsgWaitForMultipleObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
     * }
     */
    public static MethodHandle MsgWaitForMultipleObjects$handle() {
        return MsgWaitForMultipleObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
     * }
     */
    public static MemorySegment MsgWaitForMultipleObjects$address() {
        return MsgWaitForMultipleObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
     * }
     */
    public static int MsgWaitForMultipleObjects(int nCount, MemorySegment pHandles, int fWaitAll, int dwMilliseconds, int dwWakeMask) {
        var mh$ = MsgWaitForMultipleObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MsgWaitForMultipleObjects", nCount, pHandles, fWaitAll, dwMilliseconds, dwWakeMask);
            }
            return (int)mh$.invokeExact(nCount, pHandles, fWaitAll, dwMilliseconds, dwWakeMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MsgWaitForMultipleObjectsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MsgWaitForMultipleObjectsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MsgWaitForMultipleObjectsEx$descriptor() {
        return MsgWaitForMultipleObjectsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags)
     * }
     */
    public static MethodHandle MsgWaitForMultipleObjectsEx$handle() {
        return MsgWaitForMultipleObjectsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags)
     * }
     */
    public static MemorySegment MsgWaitForMultipleObjectsEx$address() {
        return MsgWaitForMultipleObjectsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags)
     * }
     */
    public static int MsgWaitForMultipleObjectsEx(int nCount, MemorySegment pHandles, int dwMilliseconds, int dwWakeMask, int dwFlags) {
        var mh$ = MsgWaitForMultipleObjectsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MsgWaitForMultipleObjectsEx", nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags);
            }
            return (int)mh$.invokeExact(nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
     * }
     */
    public static FunctionDescriptor SetTimer$descriptor() {
        return SetTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
     * }
     */
    public static MethodHandle SetTimer$handle() {
        return SetTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
     * }
     */
    public static MemorySegment SetTimer$address() {
        return SetTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
     * }
     */
    public static long SetTimer(MemorySegment hWnd, long nIDEvent, int uElapse, MemorySegment lpTimerFunc) {
        var mh$ = SetTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTimer", hWnd, nIDEvent, uElapse, lpTimerFunc);
            }
            return (long)mh$.invokeExact(hWnd, nIDEvent, uElapse, lpTimerFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCoalescableTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetCoalescableTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT_PTR SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay)
     * }
     */
    public static FunctionDescriptor SetCoalescableTimer$descriptor() {
        return SetCoalescableTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT_PTR SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay)
     * }
     */
    public static MethodHandle SetCoalescableTimer$handle() {
        return SetCoalescableTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT_PTR SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay)
     * }
     */
    public static MemorySegment SetCoalescableTimer$address() {
        return SetCoalescableTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT_PTR SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay)
     * }
     */
    public static long SetCoalescableTimer(MemorySegment hWnd, long nIDEvent, int uElapse, MemorySegment lpTimerFunc, int uToleranceDelay) {
        var mh$ = SetCoalescableTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCoalescableTimer", hWnd, nIDEvent, uElapse, lpTimerFunc, uToleranceDelay);
            }
            return (long)mh$.invokeExact(hWnd, nIDEvent, uElapse, lpTimerFunc, uToleranceDelay);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class KillTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("KillTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL KillTimer(HWND hWnd, UINT_PTR uIDEvent)
     * }
     */
    public static FunctionDescriptor KillTimer$descriptor() {
        return KillTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL KillTimer(HWND hWnd, UINT_PTR uIDEvent)
     * }
     */
    public static MethodHandle KillTimer$handle() {
        return KillTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL KillTimer(HWND hWnd, UINT_PTR uIDEvent)
     * }
     */
    public static MemorySegment KillTimer$address() {
        return KillTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL KillTimer(HWND hWnd, UINT_PTR uIDEvent)
     * }
     */
    public static int KillTimer(MemorySegment hWnd, long uIDEvent) {
        var mh$ = KillTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("KillTimer", hWnd, uIDEvent);
            }
            return (int)mh$.invokeExact(hWnd, uIDEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsWindowUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindowUnicode(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindowUnicode$descriptor() {
        return IsWindowUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindowUnicode(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindowUnicode$handle() {
        return IsWindowUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWindowUnicode(HWND hWnd)
     * }
     */
    public static MemorySegment IsWindowUnicode$address() {
        return IsWindowUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWindowUnicode(HWND hWnd)
     * }
     */
    public static int IsWindowUnicode(MemorySegment hWnd) {
        var mh$ = IsWindowUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowUnicode", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnableWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableWindow(HWND hWnd, BOOL bEnable)
     * }
     */
    public static FunctionDescriptor EnableWindow$descriptor() {
        return EnableWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableWindow(HWND hWnd, BOOL bEnable)
     * }
     */
    public static MethodHandle EnableWindow$handle() {
        return EnableWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnableWindow(HWND hWnd, BOOL bEnable)
     * }
     */
    public static MemorySegment EnableWindow$address() {
        return EnableWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnableWindow(HWND hWnd, BOOL bEnable)
     * }
     */
    public static int EnableWindow(MemorySegment hWnd, int bEnable) {
        var mh$ = EnableWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableWindow", hWnd, bEnable);
            }
            return (int)mh$.invokeExact(hWnd, bEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsWindowEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindowEnabled(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindowEnabled$descriptor() {
        return IsWindowEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindowEnabled(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindowEnabled$handle() {
        return IsWindowEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWindowEnabled(HWND hWnd)
     * }
     */
    public static MemorySegment IsWindowEnabled$address() {
        return IsWindowEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWindowEnabled(HWND hWnd)
     * }
     */
    public static int IsWindowEnabled(MemorySegment hWnd) {
        var mh$ = IsWindowEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowEnabled", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadAcceleratorsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadAcceleratorsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName)
     * }
     */
    public static FunctionDescriptor LoadAcceleratorsA$descriptor() {
        return LoadAcceleratorsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName)
     * }
     */
    public static MethodHandle LoadAcceleratorsA$handle() {
        return LoadAcceleratorsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName)
     * }
     */
    public static MemorySegment LoadAcceleratorsA$address() {
        return LoadAcceleratorsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName)
     * }
     */
    public static MemorySegment LoadAcceleratorsA(MemorySegment hInstance, MemorySegment lpTableName) {
        var mh$ = LoadAcceleratorsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadAcceleratorsA", hInstance, lpTableName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTableName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadAcceleratorsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadAcceleratorsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
     * }
     */
    public static FunctionDescriptor LoadAcceleratorsW$descriptor() {
        return LoadAcceleratorsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
     * }
     */
    public static MethodHandle LoadAcceleratorsW$handle() {
        return LoadAcceleratorsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
     * }
     */
    public static MemorySegment LoadAcceleratorsW$address() {
        return LoadAcceleratorsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
     * }
     */
    public static MemorySegment LoadAcceleratorsW(MemorySegment hInstance, MemorySegment lpTableName) {
        var mh$ = LoadAcceleratorsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadAcceleratorsW", hInstance, lpTableName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTableName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateAcceleratorTableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateAcceleratorTableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableA(LPACCEL paccel, int cAccel)
     * }
     */
    public static FunctionDescriptor CreateAcceleratorTableA$descriptor() {
        return CreateAcceleratorTableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableA(LPACCEL paccel, int cAccel)
     * }
     */
    public static MethodHandle CreateAcceleratorTableA$handle() {
        return CreateAcceleratorTableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableA(LPACCEL paccel, int cAccel)
     * }
     */
    public static MemorySegment CreateAcceleratorTableA$address() {
        return CreateAcceleratorTableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableA(LPACCEL paccel, int cAccel)
     * }
     */
    public static MemorySegment CreateAcceleratorTableA(MemorySegment paccel, int cAccel) {
        var mh$ = CreateAcceleratorTableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateAcceleratorTableA", paccel, cAccel);
            }
            return (MemorySegment)mh$.invokeExact(paccel, cAccel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateAcceleratorTableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateAcceleratorTableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableW(LPACCEL paccel, int cAccel)
     * }
     */
    public static FunctionDescriptor CreateAcceleratorTableW$descriptor() {
        return CreateAcceleratorTableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableW(LPACCEL paccel, int cAccel)
     * }
     */
    public static MethodHandle CreateAcceleratorTableW$handle() {
        return CreateAcceleratorTableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableW(LPACCEL paccel, int cAccel)
     * }
     */
    public static MemorySegment CreateAcceleratorTableW$address() {
        return CreateAcceleratorTableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableW(LPACCEL paccel, int cAccel)
     * }
     */
    public static MemorySegment CreateAcceleratorTableW(MemorySegment paccel, int cAccel) {
        var mh$ = CreateAcceleratorTableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateAcceleratorTableW", paccel, cAccel);
            }
            return (MemorySegment)mh$.invokeExact(paccel, cAccel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyAcceleratorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DestroyAcceleratorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyAcceleratorTable(HACCEL hAccel)
     * }
     */
    public static FunctionDescriptor DestroyAcceleratorTable$descriptor() {
        return DestroyAcceleratorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyAcceleratorTable(HACCEL hAccel)
     * }
     */
    public static MethodHandle DestroyAcceleratorTable$handle() {
        return DestroyAcceleratorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DestroyAcceleratorTable(HACCEL hAccel)
     * }
     */
    public static MemorySegment DestroyAcceleratorTable$address() {
        return DestroyAcceleratorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DestroyAcceleratorTable(HACCEL hAccel)
     * }
     */
    public static int DestroyAcceleratorTable(MemorySegment hAccel) {
        var mh$ = DestroyAcceleratorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyAcceleratorTable", hAccel);
            }
            return (int)mh$.invokeExact(hAccel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyAcceleratorTableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyAcceleratorTableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static FunctionDescriptor CopyAcceleratorTableA$descriptor() {
        return CopyAcceleratorTableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static MethodHandle CopyAcceleratorTableA$handle() {
        return CopyAcceleratorTableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static MemorySegment CopyAcceleratorTableA$address() {
        return CopyAcceleratorTableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static int CopyAcceleratorTableA(MemorySegment hAccelSrc, MemorySegment lpAccelDst, int cAccelEntries) {
        var mh$ = CopyAcceleratorTableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyAcceleratorTableA", hAccelSrc, lpAccelDst, cAccelEntries);
            }
            return (int)mh$.invokeExact(hAccelSrc, lpAccelDst, cAccelEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyAcceleratorTableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyAcceleratorTableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static FunctionDescriptor CopyAcceleratorTableW$descriptor() {
        return CopyAcceleratorTableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static MethodHandle CopyAcceleratorTableW$handle() {
        return CopyAcceleratorTableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static MemorySegment CopyAcceleratorTableW$address() {
        return CopyAcceleratorTableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static int CopyAcceleratorTableW(MemorySegment hAccelSrc, MemorySegment lpAccelDst, int cAccelEntries) {
        var mh$ = CopyAcceleratorTableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyAcceleratorTableW", hAccelSrc, lpAccelDst, cAccelEntries);
            }
            return (int)mh$.invokeExact(hAccelSrc, lpAccelDst, cAccelEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateAcceleratorA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TranslateAcceleratorA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor TranslateAcceleratorA$descriptor() {
        return TranslateAcceleratorA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static MethodHandle TranslateAcceleratorA$handle() {
        return TranslateAcceleratorA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static MemorySegment TranslateAcceleratorA$address() {
        return TranslateAcceleratorA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static int TranslateAcceleratorA(MemorySegment hWnd, MemorySegment hAccTable, MemorySegment lpMsg) {
        var mh$ = TranslateAcceleratorA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateAcceleratorA", hWnd, hAccTable, lpMsg);
            }
            return (int)mh$.invokeExact(hWnd, hAccTable, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateAcceleratorW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TranslateAcceleratorW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor TranslateAcceleratorW$descriptor() {
        return TranslateAcceleratorW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static MethodHandle TranslateAcceleratorW$handle() {
        return TranslateAcceleratorW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static MemorySegment TranslateAcceleratorW$address() {
        return TranslateAcceleratorW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static int TranslateAcceleratorW(MemorySegment hWnd, MemorySegment hAccTable, MemorySegment lpMsg) {
        var mh$ = TranslateAcceleratorW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateAcceleratorW", hWnd, hAccTable, lpMsg);
            }
            return (int)mh$.invokeExact(hWnd, hAccTable, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemMetrics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemMetrics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetSystemMetrics(int nIndex)
     * }
     */
    public static FunctionDescriptor GetSystemMetrics$descriptor() {
        return GetSystemMetrics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetSystemMetrics(int nIndex)
     * }
     */
    public static MethodHandle GetSystemMetrics$handle() {
        return GetSystemMetrics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetSystemMetrics(int nIndex)
     * }
     */
    public static MemorySegment GetSystemMetrics$address() {
        return GetSystemMetrics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetSystemMetrics(int nIndex)
     * }
     */
    public static int GetSystemMetrics(int nIndex) {
        var mh$ = GetSystemMetrics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemMetrics", nIndex);
            }
            return (int)mh$.invokeExact(nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemMetricsForDpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemMetricsForDpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetSystemMetricsForDpi(int nIndex, UINT dpi)
     * }
     */
    public static FunctionDescriptor GetSystemMetricsForDpi$descriptor() {
        return GetSystemMetricsForDpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetSystemMetricsForDpi(int nIndex, UINT dpi)
     * }
     */
    public static MethodHandle GetSystemMetricsForDpi$handle() {
        return GetSystemMetricsForDpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetSystemMetricsForDpi(int nIndex, UINT dpi)
     * }
     */
    public static MemorySegment GetSystemMetricsForDpi$address() {
        return GetSystemMetricsForDpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetSystemMetricsForDpi(int nIndex, UINT dpi)
     * }
     */
    public static int GetSystemMetricsForDpi(int nIndex, int dpi) {
        var mh$ = GetSystemMetricsForDpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemMetricsForDpi", nIndex, dpi);
            }
            return (int)mh$.invokeExact(nIndex, dpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadMenuA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName)
     * }
     */
    public static FunctionDescriptor LoadMenuA$descriptor() {
        return LoadMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName)
     * }
     */
    public static MethodHandle LoadMenuA$handle() {
        return LoadMenuA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName)
     * }
     */
    public static MemorySegment LoadMenuA$address() {
        return LoadMenuA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName)
     * }
     */
    public static MemorySegment LoadMenuA(MemorySegment hInstance, MemorySegment lpMenuName) {
        var mh$ = LoadMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuA", hInstance, lpMenuName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpMenuName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadMenuW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
     * }
     */
    public static FunctionDescriptor LoadMenuW$descriptor() {
        return LoadMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
     * }
     */
    public static MethodHandle LoadMenuW$handle() {
        return LoadMenuW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
     * }
     */
    public static MemorySegment LoadMenuW$address() {
        return LoadMenuW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
     * }
     */
    public static MemorySegment LoadMenuW(MemorySegment hInstance, MemorySegment lpMenuName) {
        var mh$ = LoadMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuW", hInstance, lpMenuName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpMenuName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuIndirectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadMenuIndirectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectA(const MENUTEMPLATEA *lpMenuTemplate)
     * }
     */
    public static FunctionDescriptor LoadMenuIndirectA$descriptor() {
        return LoadMenuIndirectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectA(const MENUTEMPLATEA *lpMenuTemplate)
     * }
     */
    public static MethodHandle LoadMenuIndirectA$handle() {
        return LoadMenuIndirectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectA(const MENUTEMPLATEA *lpMenuTemplate)
     * }
     */
    public static MemorySegment LoadMenuIndirectA$address() {
        return LoadMenuIndirectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectA(const MENUTEMPLATEA *lpMenuTemplate)
     * }
     */
    public static MemorySegment LoadMenuIndirectA(MemorySegment lpMenuTemplate) {
        var mh$ = LoadMenuIndirectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuIndirectA", lpMenuTemplate);
            }
            return (MemorySegment)mh$.invokeExact(lpMenuTemplate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuIndirectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadMenuIndirectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectW(const MENUTEMPLATEW *lpMenuTemplate)
     * }
     */
    public static FunctionDescriptor LoadMenuIndirectW$descriptor() {
        return LoadMenuIndirectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectW(const MENUTEMPLATEW *lpMenuTemplate)
     * }
     */
    public static MethodHandle LoadMenuIndirectW$handle() {
        return LoadMenuIndirectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectW(const MENUTEMPLATEW *lpMenuTemplate)
     * }
     */
    public static MemorySegment LoadMenuIndirectW$address() {
        return LoadMenuIndirectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectW(const MENUTEMPLATEW *lpMenuTemplate)
     * }
     */
    public static MemorySegment LoadMenuIndirectW(MemorySegment lpMenuTemplate) {
        var mh$ = LoadMenuIndirectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuIndirectW", lpMenuTemplate);
            }
            return (MemorySegment)mh$.invokeExact(lpMenuTemplate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU GetMenu(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetMenu$descriptor() {
        return GetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU GetMenu(HWND hWnd)
     * }
     */
    public static MethodHandle GetMenu$handle() {
        return GetMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU GetMenu(HWND hWnd)
     * }
     */
    public static MemorySegment GetMenu$address() {
        return GetMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU GetMenu(HWND hWnd)
     * }
     */
    public static MemorySegment GetMenu(MemorySegment hWnd) {
        var mh$ = GetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenu", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenu(HWND hWnd, HMENU hMenu)
     * }
     */
    public static FunctionDescriptor SetMenu$descriptor() {
        return SetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenu(HWND hWnd, HMENU hMenu)
     * }
     */
    public static MethodHandle SetMenu$handle() {
        return SetMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenu(HWND hWnd, HMENU hMenu)
     * }
     */
    public static MemorySegment SetMenu$address() {
        return SetMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenu(HWND hWnd, HMENU hMenu)
     * }
     */
    public static int SetMenu(MemorySegment hWnd, MemorySegment hMenu) {
        var mh$ = SetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenu", hWnd, hMenu);
            }
            return (int)mh$.invokeExact(hWnd, hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChangeMenuA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static FunctionDescriptor ChangeMenuA$descriptor() {
        return ChangeMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static MethodHandle ChangeMenuA$handle() {
        return ChangeMenuA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static MemorySegment ChangeMenuA$address() {
        return ChangeMenuA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static int ChangeMenuA(MemorySegment hMenu, int cmd, MemorySegment lpszNewItem, int cmdInsert, int flags) {
        var mh$ = ChangeMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeMenuA", hMenu, cmd, lpszNewItem, cmdInsert, flags);
            }
            return (int)mh$.invokeExact(hMenu, cmd, lpszNewItem, cmdInsert, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChangeMenuW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static FunctionDescriptor ChangeMenuW$descriptor() {
        return ChangeMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static MethodHandle ChangeMenuW$handle() {
        return ChangeMenuW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static MemorySegment ChangeMenuW$address() {
        return ChangeMenuW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static int ChangeMenuW(MemorySegment hMenu, int cmd, MemorySegment lpszNewItem, int cmdInsert, int flags) {
        var mh$ = ChangeMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeMenuW", hMenu, cmd, lpszNewItem, cmdInsert, flags);
            }
            return (int)mh$.invokeExact(hMenu, cmd, lpszNewItem, cmdInsert, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HiliteMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HiliteMenuItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite)
     * }
     */
    public static FunctionDescriptor HiliteMenuItem$descriptor() {
        return HiliteMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite)
     * }
     */
    public static MethodHandle HiliteMenuItem$handle() {
        return HiliteMenuItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite)
     * }
     */
    public static MemorySegment HiliteMenuItem$address() {
        return HiliteMenuItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite)
     * }
     */
    public static int HiliteMenuItem(MemorySegment hWnd, MemorySegment hMenu, int uIDHiliteItem, int uHilite) {
        var mh$ = HiliteMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HiliteMenuItem", hWnd, hMenu, uIDHiliteItem, uHilite);
            }
            return (int)mh$.invokeExact(hWnd, hMenu, uIDHiliteItem, uHilite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenuStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static FunctionDescriptor GetMenuStringA$descriptor() {
        return GetMenuStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static MethodHandle GetMenuStringA$handle() {
        return GetMenuStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static MemorySegment GetMenuStringA$address() {
        return GetMenuStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static int GetMenuStringA(MemorySegment hMenu, int uIDItem, MemorySegment lpString, int cchMax, int flags) {
        var mh$ = GetMenuStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuStringA", hMenu, uIDItem, lpString, cchMax, flags);
            }
            return (int)mh$.invokeExact(hMenu, uIDItem, lpString, cchMax, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenuStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static FunctionDescriptor GetMenuStringW$descriptor() {
        return GetMenuStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static MethodHandle GetMenuStringW$handle() {
        return GetMenuStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static MemorySegment GetMenuStringW$address() {
        return GetMenuStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static int GetMenuStringW(MemorySegment hMenu, int uIDItem, MemorySegment lpString, int cchMax, int flags) {
        var mh$ = GetMenuStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuStringW", hMenu, uIDItem, lpString, cchMax, flags);
            }
            return (int)mh$.invokeExact(hMenu, uIDItem, lpString, cchMax, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenuState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
     * }
     */
    public static FunctionDescriptor GetMenuState$descriptor() {
        return GetMenuState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
     * }
     */
    public static MethodHandle GetMenuState$handle() {
        return GetMenuState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
     * }
     */
    public static MemorySegment GetMenuState$address() {
        return GetMenuState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
     * }
     */
    public static int GetMenuState(MemorySegment hMenu, int uId, int uFlags) {
        var mh$ = GetMenuState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuState", hMenu, uId, uFlags);
            }
            return (int)mh$.invokeExact(hMenu, uId, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawMenuBar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawMenuBar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawMenuBar(HWND hWnd)
     * }
     */
    public static FunctionDescriptor DrawMenuBar$descriptor() {
        return DrawMenuBar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawMenuBar(HWND hWnd)
     * }
     */
    public static MethodHandle DrawMenuBar$handle() {
        return DrawMenuBar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawMenuBar(HWND hWnd)
     * }
     */
    public static MemorySegment DrawMenuBar$address() {
        return DrawMenuBar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawMenuBar(HWND hWnd)
     * }
     */
    public static int DrawMenuBar(MemorySegment hWnd) {
        var mh$ = DrawMenuBar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawMenuBar", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU GetSystemMenu(HWND hWnd, BOOL bRevert)
     * }
     */
    public static FunctionDescriptor GetSystemMenu$descriptor() {
        return GetSystemMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU GetSystemMenu(HWND hWnd, BOOL bRevert)
     * }
     */
    public static MethodHandle GetSystemMenu$handle() {
        return GetSystemMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU GetSystemMenu(HWND hWnd, BOOL bRevert)
     * }
     */
    public static MemorySegment GetSystemMenu$address() {
        return GetSystemMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU GetSystemMenu(HWND hWnd, BOOL bRevert)
     * }
     */
    public static MemorySegment GetSystemMenu(MemorySegment hWnd, int bRevert) {
        var mh$ = GetSystemMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemMenu", hWnd, bRevert);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, bRevert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU CreateMenu()
     * }
     */
    public static FunctionDescriptor CreateMenu$descriptor() {
        return CreateMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU CreateMenu()
     * }
     */
    public static MethodHandle CreateMenu$handle() {
        return CreateMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU CreateMenu()
     * }
     */
    public static MemorySegment CreateMenu$address() {
        return CreateMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU CreateMenu()
     * }
     */
    public static MemorySegment CreateMenu() {
        var mh$ = CreateMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMenu");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePopupMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePopupMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU CreatePopupMenu()
     * }
     */
    public static FunctionDescriptor CreatePopupMenu$descriptor() {
        return CreatePopupMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU CreatePopupMenu()
     * }
     */
    public static MethodHandle CreatePopupMenu$handle() {
        return CreatePopupMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU CreatePopupMenu()
     * }
     */
    public static MemorySegment CreatePopupMenu$address() {
        return CreatePopupMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU CreatePopupMenu()
     * }
     */
    public static MemorySegment CreatePopupMenu() {
        var mh$ = CreatePopupMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePopupMenu");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DestroyMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyMenu(HMENU hMenu)
     * }
     */
    public static FunctionDescriptor DestroyMenu$descriptor() {
        return DestroyMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyMenu(HMENU hMenu)
     * }
     */
    public static MethodHandle DestroyMenu$handle() {
        return DestroyMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DestroyMenu(HMENU hMenu)
     * }
     */
    public static MemorySegment DestroyMenu$address() {
        return DestroyMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DestroyMenu(HMENU hMenu)
     * }
     */
    public static int DestroyMenu(MemorySegment hMenu) {
        var mh$ = DestroyMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyMenu", hMenu);
            }
            return (int)mh$.invokeExact(hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CheckMenuItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
     * }
     */
    public static FunctionDescriptor CheckMenuItem$descriptor() {
        return CheckMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
     * }
     */
    public static MethodHandle CheckMenuItem$handle() {
        return CheckMenuItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
     * }
     */
    public static MemorySegment CheckMenuItem$address() {
        return CheckMenuItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
     * }
     */
    public static int CheckMenuItem(MemorySegment hMenu, int uIDCheckItem, int uCheck) {
        var mh$ = CheckMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckMenuItem", hMenu, uIDCheckItem, uCheck);
            }
            return (int)mh$.invokeExact(hMenu, uIDCheckItem, uCheck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnableMenuItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
     * }
     */
    public static FunctionDescriptor EnableMenuItem$descriptor() {
        return EnableMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
     * }
     */
    public static MethodHandle EnableMenuItem$handle() {
        return EnableMenuItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
     * }
     */
    public static MemorySegment EnableMenuItem$address() {
        return EnableMenuItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
     * }
     */
    public static int EnableMenuItem(MemorySegment hMenu, int uIDEnableItem, int uEnable) {
        var mh$ = EnableMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableMenuItem", hMenu, uIDEnableItem, uEnable);
            }
            return (int)mh$.invokeExact(hMenu, uIDEnableItem, uEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSubMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSubMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU GetSubMenu(HMENU hMenu, int nPos)
     * }
     */
    public static FunctionDescriptor GetSubMenu$descriptor() {
        return GetSubMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU GetSubMenu(HMENU hMenu, int nPos)
     * }
     */
    public static MethodHandle GetSubMenu$handle() {
        return GetSubMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMENU GetSubMenu(HMENU hMenu, int nPos)
     * }
     */
    public static MemorySegment GetSubMenu$address() {
        return GetSubMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMENU GetSubMenu(HMENU hMenu, int nPos)
     * }
     */
    public static MemorySegment GetSubMenu(MemorySegment hMenu, int nPos) {
        var mh$ = GetSubMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSubMenu", hMenu, nPos);
            }
            return (MemorySegment)mh$.invokeExact(hMenu, nPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenuItemID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMenuItemID(HMENU hMenu, int nPos)
     * }
     */
    public static FunctionDescriptor GetMenuItemID$descriptor() {
        return GetMenuItemID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMenuItemID(HMENU hMenu, int nPos)
     * }
     */
    public static MethodHandle GetMenuItemID$handle() {
        return GetMenuItemID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetMenuItemID(HMENU hMenu, int nPos)
     * }
     */
    public static MemorySegment GetMenuItemID$address() {
        return GetMenuItemID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetMenuItemID(HMENU hMenu, int nPos)
     * }
     */
    public static int GetMenuItemID(MemorySegment hMenu, int nPos) {
        var mh$ = GetMenuItemID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemID", hMenu, nPos);
            }
            return (int)mh$.invokeExact(hMenu, nPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenuItemCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMenuItemCount(HMENU hMenu)
     * }
     */
    public static FunctionDescriptor GetMenuItemCount$descriptor() {
        return GetMenuItemCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMenuItemCount(HMENU hMenu)
     * }
     */
    public static MethodHandle GetMenuItemCount$handle() {
        return GetMenuItemCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMenuItemCount(HMENU hMenu)
     * }
     */
    public static MemorySegment GetMenuItemCount$address() {
        return GetMenuItemCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMenuItemCount(HMENU hMenu)
     * }
     */
    public static int GetMenuItemCount(MemorySegment hMenu) {
        var mh$ = GetMenuItemCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemCount", hMenu);
            }
            return (int)mh$.invokeExact(hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InsertMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InsertMenuA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor InsertMenuA$descriptor() {
        return InsertMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MethodHandle InsertMenuA$handle() {
        return InsertMenuA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MemorySegment InsertMenuA$address() {
        return InsertMenuA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static int InsertMenuA(MemorySegment hMenu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = InsertMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuA", hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InsertMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InsertMenuW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor InsertMenuW$descriptor() {
        return InsertMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MethodHandle InsertMenuW$handle() {
        return InsertMenuW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MemorySegment InsertMenuW$address() {
        return InsertMenuW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static int InsertMenuW(MemorySegment hMenu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = InsertMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuW", hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AppendMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AppendMenuA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor AppendMenuA$descriptor() {
        return AppendMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MethodHandle AppendMenuA$handle() {
        return AppendMenuA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MemorySegment AppendMenuA$address() {
        return AppendMenuA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static int AppendMenuA(MemorySegment hMenu, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = AppendMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AppendMenuA", hMenu, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AppendMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AppendMenuW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor AppendMenuW$descriptor() {
        return AppendMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MethodHandle AppendMenuW$handle() {
        return AppendMenuW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MemorySegment AppendMenuW$address() {
        return AppendMenuW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static int AppendMenuW(MemorySegment hMenu, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = AppendMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AppendMenuW", hMenu, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModifyMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ModifyMenuA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor ModifyMenuA$descriptor() {
        return ModifyMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MethodHandle ModifyMenuA$handle() {
        return ModifyMenuA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MemorySegment ModifyMenuA$address() {
        return ModifyMenuA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static int ModifyMenuA(MemorySegment hMnu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = ModifyMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModifyMenuA", hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModifyMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ModifyMenuW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor ModifyMenuW$descriptor() {
        return ModifyMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MethodHandle ModifyMenuW$handle() {
        return ModifyMenuW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MemorySegment ModifyMenuW$address() {
        return ModifyMenuW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static int ModifyMenuW(MemorySegment hMnu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = ModifyMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModifyMenuW", hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static FunctionDescriptor RemoveMenu$descriptor() {
        return RemoveMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static MethodHandle RemoveMenu$handle() {
        return RemoveMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static MemorySegment RemoveMenu$address() {
        return RemoveMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static int RemoveMenu(MemorySegment hMenu, int uPosition, int uFlags) {
        var mh$ = RemoveMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveMenu", hMenu, uPosition, uFlags);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DeleteMenu$descriptor() {
        return DeleteMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static MethodHandle DeleteMenu$handle() {
        return DeleteMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static MemorySegment DeleteMenu$address() {
        return DeleteMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static int DeleteMenu(MemorySegment hMenu, int uPosition, int uFlags) {
        var mh$ = DeleteMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteMenu", hMenu, uPosition, uFlags);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuItemBitmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMenuItemBitmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked)
     * }
     */
    public static FunctionDescriptor SetMenuItemBitmaps$descriptor() {
        return SetMenuItemBitmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked)
     * }
     */
    public static MethodHandle SetMenuItemBitmaps$handle() {
        return SetMenuItemBitmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked)
     * }
     */
    public static MemorySegment SetMenuItemBitmaps$address() {
        return SetMenuItemBitmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked)
     * }
     */
    public static int SetMenuItemBitmaps(MemorySegment hMenu, int uPosition, int uFlags, MemorySegment hBitmapUnchecked, MemorySegment hBitmapChecked) {
        var mh$ = SetMenuItemBitmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuItemBitmaps", hMenu, uPosition, uFlags, hBitmapUnchecked, hBitmapChecked);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags, hBitmapUnchecked, hBitmapChecked);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuCheckMarkDimensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenuCheckMarkDimensions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetMenuCheckMarkDimensions()
     * }
     */
    public static FunctionDescriptor GetMenuCheckMarkDimensions$descriptor() {
        return GetMenuCheckMarkDimensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetMenuCheckMarkDimensions()
     * }
     */
    public static MethodHandle GetMenuCheckMarkDimensions$handle() {
        return GetMenuCheckMarkDimensions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG GetMenuCheckMarkDimensions()
     * }
     */
    public static MemorySegment GetMenuCheckMarkDimensions$address() {
        return GetMenuCheckMarkDimensions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG GetMenuCheckMarkDimensions()
     * }
     */
    public static int GetMenuCheckMarkDimensions() {
        var mh$ = GetMenuCheckMarkDimensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuCheckMarkDimensions");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TrackPopupMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TrackPopupMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
     * }
     */
    public static FunctionDescriptor TrackPopupMenu$descriptor() {
        return TrackPopupMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
     * }
     */
    public static MethodHandle TrackPopupMenu$handle() {
        return TrackPopupMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
     * }
     */
    public static MemorySegment TrackPopupMenu$address() {
        return TrackPopupMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
     * }
     */
    public static int TrackPopupMenu(MemorySegment hMenu, int uFlags, int x, int y, int nReserved, MemorySegment hWnd, MemorySegment prcRect) {
        var mh$ = TrackPopupMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrackPopupMenu", hMenu, uFlags, x, y, nReserved, hWnd, prcRect);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, x, y, nReserved, hWnd, prcRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef TPMPARAMS *LPTPMPARAMS
     * }
     */
    public static final AddressLayout LPTPMPARAMS = wgl_h.C_POINTER;

    private static class TrackPopupMenuEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TrackPopupMenuEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm)
     * }
     */
    public static FunctionDescriptor TrackPopupMenuEx$descriptor() {
        return TrackPopupMenuEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm)
     * }
     */
    public static MethodHandle TrackPopupMenuEx$handle() {
        return TrackPopupMenuEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm)
     * }
     */
    public static MemorySegment TrackPopupMenuEx$address() {
        return TrackPopupMenuEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm)
     * }
     */
    public static int TrackPopupMenuEx(MemorySegment hMenu, int uFlags, int x, int y, MemorySegment hwnd, MemorySegment lptpm) {
        var mh$ = TrackPopupMenuEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrackPopupMenuEx", hMenu, uFlags, x, y, hwnd, lptpm);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, x, y, hwnd, lptpm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CalculatePopupWindowPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CalculatePopupWindowPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CalculatePopupWindowPosition(const POINT *anchorPoint, const SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition)
     * }
     */
    public static FunctionDescriptor CalculatePopupWindowPosition$descriptor() {
        return CalculatePopupWindowPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CalculatePopupWindowPosition(const POINT *anchorPoint, const SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition)
     * }
     */
    public static MethodHandle CalculatePopupWindowPosition$handle() {
        return CalculatePopupWindowPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CalculatePopupWindowPosition(const POINT *anchorPoint, const SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition)
     * }
     */
    public static MemorySegment CalculatePopupWindowPosition$address() {
        return CalculatePopupWindowPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CalculatePopupWindowPosition(const POINT *anchorPoint, const SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition)
     * }
     */
    public static int CalculatePopupWindowPosition(MemorySegment anchorPoint, MemorySegment windowSize, int flags, MemorySegment excludeRect, MemorySegment popupWindowPosition) {
        var mh$ = CalculatePopupWindowPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CalculatePopupWindowPosition", anchorPoint, windowSize, flags, excludeRect, popupWindowPosition);
            }
            return (int)mh$.invokeExact(anchorPoint, windowSize, flags, excludeRect, popupWindowPosition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUINFO {
     *     DWORD cbSize;
     *     DWORD fMask;
     *     DWORD dwStyle;
     *     UINT cyMax;
     *     HBRUSH hbrBack;
     *     DWORD dwContextHelpID;
     *     ULONG_PTR dwMenuData;
     * } *LPMENUINFO
     * }
     */
    public static final AddressLayout LPMENUINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const MENUINFO *LPCMENUINFO
     * }
     */
    public static final AddressLayout LPCMENUINFO = wgl_h.C_POINTER;

    private static class GetMenuInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenuInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuInfo(HMENU, LPMENUINFO)
     * }
     */
    public static FunctionDescriptor GetMenuInfo$descriptor() {
        return GetMenuInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuInfo(HMENU, LPMENUINFO)
     * }
     */
    public static MethodHandle GetMenuInfo$handle() {
        return GetMenuInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMenuInfo(HMENU, LPMENUINFO)
     * }
     */
    public static MemorySegment GetMenuInfo$address() {
        return GetMenuInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMenuInfo(HMENU, LPMENUINFO)
     * }
     */
    public static int GetMenuInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetMenuInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuInfo", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMenuInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuInfo(HMENU, LPCMENUINFO)
     * }
     */
    public static FunctionDescriptor SetMenuInfo$descriptor() {
        return SetMenuInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuInfo(HMENU, LPCMENUINFO)
     * }
     */
    public static MethodHandle SetMenuInfo$handle() {
        return SetMenuInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenuInfo(HMENU, LPCMENUINFO)
     * }
     */
    public static MemorySegment SetMenuInfo$address() {
        return SetMenuInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenuInfo(HMENU, LPCMENUINFO)
     * }
     */
    public static int SetMenuInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = SetMenuInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuInfo", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EndMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndMenu()
     * }
     */
    public static FunctionDescriptor EndMenu$descriptor() {
        return EndMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndMenu()
     * }
     */
    public static MethodHandle EndMenu$handle() {
        return EndMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndMenu()
     * }
     */
    public static MemorySegment EndMenu$address() {
        return EndMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndMenu()
     * }
     */
    public static int EndMenu() {
        var mh$ = EndMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndMenu");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUGETOBJECTINFO {
     *     DWORD dwFlags;
     *     UINT uPos;
     *     HMENU hmenu;
     *     PVOID riid;
     *     PVOID pvObj;
     * } *PMENUGETOBJECTINFO
     * }
     */
    public static final AddressLayout PMENUGETOBJECTINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUITEMINFOA {
     *     UINT cbSize;
     *     UINT fMask;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HMENU hSubMenu;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     ULONG_PTR dwItemData;
     *     LPSTR dwTypeData;
     *     UINT cch;
     *     HBITMAP hbmpItem;
     * } *LPMENUITEMINFOA
     * }
     */
    public static final AddressLayout LPMENUITEMINFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUITEMINFOW {
     *     UINT cbSize;
     *     UINT fMask;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HMENU hSubMenu;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     ULONG_PTR dwItemData;
     *     LPWSTR dwTypeData;
     *     UINT cch;
     *     HBITMAP hbmpItem;
     * } *LPMENUITEMINFOW
     * }
     */
    public static final AddressLayout LPMENUITEMINFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMENUITEMINFOA LPMENUITEMINFO
     * }
     */
    public static final AddressLayout LPMENUITEMINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const MENUITEMINFOA *LPCMENUITEMINFOA
     * }
     */
    public static final AddressLayout LPCMENUITEMINFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const MENUITEMINFOW *LPCMENUITEMINFOW
     * }
     */
    public static final AddressLayout LPCMENUITEMINFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCMENUITEMINFOA LPCMENUITEMINFO
     * }
     */
    public static final AddressLayout LPCMENUITEMINFO = wgl_h.C_POINTER;

    private static class InsertMenuItemA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InsertMenuItemA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi)
     * }
     */
    public static FunctionDescriptor InsertMenuItemA$descriptor() {
        return InsertMenuItemA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi)
     * }
     */
    public static MethodHandle InsertMenuItemA$handle() {
        return InsertMenuItemA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi)
     * }
     */
    public static MemorySegment InsertMenuItemA$address() {
        return InsertMenuItemA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi)
     * }
     */
    public static int InsertMenuItemA(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmi) {
        var mh$ = InsertMenuItemA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuItemA", hmenu, item, fByPosition, lpmi);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InsertMenuItemW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InsertMenuItemW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
     * }
     */
    public static FunctionDescriptor InsertMenuItemW$descriptor() {
        return InsertMenuItemW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
     * }
     */
    public static MethodHandle InsertMenuItemW$handle() {
        return InsertMenuItemW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
     * }
     */
    public static MemorySegment InsertMenuItemW$address() {
        return InsertMenuItemW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
     * }
     */
    public static int InsertMenuItemW(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmi) {
        var mh$ = InsertMenuItemW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuItemW", hmenu, item, fByPosition, lpmi);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenuItemInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii)
     * }
     */
    public static FunctionDescriptor GetMenuItemInfoA$descriptor() {
        return GetMenuItemInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii)
     * }
     */
    public static MethodHandle GetMenuItemInfoA$handle() {
        return GetMenuItemInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii)
     * }
     */
    public static MemorySegment GetMenuItemInfoA$address() {
        return GetMenuItemInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii)
     * }
     */
    public static int GetMenuItemInfoA(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmii) {
        var mh$ = GetMenuItemInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemInfoA", hmenu, item, fByPosition, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenuItemInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii)
     * }
     */
    public static FunctionDescriptor GetMenuItemInfoW$descriptor() {
        return GetMenuItemInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii)
     * }
     */
    public static MethodHandle GetMenuItemInfoW$handle() {
        return GetMenuItemInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii)
     * }
     */
    public static MemorySegment GetMenuItemInfoW$address() {
        return GetMenuItemInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii)
     * }
     */
    public static int GetMenuItemInfoW(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmii) {
        var mh$ = GetMenuItemInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemInfoW", hmenu, item, fByPosition, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuItemInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMenuItemInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii)
     * }
     */
    public static FunctionDescriptor SetMenuItemInfoA$descriptor() {
        return SetMenuItemInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii)
     * }
     */
    public static MethodHandle SetMenuItemInfoA$handle() {
        return SetMenuItemInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii)
     * }
     */
    public static MemorySegment SetMenuItemInfoA$address() {
        return SetMenuItemInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii)
     * }
     */
    public static int SetMenuItemInfoA(MemorySegment hmenu, int item, int fByPositon, MemorySegment lpmii) {
        var mh$ = SetMenuItemInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuItemInfoA", hmenu, item, fByPositon, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPositon, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuItemInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMenuItemInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
     * }
     */
    public static FunctionDescriptor SetMenuItemInfoW$descriptor() {
        return SetMenuItemInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
     * }
     */
    public static MethodHandle SetMenuItemInfoW$handle() {
        return SetMenuItemInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
     * }
     */
    public static MemorySegment SetMenuItemInfoW$address() {
        return SetMenuItemInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
     * }
     */
    public static int SetMenuItemInfoW(MemorySegment hmenu, int item, int fByPositon, MemorySegment lpmii) {
        var mh$ = SetMenuItemInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuItemInfoW", hmenu, item, fByPositon, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPositon, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuDefaultItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenuDefaultItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags)
     * }
     */
    public static FunctionDescriptor GetMenuDefaultItem$descriptor() {
        return GetMenuDefaultItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags)
     * }
     */
    public static MethodHandle GetMenuDefaultItem$handle() {
        return GetMenuDefaultItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags)
     * }
     */
    public static MemorySegment GetMenuDefaultItem$address() {
        return GetMenuDefaultItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags)
     * }
     */
    public static int GetMenuDefaultItem(MemorySegment hMenu, int fByPos, int gmdiFlags) {
        var mh$ = GetMenuDefaultItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuDefaultItem", hMenu, fByPos, gmdiFlags);
            }
            return (int)mh$.invokeExact(hMenu, fByPos, gmdiFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuDefaultItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetMenuDefaultItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos)
     * }
     */
    public static FunctionDescriptor SetMenuDefaultItem$descriptor() {
        return SetMenuDefaultItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos)
     * }
     */
    public static MethodHandle SetMenuDefaultItem$handle() {
        return SetMenuDefaultItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos)
     * }
     */
    public static MemorySegment SetMenuDefaultItem$address() {
        return SetMenuDefaultItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos)
     * }
     */
    public static int SetMenuDefaultItem(MemorySegment hMenu, int uItem, int fByPos) {
        var mh$ = SetMenuDefaultItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuDefaultItem", hMenu, uItem, fByPos);
            }
            return (int)mh$.invokeExact(hMenu, uItem, fByPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMenuItemRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem)
     * }
     */
    public static FunctionDescriptor GetMenuItemRect$descriptor() {
        return GetMenuItemRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem)
     * }
     */
    public static MethodHandle GetMenuItemRect$handle() {
        return GetMenuItemRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem)
     * }
     */
    public static MemorySegment GetMenuItemRect$address() {
        return GetMenuItemRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem)
     * }
     */
    public static int GetMenuItemRect(MemorySegment hWnd, MemorySegment hMenu, int uItem, MemorySegment lprcItem) {
        var mh$ = GetMenuItemRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemRect", hWnd, hMenu, uItem, lprcItem);
            }
            return (int)mh$.invokeExact(hWnd, hMenu, uItem, lprcItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MenuItemFromPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            tagPOINT.layout()
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MenuItemFromPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen)
     * }
     */
    public static FunctionDescriptor MenuItemFromPoint$descriptor() {
        return MenuItemFromPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen)
     * }
     */
    public static MethodHandle MenuItemFromPoint$handle() {
        return MenuItemFromPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen)
     * }
     */
    public static MemorySegment MenuItemFromPoint$address() {
        return MenuItemFromPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen)
     * }
     */
    public static int MenuItemFromPoint(MemorySegment hWnd, MemorySegment hMenu, MemorySegment ptScreen) {
        var mh$ = MenuItemFromPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MenuItemFromPoint", hWnd, hMenu, ptScreen);
            }
            return (int)mh$.invokeExact(hWnd, hMenu, ptScreen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDROPSTRUCT {
     *     HWND hwndSource;
     *     HWND hwndSink;
     *     DWORD wFmt;
     *     ULONG_PTR dwData;
     *     POINT ptDrop;
     *     DWORD dwControlData;
     * } *PDROPSTRUCT
     * }
     */
    public static final AddressLayout PDROPSTRUCT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDROPSTRUCT {
     *     HWND hwndSource;
     *     HWND hwndSink;
     *     DWORD wFmt;
     *     ULONG_PTR dwData;
     *     POINT ptDrop;
     *     DWORD dwControlData;
     * } *LPDROPSTRUCT
     * }
     */
    public static final AddressLayout LPDROPSTRUCT = wgl_h.C_POINTER;

    private static class DragObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DragObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur)
     * }
     */
    public static FunctionDescriptor DragObject$descriptor() {
        return DragObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur)
     * }
     */
    public static MethodHandle DragObject$handle() {
        return DragObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur)
     * }
     */
    public static MemorySegment DragObject$address() {
        return DragObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur)
     * }
     */
    public static int DragObject(MemorySegment hwndParent, MemorySegment hwndFrom, int fmt, long data, MemorySegment hcur) {
        var mh$ = DragObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DragObject", hwndParent, hwndFrom, fmt, data, hcur);
            }
            return (int)mh$.invokeExact(hwndParent, hwndFrom, fmt, data, hcur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DragDetect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            tagPOINT.layout()
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DragDetect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DragDetect(HWND hwnd, POINT pt)
     * }
     */
    public static FunctionDescriptor DragDetect$descriptor() {
        return DragDetect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DragDetect(HWND hwnd, POINT pt)
     * }
     */
    public static MethodHandle DragDetect$handle() {
        return DragDetect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DragDetect(HWND hwnd, POINT pt)
     * }
     */
    public static MemorySegment DragDetect$address() {
        return DragDetect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DragDetect(HWND hwnd, POINT pt)
     * }
     */
    public static int DragDetect(MemorySegment hwnd, MemorySegment pt) {
        var mh$ = DragDetect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DragDetect", hwnd, pt);
            }
            return (int)mh$.invokeExact(hwnd, pt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawIcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
     * }
     */
    public static FunctionDescriptor DrawIcon$descriptor() {
        return DrawIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
     * }
     */
    public static MethodHandle DrawIcon$handle() {
        return DrawIcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
     * }
     */
    public static MemorySegment DrawIcon$address() {
        return DrawIcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
     * }
     */
    public static int DrawIcon(MemorySegment hDC, int X, int Y, MemorySegment hIcon) {
        var mh$ = DrawIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawIcon", hDC, X, Y, hIcon);
            }
            return (int)mh$.invokeExact(hDC, X, Y, hIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDRAWTEXTPARAMS {
     *     UINT cbSize;
     *     int iTabLength;
     *     int iLeftMargin;
     *     int iRightMargin;
     *     UINT uiLengthDrawn;
     * } *LPDRAWTEXTPARAMS
     * }
     */
    public static final AddressLayout LPDRAWTEXTPARAMS = wgl_h.C_POINTER;

    private static class DrawTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static FunctionDescriptor DrawTextA$descriptor() {
        return DrawTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static MethodHandle DrawTextA$handle() {
        return DrawTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static MemorySegment DrawTextA$address() {
        return DrawTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static int DrawTextA(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format) {
        var mh$ = DrawTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextA", hdc, lpchText, cchText, lprc, format);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static FunctionDescriptor DrawTextW$descriptor() {
        return DrawTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static MethodHandle DrawTextW$handle() {
        return DrawTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static MemorySegment DrawTextW$address() {
        return DrawTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static int DrawTextW(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format) {
        var mh$ = DrawTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextW", hdc, lpchText, cchText, lprc, format);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawTextExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static FunctionDescriptor DrawTextExA$descriptor() {
        return DrawTextExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static MethodHandle DrawTextExA$handle() {
        return DrawTextExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static MemorySegment DrawTextExA$address() {
        return DrawTextExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static int DrawTextExA(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format, MemorySegment lpdtp) {
        var mh$ = DrawTextExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextExA", hdc, lpchText, cchText, lprc, format, lpdtp);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format, lpdtp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawTextExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static FunctionDescriptor DrawTextExW$descriptor() {
        return DrawTextExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static MethodHandle DrawTextExW$handle() {
        return DrawTextExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static MemorySegment DrawTextExW$address() {
        return DrawTextExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static int DrawTextExW(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format, MemorySegment lpdtp) {
        var mh$ = DrawTextExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextExW", hdc, lpchText, cchText, lprc, format, lpdtp);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format, lpdtp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrayStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GrayStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static FunctionDescriptor GrayStringA$descriptor() {
        return GrayStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static MethodHandle GrayStringA$handle() {
        return GrayStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static MemorySegment GrayStringA$address() {
        return GrayStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static int GrayStringA(MemorySegment hDC, MemorySegment hBrush, MemorySegment lpOutputFunc, long lpData, int nCount, int X, int Y, int nWidth, int nHeight) {
        var mh$ = GrayStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrayStringA", hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
            }
            return (int)mh$.invokeExact(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrayStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GrayStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static FunctionDescriptor GrayStringW$descriptor() {
        return GrayStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static MethodHandle GrayStringW$handle() {
        return GrayStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static MemorySegment GrayStringW$address() {
        return GrayStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static int GrayStringW(MemorySegment hDC, MemorySegment hBrush, MemorySegment lpOutputFunc, long lpData, int nCount, int X, int Y, int nWidth, int nHeight) {
        var mh$ = GrayStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrayStringW", hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
            }
            return (int)mh$.invokeExact(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawStateA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawStateA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DrawStateA$descriptor() {
        return DrawStateA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle DrawStateA$handle() {
        return DrawStateA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MemorySegment DrawStateA$address() {
        return DrawStateA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static int DrawStateA(MemorySegment hdc, MemorySegment hbrFore, MemorySegment qfnCallBack, long lData, long wData, int x, int y, int cx, int cy, int uFlags) {
        var mh$ = DrawStateA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawStateA", hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
            }
            return (int)mh$.invokeExact(hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawStateW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DrawStateW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DrawStateW$descriptor() {
        return DrawStateW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle DrawStateW$handle() {
        return DrawStateW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MemorySegment DrawStateW$address() {
        return DrawStateW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static int DrawStateW(MemorySegment hdc, MemorySegment hbrFore, MemorySegment qfnCallBack, long lData, long wData, int x, int y, int cx, int cy, int uFlags) {
        var mh$ = DrawStateW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawStateW", hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
            }
            return (int)mh$.invokeExact(hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TabbedTextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TabbedTextOutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static FunctionDescriptor TabbedTextOutA$descriptor() {
        return TabbedTextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static MethodHandle TabbedTextOutA$handle() {
        return TabbedTextOutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static MemorySegment TabbedTextOutA$address() {
        return TabbedTextOutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static int TabbedTextOutA(MemorySegment hdc, int x, int y, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions, int nTabOrigin) {
        var mh$ = TabbedTextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TabbedTextOutA", hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TabbedTextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TabbedTextOutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static FunctionDescriptor TabbedTextOutW$descriptor() {
        return TabbedTextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static MethodHandle TabbedTextOutW$handle() {
        return TabbedTextOutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static MemorySegment TabbedTextOutW$address() {
        return TabbedTextOutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static int TabbedTextOutW(MemorySegment hdc, int x, int y, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions, int nTabOrigin) {
        var mh$ = TabbedTextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TabbedTextOutW", hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTabbedTextExtentA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTabbedTextExtentA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static FunctionDescriptor GetTabbedTextExtentA$descriptor() {
        return GetTabbedTextExtentA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static MethodHandle GetTabbedTextExtentA$handle() {
        return GetTabbedTextExtentA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static MemorySegment GetTabbedTextExtentA$address() {
        return GetTabbedTextExtentA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static int GetTabbedTextExtentA(MemorySegment hdc, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions) {
        var mh$ = GetTabbedTextExtentA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTabbedTextExtentA", hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
            }
            return (int)mh$.invokeExact(hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTabbedTextExtentW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTabbedTextExtentW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static FunctionDescriptor GetTabbedTextExtentW$descriptor() {
        return GetTabbedTextExtentW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static MethodHandle GetTabbedTextExtentW$handle() {
        return GetTabbedTextExtentW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static MemorySegment GetTabbedTextExtentW$address() {
        return GetTabbedTextExtentW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static int GetTabbedTextExtentW(MemorySegment hdc, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions) {
        var mh$ = GetTabbedTextExtentW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTabbedTextExtentW", hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
            }
            return (int)mh$.invokeExact(hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UpdateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor UpdateWindow$descriptor() {
        return UpdateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateWindow(HWND hWnd)
     * }
     */
    public static MethodHandle UpdateWindow$handle() {
        return UpdateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateWindow(HWND hWnd)
     * }
     */
    public static MemorySegment UpdateWindow$address() {
        return UpdateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateWindow(HWND hWnd)
     * }
     */
    public static int UpdateWindow(MemorySegment hWnd) {
        var mh$ = UpdateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetActiveWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetActiveWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetActiveWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetActiveWindow$descriptor() {
        return SetActiveWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetActiveWindow(HWND hWnd)
     * }
     */
    public static MethodHandle SetActiveWindow$handle() {
        return SetActiveWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND SetActiveWindow(HWND hWnd)
     * }
     */
    public static MemorySegment SetActiveWindow$address() {
        return SetActiveWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND SetActiveWindow(HWND hWnd)
     * }
     */
    public static MemorySegment SetActiveWindow(MemorySegment hWnd) {
        var mh$ = SetActiveWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetActiveWindow", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetForegroundWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetForegroundWindow()
     * }
     */
    public static FunctionDescriptor GetForegroundWindow$descriptor() {
        return GetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetForegroundWindow()
     * }
     */
    public static MethodHandle GetForegroundWindow$handle() {
        return GetForegroundWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetForegroundWindow()
     * }
     */
    public static MemorySegment GetForegroundWindow$address() {
        return GetForegroundWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetForegroundWindow()
     * }
     */
    public static MemorySegment GetForegroundWindow() {
        var mh$ = GetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetForegroundWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PaintDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PaintDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PaintDesktop(HDC hdc)
     * }
     */
    public static FunctionDescriptor PaintDesktop$descriptor() {
        return PaintDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PaintDesktop(HDC hdc)
     * }
     */
    public static MethodHandle PaintDesktop$handle() {
        return PaintDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PaintDesktop(HDC hdc)
     * }
     */
    public static MemorySegment PaintDesktop$address() {
        return PaintDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PaintDesktop(HDC hdc)
     * }
     */
    public static int PaintDesktop(MemorySegment hdc) {
        var mh$ = PaintDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PaintDesktop", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchToThisWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SwitchToThisWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SwitchToThisWindow(HWND hwnd, BOOL fUnknown)
     * }
     */
    public static FunctionDescriptor SwitchToThisWindow$descriptor() {
        return SwitchToThisWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SwitchToThisWindow(HWND hwnd, BOOL fUnknown)
     * }
     */
    public static MethodHandle SwitchToThisWindow$handle() {
        return SwitchToThisWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SwitchToThisWindow(HWND hwnd, BOOL fUnknown)
     * }
     */
    public static MemorySegment SwitchToThisWindow$address() {
        return SwitchToThisWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SwitchToThisWindow(HWND hwnd, BOOL fUnknown)
     * }
     */
    public static void SwitchToThisWindow(MemorySegment hwnd, int fUnknown) {
        var mh$ = SwitchToThisWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchToThisWindow", hwnd, fUnknown);
            }
            mh$.invokeExact(hwnd, fUnknown);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetForegroundWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetForegroundWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetForegroundWindow$descriptor() {
        return SetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetForegroundWindow(HWND hWnd)
     * }
     */
    public static MethodHandle SetForegroundWindow$handle() {
        return SetForegroundWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetForegroundWindow(HWND hWnd)
     * }
     */
    public static MemorySegment SetForegroundWindow$address() {
        return SetForegroundWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetForegroundWindow(HWND hWnd)
     * }
     */
    public static int SetForegroundWindow(MemorySegment hWnd) {
        var mh$ = SetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetForegroundWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllowSetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AllowSetForegroundWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllowSetForegroundWindow(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor AllowSetForegroundWindow$descriptor() {
        return AllowSetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllowSetForegroundWindow(DWORD dwProcessId)
     * }
     */
    public static MethodHandle AllowSetForegroundWindow$handle() {
        return AllowSetForegroundWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllowSetForegroundWindow(DWORD dwProcessId)
     * }
     */
    public static MemorySegment AllowSetForegroundWindow$address() {
        return AllowSetForegroundWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllowSetForegroundWindow(DWORD dwProcessId)
     * }
     */
    public static int AllowSetForegroundWindow(int dwProcessId) {
        var mh$ = AllowSetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllowSetForegroundWindow", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockSetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LockSetForegroundWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockSetForegroundWindow(UINT uLockCode)
     * }
     */
    public static FunctionDescriptor LockSetForegroundWindow$descriptor() {
        return LockSetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockSetForegroundWindow(UINT uLockCode)
     * }
     */
    public static MethodHandle LockSetForegroundWindow$handle() {
        return LockSetForegroundWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LockSetForegroundWindow(UINT uLockCode)
     * }
     */
    public static MemorySegment LockSetForegroundWindow$address() {
        return LockSetForegroundWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LockSetForegroundWindow(UINT uLockCode)
     * }
     */
    public static int LockSetForegroundWindow(int uLockCode) {
        var mh$ = LockSetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockSetForegroundWindow", uLockCode);
            }
            return (int)mh$.invokeExact(uLockCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WindowFromDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WindowFromDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND WindowFromDC(HDC hDC)
     * }
     */
    public static FunctionDescriptor WindowFromDC$descriptor() {
        return WindowFromDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND WindowFromDC(HDC hDC)
     * }
     */
    public static MethodHandle WindowFromDC$handle() {
        return WindowFromDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND WindowFromDC(HDC hDC)
     * }
     */
    public static MemorySegment WindowFromDC$address() {
        return WindowFromDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND WindowFromDC(HDC hDC)
     * }
     */
    public static MemorySegment WindowFromDC(MemorySegment hDC) {
        var mh$ = WindowFromDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WindowFromDC", hDC);
            }
            return (MemorySegment)mh$.invokeExact(hDC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC GetDC(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetDC$descriptor() {
        return GetDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC GetDC(HWND hWnd)
     * }
     */
    public static MethodHandle GetDC$handle() {
        return GetDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC GetDC(HWND hWnd)
     * }
     */
    public static MemorySegment GetDC$address() {
        return GetDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC GetDC(HWND hWnd)
     * }
     */
    public static MemorySegment GetDC(MemorySegment hWnd) {
        var mh$ = GetDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDC", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDCEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
     * }
     */
    public static FunctionDescriptor GetDCEx$descriptor() {
        return GetDCEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
     * }
     */
    public static MethodHandle GetDCEx$handle() {
        return GetDCEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
     * }
     */
    public static MemorySegment GetDCEx$address() {
        return GetDCEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
     * }
     */
    public static MemorySegment GetDCEx(MemorySegment hWnd, MemorySegment hrgnClip, int flags) {
        var mh$ = GetDCEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCEx", hWnd, hrgnClip, flags);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, hrgnClip, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWindowDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC GetWindowDC(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetWindowDC$descriptor() {
        return GetWindowDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC GetWindowDC(HWND hWnd)
     * }
     */
    public static MethodHandle GetWindowDC$handle() {
        return GetWindowDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC GetWindowDC(HWND hWnd)
     * }
     */
    public static MemorySegment GetWindowDC$address() {
        return GetWindowDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC GetWindowDC(HWND hWnd)
     * }
     */
    public static MemorySegment GetWindowDC(MemorySegment hWnd) {
        var mh$ = GetWindowDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowDC", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReleaseDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ReleaseDC(HWND hWnd, HDC hDC)
     * }
     */
    public static FunctionDescriptor ReleaseDC$descriptor() {
        return ReleaseDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ReleaseDC(HWND hWnd, HDC hDC)
     * }
     */
    public static MethodHandle ReleaseDC$handle() {
        return ReleaseDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ReleaseDC(HWND hWnd, HDC hDC)
     * }
     */
    public static MemorySegment ReleaseDC$address() {
        return ReleaseDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ReleaseDC(HWND hWnd, HDC hDC)
     * }
     */
    public static int ReleaseDC(MemorySegment hWnd, MemorySegment hDC) {
        var mh$ = ReleaseDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseDC", hWnd, hDC);
            }
            return (int)mh$.invokeExact(hWnd, hDC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginPaint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("BeginPaint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
     * }
     */
    public static FunctionDescriptor BeginPaint$descriptor() {
        return BeginPaint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
     * }
     */
    public static MethodHandle BeginPaint$handle() {
        return BeginPaint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
     * }
     */
    public static MemorySegment BeginPaint$address() {
        return BeginPaint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
     * }
     */
    public static MemorySegment BeginPaint(MemorySegment hWnd, MemorySegment lpPaint) {
        var mh$ = BeginPaint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginPaint", hWnd, lpPaint);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, lpPaint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndPaint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EndPaint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
     * }
     */
    public static FunctionDescriptor EndPaint$descriptor() {
        return EndPaint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
     * }
     */
    public static MethodHandle EndPaint$handle() {
        return EndPaint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
     * }
     */
    public static MemorySegment EndPaint$address() {
        return EndPaint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
     * }
     */
    public static int EndPaint(MemorySegment hWnd, MemorySegment lpPaint) {
        var mh$ = EndPaint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndPaint", hWnd, lpPaint);
            }
            return (int)mh$.invokeExact(hWnd, lpPaint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUpdateRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetUpdateRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase)
     * }
     */
    public static FunctionDescriptor GetUpdateRect$descriptor() {
        return GetUpdateRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase)
     * }
     */
    public static MethodHandle GetUpdateRect$handle() {
        return GetUpdateRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase)
     * }
     */
    public static MemorySegment GetUpdateRect$address() {
        return GetUpdateRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase)
     * }
     */
    public static int GetUpdateRect(MemorySegment hWnd, MemorySegment lpRect, int bErase) {
        var mh$ = GetUpdateRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUpdateRect", hWnd, lpRect, bErase);
            }
            return (int)mh$.invokeExact(hWnd, lpRect, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUpdateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetUpdateRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static FunctionDescriptor GetUpdateRgn$descriptor() {
        return GetUpdateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static MethodHandle GetUpdateRgn$handle() {
        return GetUpdateRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static MemorySegment GetUpdateRgn$address() {
        return GetUpdateRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static int GetUpdateRgn(MemorySegment hWnd, MemorySegment hRgn, int bErase) {
        var mh$ = GetUpdateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUpdateRgn", hWnd, hRgn, bErase);
            }
            return (int)mh$.invokeExact(hWnd, hRgn, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetWindowRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw)
     * }
     */
    public static FunctionDescriptor SetWindowRgn$descriptor() {
        return SetWindowRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw)
     * }
     */
    public static MethodHandle SetWindowRgn$handle() {
        return SetWindowRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw)
     * }
     */
    public static MemorySegment SetWindowRgn$address() {
        return SetWindowRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw)
     * }
     */
    public static int SetWindowRgn(MemorySegment hWnd, MemorySegment hRgn, int bRedraw) {
        var mh$ = SetWindowRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowRgn", hWnd, hRgn, bRedraw);
            }
            return (int)mh$.invokeExact(hWnd, hRgn, bRedraw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWindowRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static FunctionDescriptor GetWindowRgn$descriptor() {
        return GetWindowRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static MethodHandle GetWindowRgn$handle() {
        return GetWindowRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetWindowRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static MemorySegment GetWindowRgn$address() {
        return GetWindowRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetWindowRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static int GetWindowRgn(MemorySegment hWnd, MemorySegment hRgn) {
        var mh$ = GetWindowRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowRgn", hWnd, hRgn);
            }
            return (int)mh$.invokeExact(hWnd, hRgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowRgnBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWindowRgnBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowRgnBox(HWND hWnd, LPRECT lprc)
     * }
     */
    public static FunctionDescriptor GetWindowRgnBox$descriptor() {
        return GetWindowRgnBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowRgnBox(HWND hWnd, LPRECT lprc)
     * }
     */
    public static MethodHandle GetWindowRgnBox$handle() {
        return GetWindowRgnBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetWindowRgnBox(HWND hWnd, LPRECT lprc)
     * }
     */
    public static MemorySegment GetWindowRgnBox$address() {
        return GetWindowRgnBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetWindowRgnBox(HWND hWnd, LPRECT lprc)
     * }
     */
    public static int GetWindowRgnBox(MemorySegment hWnd, MemorySegment lprc) {
        var mh$ = GetWindowRgnBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowRgnBox", hWnd, lprc);
            }
            return (int)mh$.invokeExact(hWnd, lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExcludeUpdateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExcludeUpdateRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExcludeUpdateRgn(HDC hDC, HWND hWnd)
     * }
     */
    public static FunctionDescriptor ExcludeUpdateRgn$descriptor() {
        return ExcludeUpdateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExcludeUpdateRgn(HDC hDC, HWND hWnd)
     * }
     */
    public static MethodHandle ExcludeUpdateRgn$handle() {
        return ExcludeUpdateRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExcludeUpdateRgn(HDC hDC, HWND hWnd)
     * }
     */
    public static MemorySegment ExcludeUpdateRgn$address() {
        return ExcludeUpdateRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExcludeUpdateRgn(HDC hDC, HWND hWnd)
     * }
     */
    public static int ExcludeUpdateRgn(MemorySegment hDC, MemorySegment hWnd) {
        var mh$ = ExcludeUpdateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExcludeUpdateRgn", hDC, hWnd);
            }
            return (int)mh$.invokeExact(hDC, hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvalidateRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InvalidateRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
     * }
     */
    public static FunctionDescriptor InvalidateRect$descriptor() {
        return InvalidateRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
     * }
     */
    public static MethodHandle InvalidateRect$handle() {
        return InvalidateRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
     * }
     */
    public static MemorySegment InvalidateRect$address() {
        return InvalidateRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
     * }
     */
    public static int InvalidateRect(MemorySegment hWnd, MemorySegment lpRect, int bErase) {
        var mh$ = InvalidateRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvalidateRect", hWnd, lpRect, bErase);
            }
            return (int)mh$.invokeExact(hWnd, lpRect, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ValidateRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ValidateRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ValidateRect(HWND hWnd, const RECT *lpRect)
     * }
     */
    public static FunctionDescriptor ValidateRect$descriptor() {
        return ValidateRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ValidateRect(HWND hWnd, const RECT *lpRect)
     * }
     */
    public static MethodHandle ValidateRect$handle() {
        return ValidateRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ValidateRect(HWND hWnd, const RECT *lpRect)
     * }
     */
    public static MemorySegment ValidateRect$address() {
        return ValidateRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ValidateRect(HWND hWnd, const RECT *lpRect)
     * }
     */
    public static int ValidateRect(MemorySegment hWnd, MemorySegment lpRect) {
        var mh$ = ValidateRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ValidateRect", hWnd, lpRect);
            }
            return (int)mh$.invokeExact(hWnd, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvalidateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InvalidateRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static FunctionDescriptor InvalidateRgn$descriptor() {
        return InvalidateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static MethodHandle InvalidateRgn$handle() {
        return InvalidateRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static MemorySegment InvalidateRgn$address() {
        return InvalidateRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static int InvalidateRgn(MemorySegment hWnd, MemorySegment hRgn, int bErase) {
        var mh$ = InvalidateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvalidateRgn", hWnd, hRgn, bErase);
            }
            return (int)mh$.invokeExact(hWnd, hRgn, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ValidateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ValidateRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ValidateRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static FunctionDescriptor ValidateRgn$descriptor() {
        return ValidateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ValidateRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static MethodHandle ValidateRgn$handle() {
        return ValidateRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ValidateRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static MemorySegment ValidateRgn$address() {
        return ValidateRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ValidateRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static int ValidateRgn(MemorySegment hWnd, MemorySegment hRgn) {
        var mh$ = ValidateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ValidateRgn", hWnd, hRgn);
            }
            return (int)mh$.invokeExact(hWnd, hRgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RedrawWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RedrawWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags)
     * }
     */
    public static FunctionDescriptor RedrawWindow$descriptor() {
        return RedrawWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags)
     * }
     */
    public static MethodHandle RedrawWindow$handle() {
        return RedrawWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags)
     * }
     */
    public static MemorySegment RedrawWindow$address() {
        return RedrawWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags)
     * }
     */
    public static int RedrawWindow(MemorySegment hWnd, MemorySegment lprcUpdate, MemorySegment hrgnUpdate, int flags) {
        var mh$ = RedrawWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RedrawWindow", hWnd, lprcUpdate, hrgnUpdate, flags);
            }
            return (int)mh$.invokeExact(hWnd, lprcUpdate, hrgnUpdate, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

