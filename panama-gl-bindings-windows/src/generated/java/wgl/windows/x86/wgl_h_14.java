// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class wgl_h_14 extends wgl_h_15 {

    wgl_h_14() {
        // Should not be called directly
    }

    private static class OleCreateFromFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleCreateFromFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateFromFile(const IID *const rclsid, LPCOLESTR lpszFileName, const IID *const riid, DWORD renderopt, LPFORMATETC lpFormatEtc, LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID *ppvObj)
     * }
     */
    public static FunctionDescriptor OleCreateFromFile$descriptor() {
        return OleCreateFromFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateFromFile(const IID *const rclsid, LPCOLESTR lpszFileName, const IID *const riid, DWORD renderopt, LPFORMATETC lpFormatEtc, LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID *ppvObj)
     * }
     */
    public static MethodHandle OleCreateFromFile$handle() {
        return OleCreateFromFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateFromFile(const IID *const rclsid, LPCOLESTR lpszFileName, const IID *const riid, DWORD renderopt, LPFORMATETC lpFormatEtc, LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID *ppvObj)
     * }
     */
    public static MemorySegment OleCreateFromFile$address() {
        return OleCreateFromFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleCreateFromFile(const IID *const rclsid, LPCOLESTR lpszFileName, const IID *const riid, DWORD renderopt, LPFORMATETC lpFormatEtc, LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID *ppvObj)
     * }
     */
    public static int OleCreateFromFile(MemorySegment rclsid, MemorySegment lpszFileName, MemorySegment riid, int renderopt, MemorySegment lpFormatEtc, MemorySegment pClientSite, MemorySegment pStg, MemorySegment ppvObj) {
        var mh$ = OleCreateFromFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleCreateFromFile", rclsid, lpszFileName, riid, renderopt, lpFormatEtc, pClientSite, pStg, ppvObj);
            }
            return (int)mh$.invokeExact(rclsid, lpszFileName, riid, renderopt, lpFormatEtc, pClientSite, pStg, ppvObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleCreateFromFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleCreateFromFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateFromFileEx(const IID *const rclsid, LPCOLESTR lpszFileName, const IID *const riid, DWORD dwFlags, DWORD renderopt, ULONG cFormats, DWORD *rgAdvf, LPFORMATETC rgFormatEtc, IAdviseSink *lpAdviseSink, DWORD *rgdwConnection, LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID *ppvObj)
     * }
     */
    public static FunctionDescriptor OleCreateFromFileEx$descriptor() {
        return OleCreateFromFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateFromFileEx(const IID *const rclsid, LPCOLESTR lpszFileName, const IID *const riid, DWORD dwFlags, DWORD renderopt, ULONG cFormats, DWORD *rgAdvf, LPFORMATETC rgFormatEtc, IAdviseSink *lpAdviseSink, DWORD *rgdwConnection, LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID *ppvObj)
     * }
     */
    public static MethodHandle OleCreateFromFileEx$handle() {
        return OleCreateFromFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateFromFileEx(const IID *const rclsid, LPCOLESTR lpszFileName, const IID *const riid, DWORD dwFlags, DWORD renderopt, ULONG cFormats, DWORD *rgAdvf, LPFORMATETC rgFormatEtc, IAdviseSink *lpAdviseSink, DWORD *rgdwConnection, LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID *ppvObj)
     * }
     */
    public static MemorySegment OleCreateFromFileEx$address() {
        return OleCreateFromFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleCreateFromFileEx(const IID *const rclsid, LPCOLESTR lpszFileName, const IID *const riid, DWORD dwFlags, DWORD renderopt, ULONG cFormats, DWORD *rgAdvf, LPFORMATETC rgFormatEtc, IAdviseSink *lpAdviseSink, DWORD *rgdwConnection, LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID *ppvObj)
     * }
     */
    public static int OleCreateFromFileEx(MemorySegment rclsid, MemorySegment lpszFileName, MemorySegment riid, int dwFlags, int renderopt, int cFormats, MemorySegment rgAdvf, MemorySegment rgFormatEtc, MemorySegment lpAdviseSink, MemorySegment rgdwConnection, MemorySegment pClientSite, MemorySegment pStg, MemorySegment ppvObj) {
        var mh$ = OleCreateFromFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleCreateFromFileEx", rclsid, lpszFileName, riid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, pClientSite, pStg, ppvObj);
            }
            return (int)mh$.invokeExact(rclsid, lpszFileName, riid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, pClientSite, pStg, ppvObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleLoad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleLoad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleLoad(LPSTORAGE pStg, const IID *const riid, LPOLECLIENTSITE pClientSite, LPVOID *ppvObj)
     * }
     */
    public static FunctionDescriptor OleLoad$descriptor() {
        return OleLoad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleLoad(LPSTORAGE pStg, const IID *const riid, LPOLECLIENTSITE pClientSite, LPVOID *ppvObj)
     * }
     */
    public static MethodHandle OleLoad$handle() {
        return OleLoad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleLoad(LPSTORAGE pStg, const IID *const riid, LPOLECLIENTSITE pClientSite, LPVOID *ppvObj)
     * }
     */
    public static MemorySegment OleLoad$address() {
        return OleLoad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleLoad(LPSTORAGE pStg, const IID *const riid, LPOLECLIENTSITE pClientSite, LPVOID *ppvObj)
     * }
     */
    public static int OleLoad(MemorySegment pStg, MemorySegment riid, MemorySegment pClientSite, MemorySegment ppvObj) {
        var mh$ = OleLoad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleLoad", pStg, riid, pClientSite, ppvObj);
            }
            return (int)mh$.invokeExact(pStg, riid, pClientSite, ppvObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleSave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleSave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad)
     * }
     */
    public static FunctionDescriptor OleSave$descriptor() {
        return OleSave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad)
     * }
     */
    public static MethodHandle OleSave$handle() {
        return OleSave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad)
     * }
     */
    public static MemorySegment OleSave$address() {
        return OleSave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad)
     * }
     */
    public static int OleSave(MemorySegment pPS, MemorySegment pStg, int fSameAsLoad) {
        var mh$ = OleSave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleSave", pPS, pStg, fSameAsLoad);
            }
            return (int)mh$.invokeExact(pPS, pStg, fSameAsLoad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleLoadFromStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleLoadFromStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleLoadFromStream(LPSTREAM pStm, const IID *const iidInterface, LPVOID *ppvObj)
     * }
     */
    public static FunctionDescriptor OleLoadFromStream$descriptor() {
        return OleLoadFromStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleLoadFromStream(LPSTREAM pStm, const IID *const iidInterface, LPVOID *ppvObj)
     * }
     */
    public static MethodHandle OleLoadFromStream$handle() {
        return OleLoadFromStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleLoadFromStream(LPSTREAM pStm, const IID *const iidInterface, LPVOID *ppvObj)
     * }
     */
    public static MemorySegment OleLoadFromStream$address() {
        return OleLoadFromStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleLoadFromStream(LPSTREAM pStm, const IID *const iidInterface, LPVOID *ppvObj)
     * }
     */
    public static int OleLoadFromStream(MemorySegment pStm, MemorySegment iidInterface, MemorySegment ppvObj) {
        var mh$ = OleLoadFromStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleLoadFromStream", pStm, iidInterface, ppvObj);
            }
            return (int)mh$.invokeExact(pStm, iidInterface, ppvObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleSaveToStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleSaveToStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleSaveToStream(LPPERSISTSTREAM pPStm, LPSTREAM pStm)
     * }
     */
    public static FunctionDescriptor OleSaveToStream$descriptor() {
        return OleSaveToStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleSaveToStream(LPPERSISTSTREAM pPStm, LPSTREAM pStm)
     * }
     */
    public static MethodHandle OleSaveToStream$handle() {
        return OleSaveToStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleSaveToStream(LPPERSISTSTREAM pPStm, LPSTREAM pStm)
     * }
     */
    public static MemorySegment OleSaveToStream$address() {
        return OleSaveToStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleSaveToStream(LPPERSISTSTREAM pPStm, LPSTREAM pStm)
     * }
     */
    public static int OleSaveToStream(MemorySegment pPStm, MemorySegment pStm) {
        var mh$ = OleSaveToStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleSaveToStream", pPStm, pStm);
            }
            return (int)mh$.invokeExact(pPStm, pStm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleSetContainedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleSetContainedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained)
     * }
     */
    public static FunctionDescriptor OleSetContainedObject$descriptor() {
        return OleSetContainedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained)
     * }
     */
    public static MethodHandle OleSetContainedObject$handle() {
        return OleSetContainedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained)
     * }
     */
    public static MemorySegment OleSetContainedObject$address() {
        return OleSetContainedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained)
     * }
     */
    public static int OleSetContainedObject(MemorySegment pUnknown, int fContained) {
        var mh$ = OleSetContainedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleSetContainedObject", pUnknown, fContained);
            }
            return (int)mh$.invokeExact(pUnknown, fContained);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleNoteObjectVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleNoteObjectVisible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible)
     * }
     */
    public static FunctionDescriptor OleNoteObjectVisible$descriptor() {
        return OleNoteObjectVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible)
     * }
     */
    public static MethodHandle OleNoteObjectVisible$handle() {
        return OleNoteObjectVisible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible)
     * }
     */
    public static MemorySegment OleNoteObjectVisible$address() {
        return OleNoteObjectVisible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible)
     * }
     */
    public static int OleNoteObjectVisible(MemorySegment pUnknown, int fVisible) {
        var mh$ = OleNoteObjectVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleNoteObjectVisible", pUnknown, fVisible);
            }
            return (int)mh$.invokeExact(pUnknown, fVisible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterDragDrop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterDragDrop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget)
     * }
     */
    public static FunctionDescriptor RegisterDragDrop$descriptor() {
        return RegisterDragDrop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget)
     * }
     */
    public static MethodHandle RegisterDragDrop$handle() {
        return RegisterDragDrop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget)
     * }
     */
    public static MemorySegment RegisterDragDrop$address() {
        return RegisterDragDrop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget)
     * }
     */
    public static int RegisterDragDrop(MemorySegment hwnd, MemorySegment pDropTarget) {
        var mh$ = RegisterDragDrop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterDragDrop", hwnd, pDropTarget);
            }
            return (int)mh$.invokeExact(hwnd, pDropTarget);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RevokeDragDrop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RevokeDragDrop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT RevokeDragDrop(HWND hwnd)
     * }
     */
    public static FunctionDescriptor RevokeDragDrop$descriptor() {
        return RevokeDragDrop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT RevokeDragDrop(HWND hwnd)
     * }
     */
    public static MethodHandle RevokeDragDrop$handle() {
        return RevokeDragDrop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT RevokeDragDrop(HWND hwnd)
     * }
     */
    public static MemorySegment RevokeDragDrop$address() {
        return RevokeDragDrop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT RevokeDragDrop(HWND hwnd)
     * }
     */
    public static int RevokeDragDrop(MemorySegment hwnd) {
        var mh$ = RevokeDragDrop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RevokeDragDrop", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DoDragDrop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DoDragDrop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource, DWORD dwOKEffects, LPDWORD pdwEffect)
     * }
     */
    public static FunctionDescriptor DoDragDrop$descriptor() {
        return DoDragDrop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource, DWORD dwOKEffects, LPDWORD pdwEffect)
     * }
     */
    public static MethodHandle DoDragDrop$handle() {
        return DoDragDrop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource, DWORD dwOKEffects, LPDWORD pdwEffect)
     * }
     */
    public static MemorySegment DoDragDrop$address() {
        return DoDragDrop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource, DWORD dwOKEffects, LPDWORD pdwEffect)
     * }
     */
    public static int DoDragDrop(MemorySegment pDataObj, MemorySegment pDropSource, int dwOKEffects, MemorySegment pdwEffect) {
        var mh$ = DoDragDrop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DoDragDrop", pDataObj, pDropSource, dwOKEffects, pdwEffect);
            }
            return (int)mh$.invokeExact(pDataObj, pDropSource, dwOKEffects, pdwEffect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleSetClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleSetClipboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleSetClipboard(LPDATAOBJECT pDataObj)
     * }
     */
    public static FunctionDescriptor OleSetClipboard$descriptor() {
        return OleSetClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleSetClipboard(LPDATAOBJECT pDataObj)
     * }
     */
    public static MethodHandle OleSetClipboard$handle() {
        return OleSetClipboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleSetClipboard(LPDATAOBJECT pDataObj)
     * }
     */
    public static MemorySegment OleSetClipboard$address() {
        return OleSetClipboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleSetClipboard(LPDATAOBJECT pDataObj)
     * }
     */
    public static int OleSetClipboard(MemorySegment pDataObj) {
        var mh$ = OleSetClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleSetClipboard", pDataObj);
            }
            return (int)mh$.invokeExact(pDataObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleGetClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleGetClipboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleGetClipboard(LPDATAOBJECT *ppDataObj)
     * }
     */
    public static FunctionDescriptor OleGetClipboard$descriptor() {
        return OleGetClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleGetClipboard(LPDATAOBJECT *ppDataObj)
     * }
     */
    public static MethodHandle OleGetClipboard$handle() {
        return OleGetClipboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleGetClipboard(LPDATAOBJECT *ppDataObj)
     * }
     */
    public static MemorySegment OleGetClipboard$address() {
        return OleGetClipboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleGetClipboard(LPDATAOBJECT *ppDataObj)
     * }
     */
    public static int OleGetClipboard(MemorySegment ppDataObj) {
        var mh$ = OleGetClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleGetClipboard", ppDataObj);
            }
            return (int)mh$.invokeExact(ppDataObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleGetClipboardWithEnterpriseInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleGetClipboardWithEnterpriseInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleGetClipboardWithEnterpriseInfo(IDataObject **dataObject, PWSTR *dataEnterpriseId, PWSTR *sourceDescription, PWSTR *targetDescription, PWSTR *dataDescription)
     * }
     */
    public static FunctionDescriptor OleGetClipboardWithEnterpriseInfo$descriptor() {
        return OleGetClipboardWithEnterpriseInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleGetClipboardWithEnterpriseInfo(IDataObject **dataObject, PWSTR *dataEnterpriseId, PWSTR *sourceDescription, PWSTR *targetDescription, PWSTR *dataDescription)
     * }
     */
    public static MethodHandle OleGetClipboardWithEnterpriseInfo$handle() {
        return OleGetClipboardWithEnterpriseInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleGetClipboardWithEnterpriseInfo(IDataObject **dataObject, PWSTR *dataEnterpriseId, PWSTR *sourceDescription, PWSTR *targetDescription, PWSTR *dataDescription)
     * }
     */
    public static MemorySegment OleGetClipboardWithEnterpriseInfo$address() {
        return OleGetClipboardWithEnterpriseInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleGetClipboardWithEnterpriseInfo(IDataObject **dataObject, PWSTR *dataEnterpriseId, PWSTR *sourceDescription, PWSTR *targetDescription, PWSTR *dataDescription)
     * }
     */
    public static int OleGetClipboardWithEnterpriseInfo(MemorySegment dataObject, MemorySegment dataEnterpriseId, MemorySegment sourceDescription, MemorySegment targetDescription, MemorySegment dataDescription) {
        var mh$ = OleGetClipboardWithEnterpriseInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleGetClipboardWithEnterpriseInfo", dataObject, dataEnterpriseId, sourceDescription, targetDescription, dataDescription);
            }
            return (int)mh$.invokeExact(dataObject, dataEnterpriseId, sourceDescription, targetDescription, dataDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleFlushClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleFlushClipboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleFlushClipboard()
     * }
     */
    public static FunctionDescriptor OleFlushClipboard$descriptor() {
        return OleFlushClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleFlushClipboard()
     * }
     */
    public static MethodHandle OleFlushClipboard$handle() {
        return OleFlushClipboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleFlushClipboard()
     * }
     */
    public static MemorySegment OleFlushClipboard$address() {
        return OleFlushClipboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleFlushClipboard()
     * }
     */
    public static int OleFlushClipboard() {
        var mh$ = OleFlushClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleFlushClipboard");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleIsCurrentClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleIsCurrentClipboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleIsCurrentClipboard(LPDATAOBJECT pDataObj)
     * }
     */
    public static FunctionDescriptor OleIsCurrentClipboard$descriptor() {
        return OleIsCurrentClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleIsCurrentClipboard(LPDATAOBJECT pDataObj)
     * }
     */
    public static MethodHandle OleIsCurrentClipboard$handle() {
        return OleIsCurrentClipboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleIsCurrentClipboard(LPDATAOBJECT pDataObj)
     * }
     */
    public static MemorySegment OleIsCurrentClipboard$address() {
        return OleIsCurrentClipboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleIsCurrentClipboard(LPDATAOBJECT pDataObj)
     * }
     */
    public static int OleIsCurrentClipboard(MemorySegment pDataObj) {
        var mh$ = OleIsCurrentClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleIsCurrentClipboard", pDataObj);
            }
            return (int)mh$.invokeExact(pDataObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleCreateMenuDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleCreateMenuDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HOLEMENU OleCreateMenuDescriptor(HMENU hmenuCombined, LPOLEMENUGROUPWIDTHS lpMenuWidths)
     * }
     */
    public static FunctionDescriptor OleCreateMenuDescriptor$descriptor() {
        return OleCreateMenuDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HOLEMENU OleCreateMenuDescriptor(HMENU hmenuCombined, LPOLEMENUGROUPWIDTHS lpMenuWidths)
     * }
     */
    public static MethodHandle OleCreateMenuDescriptor$handle() {
        return OleCreateMenuDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HOLEMENU OleCreateMenuDescriptor(HMENU hmenuCombined, LPOLEMENUGROUPWIDTHS lpMenuWidths)
     * }
     */
    public static MemorySegment OleCreateMenuDescriptor$address() {
        return OleCreateMenuDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HOLEMENU OleCreateMenuDescriptor(HMENU hmenuCombined, LPOLEMENUGROUPWIDTHS lpMenuWidths)
     * }
     */
    public static MemorySegment OleCreateMenuDescriptor(MemorySegment hmenuCombined, MemorySegment lpMenuWidths) {
        var mh$ = OleCreateMenuDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleCreateMenuDescriptor", hmenuCombined, lpMenuWidths);
            }
            return (MemorySegment)mh$.invokeExact(hmenuCombined, lpMenuWidths);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleSetMenuDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleSetMenuDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleSetMenuDescriptor(HOLEMENU holemenu, HWND hwndFrame, HWND hwndActiveObject, LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEACTIVEOBJECT lpActiveObj)
     * }
     */
    public static FunctionDescriptor OleSetMenuDescriptor$descriptor() {
        return OleSetMenuDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleSetMenuDescriptor(HOLEMENU holemenu, HWND hwndFrame, HWND hwndActiveObject, LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEACTIVEOBJECT lpActiveObj)
     * }
     */
    public static MethodHandle OleSetMenuDescriptor$handle() {
        return OleSetMenuDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleSetMenuDescriptor(HOLEMENU holemenu, HWND hwndFrame, HWND hwndActiveObject, LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEACTIVEOBJECT lpActiveObj)
     * }
     */
    public static MemorySegment OleSetMenuDescriptor$address() {
        return OleSetMenuDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleSetMenuDescriptor(HOLEMENU holemenu, HWND hwndFrame, HWND hwndActiveObject, LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEACTIVEOBJECT lpActiveObj)
     * }
     */
    public static int OleSetMenuDescriptor(MemorySegment holemenu, MemorySegment hwndFrame, MemorySegment hwndActiveObject, MemorySegment lpFrame, MemorySegment lpActiveObj) {
        var mh$ = OleSetMenuDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleSetMenuDescriptor", holemenu, hwndFrame, hwndActiveObject, lpFrame, lpActiveObj);
            }
            return (int)mh$.invokeExact(holemenu, hwndFrame, hwndActiveObject, lpFrame, lpActiveObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleDestroyMenuDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleDestroyMenuDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleDestroyMenuDescriptor(HOLEMENU holemenu)
     * }
     */
    public static FunctionDescriptor OleDestroyMenuDescriptor$descriptor() {
        return OleDestroyMenuDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleDestroyMenuDescriptor(HOLEMENU holemenu)
     * }
     */
    public static MethodHandle OleDestroyMenuDescriptor$handle() {
        return OleDestroyMenuDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleDestroyMenuDescriptor(HOLEMENU holemenu)
     * }
     */
    public static MemorySegment OleDestroyMenuDescriptor$address() {
        return OleDestroyMenuDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleDestroyMenuDescriptor(HOLEMENU holemenu)
     * }
     */
    public static int OleDestroyMenuDescriptor(MemorySegment holemenu) {
        var mh$ = OleDestroyMenuDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleDestroyMenuDescriptor", holemenu);
            }
            return (int)mh$.invokeExact(holemenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleTranslateAccelerator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleTranslateAccelerator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleTranslateAccelerator(LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg)
     * }
     */
    public static FunctionDescriptor OleTranslateAccelerator$descriptor() {
        return OleTranslateAccelerator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleTranslateAccelerator(LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg)
     * }
     */
    public static MethodHandle OleTranslateAccelerator$handle() {
        return OleTranslateAccelerator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleTranslateAccelerator(LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg)
     * }
     */
    public static MemorySegment OleTranslateAccelerator$address() {
        return OleTranslateAccelerator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleTranslateAccelerator(LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg)
     * }
     */
    public static int OleTranslateAccelerator(MemorySegment lpFrame, MemorySegment lpFrameInfo, MemorySegment lpmsg) {
        var mh$ = OleTranslateAccelerator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleTranslateAccelerator", lpFrame, lpFrameInfo, lpmsg);
            }
            return (int)mh$.invokeExact(lpFrame, lpFrameInfo, lpmsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleDuplicateData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleDuplicateData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HANDLE OleDuplicateData(HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags)
     * }
     */
    public static FunctionDescriptor OleDuplicateData$descriptor() {
        return OleDuplicateData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HANDLE OleDuplicateData(HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags)
     * }
     */
    public static MethodHandle OleDuplicateData$handle() {
        return OleDuplicateData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HANDLE OleDuplicateData(HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags)
     * }
     */
    public static MemorySegment OleDuplicateData$address() {
        return OleDuplicateData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HANDLE OleDuplicateData(HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags)
     * }
     */
    public static MemorySegment OleDuplicateData(MemorySegment hSrc, short cfFormat, int uiFlags) {
        var mh$ = OleDuplicateData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleDuplicateData", hSrc, cfFormat, uiFlags);
            }
            return (MemorySegment)mh$.invokeExact(hSrc, cfFormat, uiFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleDraw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleDraw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleDraw(LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, LPCRECT lprcBounds)
     * }
     */
    public static FunctionDescriptor OleDraw$descriptor() {
        return OleDraw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleDraw(LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, LPCRECT lprcBounds)
     * }
     */
    public static MethodHandle OleDraw$handle() {
        return OleDraw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleDraw(LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, LPCRECT lprcBounds)
     * }
     */
    public static MemorySegment OleDraw$address() {
        return OleDraw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleDraw(LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, LPCRECT lprcBounds)
     * }
     */
    public static int OleDraw(MemorySegment pUnknown, int dwAspect, MemorySegment hdcDraw, MemorySegment lprcBounds) {
        var mh$ = OleDraw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleDraw", pUnknown, dwAspect, hdcDraw, lprcBounds);
            }
            return (int)mh$.invokeExact(pUnknown, dwAspect, hdcDraw, lprcBounds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleRun(LPUNKNOWN pUnknown)
     * }
     */
    public static FunctionDescriptor OleRun$descriptor() {
        return OleRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleRun(LPUNKNOWN pUnknown)
     * }
     */
    public static MethodHandle OleRun$handle() {
        return OleRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleRun(LPUNKNOWN pUnknown)
     * }
     */
    public static MemorySegment OleRun$address() {
        return OleRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleRun(LPUNKNOWN pUnknown)
     * }
     */
    public static int OleRun(MemorySegment pUnknown) {
        var mh$ = OleRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleRun", pUnknown);
            }
            return (int)mh$.invokeExact(pUnknown);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleIsRunning {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleIsRunning");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL OleIsRunning(LPOLEOBJECT pObject)
     * }
     */
    public static FunctionDescriptor OleIsRunning$descriptor() {
        return OleIsRunning.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL OleIsRunning(LPOLEOBJECT pObject)
     * }
     */
    public static MethodHandle OleIsRunning$handle() {
        return OleIsRunning.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL OleIsRunning(LPOLEOBJECT pObject)
     * }
     */
    public static MemorySegment OleIsRunning$address() {
        return OleIsRunning.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL OleIsRunning(LPOLEOBJECT pObject)
     * }
     */
    public static int OleIsRunning(MemorySegment pObject) {
        var mh$ = OleIsRunning.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleIsRunning", pObject);
            }
            return (int)mh$.invokeExact(pObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleLockRunning {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleLockRunning");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses)
     * }
     */
    public static FunctionDescriptor OleLockRunning$descriptor() {
        return OleLockRunning.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses)
     * }
     */
    public static MethodHandle OleLockRunning$handle() {
        return OleLockRunning.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses)
     * }
     */
    public static MemorySegment OleLockRunning$address() {
        return OleLockRunning.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses)
     * }
     */
    public static int OleLockRunning(MemorySegment pUnknown, int fLock, int fLastUnlockCloses) {
        var mh$ = OleLockRunning.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleLockRunning", pUnknown, fLock, fLastUnlockCloses);
            }
            return (int)mh$.invokeExact(pUnknown, fLock, fLastUnlockCloses);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseStgMedium {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReleaseStgMedium");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ReleaseStgMedium(LPSTGMEDIUM)
     * }
     */
    public static FunctionDescriptor ReleaseStgMedium$descriptor() {
        return ReleaseStgMedium.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ReleaseStgMedium(LPSTGMEDIUM)
     * }
     */
    public static MethodHandle ReleaseStgMedium$handle() {
        return ReleaseStgMedium.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ReleaseStgMedium(LPSTGMEDIUM)
     * }
     */
    public static MemorySegment ReleaseStgMedium$address() {
        return ReleaseStgMedium.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ReleaseStgMedium(LPSTGMEDIUM)
     * }
     */
    public static void ReleaseStgMedium(MemorySegment x0) {
        var mh$ = ReleaseStgMedium.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseStgMedium", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateOleAdviseHolder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateOleAdviseHolder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT CreateOleAdviseHolder(LPOLEADVISEHOLDER *ppOAHolder)
     * }
     */
    public static FunctionDescriptor CreateOleAdviseHolder$descriptor() {
        return CreateOleAdviseHolder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT CreateOleAdviseHolder(LPOLEADVISEHOLDER *ppOAHolder)
     * }
     */
    public static MethodHandle CreateOleAdviseHolder$handle() {
        return CreateOleAdviseHolder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT CreateOleAdviseHolder(LPOLEADVISEHOLDER *ppOAHolder)
     * }
     */
    public static MemorySegment CreateOleAdviseHolder$address() {
        return CreateOleAdviseHolder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT CreateOleAdviseHolder(LPOLEADVISEHOLDER *ppOAHolder)
     * }
     */
    public static int CreateOleAdviseHolder(MemorySegment ppOAHolder) {
        var mh$ = CreateOleAdviseHolder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateOleAdviseHolder", ppOAHolder);
            }
            return (int)mh$.invokeExact(ppOAHolder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleCreateDefaultHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleCreateDefaultHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateDefaultHandler(const IID *const clsid, LPUNKNOWN pUnkOuter, const IID *const riid, LPVOID *lplpObj)
     * }
     */
    public static FunctionDescriptor OleCreateDefaultHandler$descriptor() {
        return OleCreateDefaultHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateDefaultHandler(const IID *const clsid, LPUNKNOWN pUnkOuter, const IID *const riid, LPVOID *lplpObj)
     * }
     */
    public static MethodHandle OleCreateDefaultHandler$handle() {
        return OleCreateDefaultHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateDefaultHandler(const IID *const clsid, LPUNKNOWN pUnkOuter, const IID *const riid, LPVOID *lplpObj)
     * }
     */
    public static MemorySegment OleCreateDefaultHandler$address() {
        return OleCreateDefaultHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleCreateDefaultHandler(const IID *const clsid, LPUNKNOWN pUnkOuter, const IID *const riid, LPVOID *lplpObj)
     * }
     */
    public static int OleCreateDefaultHandler(MemorySegment clsid, MemorySegment pUnkOuter, MemorySegment riid, MemorySegment lplpObj) {
        var mh$ = OleCreateDefaultHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleCreateDefaultHandler", clsid, pUnkOuter, riid, lplpObj);
            }
            return (int)mh$.invokeExact(clsid, pUnkOuter, riid, lplpObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleCreateEmbeddingHelper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleCreateEmbeddingHelper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateEmbeddingHelper(const IID *const clsid, LPUNKNOWN pUnkOuter, DWORD flags, LPCLASSFACTORY pCF, const IID *const riid, LPVOID *lplpObj)
     * }
     */
    public static FunctionDescriptor OleCreateEmbeddingHelper$descriptor() {
        return OleCreateEmbeddingHelper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateEmbeddingHelper(const IID *const clsid, LPUNKNOWN pUnkOuter, DWORD flags, LPCLASSFACTORY pCF, const IID *const riid, LPVOID *lplpObj)
     * }
     */
    public static MethodHandle OleCreateEmbeddingHelper$handle() {
        return OleCreateEmbeddingHelper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleCreateEmbeddingHelper(const IID *const clsid, LPUNKNOWN pUnkOuter, DWORD flags, LPCLASSFACTORY pCF, const IID *const riid, LPVOID *lplpObj)
     * }
     */
    public static MemorySegment OleCreateEmbeddingHelper$address() {
        return OleCreateEmbeddingHelper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleCreateEmbeddingHelper(const IID *const clsid, LPUNKNOWN pUnkOuter, DWORD flags, LPCLASSFACTORY pCF, const IID *const riid, LPVOID *lplpObj)
     * }
     */
    public static int OleCreateEmbeddingHelper(MemorySegment clsid, MemorySegment pUnkOuter, int flags, MemorySegment pCF, MemorySegment riid, MemorySegment lplpObj) {
        var mh$ = OleCreateEmbeddingHelper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleCreateEmbeddingHelper", clsid, pUnkOuter, flags, pCF, riid, lplpObj);
            }
            return (int)mh$.invokeExact(clsid, pUnkOuter, flags, pCF, riid, lplpObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAccelerator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsAccelerator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, WORD *lpwCmd)
     * }
     */
    public static FunctionDescriptor IsAccelerator$descriptor() {
        return IsAccelerator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, WORD *lpwCmd)
     * }
     */
    public static MethodHandle IsAccelerator$handle() {
        return IsAccelerator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, WORD *lpwCmd)
     * }
     */
    public static MemorySegment IsAccelerator$address() {
        return IsAccelerator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, WORD *lpwCmd)
     * }
     */
    public static int IsAccelerator(MemorySegment hAccel, int cAccelEntries, MemorySegment lpMsg, MemorySegment lpwCmd) {
        var mh$ = IsAccelerator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAccelerator", hAccel, cAccelEntries, lpMsg, lpwCmd);
            }
            return (int)mh$.invokeExact(hAccel, cAccelEntries, lpMsg, lpwCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleGetIconOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleGetIconOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HGLOBAL OleGetIconOfFile(LPOLESTR lpszPath, BOOL fUseFileAsLabel)
     * }
     */
    public static FunctionDescriptor OleGetIconOfFile$descriptor() {
        return OleGetIconOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HGLOBAL OleGetIconOfFile(LPOLESTR lpszPath, BOOL fUseFileAsLabel)
     * }
     */
    public static MethodHandle OleGetIconOfFile$handle() {
        return OleGetIconOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HGLOBAL OleGetIconOfFile(LPOLESTR lpszPath, BOOL fUseFileAsLabel)
     * }
     */
    public static MemorySegment OleGetIconOfFile$address() {
        return OleGetIconOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HGLOBAL OleGetIconOfFile(LPOLESTR lpszPath, BOOL fUseFileAsLabel)
     * }
     */
    public static MemorySegment OleGetIconOfFile(MemorySegment lpszPath, int fUseFileAsLabel) {
        var mh$ = OleGetIconOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleGetIconOfFile", lpszPath, fUseFileAsLabel);
            }
            return (MemorySegment)mh$.invokeExact(lpszPath, fUseFileAsLabel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleGetIconOfClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleGetIconOfClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HGLOBAL OleGetIconOfClass(const IID *const rclsid, LPOLESTR lpszLabel, BOOL fUseTypeAsLabel)
     * }
     */
    public static FunctionDescriptor OleGetIconOfClass$descriptor() {
        return OleGetIconOfClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HGLOBAL OleGetIconOfClass(const IID *const rclsid, LPOLESTR lpszLabel, BOOL fUseTypeAsLabel)
     * }
     */
    public static MethodHandle OleGetIconOfClass$handle() {
        return OleGetIconOfClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HGLOBAL OleGetIconOfClass(const IID *const rclsid, LPOLESTR lpszLabel, BOOL fUseTypeAsLabel)
     * }
     */
    public static MemorySegment OleGetIconOfClass$address() {
        return OleGetIconOfClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HGLOBAL OleGetIconOfClass(const IID *const rclsid, LPOLESTR lpszLabel, BOOL fUseTypeAsLabel)
     * }
     */
    public static MemorySegment OleGetIconOfClass(MemorySegment rclsid, MemorySegment lpszLabel, int fUseTypeAsLabel) {
        var mh$ = OleGetIconOfClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleGetIconOfClass", rclsid, lpszLabel, fUseTypeAsLabel);
            }
            return (MemorySegment)mh$.invokeExact(rclsid, lpszLabel, fUseTypeAsLabel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleMetafilePictFromIconAndLabel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleMetafilePictFromIconAndLabel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HGLOBAL OleMetafilePictFromIconAndLabel(HICON hIcon, LPOLESTR lpszLabel, LPOLESTR lpszSourceFile, UINT iIconIndex)
     * }
     */
    public static FunctionDescriptor OleMetafilePictFromIconAndLabel$descriptor() {
        return OleMetafilePictFromIconAndLabel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HGLOBAL OleMetafilePictFromIconAndLabel(HICON hIcon, LPOLESTR lpszLabel, LPOLESTR lpszSourceFile, UINT iIconIndex)
     * }
     */
    public static MethodHandle OleMetafilePictFromIconAndLabel$handle() {
        return OleMetafilePictFromIconAndLabel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HGLOBAL OleMetafilePictFromIconAndLabel(HICON hIcon, LPOLESTR lpszLabel, LPOLESTR lpszSourceFile, UINT iIconIndex)
     * }
     */
    public static MemorySegment OleMetafilePictFromIconAndLabel$address() {
        return OleMetafilePictFromIconAndLabel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HGLOBAL OleMetafilePictFromIconAndLabel(HICON hIcon, LPOLESTR lpszLabel, LPOLESTR lpszSourceFile, UINT iIconIndex)
     * }
     */
    public static MemorySegment OleMetafilePictFromIconAndLabel(MemorySegment hIcon, MemorySegment lpszLabel, MemorySegment lpszSourceFile, int iIconIndex) {
        var mh$ = OleMetafilePictFromIconAndLabel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleMetafilePictFromIconAndLabel", hIcon, lpszLabel, lpszSourceFile, iIconIndex);
            }
            return (MemorySegment)mh$.invokeExact(hIcon, lpszLabel, lpszSourceFile, iIconIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleRegGetUserType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleRegGetUserType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleRegGetUserType(const IID *const clsid, DWORD dwFormOfType, LPOLESTR *pszUserType)
     * }
     */
    public static FunctionDescriptor OleRegGetUserType$descriptor() {
        return OleRegGetUserType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleRegGetUserType(const IID *const clsid, DWORD dwFormOfType, LPOLESTR *pszUserType)
     * }
     */
    public static MethodHandle OleRegGetUserType$handle() {
        return OleRegGetUserType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleRegGetUserType(const IID *const clsid, DWORD dwFormOfType, LPOLESTR *pszUserType)
     * }
     */
    public static MemorySegment OleRegGetUserType$address() {
        return OleRegGetUserType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleRegGetUserType(const IID *const clsid, DWORD dwFormOfType, LPOLESTR *pszUserType)
     * }
     */
    public static int OleRegGetUserType(MemorySegment clsid, int dwFormOfType, MemorySegment pszUserType) {
        var mh$ = OleRegGetUserType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleRegGetUserType", clsid, dwFormOfType, pszUserType);
            }
            return (int)mh$.invokeExact(clsid, dwFormOfType, pszUserType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleRegGetMiscStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleRegGetMiscStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleRegGetMiscStatus(const IID *const clsid, DWORD dwAspect, DWORD *pdwStatus)
     * }
     */
    public static FunctionDescriptor OleRegGetMiscStatus$descriptor() {
        return OleRegGetMiscStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleRegGetMiscStatus(const IID *const clsid, DWORD dwAspect, DWORD *pdwStatus)
     * }
     */
    public static MethodHandle OleRegGetMiscStatus$handle() {
        return OleRegGetMiscStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleRegGetMiscStatus(const IID *const clsid, DWORD dwAspect, DWORD *pdwStatus)
     * }
     */
    public static MemorySegment OleRegGetMiscStatus$address() {
        return OleRegGetMiscStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleRegGetMiscStatus(const IID *const clsid, DWORD dwAspect, DWORD *pdwStatus)
     * }
     */
    public static int OleRegGetMiscStatus(MemorySegment clsid, int dwAspect, MemorySegment pdwStatus) {
        var mh$ = OleRegGetMiscStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleRegGetMiscStatus", clsid, dwAspect, pdwStatus);
            }
            return (int)mh$.invokeExact(clsid, dwAspect, pdwStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleRegEnumFormatEtc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleRegEnumFormatEtc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleRegEnumFormatEtc(const IID *const clsid, DWORD dwDirection, LPENUMFORMATETC *ppenum)
     * }
     */
    public static FunctionDescriptor OleRegEnumFormatEtc$descriptor() {
        return OleRegEnumFormatEtc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleRegEnumFormatEtc(const IID *const clsid, DWORD dwDirection, LPENUMFORMATETC *ppenum)
     * }
     */
    public static MethodHandle OleRegEnumFormatEtc$handle() {
        return OleRegEnumFormatEtc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleRegEnumFormatEtc(const IID *const clsid, DWORD dwDirection, LPENUMFORMATETC *ppenum)
     * }
     */
    public static MemorySegment OleRegEnumFormatEtc$address() {
        return OleRegEnumFormatEtc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleRegEnumFormatEtc(const IID *const clsid, DWORD dwDirection, LPENUMFORMATETC *ppenum)
     * }
     */
    public static int OleRegEnumFormatEtc(MemorySegment clsid, int dwDirection, MemorySegment ppenum) {
        var mh$ = OleRegEnumFormatEtc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleRegEnumFormatEtc", clsid, dwDirection, ppenum);
            }
            return (int)mh$.invokeExact(clsid, dwDirection, ppenum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleRegEnumVerbs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleRegEnumVerbs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleRegEnumVerbs(const IID *const clsid, LPENUMOLEVERB *ppenum)
     * }
     */
    public static FunctionDescriptor OleRegEnumVerbs$descriptor() {
        return OleRegEnumVerbs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleRegEnumVerbs(const IID *const clsid, LPENUMOLEVERB *ppenum)
     * }
     */
    public static MethodHandle OleRegEnumVerbs$handle() {
        return OleRegEnumVerbs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleRegEnumVerbs(const IID *const clsid, LPENUMOLEVERB *ppenum)
     * }
     */
    public static MemorySegment OleRegEnumVerbs$address() {
        return OleRegEnumVerbs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleRegEnumVerbs(const IID *const clsid, LPENUMOLEVERB *ppenum)
     * }
     */
    public static int OleRegEnumVerbs(MemorySegment clsid, MemorySegment ppenum) {
        var mh$ = OleRegEnumVerbs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleRegEnumVerbs", clsid, ppenum);
            }
            return (int)mh$.invokeExact(clsid, ppenum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _OLESTREAM *LPOLESTREAM
     * }
     */
    public static final AddressLayout LPOLESTREAM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef OLESTREAMVTBL *LPOLESTREAMVTBL
     * }
     */
    public static final AddressLayout LPOLESTREAMVTBL = wgl_h.C_POINTER;

    private static class OleConvertOLESTREAMToIStorage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleConvertOLESTREAMToIStorage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertOLESTREAMToIStorage(LPOLESTREAM lpolestream, LPSTORAGE pstg, const DVTARGETDEVICE *ptd)
     * }
     */
    public static FunctionDescriptor OleConvertOLESTREAMToIStorage$descriptor() {
        return OleConvertOLESTREAMToIStorage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertOLESTREAMToIStorage(LPOLESTREAM lpolestream, LPSTORAGE pstg, const DVTARGETDEVICE *ptd)
     * }
     */
    public static MethodHandle OleConvertOLESTREAMToIStorage$handle() {
        return OleConvertOLESTREAMToIStorage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertOLESTREAMToIStorage(LPOLESTREAM lpolestream, LPSTORAGE pstg, const DVTARGETDEVICE *ptd)
     * }
     */
    public static MemorySegment OleConvertOLESTREAMToIStorage$address() {
        return OleConvertOLESTREAMToIStorage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleConvertOLESTREAMToIStorage(LPOLESTREAM lpolestream, LPSTORAGE pstg, const DVTARGETDEVICE *ptd)
     * }
     */
    public static int OleConvertOLESTREAMToIStorage(MemorySegment lpolestream, MemorySegment pstg, MemorySegment ptd) {
        var mh$ = OleConvertOLESTREAMToIStorage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleConvertOLESTREAMToIStorage", lpolestream, pstg, ptd);
            }
            return (int)mh$.invokeExact(lpolestream, pstg, ptd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleConvertIStorageToOLESTREAM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleConvertIStorageToOLESTREAM");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertIStorageToOLESTREAM(LPSTORAGE pstg, LPOLESTREAM lpolestream)
     * }
     */
    public static FunctionDescriptor OleConvertIStorageToOLESTREAM$descriptor() {
        return OleConvertIStorageToOLESTREAM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertIStorageToOLESTREAM(LPSTORAGE pstg, LPOLESTREAM lpolestream)
     * }
     */
    public static MethodHandle OleConvertIStorageToOLESTREAM$handle() {
        return OleConvertIStorageToOLESTREAM.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertIStorageToOLESTREAM(LPSTORAGE pstg, LPOLESTREAM lpolestream)
     * }
     */
    public static MemorySegment OleConvertIStorageToOLESTREAM$address() {
        return OleConvertIStorageToOLESTREAM.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleConvertIStorageToOLESTREAM(LPSTORAGE pstg, LPOLESTREAM lpolestream)
     * }
     */
    public static int OleConvertIStorageToOLESTREAM(MemorySegment pstg, MemorySegment lpolestream) {
        var mh$ = OleConvertIStorageToOLESTREAM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleConvertIStorageToOLESTREAM", pstg, lpolestream);
            }
            return (int)mh$.invokeExact(pstg, lpolestream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleDoAutoConvert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleDoAutoConvert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew)
     * }
     */
    public static FunctionDescriptor OleDoAutoConvert$descriptor() {
        return OleDoAutoConvert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew)
     * }
     */
    public static MethodHandle OleDoAutoConvert$handle() {
        return OleDoAutoConvert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew)
     * }
     */
    public static MemorySegment OleDoAutoConvert$address() {
        return OleDoAutoConvert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew)
     * }
     */
    public static int OleDoAutoConvert(MemorySegment pStg, MemorySegment pClsidNew) {
        var mh$ = OleDoAutoConvert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleDoAutoConvert", pStg, pClsidNew);
            }
            return (int)mh$.invokeExact(pStg, pClsidNew);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleGetAutoConvert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleGetAutoConvert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleGetAutoConvert(const IID *const clsidOld, LPCLSID pClsidNew)
     * }
     */
    public static FunctionDescriptor OleGetAutoConvert$descriptor() {
        return OleGetAutoConvert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleGetAutoConvert(const IID *const clsidOld, LPCLSID pClsidNew)
     * }
     */
    public static MethodHandle OleGetAutoConvert$handle() {
        return OleGetAutoConvert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleGetAutoConvert(const IID *const clsidOld, LPCLSID pClsidNew)
     * }
     */
    public static MemorySegment OleGetAutoConvert$address() {
        return OleGetAutoConvert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleGetAutoConvert(const IID *const clsidOld, LPCLSID pClsidNew)
     * }
     */
    public static int OleGetAutoConvert(MemorySegment clsidOld, MemorySegment pClsidNew) {
        var mh$ = OleGetAutoConvert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleGetAutoConvert", clsidOld, pClsidNew);
            }
            return (int)mh$.invokeExact(clsidOld, pClsidNew);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleSetAutoConvert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleSetAutoConvert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleSetAutoConvert(const IID *const clsidOld, const IID *const clsidNew)
     * }
     */
    public static FunctionDescriptor OleSetAutoConvert$descriptor() {
        return OleSetAutoConvert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleSetAutoConvert(const IID *const clsidOld, const IID *const clsidNew)
     * }
     */
    public static MethodHandle OleSetAutoConvert$handle() {
        return OleSetAutoConvert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleSetAutoConvert(const IID *const clsidOld, const IID *const clsidNew)
     * }
     */
    public static MemorySegment OleSetAutoConvert$address() {
        return OleSetAutoConvert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleSetAutoConvert(const IID *const clsidOld, const IID *const clsidNew)
     * }
     */
    public static int OleSetAutoConvert(MemorySegment clsidOld, MemorySegment clsidNew) {
        var mh$ = OleSetAutoConvert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleSetAutoConvert", clsidOld, clsidNew);
            }
            return (int)mh$.invokeExact(clsidOld, clsidNew);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConvertStg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetConvertStg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SetConvertStg(LPSTORAGE pStg, BOOL fConvert)
     * }
     */
    public static FunctionDescriptor SetConvertStg$descriptor() {
        return SetConvertStg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SetConvertStg(LPSTORAGE pStg, BOOL fConvert)
     * }
     */
    public static MethodHandle SetConvertStg$handle() {
        return SetConvertStg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT SetConvertStg(LPSTORAGE pStg, BOOL fConvert)
     * }
     */
    public static MemorySegment SetConvertStg$address() {
        return SetConvertStg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT SetConvertStg(LPSTORAGE pStg, BOOL fConvert)
     * }
     */
    public static int SetConvertStg(MemorySegment pStg, int fConvert) {
        var mh$ = SetConvertStg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConvertStg", pStg, fConvert);
            }
            return (int)mh$.invokeExact(pStg, fConvert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleConvertIStorageToOLESTREAMEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleConvertIStorageToOLESTREAMEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertIStorageToOLESTREAMEx(LPSTORAGE pstg, CLIPFORMAT cfFormat, LONG lWidth, LONG lHeight, DWORD dwSize, LPSTGMEDIUM pmedium, LPOLESTREAM polestm)
     * }
     */
    public static FunctionDescriptor OleConvertIStorageToOLESTREAMEx$descriptor() {
        return OleConvertIStorageToOLESTREAMEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertIStorageToOLESTREAMEx(LPSTORAGE pstg, CLIPFORMAT cfFormat, LONG lWidth, LONG lHeight, DWORD dwSize, LPSTGMEDIUM pmedium, LPOLESTREAM polestm)
     * }
     */
    public static MethodHandle OleConvertIStorageToOLESTREAMEx$handle() {
        return OleConvertIStorageToOLESTREAMEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertIStorageToOLESTREAMEx(LPSTORAGE pstg, CLIPFORMAT cfFormat, LONG lWidth, LONG lHeight, DWORD dwSize, LPSTGMEDIUM pmedium, LPOLESTREAM polestm)
     * }
     */
    public static MemorySegment OleConvertIStorageToOLESTREAMEx$address() {
        return OleConvertIStorageToOLESTREAMEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleConvertIStorageToOLESTREAMEx(LPSTORAGE pstg, CLIPFORMAT cfFormat, LONG lWidth, LONG lHeight, DWORD dwSize, LPSTGMEDIUM pmedium, LPOLESTREAM polestm)
     * }
     */
    public static int OleConvertIStorageToOLESTREAMEx(MemorySegment pstg, short cfFormat, int lWidth, int lHeight, int dwSize, MemorySegment pmedium, MemorySegment polestm) {
        var mh$ = OleConvertIStorageToOLESTREAMEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleConvertIStorageToOLESTREAMEx", pstg, cfFormat, lWidth, lHeight, dwSize, pmedium, polestm);
            }
            return (int)mh$.invokeExact(pstg, cfFormat, lWidth, lHeight, dwSize, pmedium, polestm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OleConvertOLESTREAMToIStorageEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OleConvertOLESTREAMToIStorageEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertOLESTREAMToIStorageEx(LPOLESTREAM polestm, LPSTORAGE pstg, CLIPFORMAT *pcfFormat, LONG *plwWidth, LONG *plHeight, DWORD *pdwSize, LPSTGMEDIUM pmedium)
     * }
     */
    public static FunctionDescriptor OleConvertOLESTREAMToIStorageEx$descriptor() {
        return OleConvertOLESTREAMToIStorageEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertOLESTREAMToIStorageEx(LPOLESTREAM polestm, LPSTORAGE pstg, CLIPFORMAT *pcfFormat, LONG *plwWidth, LONG *plHeight, DWORD *pdwSize, LPSTGMEDIUM pmedium)
     * }
     */
    public static MethodHandle OleConvertOLESTREAMToIStorageEx$handle() {
        return OleConvertOLESTREAMToIStorageEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HRESULT OleConvertOLESTREAMToIStorageEx(LPOLESTREAM polestm, LPSTORAGE pstg, CLIPFORMAT *pcfFormat, LONG *plwWidth, LONG *plHeight, DWORD *pdwSize, LPSTGMEDIUM pmedium)
     * }
     */
    public static MemorySegment OleConvertOLESTREAMToIStorageEx$address() {
        return OleConvertOLESTREAMToIStorageEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HRESULT OleConvertOLESTREAMToIStorageEx(LPOLESTREAM polestm, LPSTORAGE pstg, CLIPFORMAT *pcfFormat, LONG *plwWidth, LONG *plHeight, DWORD *pdwSize, LPSTGMEDIUM pmedium)
     * }
     */
    public static int OleConvertOLESTREAMToIStorageEx(MemorySegment polestm, MemorySegment pstg, MemorySegment pcfFormat, MemorySegment plwWidth, MemorySegment plHeight, MemorySegment pdwSize, MemorySegment pmedium) {
        var mh$ = OleConvertOLESTREAMToIStorageEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OleConvertOLESTREAMToIStorageEx", polestm, pstg, pcfFormat, plwWidth, plHeight, pdwSize, pmedium);
            }
            return (int)mh$.invokeExact(polestm, pstg, pcfFormat, plwWidth, plHeight, pdwSize, pmedium);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IID_IPrintDialogCallback$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("IID_IPrintDialogCallback").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID IID_IPrintDialogCallback
     * }
     */
    public static GroupLayout IID_IPrintDialogCallback$layout() {
        return IID_IPrintDialogCallback$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID IID_IPrintDialogCallback
     * }
     */
    public static MemorySegment IID_IPrintDialogCallback() {
        return IID_IPrintDialogCallback$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID IID_IPrintDialogCallback
     * }
     */
    public static void IID_IPrintDialogCallback(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, IID_IPrintDialogCallback$constants.SEGMENT, 0L, IID_IPrintDialogCallback$constants.LAYOUT.byteSize());
    }

    private static class IID_IPrintDialogServices$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("IID_IPrintDialogServices").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID IID_IPrintDialogServices
     * }
     */
    public static GroupLayout IID_IPrintDialogServices$layout() {
        return IID_IPrintDialogServices$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID IID_IPrintDialogServices
     * }
     */
    public static MemorySegment IID_IPrintDialogServices() {
        return IID_IPrintDialogServices$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID IID_IPrintDialogServices
     * }
     */
    public static void IID_IPrintDialogServices(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, IID_IPrintDialogServices$constants.SEGMENT, 0L, IID_IPrintDialogServices$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagOFN_NT4A {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCSTR lpstrFilter;
     *     LPSTR lpstrCustomFilter;
     *     DWORD nMaxCustFilter;
     *     DWORD nFilterIndex;
     *     LPSTR lpstrFile;
     *     DWORD nMaxFile;
     *     LPSTR lpstrFileTitle;
     *     DWORD nMaxFileTitle;
     *     LPCSTR lpstrInitialDir;
     *     LPCSTR lpstrTitle;
     *     DWORD Flags;
     *     WORD nFileOffset;
     *     WORD nFileExtension;
     *     LPCSTR lpstrDefExt;
     *     LPARAM lCustData;
     *     LPOFNHOOKPROC lpfnHook;
     *     LPCSTR lpTemplateName;
     * } *LPOPENFILENAME_NT4A
     * }
     */
    public static final AddressLayout LPOPENFILENAME_NT4A = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagOFN_NT4W {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCWSTR lpstrFilter;
     *     LPWSTR lpstrCustomFilter;
     *     DWORD nMaxCustFilter;
     *     DWORD nFilterIndex;
     *     LPWSTR lpstrFile;
     *     DWORD nMaxFile;
     *     LPWSTR lpstrFileTitle;
     *     DWORD nMaxFileTitle;
     *     LPCWSTR lpstrInitialDir;
     *     LPCWSTR lpstrTitle;
     *     DWORD Flags;
     *     WORD nFileOffset;
     *     WORD nFileExtension;
     *     LPCWSTR lpstrDefExt;
     *     LPARAM lCustData;
     *     LPOFNHOOKPROC lpfnHook;
     *     LPCWSTR lpTemplateName;
     * } *LPOPENFILENAME_NT4W
     * }
     */
    public static final AddressLayout LPOPENFILENAME_NT4W = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPOPENFILENAME_NT4A LPOPENFILENAME_NT4
     * }
     */
    public static final AddressLayout LPOPENFILENAME_NT4 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagOFNA {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCSTR lpstrFilter;
     *     LPSTR lpstrCustomFilter;
     *     DWORD nMaxCustFilter;
     *     DWORD nFilterIndex;
     *     LPSTR lpstrFile;
     *     DWORD nMaxFile;
     *     LPSTR lpstrFileTitle;
     *     DWORD nMaxFileTitle;
     *     LPCSTR lpstrInitialDir;
     *     LPCSTR lpstrTitle;
     *     DWORD Flags;
     *     WORD nFileOffset;
     *     WORD nFileExtension;
     *     LPCSTR lpstrDefExt;
     *     LPARAM lCustData;
     *     LPOFNHOOKPROC lpfnHook;
     *     LPCSTR lpTemplateName;
     *     void *pvReserved;
     *     DWORD dwReserved;
     *     DWORD FlagsEx;
     * } *LPOPENFILENAMEA
     * }
     */
    public static final AddressLayout LPOPENFILENAMEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagOFNW {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCWSTR lpstrFilter;
     *     LPWSTR lpstrCustomFilter;
     *     DWORD nMaxCustFilter;
     *     DWORD nFilterIndex;
     *     LPWSTR lpstrFile;
     *     DWORD nMaxFile;
     *     LPWSTR lpstrFileTitle;
     *     DWORD nMaxFileTitle;
     *     LPCWSTR lpstrInitialDir;
     *     LPCWSTR lpstrTitle;
     *     DWORD Flags;
     *     WORD nFileOffset;
     *     WORD nFileExtension;
     *     LPCWSTR lpstrDefExt;
     *     LPARAM lCustData;
     *     LPOFNHOOKPROC lpfnHook;
     *     LPCWSTR lpTemplateName;
     *     void *pvReserved;
     *     DWORD dwReserved;
     *     DWORD FlagsEx;
     * } *LPOPENFILENAMEW
     * }
     */
    public static final AddressLayout LPOPENFILENAMEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPOPENFILENAMEA LPOPENFILENAME
     * }
     */
    public static final AddressLayout LPOPENFILENAME = wgl_h.C_POINTER;

    private static class GetOpenFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetOpenFileNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOpenFileNameA(LPOPENFILENAMEA)
     * }
     */
    public static FunctionDescriptor GetOpenFileNameA$descriptor() {
        return GetOpenFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOpenFileNameA(LPOPENFILENAMEA)
     * }
     */
    public static MethodHandle GetOpenFileNameA$handle() {
        return GetOpenFileNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOpenFileNameA(LPOPENFILENAMEA)
     * }
     */
    public static MemorySegment GetOpenFileNameA$address() {
        return GetOpenFileNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOpenFileNameA(LPOPENFILENAMEA)
     * }
     */
    public static int GetOpenFileNameA(MemorySegment x0) {
        var mh$ = GetOpenFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOpenFileNameA", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOpenFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetOpenFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOpenFileNameW(LPOPENFILENAMEW)
     * }
     */
    public static FunctionDescriptor GetOpenFileNameW$descriptor() {
        return GetOpenFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOpenFileNameW(LPOPENFILENAMEW)
     * }
     */
    public static MethodHandle GetOpenFileNameW$handle() {
        return GetOpenFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOpenFileNameW(LPOPENFILENAMEW)
     * }
     */
    public static MemorySegment GetOpenFileNameW$address() {
        return GetOpenFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOpenFileNameW(LPOPENFILENAMEW)
     * }
     */
    public static int GetOpenFileNameW(MemorySegment x0) {
        var mh$ = GetOpenFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOpenFileNameW", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSaveFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSaveFileNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSaveFileNameA(LPOPENFILENAMEA)
     * }
     */
    public static FunctionDescriptor GetSaveFileNameA$descriptor() {
        return GetSaveFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSaveFileNameA(LPOPENFILENAMEA)
     * }
     */
    public static MethodHandle GetSaveFileNameA$handle() {
        return GetSaveFileNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSaveFileNameA(LPOPENFILENAMEA)
     * }
     */
    public static MemorySegment GetSaveFileNameA$address() {
        return GetSaveFileNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSaveFileNameA(LPOPENFILENAMEA)
     * }
     */
    public static int GetSaveFileNameA(MemorySegment x0) {
        var mh$ = GetSaveFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSaveFileNameA", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSaveFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSaveFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSaveFileNameW(LPOPENFILENAMEW)
     * }
     */
    public static FunctionDescriptor GetSaveFileNameW$descriptor() {
        return GetSaveFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSaveFileNameW(LPOPENFILENAMEW)
     * }
     */
    public static MethodHandle GetSaveFileNameW$handle() {
        return GetSaveFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSaveFileNameW(LPOPENFILENAMEW)
     * }
     */
    public static MemorySegment GetSaveFileNameW$address() {
        return GetSaveFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSaveFileNameW(LPOPENFILENAMEW)
     * }
     */
    public static int GetSaveFileNameW(MemorySegment x0) {
        var mh$ = GetSaveFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSaveFileNameW", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileTitleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileTitleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short GetFileTitleA(LPCSTR, LPSTR Buf, WORD cchSize)
     * }
     */
    public static FunctionDescriptor GetFileTitleA$descriptor() {
        return GetFileTitleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short GetFileTitleA(LPCSTR, LPSTR Buf, WORD cchSize)
     * }
     */
    public static MethodHandle GetFileTitleA$handle() {
        return GetFileTitleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short GetFileTitleA(LPCSTR, LPSTR Buf, WORD cchSize)
     * }
     */
    public static MemorySegment GetFileTitleA$address() {
        return GetFileTitleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short GetFileTitleA(LPCSTR, LPSTR Buf, WORD cchSize)
     * }
     */
    public static short GetFileTitleA(MemorySegment x0, MemorySegment Buf, short cchSize) {
        var mh$ = GetFileTitleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileTitleA", x0, Buf, cchSize);
            }
            return (short)mh$.invokeExact(x0, Buf, cchSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileTitleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileTitleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short GetFileTitleW(LPCWSTR, LPWSTR Buf, WORD cchSize)
     * }
     */
    public static FunctionDescriptor GetFileTitleW$descriptor() {
        return GetFileTitleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short GetFileTitleW(LPCWSTR, LPWSTR Buf, WORD cchSize)
     * }
     */
    public static MethodHandle GetFileTitleW$handle() {
        return GetFileTitleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short GetFileTitleW(LPCWSTR, LPWSTR Buf, WORD cchSize)
     * }
     */
    public static MemorySegment GetFileTitleW$address() {
        return GetFileTitleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short GetFileTitleW(LPCWSTR, LPWSTR Buf, WORD cchSize)
     * }
     */
    public static short GetFileTitleW(MemorySegment x0, MemorySegment Buf, short cchSize) {
        var mh$ = GetFileTitleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileTitleW", x0, Buf, cchSize);
            }
            return (short)mh$.invokeExact(x0, Buf, cchSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _OFNOTIFYA {
     *     NMHDR hdr;
     *     LPOPENFILENAMEA lpOFN;
     *     LPSTR pszFile;
     * } *LPOFNOTIFYA
     * }
     */
    public static final AddressLayout LPOFNOTIFYA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OFNOTIFYW {
     *     NMHDR hdr;
     *     LPOPENFILENAMEW lpOFN;
     *     LPWSTR pszFile;
     * } *LPOFNOTIFYW
     * }
     */
    public static final AddressLayout LPOFNOTIFYW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPOFNOTIFYA LPOFNOTIFY
     * }
     */
    public static final AddressLayout LPOFNOTIFY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OFNOTIFYEXA {
     *     NMHDR hdr;
     *     LPOPENFILENAMEA lpOFN;
     *     LPVOID psf;
     *     LPVOID pidl;
     * } *LPOFNOTIFYEXA
     * }
     */
    public static final AddressLayout LPOFNOTIFYEXA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OFNOTIFYEXW {
     *     NMHDR hdr;
     *     LPOPENFILENAMEW lpOFN;
     *     LPVOID psf;
     *     LPVOID pidl;
     * } *LPOFNOTIFYEXW
     * }
     */
    public static final AddressLayout LPOFNOTIFYEXW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPOFNOTIFYEXA LPOFNOTIFYEX
     * }
     */
    public static final AddressLayout LPOFNOTIFYEX = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHOOSECOLORA {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HWND hInstance;
     *     COLORREF rgbResult;
     *     COLORREF *lpCustColors;
     *     DWORD Flags;
     *     LPARAM lCustData;
     *     LPCCHOOKPROC lpfnHook;
     *     LPCSTR lpTemplateName;
     * } *LPCHOOSECOLORA
     * }
     */
    public static final AddressLayout LPCHOOSECOLORA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHOOSECOLORW {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HWND hInstance;
     *     COLORREF rgbResult;
     *     COLORREF *lpCustColors;
     *     DWORD Flags;
     *     LPARAM lCustData;
     *     LPCCHOOKPROC lpfnHook;
     *     LPCWSTR lpTemplateName;
     * } *LPCHOOSECOLORW
     * }
     */
    public static final AddressLayout LPCHOOSECOLORW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCHOOSECOLORA LPCHOOSECOLOR
     * }
     */
    public static final AddressLayout LPCHOOSECOLOR = wgl_h.C_POINTER;

    private static class ChooseColorA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChooseColorA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChooseColorA(LPCHOOSECOLORA)
     * }
     */
    public static FunctionDescriptor ChooseColorA$descriptor() {
        return ChooseColorA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChooseColorA(LPCHOOSECOLORA)
     * }
     */
    public static MethodHandle ChooseColorA$handle() {
        return ChooseColorA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChooseColorA(LPCHOOSECOLORA)
     * }
     */
    public static MemorySegment ChooseColorA$address() {
        return ChooseColorA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChooseColorA(LPCHOOSECOLORA)
     * }
     */
    public static int ChooseColorA(MemorySegment x0) {
        var mh$ = ChooseColorA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChooseColorA", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChooseColorW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChooseColorW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChooseColorW(LPCHOOSECOLORW)
     * }
     */
    public static FunctionDescriptor ChooseColorW$descriptor() {
        return ChooseColorW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChooseColorW(LPCHOOSECOLORW)
     * }
     */
    public static MethodHandle ChooseColorW$handle() {
        return ChooseColorW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChooseColorW(LPCHOOSECOLORW)
     * }
     */
    public static MemorySegment ChooseColorW$address() {
        return ChooseColorW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChooseColorW(LPCHOOSECOLORW)
     * }
     */
    public static int ChooseColorW(MemorySegment x0) {
        var mh$ = ChooseColorW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChooseColorW", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagFINDREPLACEA {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     DWORD Flags;
     *     LPSTR lpstrFindWhat;
     *     LPSTR lpstrReplaceWith;
     *     WORD wFindWhatLen;
     *     WORD wReplaceWithLen;
     *     LPARAM lCustData;
     *     LPFRHOOKPROC lpfnHook;
     *     LPCSTR lpTemplateName;
     * } *LPFINDREPLACEA
     * }
     */
    public static final AddressLayout LPFINDREPLACEA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagFINDREPLACEW {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     DWORD Flags;
     *     LPWSTR lpstrFindWhat;
     *     LPWSTR lpstrReplaceWith;
     *     WORD wFindWhatLen;
     *     WORD wReplaceWithLen;
     *     LPARAM lCustData;
     *     LPFRHOOKPROC lpfnHook;
     *     LPCWSTR lpTemplateName;
     * } *LPFINDREPLACEW
     * }
     */
    public static final AddressLayout LPFINDREPLACEW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPFINDREPLACEA LPFINDREPLACE
     * }
     */
    public static final AddressLayout LPFINDREPLACE = wgl_h.C_POINTER;

    private static class FindTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND FindTextA(LPFINDREPLACEA)
     * }
     */
    public static FunctionDescriptor FindTextA$descriptor() {
        return FindTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND FindTextA(LPFINDREPLACEA)
     * }
     */
    public static MethodHandle FindTextA$handle() {
        return FindTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND FindTextA(LPFINDREPLACEA)
     * }
     */
    public static MemorySegment FindTextA$address() {
        return FindTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND FindTextA(LPFINDREPLACEA)
     * }
     */
    public static MemorySegment FindTextA(MemorySegment x0) {
        var mh$ = FindTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindTextA", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND FindTextW(LPFINDREPLACEW)
     * }
     */
    public static FunctionDescriptor FindTextW$descriptor() {
        return FindTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND FindTextW(LPFINDREPLACEW)
     * }
     */
    public static MethodHandle FindTextW$handle() {
        return FindTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND FindTextW(LPFINDREPLACEW)
     * }
     */
    public static MemorySegment FindTextW$address() {
        return FindTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND FindTextW(LPFINDREPLACEW)
     * }
     */
    public static MemorySegment FindTextW(MemorySegment x0) {
        var mh$ = FindTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindTextW", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReplaceTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND ReplaceTextA(LPFINDREPLACEA)
     * }
     */
    public static FunctionDescriptor ReplaceTextA$descriptor() {
        return ReplaceTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND ReplaceTextA(LPFINDREPLACEA)
     * }
     */
    public static MethodHandle ReplaceTextA$handle() {
        return ReplaceTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND ReplaceTextA(LPFINDREPLACEA)
     * }
     */
    public static MemorySegment ReplaceTextA$address() {
        return ReplaceTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND ReplaceTextA(LPFINDREPLACEA)
     * }
     */
    public static MemorySegment ReplaceTextA(MemorySegment x0) {
        var mh$ = ReplaceTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceTextA", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReplaceTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND ReplaceTextW(LPFINDREPLACEW)
     * }
     */
    public static FunctionDescriptor ReplaceTextW$descriptor() {
        return ReplaceTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND ReplaceTextW(LPFINDREPLACEW)
     * }
     */
    public static MethodHandle ReplaceTextW$handle() {
        return ReplaceTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND ReplaceTextW(LPFINDREPLACEW)
     * }
     */
    public static MemorySegment ReplaceTextW$address() {
        return ReplaceTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND ReplaceTextW(LPFINDREPLACEW)
     * }
     */
    public static MemorySegment ReplaceTextW(MemorySegment x0) {
        var mh$ = ReplaceTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceTextW", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef CHOOSEFONTA *LPCHOOSEFONTA
     * }
     */
    public static final AddressLayout LPCHOOSEFONTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CHOOSEFONTW *LPCHOOSEFONTW
     * }
     */
    public static final AddressLayout LPCHOOSEFONTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCHOOSEFONTA LPCHOOSEFONT
     * }
     */
    public static final AddressLayout LPCHOOSEFONT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CHOOSEFONTA *PCCHOOSEFONTA
     * }
     */
    public static final AddressLayout PCCHOOSEFONTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CHOOSEFONTW *PCCHOOSEFONTW
     * }
     */
    public static final AddressLayout PCCHOOSEFONTW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCCHOOSEFONTA PCCHOOSEFONT
     * }
     */
    public static final AddressLayout PCCHOOSEFONT = wgl_h.C_POINTER;

    private static class ChooseFontA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChooseFontA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChooseFontA(LPCHOOSEFONTA)
     * }
     */
    public static FunctionDescriptor ChooseFontA$descriptor() {
        return ChooseFontA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChooseFontA(LPCHOOSEFONTA)
     * }
     */
    public static MethodHandle ChooseFontA$handle() {
        return ChooseFontA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChooseFontA(LPCHOOSEFONTA)
     * }
     */
    public static MemorySegment ChooseFontA$address() {
        return ChooseFontA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChooseFontA(LPCHOOSEFONTA)
     * }
     */
    public static int ChooseFontA(MemorySegment x0) {
        var mh$ = ChooseFontA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChooseFontA", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChooseFontW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChooseFontW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChooseFontW(LPCHOOSEFONTW)
     * }
     */
    public static FunctionDescriptor ChooseFontW$descriptor() {
        return ChooseFontW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChooseFontW(LPCHOOSEFONTW)
     * }
     */
    public static MethodHandle ChooseFontW$handle() {
        return ChooseFontW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChooseFontW(LPCHOOSEFONTW)
     * }
     */
    public static MemorySegment ChooseFontW$address() {
        return ChooseFontW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChooseFontW(LPCHOOSEFONTW)
     * }
     */
    public static int ChooseFontW(MemorySegment x0) {
        var mh$ = ChooseFontW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChooseFontW", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagPDA {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HGLOBAL hDevMode;
     *     HGLOBAL hDevNames;
     *     HDC hDC;
     *     DWORD Flags;
     *     WORD nFromPage;
     *     WORD nToPage;
     *     WORD nMinPage;
     *     WORD nMaxPage;
     *     WORD nCopies;
     *     HINSTANCE hInstance;
     *     LPARAM lCustData;
     *     LPPRINTHOOKPROC lpfnPrintHook;
     *     LPSETUPHOOKPROC lpfnSetupHook;
     *     LPCSTR lpPrintTemplateName;
     *     LPCSTR lpSetupTemplateName;
     *     HGLOBAL hPrintTemplate;
     *     HGLOBAL hSetupTemplate;
     * } *LPPRINTDLGA
     * }
     */
    public static final AddressLayout LPPRINTDLGA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPDW {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HGLOBAL hDevMode;
     *     HGLOBAL hDevNames;
     *     HDC hDC;
     *     DWORD Flags;
     *     WORD nFromPage;
     *     WORD nToPage;
     *     WORD nMinPage;
     *     WORD nMaxPage;
     *     WORD nCopies;
     *     HINSTANCE hInstance;
     *     LPARAM lCustData;
     *     LPPRINTHOOKPROC lpfnPrintHook;
     *     LPSETUPHOOKPROC lpfnSetupHook;
     *     LPCWSTR lpPrintTemplateName;
     *     LPCWSTR lpSetupTemplateName;
     *     HGLOBAL hPrintTemplate;
     *     HGLOBAL hSetupTemplate;
     * } *LPPRINTDLGW
     * }
     */
    public static final AddressLayout LPPRINTDLGW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPPRINTDLGA LPPRINTDLG
     * }
     */
    public static final AddressLayout LPPRINTDLG = wgl_h.C_POINTER;

    private static class PrintDlgA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PrintDlgA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrintDlgA(LPPRINTDLGA pPD)
     * }
     */
    public static FunctionDescriptor PrintDlgA$descriptor() {
        return PrintDlgA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrintDlgA(LPPRINTDLGA pPD)
     * }
     */
    public static MethodHandle PrintDlgA$handle() {
        return PrintDlgA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrintDlgA(LPPRINTDLGA pPD)
     * }
     */
    public static MemorySegment PrintDlgA$address() {
        return PrintDlgA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrintDlgA(LPPRINTDLGA pPD)
     * }
     */
    public static int PrintDlgA(MemorySegment pPD) {
        var mh$ = PrintDlgA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrintDlgA", pPD);
            }
            return (int)mh$.invokeExact(pPD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrintDlgW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PrintDlgW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrintDlgW(LPPRINTDLGW pPD)
     * }
     */
    public static FunctionDescriptor PrintDlgW$descriptor() {
        return PrintDlgW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrintDlgW(LPPRINTDLGW pPD)
     * }
     */
    public static MethodHandle PrintDlgW$handle() {
        return PrintDlgW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrintDlgW(LPPRINTDLGW pPD)
     * }
     */
    public static MemorySegment PrintDlgW$address() {
        return PrintDlgW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrintDlgW(LPPRINTDLGW pPD)
     * }
     */
    public static int PrintDlgW(MemorySegment pPD) {
        var mh$ = PrintDlgW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrintDlgW", pPD);
            }
            return (int)mh$.invokeExact(pPD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PRINTPAGERANGE *LPPRINTPAGERANGE
     * }
     */
    public static final AddressLayout LPPRINTPAGERANGE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const PRINTPAGERANGE *PCPRINTPAGERANGE
     * }
     */
    public static final AddressLayout PCPRINTPAGERANGE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPDEXA {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HGLOBAL hDevMode;
     *     HGLOBAL hDevNames;
     *     HDC hDC;
     *     DWORD Flags;
     *     DWORD Flags2;
     *     DWORD ExclusionFlags;
     *     DWORD nPageRanges;
     *     DWORD nMaxPageRanges;
     *     LPPRINTPAGERANGE lpPageRanges;
     *     DWORD nMinPage;
     *     DWORD nMaxPage;
     *     DWORD nCopies;
     *     HINSTANCE hInstance;
     *     LPCSTR lpPrintTemplateName;
     *     LPUNKNOWN lpCallback;
     *     DWORD nPropertyPages;
     *     HPROPSHEETPAGE *lphPropertyPages;
     *     DWORD nStartPage;
     *     DWORD dwResultAction;
     * } *LPPRINTDLGEXA
     * }
     */
    public static final AddressLayout LPPRINTDLGEXA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPDEXW {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HGLOBAL hDevMode;
     *     HGLOBAL hDevNames;
     *     HDC hDC;
     *     DWORD Flags;
     *     DWORD Flags2;
     *     DWORD ExclusionFlags;
     *     DWORD nPageRanges;
     *     DWORD nMaxPageRanges;
     *     LPPRINTPAGERANGE lpPageRanges;
     *     DWORD nMinPage;
     *     DWORD nMaxPage;
     *     DWORD nCopies;
     *     HINSTANCE hInstance;
     *     LPCWSTR lpPrintTemplateName;
     *     LPUNKNOWN lpCallback;
     *     DWORD nPropertyPages;
     *     HPROPSHEETPAGE *lphPropertyPages;
     *     DWORD nStartPage;
     *     DWORD dwResultAction;
     * } *LPPRINTDLGEXW
     * }
     */
    public static final AddressLayout LPPRINTDLGEXW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPPRINTDLGEXA LPPRINTDLGEX
     * }
     */
    public static final AddressLayout LPPRINTDLGEX = wgl_h.C_POINTER;

    private static class PrintDlgExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PrintDlgExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT PrintDlgExA(LPPRINTDLGEXA pPD)
     * }
     */
    public static FunctionDescriptor PrintDlgExA$descriptor() {
        return PrintDlgExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT PrintDlgExA(LPPRINTDLGEXA pPD)
     * }
     */
    public static MethodHandle PrintDlgExA$handle() {
        return PrintDlgExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT PrintDlgExA(LPPRINTDLGEXA pPD)
     * }
     */
    public static MemorySegment PrintDlgExA$address() {
        return PrintDlgExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT PrintDlgExA(LPPRINTDLGEXA pPD)
     * }
     */
    public static int PrintDlgExA(MemorySegment pPD) {
        var mh$ = PrintDlgExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrintDlgExA", pPD);
            }
            return (int)mh$.invokeExact(pPD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrintDlgExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PrintDlgExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT PrintDlgExW(LPPRINTDLGEXW pPD)
     * }
     */
    public static FunctionDescriptor PrintDlgExW$descriptor() {
        return PrintDlgExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT PrintDlgExW(LPPRINTDLGEXW pPD)
     * }
     */
    public static MethodHandle PrintDlgExW$handle() {
        return PrintDlgExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT PrintDlgExW(LPPRINTDLGEXW pPD)
     * }
     */
    public static MemorySegment PrintDlgExW$address() {
        return PrintDlgExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT PrintDlgExW(LPPRINTDLGEXW pPD)
     * }
     */
    public static int PrintDlgExW(MemorySegment pPD) {
        var mh$ = PrintDlgExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrintDlgExW", pPD);
            }
            return (int)mh$.invokeExact(pPD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef DEVNAMES *LPDEVNAMES
     * }
     */
    public static final AddressLayout LPDEVNAMES = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const DEVNAMES *PCDEVNAMES
     * }
     */
    public static final AddressLayout PCDEVNAMES = wgl_h.C_POINTER;

    private static class CommDlgExtendedError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CommDlgExtendedError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CommDlgExtendedError()
     * }
     */
    public static FunctionDescriptor CommDlgExtendedError$descriptor() {
        return CommDlgExtendedError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CommDlgExtendedError()
     * }
     */
    public static MethodHandle CommDlgExtendedError$handle() {
        return CommDlgExtendedError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CommDlgExtendedError()
     * }
     */
    public static MemorySegment CommDlgExtendedError$address() {
        return CommDlgExtendedError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CommDlgExtendedError()
     * }
     */
    public static int CommDlgExtendedError() {
        var mh$ = CommDlgExtendedError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CommDlgExtendedError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagPSDA {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HGLOBAL hDevMode;
     *     HGLOBAL hDevNames;
     *     DWORD Flags;
     *     POINT ptPaperSize;
     *     RECT rtMinMargin;
     *     RECT rtMargin;
     *     HINSTANCE hInstance;
     *     LPARAM lCustData;
     *     LPPAGESETUPHOOK lpfnPageSetupHook;
     *     LPPAGEPAINTHOOK lpfnPagePaintHook;
     *     LPCSTR lpPageSetupTemplateName;
     *     HGLOBAL hPageSetupTemplate;
     * } *LPPAGESETUPDLGA
     * }
     */
    public static final AddressLayout LPPAGESETUPDLGA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPSDW {
     *     DWORD lStructSize;
     *     HWND hwndOwner;
     *     HGLOBAL hDevMode;
     *     HGLOBAL hDevNames;
     *     DWORD Flags;
     *     POINT ptPaperSize;
     *     RECT rtMinMargin;
     *     RECT rtMargin;
     *     HINSTANCE hInstance;
     *     LPARAM lCustData;
     *     LPPAGESETUPHOOK lpfnPageSetupHook;
     *     LPPAGEPAINTHOOK lpfnPagePaintHook;
     *     LPCWSTR lpPageSetupTemplateName;
     *     HGLOBAL hPageSetupTemplate;
     * } *LPPAGESETUPDLGW
     * }
     */
    public static final AddressLayout LPPAGESETUPDLGW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPPAGESETUPDLGA LPPAGESETUPDLG
     * }
     */
    public static final AddressLayout LPPAGESETUPDLG = wgl_h.C_POINTER;

    private static class PageSetupDlgA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PageSetupDlgA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PageSetupDlgA(LPPAGESETUPDLGA)
     * }
     */
    public static FunctionDescriptor PageSetupDlgA$descriptor() {
        return PageSetupDlgA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PageSetupDlgA(LPPAGESETUPDLGA)
     * }
     */
    public static MethodHandle PageSetupDlgA$handle() {
        return PageSetupDlgA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PageSetupDlgA(LPPAGESETUPDLGA)
     * }
     */
    public static MemorySegment PageSetupDlgA$address() {
        return PageSetupDlgA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PageSetupDlgA(LPPAGESETUPDLGA)
     * }
     */
    public static int PageSetupDlgA(MemorySegment x0) {
        var mh$ = PageSetupDlgA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PageSetupDlgA", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PageSetupDlgW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PageSetupDlgW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PageSetupDlgW(LPPAGESETUPDLGW)
     * }
     */
    public static FunctionDescriptor PageSetupDlgW$descriptor() {
        return PageSetupDlgW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PageSetupDlgW(LPPAGESETUPDLGW)
     * }
     */
    public static MethodHandle PageSetupDlgW$handle() {
        return PageSetupDlgW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PageSetupDlgW(LPPAGESETUPDLGW)
     * }
     */
    public static MemorySegment PageSetupDlgW$address() {
        return PageSetupDlgW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PageSetupDlgW(LPPAGESETUPDLGW)
     * }
     */
    public static int PageSetupDlgW(MemorySegment x0) {
        var mh$ = PageSetupDlgW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PageSetupDlgW", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_CharUpperW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("uaw_CharUpperW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPUWSTR uaw_CharUpperW(LPUWSTR String)
     * }
     */
    public static FunctionDescriptor uaw_CharUpperW$descriptor() {
        return uaw_CharUpperW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPUWSTR uaw_CharUpperW(LPUWSTR String)
     * }
     */
    public static MethodHandle uaw_CharUpperW$handle() {
        return uaw_CharUpperW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPUWSTR uaw_CharUpperW(LPUWSTR String)
     * }
     */
    public static MemorySegment uaw_CharUpperW$address() {
        return uaw_CharUpperW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPUWSTR uaw_CharUpperW(LPUWSTR String)
     * }
     */
    public static MemorySegment uaw_CharUpperW(MemorySegment String_) {
        var mh$ = uaw_CharUpperW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_CharUpperW", String_);
            }
            return (MemorySegment)mh$.invokeExact(String_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_lstrcmpW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("uaw_lstrcmpW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uaw_lstrcmpW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static FunctionDescriptor uaw_lstrcmpW$descriptor() {
        return uaw_lstrcmpW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uaw_lstrcmpW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MethodHandle uaw_lstrcmpW$handle() {
        return uaw_lstrcmpW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uaw_lstrcmpW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MemorySegment uaw_lstrcmpW$address() {
        return uaw_lstrcmpW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uaw_lstrcmpW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static int uaw_lstrcmpW(MemorySegment String1, MemorySegment String2) {
        var mh$ = uaw_lstrcmpW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_lstrcmpW", String1, String2);
            }
            return (int)mh$.invokeExact(String1, String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_lstrcmpiW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("uaw_lstrcmpiW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uaw_lstrcmpiW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static FunctionDescriptor uaw_lstrcmpiW$descriptor() {
        return uaw_lstrcmpiW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uaw_lstrcmpiW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MethodHandle uaw_lstrcmpiW$handle() {
        return uaw_lstrcmpiW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uaw_lstrcmpiW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MemorySegment uaw_lstrcmpiW$address() {
        return uaw_lstrcmpiW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uaw_lstrcmpiW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static int uaw_lstrcmpiW(MemorySegment String1, MemorySegment String2) {
        var mh$ = uaw_lstrcmpiW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_lstrcmpiW", String1, String2);
            }
            return (int)mh$.invokeExact(String1, String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_lstrlenW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("uaw_lstrlenW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uaw_lstrlenW(LPCUWSTR String)
     * }
     */
    public static FunctionDescriptor uaw_lstrlenW$descriptor() {
        return uaw_lstrlenW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uaw_lstrlenW(LPCUWSTR String)
     * }
     */
    public static MethodHandle uaw_lstrlenW$handle() {
        return uaw_lstrlenW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uaw_lstrlenW(LPCUWSTR String)
     * }
     */
    public static MemorySegment uaw_lstrlenW$address() {
        return uaw_lstrlenW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uaw_lstrlenW(LPCUWSTR String)
     * }
     */
    public static int uaw_lstrlenW(MemorySegment String_) {
        var mh$ = uaw_lstrlenW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_lstrlenW", String_);
            }
            return (int)mh$.invokeExact(String_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_wcschr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("uaw_wcschr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcschr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static FunctionDescriptor uaw_wcschr$descriptor() {
        return uaw_wcschr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcschr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MethodHandle uaw_wcschr$handle() {
        return uaw_wcschr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcschr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MemorySegment uaw_wcschr$address() {
        return uaw_wcschr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUWSTR uaw_wcschr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MemorySegment uaw_wcschr(MemorySegment String_, short Character) {
        var mh$ = uaw_wcschr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_wcschr", String_, Character);
            }
            return (MemorySegment)mh$.invokeExact(String_, Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_wcscpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("uaw_wcscpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcscpy(PUWSTR Destination, PCUWSTR Source)
     * }
     */
    public static FunctionDescriptor uaw_wcscpy$descriptor() {
        return uaw_wcscpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcscpy(PUWSTR Destination, PCUWSTR Source)
     * }
     */
    public static MethodHandle uaw_wcscpy$handle() {
        return uaw_wcscpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcscpy(PUWSTR Destination, PCUWSTR Source)
     * }
     */
    public static MemorySegment uaw_wcscpy$address() {
        return uaw_wcscpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUWSTR uaw_wcscpy(PUWSTR Destination, PCUWSTR Source)
     * }
     */
    public static MemorySegment uaw_wcscpy(MemorySegment Destination, MemorySegment Source) {
        var mh$ = uaw_wcscpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_wcscpy", Destination, Source);
            }
            return (MemorySegment)mh$.invokeExact(Destination, Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("uaw_wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uaw_wcsicmp(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static FunctionDescriptor uaw_wcsicmp$descriptor() {
        return uaw_wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uaw_wcsicmp(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MethodHandle uaw_wcsicmp$handle() {
        return uaw_wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uaw_wcsicmp(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MemorySegment uaw_wcsicmp$address() {
        return uaw_wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uaw_wcsicmp(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static int uaw_wcsicmp(MemorySegment String1, MemorySegment String2) {
        var mh$ = uaw_wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_wcsicmp", String1, String2);
            }
            return (int)mh$.invokeExact(String1, String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_wcslen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("uaw_wcslen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t uaw_wcslen(PCUWSTR String)
     * }
     */
    public static FunctionDescriptor uaw_wcslen$descriptor() {
        return uaw_wcslen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t uaw_wcslen(PCUWSTR String)
     * }
     */
    public static MethodHandle uaw_wcslen$handle() {
        return uaw_wcslen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t uaw_wcslen(PCUWSTR String)
     * }
     */
    public static MemorySegment uaw_wcslen$address() {
        return uaw_wcslen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t uaw_wcslen(PCUWSTR String)
     * }
     */
    public static long uaw_wcslen(MemorySegment String_) {
        var mh$ = uaw_wcslen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_wcslen", String_);
            }
            return (long)mh$.invokeExact(String_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_wcsrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("uaw_wcsrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcsrchr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static FunctionDescriptor uaw_wcsrchr$descriptor() {
        return uaw_wcsrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcsrchr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MethodHandle uaw_wcsrchr$handle() {
        return uaw_wcsrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcsrchr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MemorySegment uaw_wcsrchr$address() {
        return uaw_wcsrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUWSTR uaw_wcsrchr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MemorySegment uaw_wcsrchr(MemorySegment String_, short Character) {
        var mh$ = uaw_wcsrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_wcsrchr", String_, Character);
            }
            return (MemorySegment)mh$.invokeExact(String_, Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __unaligned WCHAR *PUWSTR_C
     * }
     */
    public static final AddressLayout PUWSTR_C = wgl_h.C_POINTER;

    private static class NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID
     * }
     */
    public static GroupLayout NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$layout() {
        return NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID
     * }
     */
    public static MemorySegment NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID() {
        return NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID
     * }
     */
    public static void NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$constants.SEGMENT, 0L, NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$constants.LAYOUT.byteSize());
    }

    private static class NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID
     * }
     */
    public static GroupLayout NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$layout() {
        return NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID
     * }
     */
    public static MemorySegment NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID() {
        return NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID
     * }
     */
    public static void NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$constants.SEGMENT, 0L, NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$constants.LAYOUT.byteSize());
    }

    private static class DOMAIN_JOIN_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("DOMAIN_JOIN_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_JOIN_GUID
     * }
     */
    public static GroupLayout DOMAIN_JOIN_GUID$layout() {
        return DOMAIN_JOIN_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_JOIN_GUID
     * }
     */
    public static MemorySegment DOMAIN_JOIN_GUID() {
        return DOMAIN_JOIN_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_JOIN_GUID
     * }
     */
    public static void DOMAIN_JOIN_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, DOMAIN_JOIN_GUID$constants.SEGMENT, 0L, DOMAIN_JOIN_GUID$constants.LAYOUT.byteSize());
    }

    private static class DOMAIN_LEAVE_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("DOMAIN_LEAVE_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_LEAVE_GUID
     * }
     */
    public static GroupLayout DOMAIN_LEAVE_GUID$layout() {
        return DOMAIN_LEAVE_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_LEAVE_GUID
     * }
     */
    public static MemorySegment DOMAIN_LEAVE_GUID() {
        return DOMAIN_LEAVE_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_LEAVE_GUID
     * }
     */
    public static void DOMAIN_LEAVE_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, DOMAIN_LEAVE_GUID$constants.SEGMENT, 0L, DOMAIN_LEAVE_GUID$constants.LAYOUT.byteSize());
    }

    private static class FIREWALL_PORT_OPEN_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("FIREWALL_PORT_OPEN_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_OPEN_GUID
     * }
     */
    public static GroupLayout FIREWALL_PORT_OPEN_GUID$layout() {
        return FIREWALL_PORT_OPEN_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_OPEN_GUID
     * }
     */
    public static MemorySegment FIREWALL_PORT_OPEN_GUID() {
        return FIREWALL_PORT_OPEN_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_OPEN_GUID
     * }
     */
    public static void FIREWALL_PORT_OPEN_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, FIREWALL_PORT_OPEN_GUID$constants.SEGMENT, 0L, FIREWALL_PORT_OPEN_GUID$constants.LAYOUT.byteSize());
    }

    private static class FIREWALL_PORT_CLOSE_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("FIREWALL_PORT_CLOSE_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_CLOSE_GUID
     * }
     */
    public static GroupLayout FIREWALL_PORT_CLOSE_GUID$layout() {
        return FIREWALL_PORT_CLOSE_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_CLOSE_GUID
     * }
     */
    public static MemorySegment FIREWALL_PORT_CLOSE_GUID() {
        return FIREWALL_PORT_CLOSE_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_CLOSE_GUID
     * }
     */
    public static void FIREWALL_PORT_CLOSE_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, FIREWALL_PORT_CLOSE_GUID$constants.SEGMENT, 0L, FIREWALL_PORT_CLOSE_GUID$constants.LAYOUT.byteSize());
    }

    private static class MACHINE_POLICY_PRESENT_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("MACHINE_POLICY_PRESENT_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID MACHINE_POLICY_PRESENT_GUID
     * }
     */
    public static GroupLayout MACHINE_POLICY_PRESENT_GUID$layout() {
        return MACHINE_POLICY_PRESENT_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID MACHINE_POLICY_PRESENT_GUID
     * }
     */
    public static MemorySegment MACHINE_POLICY_PRESENT_GUID() {
        return MACHINE_POLICY_PRESENT_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID MACHINE_POLICY_PRESENT_GUID
     * }
     */
    public static void MACHINE_POLICY_PRESENT_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, MACHINE_POLICY_PRESENT_GUID$constants.SEGMENT, 0L, MACHINE_POLICY_PRESENT_GUID$constants.LAYOUT.byteSize());
    }

    private static class USER_POLICY_PRESENT_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("USER_POLICY_PRESENT_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID USER_POLICY_PRESENT_GUID
     * }
     */
    public static GroupLayout USER_POLICY_PRESENT_GUID$layout() {
        return USER_POLICY_PRESENT_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID USER_POLICY_PRESENT_GUID
     * }
     */
    public static MemorySegment USER_POLICY_PRESENT_GUID() {
        return USER_POLICY_PRESENT_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID USER_POLICY_PRESENT_GUID
     * }
     */
    public static void USER_POLICY_PRESENT_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, USER_POLICY_PRESENT_GUID$constants.SEGMENT, 0L, USER_POLICY_PRESENT_GUID$constants.LAYOUT.byteSize());
    }

    private static class RPC_INTERFACE_EVENT_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("RPC_INTERFACE_EVENT_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID RPC_INTERFACE_EVENT_GUID
     * }
     */
    public static GroupLayout RPC_INTERFACE_EVENT_GUID$layout() {
        return RPC_INTERFACE_EVENT_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID RPC_INTERFACE_EVENT_GUID
     * }
     */
    public static MemorySegment RPC_INTERFACE_EVENT_GUID() {
        return RPC_INTERFACE_EVENT_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID RPC_INTERFACE_EVENT_GUID
     * }
     */
    public static void RPC_INTERFACE_EVENT_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, RPC_INTERFACE_EVENT_GUID$constants.SEGMENT, 0L, RPC_INTERFACE_EVENT_GUID$constants.LAYOUT.byteSize());
    }

    private static class NAMED_PIPE_EVENT_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("NAMED_PIPE_EVENT_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID NAMED_PIPE_EVENT_GUID
     * }
     */
    public static GroupLayout NAMED_PIPE_EVENT_GUID$layout() {
        return NAMED_PIPE_EVENT_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID NAMED_PIPE_EVENT_GUID
     * }
     */
    public static MemorySegment NAMED_PIPE_EVENT_GUID() {
        return NAMED_PIPE_EVENT_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID NAMED_PIPE_EVENT_GUID
     * }
     */
    public static void NAMED_PIPE_EVENT_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, NAMED_PIPE_EVENT_GUID$constants.SEGMENT, 0L, NAMED_PIPE_EVENT_GUID$constants.LAYOUT.byteSize());
    }

    private static class CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = wgl_h.findOrThrow("CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID
     * }
     */
    public static GroupLayout CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$layout() {
        return CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID
     * }
     */
    public static MemorySegment CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID() {
        return CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID
     * }
     */
    public static void CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$constants.SEGMENT, 0L, CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
     *     union {
     *         SERVICE_TRIGGER_CUSTOM_STATE_ID CustomStateId;
     *         struct {
     *             DWORD DataOffset;
     *             BYTE Data[1];
     *         } s;
     *     } u;
     * } *LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM
     * }
     */
    public static final AddressLayout LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_DESCRIPTIONA {
     *     LPSTR lpDescription;
     * } *LPSERVICE_DESCRIPTIONA
     * }
     */
    public static final AddressLayout LPSERVICE_DESCRIPTIONA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_DESCRIPTIONW {
     *     LPWSTR lpDescription;
     * } *LPSERVICE_DESCRIPTIONW
     * }
     */
    public static final AddressLayout LPSERVICE_DESCRIPTIONW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION
     * }
     */
    public static final AddressLayout LPSERVICE_DESCRIPTION = wgl_h.C_POINTER;
    private static final int SC_ACTION_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SC_ACTION_TYPE.SC_ACTION_NONE = 0
     * }
     */
    public static int SC_ACTION_NONE() {
        return SC_ACTION_NONE;
    }
    private static final int SC_ACTION_RESTART = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _SC_ACTION_TYPE.SC_ACTION_RESTART = 1
     * }
     */
    public static int SC_ACTION_RESTART() {
        return SC_ACTION_RESTART;
    }
    private static final int SC_ACTION_REBOOT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _SC_ACTION_TYPE.SC_ACTION_REBOOT = 2
     * }
     */
    public static int SC_ACTION_REBOOT() {
        return SC_ACTION_REBOOT;
    }
    private static final int SC_ACTION_RUN_COMMAND = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _SC_ACTION_TYPE.SC_ACTION_RUN_COMMAND = 3
     * }
     */
    public static int SC_ACTION_RUN_COMMAND() {
        return SC_ACTION_RUN_COMMAND;
    }
    private static final int SC_ACTION_OWN_RESTART = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _SC_ACTION_TYPE.SC_ACTION_OWN_RESTART = 4
     * }
     */
    public static int SC_ACTION_OWN_RESTART() {
        return SC_ACTION_OWN_RESTART;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SC_ACTION {
     *     SC_ACTION_TYPE Type;
     *     DWORD Delay;
     * } *LPSC_ACTION
     * }
     */
    public static final AddressLayout LPSC_ACTION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_FAILURE_ACTIONSA {
     *     DWORD dwResetPeriod;
     *     LPSTR lpRebootMsg;
     *     LPSTR lpCommand;
     *     DWORD cActions;
     *     SC_ACTION *lpsaActions;
     * } *LPSERVICE_FAILURE_ACTIONSA
     * }
     */
    public static final AddressLayout LPSERVICE_FAILURE_ACTIONSA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_FAILURE_ACTIONSW {
     *     DWORD dwResetPeriod;
     *     LPWSTR lpRebootMsg;
     *     LPWSTR lpCommand;
     *     DWORD cActions;
     *     SC_ACTION *lpsaActions;
     * } *LPSERVICE_FAILURE_ACTIONSW
     * }
     */
    public static final AddressLayout LPSERVICE_FAILURE_ACTIONSW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS
     * }
     */
    public static final AddressLayout LPSERVICE_FAILURE_ACTIONS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_DELAYED_AUTO_START_INFO {
     *     BOOL fDelayedAutostart;
     * } *LPSERVICE_DELAYED_AUTO_START_INFO
     * }
     */
    public static final AddressLayout LPSERVICE_DELAYED_AUTO_START_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_FAILURE_ACTIONS_FLAG {
     *     BOOL fFailureActionsOnNonCrashFailures;
     * } *LPSERVICE_FAILURE_ACTIONS_FLAG
     * }
     */
    public static final AddressLayout LPSERVICE_FAILURE_ACTIONS_FLAG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_SID_INFO {
     *     DWORD dwServiceSidType;
     * } *LPSERVICE_SID_INFO
     * }
     */
    public static final AddressLayout LPSERVICE_SID_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
     *     LPSTR pmszRequiredPrivileges;
     * } *LPSERVICE_REQUIRED_PRIVILEGES_INFOA
     * }
     */
    public static final AddressLayout LPSERVICE_REQUIRED_PRIVILEGES_INFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
     *     LPWSTR pmszRequiredPrivileges;
     * } *LPSERVICE_REQUIRED_PRIVILEGES_INFOW
     * }
     */
    public static final AddressLayout LPSERVICE_REQUIRED_PRIVILEGES_INFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSERVICE_REQUIRED_PRIVILEGES_INFOA LPSERVICE_REQUIRED_PRIVILEGES_INFO
     * }
     */
    public static final AddressLayout LPSERVICE_REQUIRED_PRIVILEGES_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_PRESHUTDOWN_INFO {
     *     DWORD dwPreshutdownTimeout;
     * } *LPSERVICE_PRESHUTDOWN_INFO
     * }
     */
    public static final AddressLayout LPSERVICE_PRESHUTDOWN_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM {
     *     DWORD dwDataType;
     *     DWORD cbData;
     *     PBYTE pData;
     * } *PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM
     * }
     */
    public static final AddressLayout PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TRIGGER {
     *     DWORD dwTriggerType;
     *     DWORD dwAction;
     *     GUID *pTriggerSubtype;
     *     DWORD cDataItems;
     *     PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM pDataItems;
     * } *PSERVICE_TRIGGER
     * }
     */
    public static final AddressLayout PSERVICE_TRIGGER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TRIGGER_INFO {
     *     DWORD cTriggers;
     *     PSERVICE_TRIGGER pTriggers;
     *     PBYTE pReserved;
     * } *PSERVICE_TRIGGER_INFO
     * }
     */
    public static final AddressLayout PSERVICE_TRIGGER_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_PREFERRED_NODE_INFO {
     *     USHORT usPreferredNode;
     *     BOOLEAN fDelete;
     * } *LPSERVICE_PREFERRED_NODE_INFO
     * }
     */
    public static final AddressLayout LPSERVICE_PREFERRED_NODE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TIMECHANGE_INFO {
     *     LARGE_INTEGER liNewTime;
     *     LARGE_INTEGER liOldTime;
     * } *PSERVICE_TIMECHANGE_INFO
     * }
     */
    public static final AddressLayout PSERVICE_TIMECHANGE_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_LAUNCH_PROTECTED_INFO {
     *     DWORD dwLaunchProtected;
     * } *PSERVICE_LAUNCH_PROTECTED_INFO
     * }
     */
    public static final AddressLayout PSERVICE_LAUNCH_PROTECTED_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct SC_HANDLE__ {
     *     int unused;
     * } *SC_HANDLE
     * }
     */
    public static final AddressLayout SC_HANDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SC_HANDLE *LPSC_HANDLE
     * }
     */
    public static final AddressLayout LPSC_HANDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct SERVICE_STATUS_HANDLE__ {
     *     int unused;
     * } *SERVICE_STATUS_HANDLE
     * }
     */
    public static final AddressLayout SERVICE_STATUS_HANDLE = wgl_h.C_POINTER;
    private static final int SC_STATUS_PROCESS_INFO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SC_STATUS_TYPE.SC_STATUS_PROCESS_INFO = 0
     * }
     */
    public static int SC_STATUS_PROCESS_INFO() {
        return SC_STATUS_PROCESS_INFO;
    }
    private static final int SC_ENUM_PROCESS_INFO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SC_ENUM_TYPE.SC_ENUM_PROCESS_INFO = 0
     * }
     */
    public static int SC_ENUM_PROCESS_INFO() {
        return SC_ENUM_PROCESS_INFO;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_STATUS {
     *     DWORD dwServiceType;
     *     DWORD dwCurrentState;
     *     DWORD dwControlsAccepted;
     *     DWORD dwWin32ExitCode;
     *     DWORD dwServiceSpecificExitCode;
     *     DWORD dwCheckPoint;
     *     DWORD dwWaitHint;
     * } *LPSERVICE_STATUS
     * }
     */
    public static final AddressLayout LPSERVICE_STATUS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_STATUS_PROCESS {
     *     DWORD dwServiceType;
     *     DWORD dwCurrentState;
     *     DWORD dwControlsAccepted;
     *     DWORD dwWin32ExitCode;
     *     DWORD dwServiceSpecificExitCode;
     *     DWORD dwCheckPoint;
     *     DWORD dwWaitHint;
     *     DWORD dwProcessId;
     *     DWORD dwServiceFlags;
     * } *LPSERVICE_STATUS_PROCESS
     * }
     */
    public static final AddressLayout LPSERVICE_STATUS_PROCESS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENUM_SERVICE_STATUSA {
     *     LPSTR lpServiceName;
     *     LPSTR lpDisplayName;
     *     SERVICE_STATUS ServiceStatus;
     * } *LPENUM_SERVICE_STATUSA
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUSA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENUM_SERVICE_STATUSW {
     *     LPWSTR lpServiceName;
     *     LPWSTR lpDisplayName;
     *     SERVICE_STATUS ServiceStatus;
     * } *LPENUM_SERVICE_STATUSW
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUSW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
     *     LPSTR lpServiceName;
     *     LPSTR lpDisplayName;
     *     SERVICE_STATUS_PROCESS ServiceStatusProcess;
     * } *LPENUM_SERVICE_STATUS_PROCESSA
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUS_PROCESSA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
     *     LPWSTR lpServiceName;
     *     LPWSTR lpDisplayName;
     *     SERVICE_STATUS_PROCESS ServiceStatusProcess;
     * } *LPENUM_SERVICE_STATUS_PROCESSW
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUS_PROCESSW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUS_PROCESS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPVOID SC_LOCK
     * }
     */
    public static final AddressLayout SC_LOCK = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _QUERY_SERVICE_LOCK_STATUSA {
     *     DWORD fIsLocked;
     *     LPSTR lpLockOwner;
     *     DWORD dwLockDuration;
     * } *LPQUERY_SERVICE_LOCK_STATUSA
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_LOCK_STATUSA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _QUERY_SERVICE_LOCK_STATUSW {
     *     DWORD fIsLocked;
     *     LPWSTR lpLockOwner;
     *     DWORD dwLockDuration;
     * } *LPQUERY_SERVICE_LOCK_STATUSW
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_LOCK_STATUSW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_LOCK_STATUS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _QUERY_SERVICE_CONFIGA {
     *     DWORD dwServiceType;
     *     DWORD dwStartType;
     *     DWORD dwErrorControl;
     *     LPSTR lpBinaryPathName;
     *     LPSTR lpLoadOrderGroup;
     *     DWORD dwTagId;
     *     LPSTR lpDependencies;
     *     LPSTR lpServiceStartName;
     *     LPSTR lpDisplayName;
     * } *LPQUERY_SERVICE_CONFIGA
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_CONFIGA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _QUERY_SERVICE_CONFIGW {
     *     DWORD dwServiceType;
     *     DWORD dwStartType;
     *     DWORD dwErrorControl;
     *     LPWSTR lpBinaryPathName;
     *     LPWSTR lpLoadOrderGroup;
     *     DWORD dwTagId;
     *     LPWSTR lpDependencies;
     *     LPWSTR lpServiceStartName;
     *     LPWSTR lpDisplayName;
     * } *LPQUERY_SERVICE_CONFIGW
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_CONFIGW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_CONFIG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TABLE_ENTRYA {
     *     LPSTR lpServiceName;
     *     LPSERVICE_MAIN_FUNCTIONA lpServiceProc;
     * } *LPSERVICE_TABLE_ENTRYA
     * }
     */
    public static final AddressLayout LPSERVICE_TABLE_ENTRYA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TABLE_ENTRYW {
     *     LPWSTR lpServiceName;
     *     LPSERVICE_MAIN_FUNCTIONW lpServiceProc;
     * } *LPSERVICE_TABLE_ENTRYW
     * }
     */
    public static final AddressLayout LPSERVICE_TABLE_ENTRYW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY
     * }
     */
    public static final AddressLayout LPSERVICE_TABLE_ENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_NOTIFY_1 {
     *     DWORD dwVersion;
     *     PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
     *     PVOID pContext;
     *     DWORD dwNotificationStatus;
     *     SERVICE_STATUS_PROCESS ServiceStatus;
     * } *PSERVICE_NOTIFY_1
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFY_1 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_NOTIFY_2A {
     *     DWORD dwVersion;
     *     PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
     *     PVOID pContext;
     *     DWORD dwNotificationStatus;
     *     SERVICE_STATUS_PROCESS ServiceStatus;
     *     DWORD dwNotificationTriggered;
     *     LPSTR pszServiceNames;
     * } *PSERVICE_NOTIFY_2A
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFY_2A = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_NOTIFY_2W {
     *     DWORD dwVersion;
     *     PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
     *     PVOID pContext;
     *     DWORD dwNotificationStatus;
     *     SERVICE_STATUS_PROCESS ServiceStatus;
     *     DWORD dwNotificationTriggered;
     *     LPWSTR pszServiceNames;
     * } *PSERVICE_NOTIFY_2W
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFY_2W = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PSERVICE_NOTIFY_2A PSERVICE_NOTIFY_2
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFY_2 = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SERVICE_NOTIFY_2A *PSERVICE_NOTIFYA
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFYA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SERVICE_NOTIFY_2W *PSERVICE_NOTIFYW
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFYW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PSERVICE_NOTIFYA PSERVICE_NOTIFY
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
     *     DWORD dwReason;
     *     LPSTR pszComment;
     *     SERVICE_STATUS_PROCESS ServiceStatus;
     * } *PSERVICE_CONTROL_STATUS_REASON_PARAMSA
     * }
     */
    public static final AddressLayout PSERVICE_CONTROL_STATUS_REASON_PARAMSA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
     *     DWORD dwReason;
     *     LPWSTR pszComment;
     *     SERVICE_STATUS_PROCESS ServiceStatus;
     * } *PSERVICE_CONTROL_STATUS_REASON_PARAMSW
     * }
     */
    public static final AddressLayout PSERVICE_CONTROL_STATUS_REASON_PARAMSW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PSERVICE_CONTROL_STATUS_REASON_PARAMSA PSERVICE_CONTROL_STATUS_REASON_PARAMS
     * }
     */
    public static final AddressLayout PSERVICE_CONTROL_STATUS_REASON_PARAMS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_START_REASON {
     *     DWORD dwReason;
     * } *PSERVICE_START_REASON
     * }
     */
    public static final AddressLayout PSERVICE_START_REASON = wgl_h.C_POINTER;

    private static class ChangeServiceConfigA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChangeServiceConfigA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigA(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName)
     * }
     */
    public static FunctionDescriptor ChangeServiceConfigA$descriptor() {
        return ChangeServiceConfigA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigA(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName)
     * }
     */
    public static MethodHandle ChangeServiceConfigA$handle() {
        return ChangeServiceConfigA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigA(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName)
     * }
     */
    public static MemorySegment ChangeServiceConfigA$address() {
        return ChangeServiceConfigA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigA(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName)
     * }
     */
    public static int ChangeServiceConfigA(MemorySegment hService, int dwServiceType, int dwStartType, int dwErrorControl, MemorySegment lpBinaryPathName, MemorySegment lpLoadOrderGroup, MemorySegment lpdwTagId, MemorySegment lpDependencies, MemorySegment lpServiceStartName, MemorySegment lpPassword, MemorySegment lpDisplayName) {
        var mh$ = ChangeServiceConfigA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeServiceConfigA", hService, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword, lpDisplayName);
            }
            return (int)mh$.invokeExact(hService, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword, lpDisplayName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeServiceConfigW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChangeServiceConfigW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigW(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName)
     * }
     */
    public static FunctionDescriptor ChangeServiceConfigW$descriptor() {
        return ChangeServiceConfigW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigW(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName)
     * }
     */
    public static MethodHandle ChangeServiceConfigW$handle() {
        return ChangeServiceConfigW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigW(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName)
     * }
     */
    public static MemorySegment ChangeServiceConfigW$address() {
        return ChangeServiceConfigW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigW(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName)
     * }
     */
    public static int ChangeServiceConfigW(MemorySegment hService, int dwServiceType, int dwStartType, int dwErrorControl, MemorySegment lpBinaryPathName, MemorySegment lpLoadOrderGroup, MemorySegment lpdwTagId, MemorySegment lpDependencies, MemorySegment lpServiceStartName, MemorySegment lpPassword, MemorySegment lpDisplayName) {
        var mh$ = ChangeServiceConfigW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeServiceConfigW", hService, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword, lpDisplayName);
            }
            return (int)mh$.invokeExact(hService, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword, lpDisplayName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeServiceConfig2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChangeServiceConfig2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static FunctionDescriptor ChangeServiceConfig2A$descriptor() {
        return ChangeServiceConfig2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static MethodHandle ChangeServiceConfig2A$handle() {
        return ChangeServiceConfig2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static MemorySegment ChangeServiceConfig2A$address() {
        return ChangeServiceConfig2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static int ChangeServiceConfig2A(MemorySegment hService, int dwInfoLevel, MemorySegment lpInfo) {
        var mh$ = ChangeServiceConfig2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeServiceConfig2A", hService, dwInfoLevel, lpInfo);
            }
            return (int)mh$.invokeExact(hService, dwInfoLevel, lpInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeServiceConfig2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChangeServiceConfig2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static FunctionDescriptor ChangeServiceConfig2W$descriptor() {
        return ChangeServiceConfig2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static MethodHandle ChangeServiceConfig2W$handle() {
        return ChangeServiceConfig2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static MemorySegment ChangeServiceConfig2W$address() {
        return ChangeServiceConfig2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static int ChangeServiceConfig2W(MemorySegment hService, int dwInfoLevel, MemorySegment lpInfo) {
        var mh$ = ChangeServiceConfig2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeServiceConfig2W", hService, dwInfoLevel, lpInfo);
            }
            return (int)mh$.invokeExact(hService, dwInfoLevel, lpInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseServiceHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseServiceHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseServiceHandle(SC_HANDLE hSCObject)
     * }
     */
    public static FunctionDescriptor CloseServiceHandle$descriptor() {
        return CloseServiceHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseServiceHandle(SC_HANDLE hSCObject)
     * }
     */
    public static MethodHandle CloseServiceHandle$handle() {
        return CloseServiceHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseServiceHandle(SC_HANDLE hSCObject)
     * }
     */
    public static MemorySegment CloseServiceHandle$address() {
        return CloseServiceHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseServiceHandle(SC_HANDLE hSCObject)
     * }
     */
    public static int CloseServiceHandle(MemorySegment hSCObject) {
        var mh$ = CloseServiceHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseServiceHandle", hSCObject);
            }
            return (int)mh$.invokeExact(hSCObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ControlService {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ControlService");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static FunctionDescriptor ControlService$descriptor() {
        return ControlService.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MethodHandle ControlService$handle() {
        return ControlService.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MemorySegment ControlService$address() {
        return ControlService.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static int ControlService(MemorySegment hService, int dwControl, MemorySegment lpServiceStatus) {
        var mh$ = ControlService.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ControlService", hService, dwControl, lpServiceStatus);
            }
            return (int)mh$.invokeExact(hService, dwControl, lpServiceStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateServiceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateServiceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword)
     * }
     */
    public static FunctionDescriptor CreateServiceA$descriptor() {
        return CreateServiceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword)
     * }
     */
    public static MethodHandle CreateServiceA$handle() {
        return CreateServiceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword)
     * }
     */
    public static MemorySegment CreateServiceA$address() {
        return CreateServiceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword)
     * }
     */
    public static MemorySegment CreateServiceA(MemorySegment hSCManager, MemorySegment lpServiceName, MemorySegment lpDisplayName, int dwDesiredAccess, int dwServiceType, int dwStartType, int dwErrorControl, MemorySegment lpBinaryPathName, MemorySegment lpLoadOrderGroup, MemorySegment lpdwTagId, MemorySegment lpDependencies, MemorySegment lpServiceStartName, MemorySegment lpPassword) {
        var mh$ = CreateServiceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateServiceA", hSCManager, lpServiceName, lpDisplayName, dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword);
            }
            return (MemorySegment)mh$.invokeExact(hSCManager, lpServiceName, lpDisplayName, dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateServiceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateServiceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword)
     * }
     */
    public static FunctionDescriptor CreateServiceW$descriptor() {
        return CreateServiceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword)
     * }
     */
    public static MethodHandle CreateServiceW$handle() {
        return CreateServiceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword)
     * }
     */
    public static MemorySegment CreateServiceW$address() {
        return CreateServiceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword)
     * }
     */
    public static MemorySegment CreateServiceW(MemorySegment hSCManager, MemorySegment lpServiceName, MemorySegment lpDisplayName, int dwDesiredAccess, int dwServiceType, int dwStartType, int dwErrorControl, MemorySegment lpBinaryPathName, MemorySegment lpLoadOrderGroup, MemorySegment lpdwTagId, MemorySegment lpDependencies, MemorySegment lpServiceStartName, MemorySegment lpPassword) {
        var mh$ = CreateServiceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateServiceW", hSCManager, lpServiceName, lpDisplayName, dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword);
            }
            return (MemorySegment)mh$.invokeExact(hSCManager, lpServiceName, lpDisplayName, dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteService {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteService");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteService(SC_HANDLE hService)
     * }
     */
    public static FunctionDescriptor DeleteService$descriptor() {
        return DeleteService.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteService(SC_HANDLE hService)
     * }
     */
    public static MethodHandle DeleteService$handle() {
        return DeleteService.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteService(SC_HANDLE hService)
     * }
     */
    public static MemorySegment DeleteService$address() {
        return DeleteService.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteService(SC_HANDLE hService)
     * }
     */
    public static int DeleteService(MemorySegment hService) {
        var mh$ = DeleteService.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteService", hService);
            }
            return (int)mh$.invokeExact(hService);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDependentServicesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumDependentServicesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesA(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static FunctionDescriptor EnumDependentServicesA$descriptor() {
        return EnumDependentServicesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesA(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static MethodHandle EnumDependentServicesA$handle() {
        return EnumDependentServicesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesA(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static MemorySegment EnumDependentServicesA$address() {
        return EnumDependentServicesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDependentServicesA(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static int EnumDependentServicesA(MemorySegment hService, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned) {
        var mh$ = EnumDependentServicesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDependentServicesA", hService, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned);
            }
            return (int)mh$.invokeExact(hService, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDependentServicesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumDependentServicesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesW(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static FunctionDescriptor EnumDependentServicesW$descriptor() {
        return EnumDependentServicesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesW(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static MethodHandle EnumDependentServicesW$handle() {
        return EnumDependentServicesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesW(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static MemorySegment EnumDependentServicesW$address() {
        return EnumDependentServicesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDependentServicesW(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static int EnumDependentServicesW(MemorySegment hService, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned) {
        var mh$ = EnumDependentServicesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDependentServicesW", hService, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned);
            }
            return (int)mh$.invokeExact(hService, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumServicesStatusA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumServicesStatusA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusA(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static FunctionDescriptor EnumServicesStatusA$descriptor() {
        return EnumServicesStatusA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusA(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static MethodHandle EnumServicesStatusA$handle() {
        return EnumServicesStatusA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusA(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static MemorySegment EnumServicesStatusA$address() {
        return EnumServicesStatusA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumServicesStatusA(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static int EnumServicesStatusA(MemorySegment hSCManager, int dwServiceType, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned, MemorySegment lpResumeHandle) {
        var mh$ = EnumServicesStatusA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumServicesStatusA", hSCManager, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle);
            }
            return (int)mh$.invokeExact(hSCManager, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumServicesStatusW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumServicesStatusW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusW(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static FunctionDescriptor EnumServicesStatusW$descriptor() {
        return EnumServicesStatusW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusW(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static MethodHandle EnumServicesStatusW$handle() {
        return EnumServicesStatusW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusW(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static MemorySegment EnumServicesStatusW$address() {
        return EnumServicesStatusW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumServicesStatusW(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static int EnumServicesStatusW(MemorySegment hSCManager, int dwServiceType, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned, MemorySegment lpResumeHandle) {
        var mh$ = EnumServicesStatusW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumServicesStatusW", hSCManager, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle);
            }
            return (int)mh$.invokeExact(hSCManager, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumServicesStatusExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumServicesStatusExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExA(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName)
     * }
     */
    public static FunctionDescriptor EnumServicesStatusExA$descriptor() {
        return EnumServicesStatusExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExA(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName)
     * }
     */
    public static MethodHandle EnumServicesStatusExA$handle() {
        return EnumServicesStatusExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExA(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName)
     * }
     */
    public static MemorySegment EnumServicesStatusExA$address() {
        return EnumServicesStatusExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExA(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName)
     * }
     */
    public static int EnumServicesStatusExA(MemorySegment hSCManager, int InfoLevel, int dwServiceType, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned, MemorySegment lpResumeHandle, MemorySegment pszGroupName) {
        var mh$ = EnumServicesStatusExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumServicesStatusExA", hSCManager, InfoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle, pszGroupName);
            }
            return (int)mh$.invokeExact(hSCManager, InfoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle, pszGroupName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumServicesStatusExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumServicesStatusExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExW(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName)
     * }
     */
    public static FunctionDescriptor EnumServicesStatusExW$descriptor() {
        return EnumServicesStatusExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExW(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName)
     * }
     */
    public static MethodHandle EnumServicesStatusExW$handle() {
        return EnumServicesStatusExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExW(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName)
     * }
     */
    public static MemorySegment EnumServicesStatusExW$address() {
        return EnumServicesStatusExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExW(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName)
     * }
     */
    public static int EnumServicesStatusExW(MemorySegment hSCManager, int InfoLevel, int dwServiceType, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned, MemorySegment lpResumeHandle, MemorySegment pszGroupName) {
        var mh$ = EnumServicesStatusExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumServicesStatusExW", hSCManager, InfoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle, pszGroupName);
            }
            return (int)mh$.invokeExact(hSCManager, InfoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle, pszGroupName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetServiceKeyNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetServiceKeyNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameA(SC_HANDLE hSCManager, LPCSTR lpDisplayName, LPSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static FunctionDescriptor GetServiceKeyNameA$descriptor() {
        return GetServiceKeyNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameA(SC_HANDLE hSCManager, LPCSTR lpDisplayName, LPSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static MethodHandle GetServiceKeyNameA$handle() {
        return GetServiceKeyNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameA(SC_HANDLE hSCManager, LPCSTR lpDisplayName, LPSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static MemorySegment GetServiceKeyNameA$address() {
        return GetServiceKeyNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameA(SC_HANDLE hSCManager, LPCSTR lpDisplayName, LPSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static int GetServiceKeyNameA(MemorySegment hSCManager, MemorySegment lpDisplayName, MemorySegment lpServiceName, MemorySegment lpcchBuffer) {
        var mh$ = GetServiceKeyNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceKeyNameA", hSCManager, lpDisplayName, lpServiceName, lpcchBuffer);
            }
            return (int)mh$.invokeExact(hSCManager, lpDisplayName, lpServiceName, lpcchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetServiceKeyNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetServiceKeyNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameW(SC_HANDLE hSCManager, LPCWSTR lpDisplayName, LPWSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static FunctionDescriptor GetServiceKeyNameW$descriptor() {
        return GetServiceKeyNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameW(SC_HANDLE hSCManager, LPCWSTR lpDisplayName, LPWSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static MethodHandle GetServiceKeyNameW$handle() {
        return GetServiceKeyNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameW(SC_HANDLE hSCManager, LPCWSTR lpDisplayName, LPWSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static MemorySegment GetServiceKeyNameW$address() {
        return GetServiceKeyNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameW(SC_HANDLE hSCManager, LPCWSTR lpDisplayName, LPWSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static int GetServiceKeyNameW(MemorySegment hSCManager, MemorySegment lpDisplayName, MemorySegment lpServiceName, MemorySegment lpcchBuffer) {
        var mh$ = GetServiceKeyNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceKeyNameW", hSCManager, lpDisplayName, lpServiceName, lpcchBuffer);
            }
            return (int)mh$.invokeExact(hSCManager, lpDisplayName, lpServiceName, lpcchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetServiceDisplayNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetServiceDisplayNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static FunctionDescriptor GetServiceDisplayNameA$descriptor() {
        return GetServiceDisplayNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static MethodHandle GetServiceDisplayNameA$handle() {
        return GetServiceDisplayNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static MemorySegment GetServiceDisplayNameA$address() {
        return GetServiceDisplayNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static int GetServiceDisplayNameA(MemorySegment hSCManager, MemorySegment lpServiceName, MemorySegment lpDisplayName, MemorySegment lpcchBuffer) {
        var mh$ = GetServiceDisplayNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceDisplayNameA", hSCManager, lpServiceName, lpDisplayName, lpcchBuffer);
            }
            return (int)mh$.invokeExact(hSCManager, lpServiceName, lpDisplayName, lpcchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetServiceDisplayNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetServiceDisplayNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPWSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static FunctionDescriptor GetServiceDisplayNameW$descriptor() {
        return GetServiceDisplayNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPWSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static MethodHandle GetServiceDisplayNameW$handle() {
        return GetServiceDisplayNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPWSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static MemorySegment GetServiceDisplayNameW$address() {
        return GetServiceDisplayNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPWSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static int GetServiceDisplayNameW(MemorySegment hSCManager, MemorySegment lpServiceName, MemorySegment lpDisplayName, MemorySegment lpcchBuffer) {
        var mh$ = GetServiceDisplayNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceDisplayNameW", hSCManager, lpServiceName, lpDisplayName, lpcchBuffer);
            }
            return (int)mh$.invokeExact(hSCManager, lpServiceName, lpDisplayName, lpcchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockServiceDatabase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LockServiceDatabase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_LOCK LockServiceDatabase(SC_HANDLE hSCManager)
     * }
     */
    public static FunctionDescriptor LockServiceDatabase$descriptor() {
        return LockServiceDatabase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_LOCK LockServiceDatabase(SC_HANDLE hSCManager)
     * }
     */
    public static MethodHandle LockServiceDatabase$handle() {
        return LockServiceDatabase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_LOCK LockServiceDatabase(SC_HANDLE hSCManager)
     * }
     */
    public static MemorySegment LockServiceDatabase$address() {
        return LockServiceDatabase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_LOCK LockServiceDatabase(SC_HANDLE hSCManager)
     * }
     */
    public static MemorySegment LockServiceDatabase(MemorySegment hSCManager) {
        var mh$ = LockServiceDatabase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockServiceDatabase", hSCManager);
            }
            return (MemorySegment)mh$.invokeExact(hSCManager);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyBootConfigStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NotifyBootConfigStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NotifyBootConfigStatus(BOOL BootAcceptable)
     * }
     */
    public static FunctionDescriptor NotifyBootConfigStatus$descriptor() {
        return NotifyBootConfigStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NotifyBootConfigStatus(BOOL BootAcceptable)
     * }
     */
    public static MethodHandle NotifyBootConfigStatus$handle() {
        return NotifyBootConfigStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL NotifyBootConfigStatus(BOOL BootAcceptable)
     * }
     */
    public static MemorySegment NotifyBootConfigStatus$address() {
        return NotifyBootConfigStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL NotifyBootConfigStatus(BOOL BootAcceptable)
     * }
     */
    public static int NotifyBootConfigStatus(int BootAcceptable) {
        var mh$ = NotifyBootConfigStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyBootConfigStatus", BootAcceptable);
            }
            return (int)mh$.invokeExact(BootAcceptable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenSCManagerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenSCManagerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenSCManagerA$descriptor() {
        return OpenSCManagerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenSCManagerA$handle() {
        return OpenSCManagerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenSCManagerA$address() {
        return OpenSCManagerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenSCManagerA(MemorySegment lpMachineName, MemorySegment lpDatabaseName, int dwDesiredAccess) {
        var mh$ = OpenSCManagerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenSCManagerA", lpMachineName, lpDatabaseName, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMachineName, lpDatabaseName, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenSCManagerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenSCManagerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenSCManagerW$descriptor() {
        return OpenSCManagerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenSCManagerW$handle() {
        return OpenSCManagerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenSCManagerW$address() {
        return OpenSCManagerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenSCManagerW(MemorySegment lpMachineName, MemorySegment lpDatabaseName, int dwDesiredAccess) {
        var mh$ = OpenSCManagerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenSCManagerW", lpMachineName, lpDatabaseName, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMachineName, lpDatabaseName, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenServiceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenServiceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenServiceA$descriptor() {
        return OpenServiceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenServiceA$handle() {
        return OpenServiceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenServiceA$address() {
        return OpenServiceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenServiceA(MemorySegment hSCManager, MemorySegment lpServiceName, int dwDesiredAccess) {
        var mh$ = OpenServiceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenServiceA", hSCManager, lpServiceName, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(hSCManager, lpServiceName, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenServiceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenServiceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenServiceW$descriptor() {
        return OpenServiceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenServiceW$handle() {
        return OpenServiceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenServiceW$address() {
        return OpenServiceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenServiceW(MemorySegment hSCManager, MemorySegment lpServiceName, int dwDesiredAccess) {
        var mh$ = OpenServiceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenServiceW", hSCManager, lpServiceName, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(hSCManager, lpServiceName, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceConfigA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryServiceConfigA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigA(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceConfigA$descriptor() {
        return QueryServiceConfigA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigA(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceConfigA$handle() {
        return QueryServiceConfigA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigA(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceConfigA$address() {
        return QueryServiceConfigA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceConfigA(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceConfigA(MemorySegment hService, MemorySegment lpServiceConfig, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceConfigA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceConfigA", hService, lpServiceConfig, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, lpServiceConfig, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceConfigW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryServiceConfigW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceConfigW$descriptor() {
        return QueryServiceConfigW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceConfigW$handle() {
        return QueryServiceConfigW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceConfigW$address() {
        return QueryServiceConfigW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceConfigW(MemorySegment hService, MemorySegment lpServiceConfig, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceConfigW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceConfigW", hService, lpServiceConfig, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, lpServiceConfig, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceConfig2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryServiceConfig2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceConfig2A$descriptor() {
        return QueryServiceConfig2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceConfig2A$handle() {
        return QueryServiceConfig2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceConfig2A$address() {
        return QueryServiceConfig2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceConfig2A(MemorySegment hService, int dwInfoLevel, MemorySegment lpBuffer, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceConfig2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceConfig2A", hService, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceConfig2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryServiceConfig2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceConfig2W$descriptor() {
        return QueryServiceConfig2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceConfig2W$handle() {
        return QueryServiceConfig2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceConfig2W$address() {
        return QueryServiceConfig2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceConfig2W(MemorySegment hService, int dwInfoLevel, MemorySegment lpBuffer, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceConfig2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceConfig2W", hService, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceLockStatusA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryServiceLockStatusA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusA(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceLockStatusA$descriptor() {
        return QueryServiceLockStatusA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusA(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceLockStatusA$handle() {
        return QueryServiceLockStatusA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusA(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceLockStatusA$address() {
        return QueryServiceLockStatusA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusA(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceLockStatusA(MemorySegment hSCManager, MemorySegment lpLockStatus, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceLockStatusA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceLockStatusA", hSCManager, lpLockStatus, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hSCManager, lpLockStatus, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceLockStatusW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryServiceLockStatusW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusW(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceLockStatusW$descriptor() {
        return QueryServiceLockStatusW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusW(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceLockStatusW$handle() {
        return QueryServiceLockStatusW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusW(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceLockStatusW$address() {
        return QueryServiceLockStatusW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusW(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceLockStatusW(MemorySegment hSCManager, MemorySegment lpLockStatus, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceLockStatusW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceLockStatusW", hSCManager, lpLockStatus, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hSCManager, lpLockStatus, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryServiceObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceObjectSecurity$descriptor() {
        return QueryServiceObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceObjectSecurity$handle() {
        return QueryServiceObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceObjectSecurity$address() {
        return QueryServiceObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceObjectSecurity(MemorySegment hService, int dwSecurityInformation, MemorySegment lpSecurityDescriptor, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceObjectSecurity", hService, dwSecurityInformation, lpSecurityDescriptor, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, dwSecurityInformation, lpSecurityDescriptor, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryServiceStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static FunctionDescriptor QueryServiceStatus$descriptor() {
        return QueryServiceStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MethodHandle QueryServiceStatus$handle() {
        return QueryServiceStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MemorySegment QueryServiceStatus$address() {
        return QueryServiceStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static int QueryServiceStatus(MemorySegment hService, MemorySegment lpServiceStatus) {
        var mh$ = QueryServiceStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceStatus", hService, lpServiceStatus);
            }
            return (int)mh$.invokeExact(hService, lpServiceStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceStatusEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryServiceStatusEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatusEx(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceStatusEx$descriptor() {
        return QueryServiceStatusEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatusEx(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceStatusEx$handle() {
        return QueryServiceStatusEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatusEx(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceStatusEx$address() {
        return QueryServiceStatusEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceStatusEx(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceStatusEx(MemorySegment hService, int InfoLevel, MemorySegment lpBuffer, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceStatusEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceStatusEx", hService, InfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, InfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterServiceCtrlHandlerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterServiceCtrlHandlerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static FunctionDescriptor RegisterServiceCtrlHandlerA$descriptor() {
        return RegisterServiceCtrlHandlerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MethodHandle RegisterServiceCtrlHandlerA$handle() {
        return RegisterServiceCtrlHandlerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerA$address() {
        return RegisterServiceCtrlHandlerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerA(MemorySegment lpServiceName, MemorySegment lpHandlerProc) {
        var mh$ = RegisterServiceCtrlHandlerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterServiceCtrlHandlerA", lpServiceName, lpHandlerProc);
            }
            return (MemorySegment)mh$.invokeExact(lpServiceName, lpHandlerProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterServiceCtrlHandlerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterServiceCtrlHandlerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static FunctionDescriptor RegisterServiceCtrlHandlerW$descriptor() {
        return RegisterServiceCtrlHandlerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MethodHandle RegisterServiceCtrlHandlerW$handle() {
        return RegisterServiceCtrlHandlerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerW$address() {
        return RegisterServiceCtrlHandlerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerW(MemorySegment lpServiceName, MemorySegment lpHandlerProc) {
        var mh$ = RegisterServiceCtrlHandlerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterServiceCtrlHandlerW", lpServiceName, lpHandlerProc);
            }
            return (MemorySegment)mh$.invokeExact(lpServiceName, lpHandlerProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterServiceCtrlHandlerExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterServiceCtrlHandlerExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA(LPCSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static FunctionDescriptor RegisterServiceCtrlHandlerExA$descriptor() {
        return RegisterServiceCtrlHandlerExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA(LPCSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MethodHandle RegisterServiceCtrlHandlerExA$handle() {
        return RegisterServiceCtrlHandlerExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA(LPCSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerExA$address() {
        return RegisterServiceCtrlHandlerExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA(LPCSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerExA(MemorySegment lpServiceName, MemorySegment lpHandlerProc, MemorySegment lpContext) {
        var mh$ = RegisterServiceCtrlHandlerExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterServiceCtrlHandlerExA", lpServiceName, lpHandlerProc, lpContext);
            }
            return (MemorySegment)mh$.invokeExact(lpServiceName, lpHandlerProc, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterServiceCtrlHandlerExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterServiceCtrlHandlerExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static FunctionDescriptor RegisterServiceCtrlHandlerExW$descriptor() {
        return RegisterServiceCtrlHandlerExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MethodHandle RegisterServiceCtrlHandlerExW$handle() {
        return RegisterServiceCtrlHandlerExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerExW$address() {
        return RegisterServiceCtrlHandlerExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerExW(MemorySegment lpServiceName, MemorySegment lpHandlerProc, MemorySegment lpContext) {
        var mh$ = RegisterServiceCtrlHandlerExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterServiceCtrlHandlerExW", lpServiceName, lpHandlerProc, lpContext);
            }
            return (MemorySegment)mh$.invokeExact(lpServiceName, lpHandlerProc, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetServiceObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetServiceObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor SetServiceObjectSecurity$descriptor() {
        return SetServiceObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor)
     * }
     */
    public static MethodHandle SetServiceObjectSecurity$handle() {
        return SetServiceObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor)
     * }
     */
    public static MemorySegment SetServiceObjectSecurity$address() {
        return SetServiceObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor)
     * }
     */
    public static int SetServiceObjectSecurity(MemorySegment hService, int dwSecurityInformation, MemorySegment lpSecurityDescriptor) {
        var mh$ = SetServiceObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetServiceObjectSecurity", hService, dwSecurityInformation, lpSecurityDescriptor);
            }
            return (int)mh$.invokeExact(hService, dwSecurityInformation, lpSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetServiceStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetServiceStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static FunctionDescriptor SetServiceStatus$descriptor() {
        return SetServiceStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MethodHandle SetServiceStatus$handle() {
        return SetServiceStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MemorySegment SetServiceStatus$address() {
        return SetServiceStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static int SetServiceStatus(MemorySegment hServiceStatus, MemorySegment lpServiceStatus) {
        var mh$ = SetServiceStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetServiceStatus", hServiceStatus, lpServiceStatus);
            }
            return (int)mh$.invokeExact(hServiceStatus, lpServiceStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartServiceCtrlDispatcherA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StartServiceCtrlDispatcherA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENTRYA *lpServiceStartTable)
     * }
     */
    public static FunctionDescriptor StartServiceCtrlDispatcherA$descriptor() {
        return StartServiceCtrlDispatcherA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENTRYA *lpServiceStartTable)
     * }
     */
    public static MethodHandle StartServiceCtrlDispatcherA$handle() {
        return StartServiceCtrlDispatcherA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENTRYA *lpServiceStartTable)
     * }
     */
    public static MemorySegment StartServiceCtrlDispatcherA$address() {
        return StartServiceCtrlDispatcherA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENTRYA *lpServiceStartTable)
     * }
     */
    public static int StartServiceCtrlDispatcherA(MemorySegment lpServiceStartTable) {
        var mh$ = StartServiceCtrlDispatcherA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartServiceCtrlDispatcherA", lpServiceStartTable);
            }
            return (int)mh$.invokeExact(lpServiceStartTable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartServiceCtrlDispatcherW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StartServiceCtrlDispatcherW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherW(const SERVICE_TABLE_ENTRYW *lpServiceStartTable)
     * }
     */
    public static FunctionDescriptor StartServiceCtrlDispatcherW$descriptor() {
        return StartServiceCtrlDispatcherW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherW(const SERVICE_TABLE_ENTRYW *lpServiceStartTable)
     * }
     */
    public static MethodHandle StartServiceCtrlDispatcherW$handle() {
        return StartServiceCtrlDispatcherW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherW(const SERVICE_TABLE_ENTRYW *lpServiceStartTable)
     * }
     */
    public static MemorySegment StartServiceCtrlDispatcherW$address() {
        return StartServiceCtrlDispatcherW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherW(const SERVICE_TABLE_ENTRYW *lpServiceStartTable)
     * }
     */
    public static int StartServiceCtrlDispatcherW(MemorySegment lpServiceStartTable) {
        var mh$ = StartServiceCtrlDispatcherW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartServiceCtrlDispatcherW", lpServiceStartTable);
            }
            return (int)mh$.invokeExact(lpServiceStartTable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartServiceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StartServiceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors)
     * }
     */
    public static FunctionDescriptor StartServiceA$descriptor() {
        return StartServiceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors)
     * }
     */
    public static MethodHandle StartServiceA$handle() {
        return StartServiceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors)
     * }
     */
    public static MemorySegment StartServiceA$address() {
        return StartServiceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors)
     * }
     */
    public static int StartServiceA(MemorySegment hService, int dwNumServiceArgs, MemorySegment lpServiceArgVectors) {
        var mh$ = StartServiceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartServiceA", hService, dwNumServiceArgs, lpServiceArgVectors);
            }
            return (int)mh$.invokeExact(hService, dwNumServiceArgs, lpServiceArgVectors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartServiceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StartServiceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors)
     * }
     */
    public static FunctionDescriptor StartServiceW$descriptor() {
        return StartServiceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors)
     * }
     */
    public static MethodHandle StartServiceW$handle() {
        return StartServiceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors)
     * }
     */
    public static MemorySegment StartServiceW$address() {
        return StartServiceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors)
     * }
     */
    public static int StartServiceW(MemorySegment hService, int dwNumServiceArgs, MemorySegment lpServiceArgVectors) {
        var mh$ = StartServiceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartServiceW", hService, dwNumServiceArgs, lpServiceArgVectors);
            }
            return (int)mh$.invokeExact(hService, dwNumServiceArgs, lpServiceArgVectors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnlockServiceDatabase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnlockServiceDatabase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnlockServiceDatabase(SC_LOCK ScLock)
     * }
     */
    public static FunctionDescriptor UnlockServiceDatabase$descriptor() {
        return UnlockServiceDatabase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnlockServiceDatabase(SC_LOCK ScLock)
     * }
     */
    public static MethodHandle UnlockServiceDatabase$handle() {
        return UnlockServiceDatabase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnlockServiceDatabase(SC_LOCK ScLock)
     * }
     */
    public static MemorySegment UnlockServiceDatabase$address() {
        return UnlockServiceDatabase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnlockServiceDatabase(SC_LOCK ScLock)
     * }
     */
    public static int UnlockServiceDatabase(MemorySegment ScLock) {
        var mh$ = UnlockServiceDatabase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnlockServiceDatabase", ScLock);
            }
            return (int)mh$.invokeExact(ScLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyServiceStatusChangeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NotifyServiceStatusChangeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeA(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYA pNotifyBuffer)
     * }
     */
    public static FunctionDescriptor NotifyServiceStatusChangeA$descriptor() {
        return NotifyServiceStatusChangeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeA(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYA pNotifyBuffer)
     * }
     */
    public static MethodHandle NotifyServiceStatusChangeA$handle() {
        return NotifyServiceStatusChangeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeA(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYA pNotifyBuffer)
     * }
     */
    public static MemorySegment NotifyServiceStatusChangeA$address() {
        return NotifyServiceStatusChangeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeA(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYA pNotifyBuffer)
     * }
     */
    public static int NotifyServiceStatusChangeA(MemorySegment hService, int dwNotifyMask, MemorySegment pNotifyBuffer) {
        var mh$ = NotifyServiceStatusChangeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyServiceStatusChangeA", hService, dwNotifyMask, pNotifyBuffer);
            }
            return (int)mh$.invokeExact(hService, dwNotifyMask, pNotifyBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyServiceStatusChangeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NotifyServiceStatusChangeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYW pNotifyBuffer)
     * }
     */
    public static FunctionDescriptor NotifyServiceStatusChangeW$descriptor() {
        return NotifyServiceStatusChangeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYW pNotifyBuffer)
     * }
     */
    public static MethodHandle NotifyServiceStatusChangeW$handle() {
        return NotifyServiceStatusChangeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYW pNotifyBuffer)
     * }
     */
    public static MemorySegment NotifyServiceStatusChangeW$address() {
        return NotifyServiceStatusChangeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYW pNotifyBuffer)
     * }
     */
    public static int NotifyServiceStatusChangeW(MemorySegment hService, int dwNotifyMask, MemorySegment pNotifyBuffer) {
        var mh$ = NotifyServiceStatusChangeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyServiceStatusChangeW", hService, dwNotifyMask, pNotifyBuffer);
            }
            return (int)mh$.invokeExact(hService, dwNotifyMask, pNotifyBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ControlServiceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ControlServiceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ControlServiceExA(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static FunctionDescriptor ControlServiceExA$descriptor() {
        return ControlServiceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ControlServiceExA(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static MethodHandle ControlServiceExA$handle() {
        return ControlServiceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ControlServiceExA(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static MemorySegment ControlServiceExA$address() {
        return ControlServiceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ControlServiceExA(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static int ControlServiceExA(MemorySegment hService, int dwControl, int dwInfoLevel, MemorySegment pControlParams) {
        var mh$ = ControlServiceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ControlServiceExA", hService, dwControl, dwInfoLevel, pControlParams);
            }
            return (int)mh$.invokeExact(hService, dwControl, dwInfoLevel, pControlParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ControlServiceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ControlServiceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ControlServiceExW(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static FunctionDescriptor ControlServiceExW$descriptor() {
        return ControlServiceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ControlServiceExW(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static MethodHandle ControlServiceExW$handle() {
        return ControlServiceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ControlServiceExW(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static MemorySegment ControlServiceExW$address() {
        return ControlServiceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ControlServiceExW(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static int ControlServiceExW(MemorySegment hService, int dwControl, int dwInfoLevel, MemorySegment pControlParams) {
        var mh$ = ControlServiceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ControlServiceExW", hService, dwControl, dwInfoLevel, pControlParams);
            }
            return (int)mh$.invokeExact(hService, dwControl, dwInfoLevel, pControlParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceDynamicInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryServiceDynamicInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceDynamicInformation(SERVICE_STATUS_HANDLE hServiceStatus, DWORD dwInfoLevel, PVOID *ppDynamicInfo)
     * }
     */
    public static FunctionDescriptor QueryServiceDynamicInformation$descriptor() {
        return QueryServiceDynamicInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceDynamicInformation(SERVICE_STATUS_HANDLE hServiceStatus, DWORD dwInfoLevel, PVOID *ppDynamicInfo)
     * }
     */
    public static MethodHandle QueryServiceDynamicInformation$handle() {
        return QueryServiceDynamicInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceDynamicInformation(SERVICE_STATUS_HANDLE hServiceStatus, DWORD dwInfoLevel, PVOID *ppDynamicInfo)
     * }
     */
    public static MemorySegment QueryServiceDynamicInformation$address() {
        return QueryServiceDynamicInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceDynamicInformation(SERVICE_STATUS_HANDLE hServiceStatus, DWORD dwInfoLevel, PVOID *ppDynamicInfo)
     * }
     */
    public static int QueryServiceDynamicInformation(MemorySegment hServiceStatus, int dwInfoLevel, MemorySegment ppDynamicInfo) {
        var mh$ = QueryServiceDynamicInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceDynamicInformation", hServiceStatus, dwInfoLevel, ppDynamicInfo);
            }
            return (int)mh$.invokeExact(hServiceStatus, dwInfoLevel, ppDynamicInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SC_EVENT_DATABASE_CHANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SC_EVENT_TYPE.SC_EVENT_DATABASE_CHANGE = 0
     * }
     */
    public static int SC_EVENT_DATABASE_CHANGE() {
        return SC_EVENT_DATABASE_CHANGE;
    }
    private static final int SC_EVENT_PROPERTY_CHANGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _SC_EVENT_TYPE.SC_EVENT_PROPERTY_CHANGE = 1
     * }
     */
    public static int SC_EVENT_PROPERTY_CHANGE() {
        return SC_EVENT_PROPERTY_CHANGE;
    }
    private static final int SC_EVENT_STATUS_CHANGE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _SC_EVENT_TYPE.SC_EVENT_STATUS_CHANGE = 2
     * }
     */
    public static int SC_EVENT_STATUS_CHANGE() {
        return SC_EVENT_STATUS_CHANGE;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _SC_EVENT_TYPE {
     *     SC_EVENT_DATABASE_CHANGE,
     *     SC_EVENT_PROPERTY_CHANGE,
     *     SC_EVENT_STATUS_CHANGE
     * } *PSC_EVENT_TYPE
     * }
     */
    public static final AddressLayout PSC_EVENT_TYPE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SC_NOTIFICATION_REGISTRATION *PSC_NOTIFICATION_REGISTRATION
     * }
     */
    public static final AddressLayout PSC_NOTIFICATION_REGISTRATION = wgl_h.C_POINTER;

    private static class SubscribeServiceChangeNotifications {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SubscribeServiceChangeNotifications");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SubscribeServiceChangeNotifications(SC_HANDLE hService, SC_EVENT_TYPE eEventType, PSC_NOTIFICATION_CALLBACK pCallback, PVOID pCallbackContext, PSC_NOTIFICATION_REGISTRATION *pSubscription)
     * }
     */
    public static FunctionDescriptor SubscribeServiceChangeNotifications$descriptor() {
        return SubscribeServiceChangeNotifications.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SubscribeServiceChangeNotifications(SC_HANDLE hService, SC_EVENT_TYPE eEventType, PSC_NOTIFICATION_CALLBACK pCallback, PVOID pCallbackContext, PSC_NOTIFICATION_REGISTRATION *pSubscription)
     * }
     */
    public static MethodHandle SubscribeServiceChangeNotifications$handle() {
        return SubscribeServiceChangeNotifications.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SubscribeServiceChangeNotifications(SC_HANDLE hService, SC_EVENT_TYPE eEventType, PSC_NOTIFICATION_CALLBACK pCallback, PVOID pCallbackContext, PSC_NOTIFICATION_REGISTRATION *pSubscription)
     * }
     */
    public static MemorySegment SubscribeServiceChangeNotifications$address() {
        return SubscribeServiceChangeNotifications.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SubscribeServiceChangeNotifications(SC_HANDLE hService, SC_EVENT_TYPE eEventType, PSC_NOTIFICATION_CALLBACK pCallback, PVOID pCallbackContext, PSC_NOTIFICATION_REGISTRATION *pSubscription)
     * }
     */
    public static int SubscribeServiceChangeNotifications(MemorySegment hService, int eEventType, MemorySegment pCallback, MemorySegment pCallbackContext, MemorySegment pSubscription) {
        var mh$ = SubscribeServiceChangeNotifications.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SubscribeServiceChangeNotifications", hService, eEventType, pCallback, pCallbackContext, pSubscription);
            }
            return (int)mh$.invokeExact(hService, eEventType, pCallback, pCallbackContext, pSubscription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnsubscribeServiceChangeNotifications {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnsubscribeServiceChangeNotifications");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnsubscribeServiceChangeNotifications(PSC_NOTIFICATION_REGISTRATION pSubscription)
     * }
     */
    public static FunctionDescriptor UnsubscribeServiceChangeNotifications$descriptor() {
        return UnsubscribeServiceChangeNotifications.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnsubscribeServiceChangeNotifications(PSC_NOTIFICATION_REGISTRATION pSubscription)
     * }
     */
    public static MethodHandle UnsubscribeServiceChangeNotifications$handle() {
        return UnsubscribeServiceChangeNotifications.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnsubscribeServiceChangeNotifications(PSC_NOTIFICATION_REGISTRATION pSubscription)
     * }
     */
    public static MemorySegment UnsubscribeServiceChangeNotifications$address() {
        return UnsubscribeServiceChangeNotifications.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnsubscribeServiceChangeNotifications(PSC_NOTIFICATION_REGISTRATION pSubscription)
     * }
     */
    public static void UnsubscribeServiceChangeNotifications(MemorySegment pSubscription) {
        var mh$ = UnsubscribeServiceChangeNotifications.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnsubscribeServiceChangeNotifications", pSubscription);
            }
            mh$.invokeExact(pSubscription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitServiceState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitServiceState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitServiceState(SC_HANDLE hService, DWORD dwNotify, DWORD dwTimeout, HANDLE hCancelEvent)
     * }
     */
    public static FunctionDescriptor WaitServiceState$descriptor() {
        return WaitServiceState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitServiceState(SC_HANDLE hService, DWORD dwNotify, DWORD dwTimeout, HANDLE hCancelEvent)
     * }
     */
    public static MethodHandle WaitServiceState$handle() {
        return WaitServiceState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitServiceState(SC_HANDLE hService, DWORD dwNotify, DWORD dwTimeout, HANDLE hCancelEvent)
     * }
     */
    public static MemorySegment WaitServiceState$address() {
        return WaitServiceState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitServiceState(SC_HANDLE hService, DWORD dwNotify, DWORD dwTimeout, HANDLE hCancelEvent)
     * }
     */
    public static int WaitServiceState(MemorySegment hService, int dwNotify, int dwTimeout, MemorySegment hCancelEvent) {
        var mh$ = WaitServiceState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitServiceState", hService, dwNotify, dwTimeout, hCancelEvent);
            }
            return (int)mh$.invokeExact(hService, dwNotify, dwTimeout, hCancelEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ServiceRegistryStateParameters = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SERVICE_REGISTRY_STATE_TYPE.ServiceRegistryStateParameters = 0
     * }
     */
    public static int ServiceRegistryStateParameters() {
        return ServiceRegistryStateParameters;
    }
    private static final int ServiceRegistryStatePersistent = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SERVICE_REGISTRY_STATE_TYPE.ServiceRegistryStatePersistent = 1
     * }
     */
    public static int ServiceRegistryStatePersistent() {
        return ServiceRegistryStatePersistent;
    }
    private static final int MaxServiceRegistryStateType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SERVICE_REGISTRY_STATE_TYPE.MaxServiceRegistryStateType = 2
     * }
     */
    public static int MaxServiceRegistryStateType() {
        return MaxServiceRegistryStateType;
    }

    private static class GetServiceRegistryStateKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetServiceRegistryStateKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetServiceRegistryStateKey(SERVICE_STATUS_HANDLE ServiceStatusHandle, SERVICE_REGISTRY_STATE_TYPE StateType, DWORD AccessMask, HKEY *ServiceStateKey)
     * }
     */
    public static FunctionDescriptor GetServiceRegistryStateKey$descriptor() {
        return GetServiceRegistryStateKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetServiceRegistryStateKey(SERVICE_STATUS_HANDLE ServiceStatusHandle, SERVICE_REGISTRY_STATE_TYPE StateType, DWORD AccessMask, HKEY *ServiceStateKey)
     * }
     */
    public static MethodHandle GetServiceRegistryStateKey$handle() {
        return GetServiceRegistryStateKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetServiceRegistryStateKey(SERVICE_STATUS_HANDLE ServiceStatusHandle, SERVICE_REGISTRY_STATE_TYPE StateType, DWORD AccessMask, HKEY *ServiceStateKey)
     * }
     */
    public static MemorySegment GetServiceRegistryStateKey$address() {
        return GetServiceRegistryStateKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetServiceRegistryStateKey(SERVICE_STATUS_HANDLE ServiceStatusHandle, SERVICE_REGISTRY_STATE_TYPE StateType, DWORD AccessMask, HKEY *ServiceStateKey)
     * }
     */
    public static int GetServiceRegistryStateKey(MemorySegment ServiceStatusHandle, int StateType, int AccessMask, MemorySegment ServiceStateKey) {
        var mh$ = GetServiceRegistryStateKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceRegistryStateKey", ServiceStatusHandle, StateType, AccessMask, ServiceStateKey);
            }
            return (int)mh$.invokeExact(ServiceStatusHandle, StateType, AccessMask, ServiceStateKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ServiceDirectoryPersistentState = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SERVICE_DIRECTORY_TYPE.ServiceDirectoryPersistentState = 0
     * }
     */
    public static int ServiceDirectoryPersistentState() {
        return ServiceDirectoryPersistentState;
    }
    private static final int ServiceDirectoryTypeMax = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SERVICE_DIRECTORY_TYPE.ServiceDirectoryTypeMax = 1
     * }
     */
    public static int ServiceDirectoryTypeMax() {
        return ServiceDirectoryTypeMax;
    }

    private static class GetServiceDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetServiceDirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetServiceDirectory(SERVICE_STATUS_HANDLE hServiceStatus, SERVICE_DIRECTORY_TYPE eDirectoryType, PWCHAR lpPathBuffer, DWORD cchPathBufferLength, DWORD *lpcchRequiredBufferLength)
     * }
     */
    public static FunctionDescriptor GetServiceDirectory$descriptor() {
        return GetServiceDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetServiceDirectory(SERVICE_STATUS_HANDLE hServiceStatus, SERVICE_DIRECTORY_TYPE eDirectoryType, PWCHAR lpPathBuffer, DWORD cchPathBufferLength, DWORD *lpcchRequiredBufferLength)
     * }
     */
    public static MethodHandle GetServiceDirectory$handle() {
        return GetServiceDirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetServiceDirectory(SERVICE_STATUS_HANDLE hServiceStatus, SERVICE_DIRECTORY_TYPE eDirectoryType, PWCHAR lpPathBuffer, DWORD cchPathBufferLength, DWORD *lpcchRequiredBufferLength)
     * }
     */
    public static MemorySegment GetServiceDirectory$address() {
        return GetServiceDirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetServiceDirectory(SERVICE_STATUS_HANDLE hServiceStatus, SERVICE_DIRECTORY_TYPE eDirectoryType, PWCHAR lpPathBuffer, DWORD cchPathBufferLength, DWORD *lpcchRequiredBufferLength)
     * }
     */
    public static int GetServiceDirectory(MemorySegment hServiceStatus, int eDirectoryType, MemorySegment lpPathBuffer, int cchPathBufferLength, MemorySegment lpcchRequiredBufferLength) {
        var mh$ = GetServiceDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceDirectory", hServiceStatus, eDirectoryType, lpPathBuffer, cchPathBufferLength, lpcchRequiredBufferLength);
            }
            return (int)mh$.invokeExact(hServiceStatus, eDirectoryType, lpPathBuffer, cchPathBufferLength, lpcchRequiredBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _MODEMDEVCAPS {
     *     DWORD dwActualSize;
     *     DWORD dwRequiredSize;
     *     DWORD dwDevSpecificOffset;
     *     DWORD dwDevSpecificSize;
     *     DWORD dwModemProviderVersion;
     *     DWORD dwModemManufacturerOffset;
     *     DWORD dwModemManufacturerSize;
     *     DWORD dwModemModelOffset;
     *     DWORD dwModemModelSize;
     *     DWORD dwModemVersionOffset;
     *     DWORD dwModemVersionSize;
     *     DWORD dwDialOptions;
     *     DWORD dwCallSetupFailTimer;
     *     DWORD dwInactivityTimeout;
     *     DWORD dwSpeakerVolume;
     *     DWORD dwSpeakerMode;
     *     DWORD dwModemOptions;
     *     DWORD dwMaxDTERate;
     *     DWORD dwMaxDCERate;
     *     BYTE abVariablePortion[1];
     * } *PMODEMDEVCAPS
     * }
     */
    public static final AddressLayout PMODEMDEVCAPS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MODEMDEVCAPS {
     *     DWORD dwActualSize;
     *     DWORD dwRequiredSize;
     *     DWORD dwDevSpecificOffset;
     *     DWORD dwDevSpecificSize;
     *     DWORD dwModemProviderVersion;
     *     DWORD dwModemManufacturerOffset;
     *     DWORD dwModemManufacturerSize;
     *     DWORD dwModemModelOffset;
     *     DWORD dwModemModelSize;
     *     DWORD dwModemVersionOffset;
     *     DWORD dwModemVersionSize;
     *     DWORD dwDialOptions;
     *     DWORD dwCallSetupFailTimer;
     *     DWORD dwInactivityTimeout;
     *     DWORD dwSpeakerVolume;
     *     DWORD dwSpeakerMode;
     *     DWORD dwModemOptions;
     *     DWORD dwMaxDTERate;
     *     DWORD dwMaxDCERate;
     *     BYTE abVariablePortion[1];
     * } *LPMODEMDEVCAPS
     * }
     */
    public static final AddressLayout LPMODEMDEVCAPS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MODEMSETTINGS {
     *     DWORD dwActualSize;
     *     DWORD dwRequiredSize;
     *     DWORD dwDevSpecificOffset;
     *     DWORD dwDevSpecificSize;
     *     DWORD dwCallSetupFailTimer;
     *     DWORD dwInactivityTimeout;
     *     DWORD dwSpeakerVolume;
     *     DWORD dwSpeakerMode;
     *     DWORD dwPreferredModemOptions;
     *     DWORD dwNegotiatedModemOptions;
     *     DWORD dwNegotiatedDCERate;
     *     BYTE abVariablePortion[1];
     * } *PMODEMSETTINGS
     * }
     */
    public static final AddressLayout PMODEMSETTINGS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MODEMSETTINGS {
     *     DWORD dwActualSize;
     *     DWORD dwRequiredSize;
     *     DWORD dwDevSpecificOffset;
     *     DWORD dwDevSpecificSize;
     *     DWORD dwCallSetupFailTimer;
     *     DWORD dwInactivityTimeout;
     *     DWORD dwSpeakerVolume;
     *     DWORD dwSpeakerMode;
     *     DWORD dwPreferredModemOptions;
     *     DWORD dwNegotiatedModemOptions;
     *     DWORD dwNegotiatedDCERate;
     *     BYTE abVariablePortion[1];
     * } *LPMODEMSETTINGS
     * }
     */
    public static final AddressLayout LPMODEMSETTINGS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HIMC__ {
     *     int unused;
     * } *HIMC
     * }
     */
    public static final AddressLayout HIMC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HIMCC__ {
     *     int unused;
     * } *HIMCC
     * }
     */
    public static final AddressLayout HIMCC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HKL *LPHKL
     * }
     */
    public static final AddressLayout LPHKL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPOSITIONFORM {
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *PCOMPOSITIONFORM
     * }
     */
    public static final AddressLayout PCOMPOSITIONFORM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPOSITIONFORM {
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *NPCOMPOSITIONFORM
     * }
     */
    public static final AddressLayout NPCOMPOSITIONFORM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPOSITIONFORM {
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *LPCOMPOSITIONFORM
     * }
     */
    public static final AddressLayout LPCOMPOSITIONFORM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATEFORM {
     *     DWORD dwIndex;
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *PCANDIDATEFORM
     * }
     */
    public static final AddressLayout PCANDIDATEFORM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATEFORM {
     *     DWORD dwIndex;
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *NPCANDIDATEFORM
     * }
     */
    public static final AddressLayout NPCANDIDATEFORM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATEFORM {
     *     DWORD dwIndex;
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *LPCANDIDATEFORM
     * }
     */
    public static final AddressLayout LPCANDIDATEFORM = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATELIST {
     *     DWORD dwSize;
     *     DWORD dwStyle;
     *     DWORD dwCount;
     *     DWORD dwSelection;
     *     DWORD dwPageStart;
     *     DWORD dwPageSize;
     *     DWORD dwOffset[1];
     * } *PCANDIDATELIST
     * }
     */
    public static final AddressLayout PCANDIDATELIST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATELIST {
     *     DWORD dwSize;
     *     DWORD dwStyle;
     *     DWORD dwCount;
     *     DWORD dwSelection;
     *     DWORD dwPageStart;
     *     DWORD dwPageSize;
     *     DWORD dwOffset[1];
     * } *NPCANDIDATELIST
     * }
     */
    public static final AddressLayout NPCANDIDATELIST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATELIST {
     *     DWORD dwSize;
     *     DWORD dwStyle;
     *     DWORD dwCount;
     *     DWORD dwSelection;
     *     DWORD dwPageStart;
     *     DWORD dwPageSize;
     *     DWORD dwOffset[1];
     * } *LPCANDIDATELIST
     * }
     */
    public static final AddressLayout LPCANDIDATELIST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDA {
     *     LPSTR lpReading;
     *     LPSTR lpWord;
     * } *PREGISTERWORDA
     * }
     */
    public static final AddressLayout PREGISTERWORDA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDA {
     *     LPSTR lpReading;
     *     LPSTR lpWord;
     * } *NPREGISTERWORDA
     * }
     */
    public static final AddressLayout NPREGISTERWORDA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDA {
     *     LPSTR lpReading;
     *     LPSTR lpWord;
     * } *LPREGISTERWORDA
     * }
     */
    public static final AddressLayout LPREGISTERWORDA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDW {
     *     LPWSTR lpReading;
     *     LPWSTR lpWord;
     * } *PREGISTERWORDW
     * }
     */
    public static final AddressLayout PREGISTERWORDW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDW {
     *     LPWSTR lpReading;
     *     LPWSTR lpWord;
     * } *NPREGISTERWORDW
     * }
     */
    public static final AddressLayout NPREGISTERWORDW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDW {
     *     LPWSTR lpReading;
     *     LPWSTR lpWord;
     * } *LPREGISTERWORDW
     * }
     */
    public static final AddressLayout LPREGISTERWORDW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PREGISTERWORDA PREGISTERWORD
     * }
     */
    public static final AddressLayout PREGISTERWORD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPREGISTERWORDA NPREGISTERWORD
     * }
     */
    public static final AddressLayout NPREGISTERWORD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPREGISTERWORDA LPREGISTERWORD
     * }
     */
    public static final AddressLayout LPREGISTERWORD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECONVERTSTRING {
     *     DWORD dwSize;
     *     DWORD dwVersion;
     *     DWORD dwStrLen;
     *     DWORD dwStrOffset;
     *     DWORD dwCompStrLen;
     *     DWORD dwCompStrOffset;
     *     DWORD dwTargetStrLen;
     *     DWORD dwTargetStrOffset;
     * } *PRECONVERTSTRING
     * }
     */
    public static final AddressLayout PRECONVERTSTRING = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECONVERTSTRING {
     *     DWORD dwSize;
     *     DWORD dwVersion;
     *     DWORD dwStrLen;
     *     DWORD dwStrOffset;
     *     DWORD dwCompStrLen;
     *     DWORD dwCompStrOffset;
     *     DWORD dwTargetStrLen;
     *     DWORD dwTargetStrOffset;
     * } *NPRECONVERTSTRING
     * }
     */
    public static final AddressLayout NPRECONVERTSTRING = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECONVERTSTRING {
     *     DWORD dwSize;
     *     DWORD dwVersion;
     *     DWORD dwStrLen;
     *     DWORD dwStrOffset;
     *     DWORD dwCompStrLen;
     *     DWORD dwCompStrOffset;
     *     DWORD dwTargetStrLen;
     *     DWORD dwTargetStrOffset;
     * } *LPRECONVERTSTRING
     * }
     */
    public static final AddressLayout LPRECONVERTSTRING = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFA {
     *     DWORD dwStyle;
     *     CHAR szDescription[32];
     * } *PSTYLEBUFA
     * }
     */
    public static final AddressLayout PSTYLEBUFA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFA {
     *     DWORD dwStyle;
     *     CHAR szDescription[32];
     * } *NPSTYLEBUFA
     * }
     */
    public static final AddressLayout NPSTYLEBUFA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFA {
     *     DWORD dwStyle;
     *     CHAR szDescription[32];
     * } *LPSTYLEBUFA
     * }
     */
    public static final AddressLayout LPSTYLEBUFA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFW {
     *     DWORD dwStyle;
     *     WCHAR szDescription[32];
     * } *PSTYLEBUFW
     * }
     */
    public static final AddressLayout PSTYLEBUFW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFW {
     *     DWORD dwStyle;
     *     WCHAR szDescription[32];
     * } *NPSTYLEBUFW
     * }
     */
    public static final AddressLayout NPSTYLEBUFW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFW {
     *     DWORD dwStyle;
     *     WCHAR szDescription[32];
     * } *LPSTYLEBUFW
     * }
     */
    public static final AddressLayout LPSTYLEBUFW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PSTYLEBUFA PSTYLEBUF
     * }
     */
    public static final AddressLayout PSTYLEBUF = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPSTYLEBUFA NPSTYLEBUF
     * }
     */
    public static final AddressLayout NPSTYLEBUF = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTYLEBUFA LPSTYLEBUF
     * }
     */
    public static final AddressLayout LPSTYLEBUF = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOA {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     CHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *PIMEMENUITEMINFOA
     * }
     */
    public static final AddressLayout PIMEMENUITEMINFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOA {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     CHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *NPIMEMENUITEMINFOA
     * }
     */
    public static final AddressLayout NPIMEMENUITEMINFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOA {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     CHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *LPIMEMENUITEMINFOA
     * }
     */
    public static final AddressLayout LPIMEMENUITEMINFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOW {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     WCHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *PIMEMENUITEMINFOW
     * }
     */
    public static final AddressLayout PIMEMENUITEMINFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOW {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     WCHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *NPIMEMENUITEMINFOW
     * }
     */
    public static final AddressLayout NPIMEMENUITEMINFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOW {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     WCHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *LPIMEMENUITEMINFOW
     * }
     */
    public static final AddressLayout LPIMEMENUITEMINFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO
     * }
     */
    public static final AddressLayout PIMEMENUITEMINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO
     * }
     */
    public static final AddressLayout NPIMEMENUITEMINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO
     * }
     */
    public static final AddressLayout LPIMEMENUITEMINFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMECHARPOSITION {
     *     DWORD dwSize;
     *     DWORD dwCharPos;
     *     POINT pt;
     *     UINT cLineHeight;
     *     RECT rcDocument;
     * } *PIMECHARPOSITION
     * }
     */
    public static final AddressLayout PIMECHARPOSITION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMECHARPOSITION {
     *     DWORD dwSize;
     *     DWORD dwCharPos;
     *     POINT pt;
     *     UINT cLineHeight;
     *     RECT rcDocument;
     * } *NPIMECHARPOSITION
     * }
     */
    public static final AddressLayout NPIMECHARPOSITION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMECHARPOSITION {
     *     DWORD dwSize;
     *     DWORD dwCharPos;
     *     POINT pt;
     *     UINT cLineHeight;
     *     RECT rcDocument;
     * } *LPIMECHARPOSITION
     * }
     */
    public static final AddressLayout LPIMECHARPOSITION = wgl_h.C_POINTER;

    private static class ImmInstallIMEA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmInstallIMEA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText)
     * }
     */
    public static FunctionDescriptor ImmInstallIMEA$descriptor() {
        return ImmInstallIMEA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText)
     * }
     */
    public static MethodHandle ImmInstallIMEA$handle() {
        return ImmInstallIMEA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText)
     * }
     */
    public static MemorySegment ImmInstallIMEA$address() {
        return ImmInstallIMEA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText)
     * }
     */
    public static MemorySegment ImmInstallIMEA(MemorySegment lpszIMEFileName, MemorySegment lpszLayoutText) {
        var mh$ = ImmInstallIMEA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmInstallIMEA", lpszIMEFileName, lpszLayoutText);
            }
            return (MemorySegment)mh$.invokeExact(lpszIMEFileName, lpszLayoutText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmInstallIMEW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmInstallIMEW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
     * }
     */
    public static FunctionDescriptor ImmInstallIMEW$descriptor() {
        return ImmInstallIMEW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
     * }
     */
    public static MethodHandle ImmInstallIMEW$handle() {
        return ImmInstallIMEW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
     * }
     */
    public static MemorySegment ImmInstallIMEW$address() {
        return ImmInstallIMEW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
     * }
     */
    public static MemorySegment ImmInstallIMEW(MemorySegment lpszIMEFileName, MemorySegment lpszLayoutText) {
        var mh$ = ImmInstallIMEW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmInstallIMEW", lpszIMEFileName, lpszLayoutText);
            }
            return (MemorySegment)mh$.invokeExact(lpszIMEFileName, lpszLayoutText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetDefaultIMEWnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetDefaultIMEWnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND ImmGetDefaultIMEWnd(HWND)
     * }
     */
    public static FunctionDescriptor ImmGetDefaultIMEWnd$descriptor() {
        return ImmGetDefaultIMEWnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND ImmGetDefaultIMEWnd(HWND)
     * }
     */
    public static MethodHandle ImmGetDefaultIMEWnd$handle() {
        return ImmGetDefaultIMEWnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND ImmGetDefaultIMEWnd(HWND)
     * }
     */
    public static MemorySegment ImmGetDefaultIMEWnd$address() {
        return ImmGetDefaultIMEWnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND ImmGetDefaultIMEWnd(HWND)
     * }
     */
    public static MemorySegment ImmGetDefaultIMEWnd(MemorySegment x0) {
        var mh$ = ImmGetDefaultIMEWnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetDefaultIMEWnd", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetDescriptionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetDescriptionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionA(HKL, LPSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetDescriptionA$descriptor() {
        return ImmGetDescriptionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionA(HKL, LPSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static MethodHandle ImmGetDescriptionA$handle() {
        return ImmGetDescriptionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionA(HKL, LPSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static MemorySegment ImmGetDescriptionA$address() {
        return ImmGetDescriptionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetDescriptionA(HKL, LPSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static int ImmGetDescriptionA(MemorySegment x0, MemorySegment lpszDescription, int uBufLen) {
        var mh$ = ImmGetDescriptionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetDescriptionA", x0, lpszDescription, uBufLen);
            }
            return (int)mh$.invokeExact(x0, lpszDescription, uBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetDescriptionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetDescriptionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionW(HKL, LPWSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetDescriptionW$descriptor() {
        return ImmGetDescriptionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionW(HKL, LPWSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static MethodHandle ImmGetDescriptionW$handle() {
        return ImmGetDescriptionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionW(HKL, LPWSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static MemorySegment ImmGetDescriptionW$address() {
        return ImmGetDescriptionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetDescriptionW(HKL, LPWSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static int ImmGetDescriptionW(MemorySegment x0, MemorySegment lpszDescription, int uBufLen) {
        var mh$ = ImmGetDescriptionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetDescriptionW", x0, lpszDescription, uBufLen);
            }
            return (int)mh$.invokeExact(x0, lpszDescription, uBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetIMEFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetIMEFileNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameA(HKL, LPSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetIMEFileNameA$descriptor() {
        return ImmGetIMEFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameA(HKL, LPSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static MethodHandle ImmGetIMEFileNameA$handle() {
        return ImmGetIMEFileNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameA(HKL, LPSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static MemorySegment ImmGetIMEFileNameA$address() {
        return ImmGetIMEFileNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameA(HKL, LPSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static int ImmGetIMEFileNameA(MemorySegment x0, MemorySegment lpszFileName, int uBufLen) {
        var mh$ = ImmGetIMEFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetIMEFileNameA", x0, lpszFileName, uBufLen);
            }
            return (int)mh$.invokeExact(x0, lpszFileName, uBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetIMEFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetIMEFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameW(HKL, LPWSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetIMEFileNameW$descriptor() {
        return ImmGetIMEFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameW(HKL, LPWSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static MethodHandle ImmGetIMEFileNameW$handle() {
        return ImmGetIMEFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameW(HKL, LPWSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static MemorySegment ImmGetIMEFileNameW$address() {
        return ImmGetIMEFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameW(HKL, LPWSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static int ImmGetIMEFileNameW(MemorySegment x0, MemorySegment lpszFileName, int uBufLen) {
        var mh$ = ImmGetIMEFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetIMEFileNameW", x0, lpszFileName, uBufLen);
            }
            return (int)mh$.invokeExact(x0, lpszFileName, uBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetProperty(HKL, DWORD)
     * }
     */
    public static FunctionDescriptor ImmGetProperty$descriptor() {
        return ImmGetProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetProperty(HKL, DWORD)
     * }
     */
    public static MethodHandle ImmGetProperty$handle() {
        return ImmGetProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetProperty(HKL, DWORD)
     * }
     */
    public static MemorySegment ImmGetProperty$address() {
        return ImmGetProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetProperty(HKL, DWORD)
     * }
     */
    public static int ImmGetProperty(MemorySegment x0, int x1) {
        var mh$ = ImmGetProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetProperty", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmIsIME {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmIsIME");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmIsIME(HKL)
     * }
     */
    public static FunctionDescriptor ImmIsIME$descriptor() {
        return ImmIsIME.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmIsIME(HKL)
     * }
     */
    public static MethodHandle ImmIsIME$handle() {
        return ImmIsIME.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmIsIME(HKL)
     * }
     */
    public static MemorySegment ImmIsIME$address() {
        return ImmIsIME.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmIsIME(HKL)
     * }
     */
    public static int ImmIsIME(MemorySegment x0) {
        var mh$ = ImmIsIME.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmIsIME", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSimulateHotKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmSimulateHotKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSimulateHotKey(HWND, DWORD)
     * }
     */
    public static FunctionDescriptor ImmSimulateHotKey$descriptor() {
        return ImmSimulateHotKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSimulateHotKey(HWND, DWORD)
     * }
     */
    public static MethodHandle ImmSimulateHotKey$handle() {
        return ImmSimulateHotKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSimulateHotKey(HWND, DWORD)
     * }
     */
    public static MemorySegment ImmSimulateHotKey$address() {
        return ImmSimulateHotKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSimulateHotKey(HWND, DWORD)
     * }
     */
    public static int ImmSimulateHotKey(MemorySegment x0, int x1) {
        var mh$ = ImmSimulateHotKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSimulateHotKey", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmCreateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HIMC ImmCreateContext()
     * }
     */
    public static FunctionDescriptor ImmCreateContext$descriptor() {
        return ImmCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HIMC ImmCreateContext()
     * }
     */
    public static MethodHandle ImmCreateContext$handle() {
        return ImmCreateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HIMC ImmCreateContext()
     * }
     */
    public static MemorySegment ImmCreateContext$address() {
        return ImmCreateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HIMC ImmCreateContext()
     * }
     */
    public static MemorySegment ImmCreateContext() {
        var mh$ = ImmCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmCreateContext");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmDestroyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmDestroyContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmDestroyContext(HIMC)
     * }
     */
    public static FunctionDescriptor ImmDestroyContext$descriptor() {
        return ImmDestroyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmDestroyContext(HIMC)
     * }
     */
    public static MethodHandle ImmDestroyContext$handle() {
        return ImmDestroyContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmDestroyContext(HIMC)
     * }
     */
    public static MemorySegment ImmDestroyContext$address() {
        return ImmDestroyContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmDestroyContext(HIMC)
     * }
     */
    public static int ImmDestroyContext(MemorySegment x0) {
        var mh$ = ImmDestroyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmDestroyContext", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HIMC ImmGetContext(HWND)
     * }
     */
    public static FunctionDescriptor ImmGetContext$descriptor() {
        return ImmGetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HIMC ImmGetContext(HWND)
     * }
     */
    public static MethodHandle ImmGetContext$handle() {
        return ImmGetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HIMC ImmGetContext(HWND)
     * }
     */
    public static MemorySegment ImmGetContext$address() {
        return ImmGetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HIMC ImmGetContext(HWND)
     * }
     */
    public static MemorySegment ImmGetContext(MemorySegment x0) {
        var mh$ = ImmGetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetContext", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmReleaseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmReleaseContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmReleaseContext(HWND, HIMC)
     * }
     */
    public static FunctionDescriptor ImmReleaseContext$descriptor() {
        return ImmReleaseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmReleaseContext(HWND, HIMC)
     * }
     */
    public static MethodHandle ImmReleaseContext$handle() {
        return ImmReleaseContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmReleaseContext(HWND, HIMC)
     * }
     */
    public static MemorySegment ImmReleaseContext$address() {
        return ImmReleaseContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmReleaseContext(HWND, HIMC)
     * }
     */
    public static int ImmReleaseContext(MemorySegment x0, MemorySegment x1) {
        var mh$ = ImmReleaseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmReleaseContext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmAssociateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmAssociateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HIMC ImmAssociateContext(HWND, HIMC)
     * }
     */
    public static FunctionDescriptor ImmAssociateContext$descriptor() {
        return ImmAssociateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HIMC ImmAssociateContext(HWND, HIMC)
     * }
     */
    public static MethodHandle ImmAssociateContext$handle() {
        return ImmAssociateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HIMC ImmAssociateContext(HWND, HIMC)
     * }
     */
    public static MemorySegment ImmAssociateContext$address() {
        return ImmAssociateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HIMC ImmAssociateContext(HWND, HIMC)
     * }
     */
    public static MemorySegment ImmAssociateContext(MemorySegment x0, MemorySegment x1) {
        var mh$ = ImmAssociateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmAssociateContext", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmAssociateContextEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmAssociateContextEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmAssociateContextEx(HWND, HIMC, DWORD)
     * }
     */
    public static FunctionDescriptor ImmAssociateContextEx$descriptor() {
        return ImmAssociateContextEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmAssociateContextEx(HWND, HIMC, DWORD)
     * }
     */
    public static MethodHandle ImmAssociateContextEx$handle() {
        return ImmAssociateContextEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmAssociateContextEx(HWND, HIMC, DWORD)
     * }
     */
    public static MemorySegment ImmAssociateContextEx$address() {
        return ImmAssociateContextEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmAssociateContextEx(HWND, HIMC, DWORD)
     * }
     */
    public static int ImmAssociateContextEx(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ImmAssociateContextEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmAssociateContextEx", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCompositionStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetCompositionStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringA(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetCompositionStringA$descriptor() {
        return ImmGetCompositionStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringA(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetCompositionStringA$handle() {
        return ImmGetCompositionStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringA(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetCompositionStringA$address() {
        return ImmGetCompositionStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringA(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static int ImmGetCompositionStringA(MemorySegment x0, int x1, MemorySegment lpBuf, int dwBufLen) {
        var mh$ = ImmGetCompositionStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCompositionStringA", x0, x1, lpBuf, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, x1, lpBuf, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCompositionStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetCompositionStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringW(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetCompositionStringW$descriptor() {
        return ImmGetCompositionStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringW(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetCompositionStringW$handle() {
        return ImmGetCompositionStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringW(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetCompositionStringW$address() {
        return ImmGetCompositionStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringW(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static int ImmGetCompositionStringW(MemorySegment x0, int x1, MemorySegment lpBuf, int dwBufLen) {
        var mh$ = ImmGetCompositionStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCompositionStringW", x0, x1, lpBuf, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, x1, lpBuf, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCompositionStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmSetCompositionStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static FunctionDescriptor ImmSetCompositionStringA$descriptor() {
        return ImmSetCompositionStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static MethodHandle ImmSetCompositionStringA$handle() {
        return ImmSetCompositionStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static MemorySegment ImmSetCompositionStringA$address() {
        return ImmSetCompositionStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static int ImmSetCompositionStringA(MemorySegment x0, int dwIndex, MemorySegment lpComp, int dwCompLen, MemorySegment lpRead, int dwReadLen) {
        var mh$ = ImmSetCompositionStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCompositionStringA", x0, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
            }
            return (int)mh$.invokeExact(x0, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCompositionStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmSetCompositionStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static FunctionDescriptor ImmSetCompositionStringW$descriptor() {
        return ImmSetCompositionStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static MethodHandle ImmSetCompositionStringW$handle() {
        return ImmSetCompositionStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static MemorySegment ImmSetCompositionStringW$address() {
        return ImmSetCompositionStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static int ImmSetCompositionStringW(MemorySegment x0, int dwIndex, MemorySegment lpComp, int dwCompLen, MemorySegment lpRead, int dwReadLen) {
        var mh$ = ImmSetCompositionStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCompositionStringW", x0, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
            }
            return (int)mh$.invokeExact(x0, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCandidateListCountA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetCandidateListCountA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static FunctionDescriptor ImmGetCandidateListCountA$descriptor() {
        return ImmGetCandidateListCountA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static MethodHandle ImmGetCandidateListCountA$handle() {
        return ImmGetCandidateListCountA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static MemorySegment ImmGetCandidateListCountA$address() {
        return ImmGetCandidateListCountA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static int ImmGetCandidateListCountA(MemorySegment x0, MemorySegment lpdwListCount) {
        var mh$ = ImmGetCandidateListCountA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCandidateListCountA", x0, lpdwListCount);
            }
            return (int)mh$.invokeExact(x0, lpdwListCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCandidateListCountW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetCandidateListCountW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static FunctionDescriptor ImmGetCandidateListCountW$descriptor() {
        return ImmGetCandidateListCountW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static MethodHandle ImmGetCandidateListCountW$handle() {
        return ImmGetCandidateListCountW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static MemorySegment ImmGetCandidateListCountW$address() {
        return ImmGetCandidateListCountW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static int ImmGetCandidateListCountW(MemorySegment x0, MemorySegment lpdwListCount) {
        var mh$ = ImmGetCandidateListCountW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCandidateListCountW", x0, lpdwListCount);
            }
            return (int)mh$.invokeExact(x0, lpdwListCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCandidateListA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetCandidateListA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetCandidateListA$descriptor() {
        return ImmGetCandidateListA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetCandidateListA$handle() {
        return ImmGetCandidateListA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetCandidateListA$address() {
        return ImmGetCandidateListA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static int ImmGetCandidateListA(MemorySegment x0, int deIndex, MemorySegment lpCandList, int dwBufLen) {
        var mh$ = ImmGetCandidateListA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCandidateListA", x0, deIndex, lpCandList, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, deIndex, lpCandList, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCandidateListW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetCandidateListW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetCandidateListW$descriptor() {
        return ImmGetCandidateListW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetCandidateListW$handle() {
        return ImmGetCandidateListW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetCandidateListW$address() {
        return ImmGetCandidateListW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static int ImmGetCandidateListW(MemorySegment x0, int deIndex, MemorySegment lpCandList, int dwBufLen) {
        var mh$ = ImmGetCandidateListW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCandidateListW", x0, deIndex, lpCandList, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, deIndex, lpCandList, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetGuideLineA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetGuideLineA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetGuideLineA$descriptor() {
        return ImmGetGuideLineA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetGuideLineA$handle() {
        return ImmGetGuideLineA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetGuideLineA$address() {
        return ImmGetGuideLineA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static int ImmGetGuideLineA(MemorySegment x0, int dwIndex, MemorySegment lpBuf, int dwBufLen) {
        var mh$ = ImmGetGuideLineA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetGuideLineA", x0, dwIndex, lpBuf, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, dwIndex, lpBuf, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetGuideLineW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetGuideLineW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetGuideLineW$descriptor() {
        return ImmGetGuideLineW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetGuideLineW$handle() {
        return ImmGetGuideLineW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetGuideLineW$address() {
        return ImmGetGuideLineW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static int ImmGetGuideLineW(MemorySegment x0, int dwIndex, MemorySegment lpBuf, int dwBufLen) {
        var mh$ = ImmGetGuideLineW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetGuideLineW", x0, dwIndex, lpBuf, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, dwIndex, lpBuf, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetConversionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetConversionStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetConversionStatus(HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
     * }
     */
    public static FunctionDescriptor ImmGetConversionStatus$descriptor() {
        return ImmGetConversionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetConversionStatus(HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
     * }
     */
    public static MethodHandle ImmGetConversionStatus$handle() {
        return ImmGetConversionStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetConversionStatus(HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
     * }
     */
    public static MemorySegment ImmGetConversionStatus$address() {
        return ImmGetConversionStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetConversionStatus(HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
     * }
     */
    public static int ImmGetConversionStatus(MemorySegment x0, MemorySegment lpfdwConversion, MemorySegment lpfdwSentence) {
        var mh$ = ImmGetConversionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetConversionStatus", x0, lpfdwConversion, lpfdwSentence);
            }
            return (int)mh$.invokeExact(x0, lpfdwConversion, lpfdwSentence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetConversionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmSetConversionStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetConversionStatus(HIMC, DWORD, DWORD)
     * }
     */
    public static FunctionDescriptor ImmSetConversionStatus$descriptor() {
        return ImmSetConversionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetConversionStatus(HIMC, DWORD, DWORD)
     * }
     */
    public static MethodHandle ImmSetConversionStatus$handle() {
        return ImmSetConversionStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetConversionStatus(HIMC, DWORD, DWORD)
     * }
     */
    public static MemorySegment ImmSetConversionStatus$address() {
        return ImmSetConversionStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetConversionStatus(HIMC, DWORD, DWORD)
     * }
     */
    public static int ImmSetConversionStatus(MemorySegment x0, int x1, int x2) {
        var mh$ = ImmSetConversionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetConversionStatus", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetOpenStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetOpenStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetOpenStatus(HIMC)
     * }
     */
    public static FunctionDescriptor ImmGetOpenStatus$descriptor() {
        return ImmGetOpenStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetOpenStatus(HIMC)
     * }
     */
    public static MethodHandle ImmGetOpenStatus$handle() {
        return ImmGetOpenStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetOpenStatus(HIMC)
     * }
     */
    public static MemorySegment ImmGetOpenStatus$address() {
        return ImmGetOpenStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetOpenStatus(HIMC)
     * }
     */
    public static int ImmGetOpenStatus(MemorySegment x0) {
        var mh$ = ImmGetOpenStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetOpenStatus", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetOpenStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmSetOpenStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetOpenStatus(HIMC, BOOL)
     * }
     */
    public static FunctionDescriptor ImmSetOpenStatus$descriptor() {
        return ImmSetOpenStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetOpenStatus(HIMC, BOOL)
     * }
     */
    public static MethodHandle ImmSetOpenStatus$handle() {
        return ImmSetOpenStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetOpenStatus(HIMC, BOOL)
     * }
     */
    public static MemorySegment ImmSetOpenStatus$address() {
        return ImmSetOpenStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetOpenStatus(HIMC, BOOL)
     * }
     */
    public static int ImmSetOpenStatus(MemorySegment x0, int x1) {
        var mh$ = ImmSetOpenStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetOpenStatus", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCompositionFontA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetCompositionFontA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static FunctionDescriptor ImmGetCompositionFontA$descriptor() {
        return ImmGetCompositionFontA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static MethodHandle ImmGetCompositionFontA$handle() {
        return ImmGetCompositionFontA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static MemorySegment ImmGetCompositionFontA$address() {
        return ImmGetCompositionFontA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static int ImmGetCompositionFontA(MemorySegment x0, MemorySegment lplf) {
        var mh$ = ImmGetCompositionFontA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCompositionFontA", x0, lplf);
            }
            return (int)mh$.invokeExact(x0, lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCompositionFontW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetCompositionFontW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static FunctionDescriptor ImmGetCompositionFontW$descriptor() {
        return ImmGetCompositionFontW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static MethodHandle ImmGetCompositionFontW$handle() {
        return ImmGetCompositionFontW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static MemorySegment ImmGetCompositionFontW$address() {
        return ImmGetCompositionFontW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static int ImmGetCompositionFontW(MemorySegment x0, MemorySegment lplf) {
        var mh$ = ImmGetCompositionFontW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCompositionFontW", x0, lplf);
            }
            return (int)mh$.invokeExact(x0, lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCompositionFontA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmSetCompositionFontA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static FunctionDescriptor ImmSetCompositionFontA$descriptor() {
        return ImmSetCompositionFontA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static MethodHandle ImmSetCompositionFontA$handle() {
        return ImmSetCompositionFontA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static MemorySegment ImmSetCompositionFontA$address() {
        return ImmSetCompositionFontA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static int ImmSetCompositionFontA(MemorySegment x0, MemorySegment lplf) {
        var mh$ = ImmSetCompositionFontA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCompositionFontA", x0, lplf);
            }
            return (int)mh$.invokeExact(x0, lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCompositionFontW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmSetCompositionFontW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static FunctionDescriptor ImmSetCompositionFontW$descriptor() {
        return ImmSetCompositionFontW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static MethodHandle ImmSetCompositionFontW$handle() {
        return ImmSetCompositionFontW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static MemorySegment ImmSetCompositionFontW$address() {
        return ImmSetCompositionFontW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static int ImmSetCompositionFontW(MemorySegment x0, MemorySegment lplf) {
        var mh$ = ImmSetCompositionFontW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCompositionFontW", x0, lplf);
            }
            return (int)mh$.invokeExact(x0, lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmConfigureIMEA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmConfigureIMEA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmConfigureIMEA$descriptor() {
        return ImmConfigureIMEA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static MethodHandle ImmConfigureIMEA$handle() {
        return ImmConfigureIMEA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static MemorySegment ImmConfigureIMEA$address() {
        return ImmConfigureIMEA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static int ImmConfigureIMEA(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = ImmConfigureIMEA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmConfigureIMEA", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmConfigureIMEW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmConfigureIMEW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmConfigureIMEW$descriptor() {
        return ImmConfigureIMEW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static MethodHandle ImmConfigureIMEW$handle() {
        return ImmConfigureIMEW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static MemorySegment ImmConfigureIMEW$address() {
        return ImmConfigureIMEW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static int ImmConfigureIMEW(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = ImmConfigureIMEW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmConfigureIMEW", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmEscapeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmEscapeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeA(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmEscapeA$descriptor() {
        return ImmEscapeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeA(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static MethodHandle ImmEscapeA$handle() {
        return ImmEscapeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeA(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static MemorySegment ImmEscapeA$address() {
        return ImmEscapeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT ImmEscapeA(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static long ImmEscapeA(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = ImmEscapeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmEscapeA", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmEscapeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmEscapeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeW(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmEscapeW$descriptor() {
        return ImmEscapeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeW(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static MethodHandle ImmEscapeW$handle() {
        return ImmEscapeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeW(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static MemorySegment ImmEscapeW$address() {
        return ImmEscapeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT ImmEscapeW(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static long ImmEscapeW(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = ImmEscapeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmEscapeW", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetConversionListA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetConversionListA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListA(HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static FunctionDescriptor ImmGetConversionListA$descriptor() {
        return ImmGetConversionListA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListA(HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static MethodHandle ImmGetConversionListA$handle() {
        return ImmGetConversionListA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListA(HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static MemorySegment ImmGetConversionListA$address() {
        return ImmGetConversionListA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetConversionListA(HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static int ImmGetConversionListA(MemorySegment x0, MemorySegment x1, MemorySegment lpSrc, MemorySegment lpDst, int dwBufLen, int uFlag) {
        var mh$ = ImmGetConversionListA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetConversionListA", x0, x1, lpSrc, lpDst, dwBufLen, uFlag);
            }
            return (int)mh$.invokeExact(x0, x1, lpSrc, lpDst, dwBufLen, uFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetConversionListW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetConversionListW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListW(HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static FunctionDescriptor ImmGetConversionListW$descriptor() {
        return ImmGetConversionListW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListW(HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static MethodHandle ImmGetConversionListW$handle() {
        return ImmGetConversionListW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListW(HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static MemorySegment ImmGetConversionListW$address() {
        return ImmGetConversionListW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetConversionListW(HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static int ImmGetConversionListW(MemorySegment x0, MemorySegment x1, MemorySegment lpSrc, MemorySegment lpDst, int dwBufLen, int uFlag) {
        var mh$ = ImmGetConversionListW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetConversionListW", x0, x1, lpSrc, lpDst, dwBufLen, uFlag);
            }
            return (int)mh$.invokeExact(x0, x1, lpSrc, lpDst, dwBufLen, uFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmNotifyIME {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmNotifyIME");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
     * }
     */
    public static FunctionDescriptor ImmNotifyIME$descriptor() {
        return ImmNotifyIME.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
     * }
     */
    public static MethodHandle ImmNotifyIME$handle() {
        return ImmNotifyIME.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
     * }
     */
    public static MemorySegment ImmNotifyIME$address() {
        return ImmNotifyIME.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
     * }
     */
    public static int ImmNotifyIME(MemorySegment x0, int dwAction, int dwIndex, int dwValue) {
        var mh$ = ImmNotifyIME.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmNotifyIME", x0, dwAction, dwIndex, dwValue);
            }
            return (int)mh$.invokeExact(x0, dwAction, dwIndex, dwValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetStatusWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetStatusWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static FunctionDescriptor ImmGetStatusWindowPos$descriptor() {
        return ImmGetStatusWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static MethodHandle ImmGetStatusWindowPos$handle() {
        return ImmGetStatusWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static MemorySegment ImmGetStatusWindowPos$address() {
        return ImmGetStatusWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static int ImmGetStatusWindowPos(MemorySegment x0, MemorySegment lpptPos) {
        var mh$ = ImmGetStatusWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetStatusWindowPos", x0, lpptPos);
            }
            return (int)mh$.invokeExact(x0, lpptPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetStatusWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmSetStatusWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static FunctionDescriptor ImmSetStatusWindowPos$descriptor() {
        return ImmSetStatusWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static MethodHandle ImmSetStatusWindowPos$handle() {
        return ImmSetStatusWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static MemorySegment ImmSetStatusWindowPos$address() {
        return ImmSetStatusWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static int ImmSetStatusWindowPos(MemorySegment x0, MemorySegment lpptPos) {
        var mh$ = ImmSetStatusWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetStatusWindowPos", x0, lpptPos);
            }
            return (int)mh$.invokeExact(x0, lpptPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCompositionWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetCompositionWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static FunctionDescriptor ImmGetCompositionWindow$descriptor() {
        return ImmGetCompositionWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static MethodHandle ImmGetCompositionWindow$handle() {
        return ImmGetCompositionWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static MemorySegment ImmGetCompositionWindow$address() {
        return ImmGetCompositionWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static int ImmGetCompositionWindow(MemorySegment x0, MemorySegment lpCompForm) {
        var mh$ = ImmGetCompositionWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCompositionWindow", x0, lpCompForm);
            }
            return (int)mh$.invokeExact(x0, lpCompForm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCompositionWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmSetCompositionWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static FunctionDescriptor ImmSetCompositionWindow$descriptor() {
        return ImmSetCompositionWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static MethodHandle ImmSetCompositionWindow$handle() {
        return ImmSetCompositionWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static MemorySegment ImmSetCompositionWindow$address() {
        return ImmSetCompositionWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static int ImmSetCompositionWindow(MemorySegment x0, MemorySegment lpCompForm) {
        var mh$ = ImmSetCompositionWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCompositionWindow", x0, lpCompForm);
            }
            return (int)mh$.invokeExact(x0, lpCompForm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCandidateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetCandidateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static FunctionDescriptor ImmGetCandidateWindow$descriptor() {
        return ImmGetCandidateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static MethodHandle ImmGetCandidateWindow$handle() {
        return ImmGetCandidateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static MemorySegment ImmGetCandidateWindow$address() {
        return ImmGetCandidateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static int ImmGetCandidateWindow(MemorySegment x0, int x1, MemorySegment lpCandidate) {
        var mh$ = ImmGetCandidateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCandidateWindow", x0, x1, lpCandidate);
            }
            return (int)mh$.invokeExact(x0, x1, lpCandidate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCandidateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmSetCandidateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static FunctionDescriptor ImmSetCandidateWindow$descriptor() {
        return ImmSetCandidateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static MethodHandle ImmSetCandidateWindow$handle() {
        return ImmSetCandidateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static MemorySegment ImmSetCandidateWindow$address() {
        return ImmSetCandidateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static int ImmSetCandidateWindow(MemorySegment x0, MemorySegment lpCandidate) {
        var mh$ = ImmSetCandidateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCandidateWindow", x0, lpCandidate);
            }
            return (int)mh$.invokeExact(x0, lpCandidate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmIsUIMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmIsUIMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static FunctionDescriptor ImmIsUIMessageA$descriptor() {
        return ImmIsUIMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static MethodHandle ImmIsUIMessageA$handle() {
        return ImmIsUIMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static MemorySegment ImmIsUIMessageA$address() {
        return ImmIsUIMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static int ImmIsUIMessageA(MemorySegment x0, int x1, long x2, long x3) {
        var mh$ = ImmIsUIMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmIsUIMessageA", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmIsUIMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmIsUIMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static FunctionDescriptor ImmIsUIMessageW$descriptor() {
        return ImmIsUIMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static MethodHandle ImmIsUIMessageW$handle() {
        return ImmIsUIMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static MemorySegment ImmIsUIMessageW$address() {
        return ImmIsUIMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static int ImmIsUIMessageW(MemorySegment x0, int x1, long x2, long x3) {
        var mh$ = ImmIsUIMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmIsUIMessageW", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetVirtualKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetVirtualKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetVirtualKey(HWND)
     * }
     */
    public static FunctionDescriptor ImmGetVirtualKey$descriptor() {
        return ImmGetVirtualKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetVirtualKey(HWND)
     * }
     */
    public static MethodHandle ImmGetVirtualKey$handle() {
        return ImmGetVirtualKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetVirtualKey(HWND)
     * }
     */
    public static MemorySegment ImmGetVirtualKey$address() {
        return ImmGetVirtualKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetVirtualKey(HWND)
     * }
     */
    public static int ImmGetVirtualKey(MemorySegment x0) {
        var mh$ = ImmGetVirtualKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetVirtualKey", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmRegisterWordA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmRegisterWordA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister)
     * }
     */
    public static FunctionDescriptor ImmRegisterWordA$descriptor() {
        return ImmRegisterWordA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister)
     * }
     */
    public static MethodHandle ImmRegisterWordA$handle() {
        return ImmRegisterWordA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister)
     * }
     */
    public static MemorySegment ImmRegisterWordA$address() {
        return ImmRegisterWordA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister)
     * }
     */
    public static int ImmRegisterWordA(MemorySegment x0, MemorySegment lpszReading, int x2, MemorySegment lpszRegister) {
        var mh$ = ImmRegisterWordA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmRegisterWordA", x0, lpszReading, x2, lpszRegister);
            }
            return (int)mh$.invokeExact(x0, lpszReading, x2, lpszRegister);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmRegisterWordW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmRegisterWordW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
     * }
     */
    public static FunctionDescriptor ImmRegisterWordW$descriptor() {
        return ImmRegisterWordW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
     * }
     */
    public static MethodHandle ImmRegisterWordW$handle() {
        return ImmRegisterWordW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
     * }
     */
    public static MemorySegment ImmRegisterWordW$address() {
        return ImmRegisterWordW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
     * }
     */
    public static int ImmRegisterWordW(MemorySegment x0, MemorySegment lpszReading, int x2, MemorySegment lpszRegister) {
        var mh$ = ImmRegisterWordW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmRegisterWordW", x0, lpszReading, x2, lpszRegister);
            }
            return (int)mh$.invokeExact(x0, lpszReading, x2, lpszRegister);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmUnregisterWordA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmUnregisterWordA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister)
     * }
     */
    public static FunctionDescriptor ImmUnregisterWordA$descriptor() {
        return ImmUnregisterWordA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister)
     * }
     */
    public static MethodHandle ImmUnregisterWordA$handle() {
        return ImmUnregisterWordA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister)
     * }
     */
    public static MemorySegment ImmUnregisterWordA$address() {
        return ImmUnregisterWordA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister)
     * }
     */
    public static int ImmUnregisterWordA(MemorySegment x0, MemorySegment lpszReading, int x2, MemorySegment lpszUnregister) {
        var mh$ = ImmUnregisterWordA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmUnregisterWordA", x0, lpszReading, x2, lpszUnregister);
            }
            return (int)mh$.invokeExact(x0, lpszReading, x2, lpszUnregister);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmUnregisterWordW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmUnregisterWordW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
     * }
     */
    public static FunctionDescriptor ImmUnregisterWordW$descriptor() {
        return ImmUnregisterWordW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
     * }
     */
    public static MethodHandle ImmUnregisterWordW$handle() {
        return ImmUnregisterWordW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
     * }
     */
    public static MemorySegment ImmUnregisterWordW$address() {
        return ImmUnregisterWordW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
     * }
     */
    public static int ImmUnregisterWordW(MemorySegment x0, MemorySegment lpszReading, int x2, MemorySegment lpszUnregister) {
        var mh$ = ImmUnregisterWordW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmUnregisterWordW", x0, lpszReading, x2, lpszUnregister);
            }
            return (int)mh$.invokeExact(x0, lpszReading, x2, lpszUnregister);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetRegisterWordStyleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetRegisterWordStyleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf)
     * }
     */
    public static FunctionDescriptor ImmGetRegisterWordStyleA$descriptor() {
        return ImmGetRegisterWordStyleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf)
     * }
     */
    public static MethodHandle ImmGetRegisterWordStyleA$handle() {
        return ImmGetRegisterWordStyleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf)
     * }
     */
    public static MemorySegment ImmGetRegisterWordStyleA$address() {
        return ImmGetRegisterWordStyleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf)
     * }
     */
    public static int ImmGetRegisterWordStyleA(MemorySegment x0, int nItem, MemorySegment lpStyleBuf) {
        var mh$ = ImmGetRegisterWordStyleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetRegisterWordStyleA", x0, nItem, lpStyleBuf);
            }
            return (int)mh$.invokeExact(x0, nItem, lpStyleBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetRegisterWordStyleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetRegisterWordStyleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf)
     * }
     */
    public static FunctionDescriptor ImmGetRegisterWordStyleW$descriptor() {
        return ImmGetRegisterWordStyleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf)
     * }
     */
    public static MethodHandle ImmGetRegisterWordStyleW$handle() {
        return ImmGetRegisterWordStyleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf)
     * }
     */
    public static MemorySegment ImmGetRegisterWordStyleW$address() {
        return ImmGetRegisterWordStyleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf)
     * }
     */
    public static int ImmGetRegisterWordStyleW(MemorySegment x0, int nItem, MemorySegment lpStyleBuf) {
        var mh$ = ImmGetRegisterWordStyleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetRegisterWordStyleW", x0, nItem, lpStyleBuf);
            }
            return (int)mh$.invokeExact(x0, nItem, lpStyleBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmEnumRegisterWordA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmEnumRegisterWordA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmEnumRegisterWordA$descriptor() {
        return ImmEnumRegisterWordA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID)
     * }
     */
    public static MethodHandle ImmEnumRegisterWordA$handle() {
        return ImmEnumRegisterWordA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID)
     * }
     */
    public static MemorySegment ImmEnumRegisterWordA$address() {
        return ImmEnumRegisterWordA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID)
     * }
     */
    public static int ImmEnumRegisterWordA(MemorySegment x0, MemorySegment x1, MemorySegment lpszReading, int x3, MemorySegment lpszRegister, MemorySegment x5) {
        var mh$ = ImmEnumRegisterWordA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmEnumRegisterWordA", x0, x1, lpszReading, x3, lpszRegister, x5);
            }
            return (int)mh$.invokeExact(x0, x1, lpszReading, x3, lpszRegister, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmEnumRegisterWordW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmEnumRegisterWordW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmEnumRegisterWordW$descriptor() {
        return ImmEnumRegisterWordW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
     * }
     */
    public static MethodHandle ImmEnumRegisterWordW$handle() {
        return ImmEnumRegisterWordW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
     * }
     */
    public static MemorySegment ImmEnumRegisterWordW$address() {
        return ImmEnumRegisterWordW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
     * }
     */
    public static int ImmEnumRegisterWordW(MemorySegment x0, MemorySegment x1, MemorySegment lpszReading, int x3, MemorySegment lpszRegister, MemorySegment x5) {
        var mh$ = ImmEnumRegisterWordW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmEnumRegisterWordW", x0, x1, lpszReading, x3, lpszRegister, x5);
            }
            return (int)mh$.invokeExact(x0, x1, lpszReading, x3, lpszRegister, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmDisableIME {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmDisableIME");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmDisableIME(DWORD)
     * }
     */
    public static FunctionDescriptor ImmDisableIME$descriptor() {
        return ImmDisableIME.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmDisableIME(DWORD)
     * }
     */
    public static MethodHandle ImmDisableIME$handle() {
        return ImmDisableIME.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmDisableIME(DWORD)
     * }
     */
    public static MemorySegment ImmDisableIME$address() {
        return ImmDisableIME.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmDisableIME(DWORD)
     * }
     */
    public static int ImmDisableIME(int x0) {
        var mh$ = ImmDisableIME.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmDisableIME", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmEnumInputContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmEnumInputContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor ImmEnumInputContext$descriptor() {
        return ImmEnumInputContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MethodHandle ImmEnumInputContext$handle() {
        return ImmEnumInputContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MemorySegment ImmEnumInputContext$address() {
        return ImmEnumInputContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static int ImmEnumInputContext(int idThread, MemorySegment lpfn, long lParam) {
        var mh$ = ImmEnumInputContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmEnumInputContext", idThread, lpfn, lParam);
            }
            return (int)mh$.invokeExact(idThread, lpfn, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetImeMenuItemsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetImeMenuItemsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor ImmGetImeMenuItemsA$descriptor() {
        return ImmGetImeMenuItemsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize)
     * }
     */
    public static MethodHandle ImmGetImeMenuItemsA$handle() {
        return ImmGetImeMenuItemsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize)
     * }
     */
    public static MemorySegment ImmGetImeMenuItemsA$address() {
        return ImmGetImeMenuItemsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize)
     * }
     */
    public static int ImmGetImeMenuItemsA(MemorySegment x0, int x1, int x2, MemorySegment lpImeParentMenu, MemorySegment lpImeMenu, int dwSize) {
        var mh$ = ImmGetImeMenuItemsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetImeMenuItemsA", x0, x1, x2, lpImeParentMenu, lpImeMenu, dwSize);
            }
            return (int)mh$.invokeExact(x0, x1, x2, lpImeParentMenu, lpImeMenu, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetImeMenuItemsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmGetImeMenuItemsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor ImmGetImeMenuItemsW$descriptor() {
        return ImmGetImeMenuItemsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize)
     * }
     */
    public static MethodHandle ImmGetImeMenuItemsW$handle() {
        return ImmGetImeMenuItemsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize)
     * }
     */
    public static MemorySegment ImmGetImeMenuItemsW$address() {
        return ImmGetImeMenuItemsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize)
     * }
     */
    public static int ImmGetImeMenuItemsW(MemorySegment x0, int x1, int x2, MemorySegment lpImeParentMenu, MemorySegment lpImeMenu, int dwSize) {
        var mh$ = ImmGetImeMenuItemsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetImeMenuItemsW", x0, x1, x2, lpImeParentMenu, lpImeMenu, dwSize);
            }
            return (int)mh$.invokeExact(x0, x1, x2, lpImeParentMenu, lpImeMenu, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmDisableTextFrameService {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmDisableTextFrameService");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmDisableTextFrameService(DWORD idThread)
     * }
     */
    public static FunctionDescriptor ImmDisableTextFrameService$descriptor() {
        return ImmDisableTextFrameService.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmDisableTextFrameService(DWORD idThread)
     * }
     */
    public static MethodHandle ImmDisableTextFrameService$handle() {
        return ImmDisableTextFrameService.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmDisableTextFrameService(DWORD idThread)
     * }
     */
    public static MemorySegment ImmDisableTextFrameService$address() {
        return ImmDisableTextFrameService.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmDisableTextFrameService(DWORD idThread)
     * }
     */
    public static int ImmDisableTextFrameService(int idThread) {
        var mh$ = ImmDisableTextFrameService.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmDisableTextFrameService", idThread);
            }
            return (int)mh$.invokeExact(idThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmDisableLegacyIME {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImmDisableLegacyIME");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmDisableLegacyIME()
     * }
     */
    public static FunctionDescriptor ImmDisableLegacyIME$descriptor() {
        return ImmDisableLegacyIME.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmDisableLegacyIME()
     * }
     */
    public static MethodHandle ImmDisableLegacyIME$handle() {
        return ImmDisableLegacyIME.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmDisableLegacyIME()
     * }
     */
    public static MemorySegment ImmDisableLegacyIME$address() {
        return ImmDisableLegacyIME.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmDisableLegacyIME()
     * }
     */
    public static int ImmDisableLegacyIME() {
        var mh$ = ImmDisableLegacyIME.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmDisableLegacyIME");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLenum
     * }
     */
    public static final OfInt GLenum = wgl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char GLboolean
     * }
     */
    public static final OfByte GLboolean = wgl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLbitfield
     * }
     */
    public static final OfInt GLbitfield = wgl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char GLbyte
     * }
     */
    public static final OfByte GLbyte = wgl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short GLshort
     * }
     */
    public static final OfShort GLshort = wgl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int GLint
     * }
     */
    public static final OfInt GLint = wgl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int GLsizei
     * }
     */
    public static final OfInt GLsizei = wgl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char GLubyte
     * }
     */
    public static final OfByte GLubyte = wgl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short GLushort
     * }
     */
    public static final OfShort GLushort = wgl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLuint
     * }
     */
    public static final OfInt GLuint = wgl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef float GLfloat
     * }
     */
    public static final OfFloat GLfloat = wgl_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef float GLclampf
     * }
     */
    public static final OfFloat GLclampf = wgl_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double GLdouble
     * }
     */
    public static final OfDouble GLdouble = wgl_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double GLclampd
     * }
     */
    public static final OfDouble GLclampd = wgl_h.C_DOUBLE;

    private static class glAccum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glAccum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static FunctionDescriptor glAccum$descriptor() {
        return glAccum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static MethodHandle glAccum$handle() {
        return glAccum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static MemorySegment glAccum$address() {
        return glAccum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static void glAccum(int op, float value) {
        var mh$ = glAccum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAccum", op, value);
            }
            mh$.invokeExact(op, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAlphaFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glAlphaFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static FunctionDescriptor glAlphaFunc$descriptor() {
        return glAlphaFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static MethodHandle glAlphaFunc$handle() {
        return glAlphaFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static MemorySegment glAlphaFunc$address() {
        return glAlphaFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static void glAlphaFunc(int func, float ref) {
        var mh$ = glAlphaFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAlphaFunc", func, ref);
            }
            mh$.invokeExact(func, ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAreTexturesResident {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glAreTexturesResident");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static FunctionDescriptor glAreTexturesResident$descriptor() {
        return glAreTexturesResident.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MethodHandle glAreTexturesResident$handle() {
        return glAreTexturesResident.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MemorySegment glAreTexturesResident$address() {
        return glAreTexturesResident.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static byte glAreTexturesResident(int n, MemorySegment textures, MemorySegment residences) {
        var mh$ = glAreTexturesResident.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAreTexturesResident", n, textures, residences);
            }
            return (byte)mh$.invokeExact(n, textures, residences);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glArrayElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glArrayElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static FunctionDescriptor glArrayElement$descriptor() {
        return glArrayElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static MethodHandle glArrayElement$handle() {
        return glArrayElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static MemorySegment glArrayElement$address() {
        return glArrayElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static void glArrayElement(int i) {
        var mh$ = glArrayElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glArrayElement", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBegin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glBegin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static FunctionDescriptor glBegin$descriptor() {
        return glBegin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static MethodHandle glBegin$handle() {
        return glBegin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static MemorySegment glBegin$address() {
        return glBegin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static void glBegin(int mode) {
        var mh$ = glBegin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBegin", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glBindTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static FunctionDescriptor glBindTexture$descriptor() {
        return glBindTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MethodHandle glBindTexture$handle() {
        return glBindTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MemorySegment glBindTexture$address() {
        return glBindTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static void glBindTexture(int target, int texture) {
        var mh$ = glBindTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindTexture", target, texture);
            }
            mh$.invokeExact(target, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static FunctionDescriptor glBitmap$descriptor() {
        return glBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MethodHandle glBitmap$handle() {
        return glBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MemorySegment glBitmap$address() {
        return glBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, MemorySegment bitmap) {
        var mh$ = glBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBitmap", width, height, xorig, yorig, xmove, ymove, bitmap);
            }
            mh$.invokeExact(width, height, xorig, yorig, xmove, ymove, bitmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glBlendFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static FunctionDescriptor glBlendFunc$descriptor() {
        return glBlendFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static MethodHandle glBlendFunc$handle() {
        return glBlendFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static MemorySegment glBlendFunc$address() {
        return glBlendFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static void glBlendFunc(int sfactor, int dfactor) {
        var mh$ = glBlendFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendFunc", sfactor, dfactor);
            }
            mh$.invokeExact(sfactor, dfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCallList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glCallList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static FunctionDescriptor glCallList$descriptor() {
        return glCallList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static MethodHandle glCallList$handle() {
        return glCallList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static MemorySegment glCallList$address() {
        return glCallList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static void glCallList(int list) {
        var mh$ = glCallList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCallList", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCallLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glCallLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static FunctionDescriptor glCallLists$descriptor() {
        return glCallLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static MethodHandle glCallLists$handle() {
        return glCallLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static MemorySegment glCallLists$address() {
        return glCallLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static void glCallLists(int n, int type, MemorySegment lists) {
        var mh$ = glCallLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCallLists", n, type, lists);
            }
            mh$.invokeExact(n, type, lists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glClear$descriptor() {
        return glClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static MethodHandle glClear$handle() {
        return glClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static MemorySegment glClear$address() {
        return glClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static void glClear(int mask) {
        var mh$ = glClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClear", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearAccum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glClearAccum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static FunctionDescriptor glClearAccum$descriptor() {
        return glClearAccum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MethodHandle glClearAccum$handle() {
        return glClearAccum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MemorySegment glClearAccum$address() {
        return glClearAccum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static void glClearAccum(float red, float green, float blue, float alpha) {
        var mh$ = glClearAccum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearAccum", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glClearColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static FunctionDescriptor glClearColor$descriptor() {
        return glClearColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MethodHandle glClearColor$handle() {
        return glClearColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MemorySegment glClearColor$address() {
        return glClearColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static void glClearColor(float red, float green, float blue, float alpha) {
        var mh$ = glClearColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearColor", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glClearDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static FunctionDescriptor glClearDepth$descriptor() {
        return glClearDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static MethodHandle glClearDepth$handle() {
        return glClearDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static MemorySegment glClearDepth$address() {
        return glClearDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static void glClearDepth(double depth) {
        var mh$ = glClearDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearDepth", depth);
            }
            mh$.invokeExact(depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glClearIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static FunctionDescriptor glClearIndex$descriptor() {
        return glClearIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static MethodHandle glClearIndex$handle() {
        return glClearIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static MemorySegment glClearIndex$address() {
        return glClearIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static void glClearIndex(float c) {
        var mh$ = glClearIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearIndex", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearStencil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glClearStencil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static FunctionDescriptor glClearStencil$descriptor() {
        return glClearStencil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static MethodHandle glClearStencil$handle() {
        return glClearStencil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static MemorySegment glClearStencil$address() {
        return glClearStencil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static void glClearStencil(int s) {
        var mh$ = glClearStencil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearStencil", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClipPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glClipPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static FunctionDescriptor glClipPlane$descriptor() {
        return glClipPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static MethodHandle glClipPlane$handle() {
        return glClipPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static MemorySegment glClipPlane$address() {
        return glClipPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static void glClipPlane(int plane, MemorySegment equation) {
        var mh$ = glClipPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClipPlane", plane, equation);
            }
            mh$.invokeExact(plane, equation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_CHAR,
            wgl_h.C_CHAR,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static FunctionDescriptor glColor3b$descriptor() {
        return glColor3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MethodHandle glColor3b$handle() {
        return glColor3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MemorySegment glColor3b$address() {
        return glColor3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static void glColor3b(byte red, byte green, byte blue) {
        var mh$ = glColor3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3b", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor3bv$descriptor() {
        return glColor3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor3bv$handle() {
        return glColor3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor3bv$address() {
        return glColor3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static void glColor3bv(MemorySegment v) {
        var mh$ = glColor3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static FunctionDescriptor glColor3d$descriptor() {
        return glColor3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MethodHandle glColor3d$handle() {
        return glColor3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MemorySegment glColor3d$address() {
        return glColor3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static void glColor3d(double red, double green, double blue) {
        var mh$ = glColor3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3d", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor3dv$descriptor() {
        return glColor3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor3dv$handle() {
        return glColor3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor3dv$address() {
        return glColor3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static void glColor3dv(MemorySegment v) {
        var mh$ = glColor3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static FunctionDescriptor glColor3f$descriptor() {
        return glColor3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MethodHandle glColor3f$handle() {
        return glColor3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MemorySegment glColor3f$address() {
        return glColor3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static void glColor3f(float red, float green, float blue) {
        var mh$ = glColor3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3f", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor3fv$descriptor() {
        return glColor3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor3fv$handle() {
        return glColor3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor3fv$address() {
        return glColor3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static void glColor3fv(MemorySegment v) {
        var mh$ = glColor3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static FunctionDescriptor glColor3i$descriptor() {
        return glColor3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MethodHandle glColor3i$handle() {
        return glColor3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MemorySegment glColor3i$address() {
        return glColor3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static void glColor3i(int red, int green, int blue) {
        var mh$ = glColor3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3i", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor3iv$descriptor() {
        return glColor3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor3iv$handle() {
        return glColor3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor3iv$address() {
        return glColor3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static void glColor3iv(MemorySegment v) {
        var mh$ = glColor3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static FunctionDescriptor glColor3s$descriptor() {
        return glColor3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MethodHandle glColor3s$handle() {
        return glColor3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MemorySegment glColor3s$address() {
        return glColor3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static void glColor3s(short red, short green, short blue) {
        var mh$ = glColor3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3s", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor3sv$descriptor() {
        return glColor3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor3sv$handle() {
        return glColor3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor3sv$address() {
        return glColor3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static void glColor3sv(MemorySegment v) {
        var mh$ = glColor3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_CHAR,
            wgl_h.C_CHAR,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static FunctionDescriptor glColor3ub$descriptor() {
        return glColor3ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MethodHandle glColor3ub$handle() {
        return glColor3ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MemorySegment glColor3ub$address() {
        return glColor3ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static void glColor3ub(byte red, byte green, byte blue) {
        var mh$ = glColor3ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ub", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor3ubv$descriptor() {
        return glColor3ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor3ubv$handle() {
        return glColor3ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor3ubv$address() {
        return glColor3ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static void glColor3ubv(MemorySegment v) {
        var mh$ = glColor3ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static FunctionDescriptor glColor3ui$descriptor() {
        return glColor3ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MethodHandle glColor3ui$handle() {
        return glColor3ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MemorySegment glColor3ui$address() {
        return glColor3ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static void glColor3ui(int red, int green, int blue) {
        var mh$ = glColor3ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ui", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor3uiv$descriptor() {
        return glColor3uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor3uiv$handle() {
        return glColor3uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor3uiv$address() {
        return glColor3uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static void glColor3uiv(MemorySegment v) {
        var mh$ = glColor3uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static FunctionDescriptor glColor3us$descriptor() {
        return glColor3us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MethodHandle glColor3us$handle() {
        return glColor3us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MemorySegment glColor3us$address() {
        return glColor3us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static void glColor3us(short red, short green, short blue) {
        var mh$ = glColor3us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3us", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor3usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor3usv$descriptor() {
        return glColor3usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor3usv$handle() {
        return glColor3usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor3usv$address() {
        return glColor3usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static void glColor3usv(MemorySegment v) {
        var mh$ = glColor3usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_CHAR,
            wgl_h.C_CHAR,
            wgl_h.C_CHAR,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4b$descriptor() {
        return glColor4b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MethodHandle glColor4b$handle() {
        return glColor4b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MemorySegment glColor4b$address() {
        return glColor4b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static void glColor4b(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4b", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor4bv$descriptor() {
        return glColor4bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor4bv$handle() {
        return glColor4bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor4bv$address() {
        return glColor4bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static void glColor4bv(MemorySegment v) {
        var mh$ = glColor4bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static FunctionDescriptor glColor4d$descriptor() {
        return glColor4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MethodHandle glColor4d$handle() {
        return glColor4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MemorySegment glColor4d$address() {
        return glColor4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static void glColor4d(double red, double green, double blue, double alpha) {
        var mh$ = glColor4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4d", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor4dv$descriptor() {
        return glColor4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor4dv$handle() {
        return glColor4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor4dv$address() {
        return glColor4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static void glColor4dv(MemorySegment v) {
        var mh$ = glColor4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static FunctionDescriptor glColor4f$descriptor() {
        return glColor4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MethodHandle glColor4f$handle() {
        return glColor4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MemorySegment glColor4f$address() {
        return glColor4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static void glColor4f(float red, float green, float blue, float alpha) {
        var mh$ = glColor4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4f", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor4fv$descriptor() {
        return glColor4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor4fv$handle() {
        return glColor4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor4fv$address() {
        return glColor4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static void glColor4fv(MemorySegment v) {
        var mh$ = glColor4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static FunctionDescriptor glColor4i$descriptor() {
        return glColor4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MethodHandle glColor4i$handle() {
        return glColor4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MemorySegment glColor4i$address() {
        return glColor4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static void glColor4i(int red, int green, int blue, int alpha) {
        var mh$ = glColor4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4i", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor4iv$descriptor() {
        return glColor4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor4iv$handle() {
        return glColor4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor4iv$address() {
        return glColor4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static void glColor4iv(MemorySegment v) {
        var mh$ = glColor4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static FunctionDescriptor glColor4s$descriptor() {
        return glColor4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MethodHandle glColor4s$handle() {
        return glColor4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MemorySegment glColor4s$address() {
        return glColor4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static void glColor4s(short red, short green, short blue, short alpha) {
        var mh$ = glColor4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4s", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor4sv$descriptor() {
        return glColor4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor4sv$handle() {
        return glColor4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor4sv$address() {
        return glColor4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static void glColor4sv(MemorySegment v) {
        var mh$ = glColor4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_CHAR,
            wgl_h.C_CHAR,
            wgl_h.C_CHAR,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4ub$descriptor() {
        return glColor4ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MethodHandle glColor4ub$handle() {
        return glColor4ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MemorySegment glColor4ub$address() {
        return glColor4ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static void glColor4ub(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ub", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor4ubv$descriptor() {
        return glColor4ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor4ubv$handle() {
        return glColor4ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor4ubv$address() {
        return glColor4ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static void glColor4ubv(MemorySegment v) {
        var mh$ = glColor4ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static FunctionDescriptor glColor4ui$descriptor() {
        return glColor4ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MethodHandle glColor4ui$handle() {
        return glColor4ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MemorySegment glColor4ui$address() {
        return glColor4ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static void glColor4ui(int red, int green, int blue, int alpha) {
        var mh$ = glColor4ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ui", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor4uiv$descriptor() {
        return glColor4uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor4uiv$handle() {
        return glColor4uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor4uiv$address() {
        return glColor4uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static void glColor4uiv(MemorySegment v) {
        var mh$ = glColor4uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static FunctionDescriptor glColor4us$descriptor() {
        return glColor4us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MethodHandle glColor4us$handle() {
        return glColor4us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MemorySegment glColor4us$address() {
        return glColor4us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static void glColor4us(short red, short green, short blue, short alpha) {
        var mh$ = glColor4us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4us", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColor4usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor4usv$descriptor() {
        return glColor4usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor4usv$handle() {
        return glColor4usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor4usv$address() {
        return glColor4usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static void glColor4usv(MemorySegment v) {
        var mh$ = glColor4usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_CHAR,
            wgl_h.C_CHAR,
            wgl_h.C_CHAR,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColorMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static FunctionDescriptor glColorMask$descriptor() {
        return glColorMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static MethodHandle glColorMask$handle() {
        return glColorMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static MemorySegment glColorMask$address() {
        return glColorMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static void glColorMask(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColorMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMask", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColorMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static FunctionDescriptor glColorMaterial$descriptor() {
        return glColorMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MethodHandle glColorMaterial$handle() {
        return glColorMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MemorySegment glColorMaterial$address() {
        return glColorMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static void glColorMaterial(int face, int mode) {
        var mh$ = glColorMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMaterial", face, mode);
            }
            mh$.invokeExact(face, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glColorPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glColorPointer$descriptor() {
        return glColorPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glColorPointer$handle() {
        return glColorPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glColorPointer$address() {
        return glColorPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glColorPointer(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glColorPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorPointer", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glCopyPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static FunctionDescriptor glCopyPixels$descriptor() {
        return glCopyPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MethodHandle glCopyPixels$handle() {
        return glCopyPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MemorySegment glCopyPixels$address() {
        return glCopyPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static void glCopyPixels(int x, int y, int width, int height, int type) {
        var mh$ = glCopyPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyPixels", x, y, width, height, type);
            }
            mh$.invokeExact(x, y, width, height, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glCopyTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage1D$descriptor() {
        return glCopyTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage1D$handle() {
        return glCopyTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage1D$address() {
        return glCopyTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static void glCopyTexImage1D(int target, int level, int internalFormat, int x, int y, int width, int border) {
        var mh$ = glCopyTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage1D", target, level, internalFormat, x, y, width, border);
            }
            mh$.invokeExact(target, level, internalFormat, x, y, width, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glCopyTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage2D$descriptor() {
        return glCopyTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage2D$handle() {
        return glCopyTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage2D$address() {
        return glCopyTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static void glCopyTexImage2D(int target, int level, int internalFormat, int x, int y, int width, int height, int border) {
        var mh$ = glCopyTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage2D", target, level, internalFormat, x, y, width, height, border);
            }
            mh$.invokeExact(target, level, internalFormat, x, y, width, height, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glCopyTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage1D$descriptor() {
        return glCopyTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyTexSubImage1D$handle() {
        return glCopyTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyTexSubImage1D$address() {
        return glCopyTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyTexSubImage1D(int target, int level, int xoffset, int x, int y, int width) {
        var mh$ = glCopyTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage1D", target, level, xoffset, x, y, width);
            }
            mh$.invokeExact(target, level, xoffset, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glCopyTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage2D$descriptor() {
        return glCopyTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyTexSubImage2D$handle() {
        return glCopyTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyTexSubImage2D$address() {
        return glCopyTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
        var mh$ = glCopyTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage2D", target, level, xoffset, yoffset, x, y, width, height);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCullFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glCullFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static FunctionDescriptor glCullFace$descriptor() {
        return glCullFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static MethodHandle glCullFace$handle() {
        return glCullFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static MemorySegment glCullFace$address() {
        return glCullFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static void glCullFace(int mode) {
        var mh$ = glCullFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCullFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glDeleteLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static FunctionDescriptor glDeleteLists$descriptor() {
        return glDeleteLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static MethodHandle glDeleteLists$handle() {
        return glDeleteLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static MemorySegment glDeleteLists$address() {
        return glDeleteLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static void glDeleteLists(int list, int range) {
        var mh$ = glDeleteLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteLists", list, range);
            }
            mh$.invokeExact(list, range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glDeleteTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static FunctionDescriptor glDeleteTextures$descriptor() {
        return glDeleteTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MethodHandle glDeleteTextures$handle() {
        return glDeleteTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MemorySegment glDeleteTextures$address() {
        return glDeleteTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static void glDeleteTextures(int n, MemorySegment textures) {
        var mh$ = glDeleteTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glDepthFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static FunctionDescriptor glDepthFunc$descriptor() {
        return glDepthFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static MethodHandle glDepthFunc$handle() {
        return glDepthFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static MemorySegment glDepthFunc$address() {
        return glDepthFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static void glDepthFunc(int func) {
        var mh$ = glDepthFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthFunc", func);
            }
            mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glDepthMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static FunctionDescriptor glDepthMask$descriptor() {
        return glDepthMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static MethodHandle glDepthMask$handle() {
        return glDepthMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static MemorySegment glDepthMask$address() {
        return glDepthMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static void glDepthMask(byte flag) {
        var mh$ = glDepthMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthMask", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glDepthRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static FunctionDescriptor glDepthRange$descriptor() {
        return glDepthRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static MethodHandle glDepthRange$handle() {
        return glDepthRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static MemorySegment glDepthRange$address() {
        return glDepthRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static void glDepthRange(double zNear, double zFar) {
        var mh$ = glDepthRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthRange", zNear, zFar);
            }
            mh$.invokeExact(zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glDisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static FunctionDescriptor glDisable$descriptor() {
        return glDisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static MethodHandle glDisable$handle() {
        return glDisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static MemorySegment glDisable$address() {
        return glDisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static void glDisable(int cap) {
        var mh$ = glDisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisable", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisableClientState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glDisableClientState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum array)
     * }
     */
    public static FunctionDescriptor glDisableClientState$descriptor() {
        return glDisableClientState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum array)
     * }
     */
    public static MethodHandle glDisableClientState$handle() {
        return glDisableClientState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum array)
     * }
     */
    public static MemorySegment glDisableClientState$address() {
        return glDisableClientState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDisableClientState(GLenum array)
     * }
     */
    public static void glDisableClientState(int array) {
        var mh$ = glDisableClientState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisableClientState", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glDrawArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static FunctionDescriptor glDrawArrays$descriptor() {
        return glDrawArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MethodHandle glDrawArrays$handle() {
        return glDrawArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MemorySegment glDrawArrays$address() {
        return glDrawArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static void glDrawArrays(int mode, int first, int count) {
        var mh$ = glDrawArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawArrays", mode, first, count);
            }
            mh$.invokeExact(mode, first, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glDrawBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static FunctionDescriptor glDrawBuffer$descriptor() {
        return glDrawBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static MethodHandle glDrawBuffer$handle() {
        return glDrawBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static MemorySegment glDrawBuffer$address() {
        return glDrawBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static void glDrawBuffer(int mode) {
        var mh$ = glDrawBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawBuffer", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glDrawElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static FunctionDescriptor glDrawElements$descriptor() {
        return glDrawElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MethodHandle glDrawElements$handle() {
        return glDrawElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MemorySegment glDrawElements$address() {
        return glDrawElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static void glDrawElements(int mode, int count, int type, MemorySegment indices) {
        var mh$ = glDrawElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawElements", mode, count, type, indices);
            }
            mh$.invokeExact(mode, count, type, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glDrawPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glDrawPixels$descriptor() {
        return glDrawPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glDrawPixels$handle() {
        return glDrawPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glDrawPixels$address() {
        return glDrawPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glDrawPixels(int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glDrawPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawPixels", width, height, format, type, pixels);
            }
            mh$.invokeExact(width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEdgeFlag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static FunctionDescriptor glEdgeFlag$descriptor() {
        return glEdgeFlag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static MethodHandle glEdgeFlag$handle() {
        return glEdgeFlag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static MemorySegment glEdgeFlag$address() {
        return glEdgeFlag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static void glEdgeFlag(byte flag) {
        var mh$ = glEdgeFlag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlag", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlagPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEdgeFlagPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glEdgeFlagPointer$descriptor() {
        return glEdgeFlagPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glEdgeFlagPointer$handle() {
        return glEdgeFlagPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glEdgeFlagPointer$address() {
        return glEdgeFlagPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glEdgeFlagPointer(int stride, MemorySegment pointer) {
        var mh$ = glEdgeFlagPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlagPointer", stride, pointer);
            }
            mh$.invokeExact(stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlagv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEdgeFlagv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static FunctionDescriptor glEdgeFlagv$descriptor() {
        return glEdgeFlagv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static MethodHandle glEdgeFlagv$handle() {
        return glEdgeFlagv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static MemorySegment glEdgeFlagv$address() {
        return glEdgeFlagv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static void glEdgeFlagv(MemorySegment flag) {
        var mh$ = glEdgeFlagv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlagv", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEnable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static FunctionDescriptor glEnable$descriptor() {
        return glEnable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static MethodHandle glEnable$handle() {
        return glEnable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static MemorySegment glEnable$address() {
        return glEnable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static void glEnable(int cap) {
        var mh$ = glEnable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnable", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnableClientState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEnableClientState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum array)
     * }
     */
    public static FunctionDescriptor glEnableClientState$descriptor() {
        return glEnableClientState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum array)
     * }
     */
    public static MethodHandle glEnableClientState$handle() {
        return glEnableClientState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum array)
     * }
     */
    public static MemorySegment glEnableClientState$address() {
        return glEnableClientState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnableClientState(GLenum array)
     * }
     */
    public static void glEnableClientState(int array) {
        var mh$ = glEnableClientState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnableClientState", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static FunctionDescriptor glEnd$descriptor() {
        return glEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static MethodHandle glEnd$handle() {
        return glEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static MemorySegment glEnd$address() {
        return glEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static void glEnd() {
        var mh$ = glEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnd");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEndList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEndList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static FunctionDescriptor glEndList$descriptor() {
        return glEndList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static MethodHandle glEndList$handle() {
        return glEndList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static MemorySegment glEndList$address() {
        return glEndList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static void glEndList() {
        var mh$ = glEndList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEndList");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1d$descriptor() {
        return glEvalCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MethodHandle glEvalCoord1d$handle() {
        return glEvalCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MemorySegment glEvalCoord1d$address() {
        return glEvalCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static void glEvalCoord1d(double u) {
        var mh$ = glEvalCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1d", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1dv$descriptor() {
        return glEvalCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord1dv$handle() {
        return glEvalCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord1dv$address() {
        return glEvalCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord1dv(MemorySegment u) {
        var mh$ = glEvalCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1f$descriptor() {
        return glEvalCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MethodHandle glEvalCoord1f$handle() {
        return glEvalCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MemorySegment glEvalCoord1f$address() {
        return glEvalCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static void glEvalCoord1f(float u) {
        var mh$ = glEvalCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1f", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1fv$descriptor() {
        return glEvalCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord1fv$handle() {
        return glEvalCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord1fv$address() {
        return glEvalCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord1fv(MemorySegment u) {
        var mh$ = glEvalCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2d$descriptor() {
        return glEvalCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MethodHandle glEvalCoord2d$handle() {
        return glEvalCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MemorySegment glEvalCoord2d$address() {
        return glEvalCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static void glEvalCoord2d(double u, double v) {
        var mh$ = glEvalCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2d", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2dv$descriptor() {
        return glEvalCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord2dv$handle() {
        return glEvalCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord2dv$address() {
        return glEvalCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord2dv(MemorySegment u) {
        var mh$ = glEvalCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2f$descriptor() {
        return glEvalCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MethodHandle glEvalCoord2f$handle() {
        return glEvalCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MemorySegment glEvalCoord2f$address() {
        return glEvalCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static void glEvalCoord2f(float u, float v) {
        var mh$ = glEvalCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2f", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2fv$descriptor() {
        return glEvalCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord2fv$handle() {
        return glEvalCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord2fv$address() {
        return glEvalCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord2fv(MemorySegment u) {
        var mh$ = glEvalCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalMesh1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static FunctionDescriptor glEvalMesh1$descriptor() {
        return glEvalMesh1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MethodHandle glEvalMesh1$handle() {
        return glEvalMesh1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MemorySegment glEvalMesh1$address() {
        return glEvalMesh1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static void glEvalMesh1(int mode, int i1, int i2) {
        var mh$ = glEvalMesh1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh1", mode, i1, i2);
            }
            mh$.invokeExact(mode, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalMesh2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static FunctionDescriptor glEvalMesh2$descriptor() {
        return glEvalMesh2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MethodHandle glEvalMesh2$handle() {
        return glEvalMesh2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MemorySegment glEvalMesh2$address() {
        return glEvalMesh2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static void glEvalMesh2(int mode, int i1, int i2, int j1, int j2) {
        var mh$ = glEvalMesh2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh2", mode, i1, i2, j1, j2);
            }
            mh$.invokeExact(mode, i1, i2, j1, j2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalPoint1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static FunctionDescriptor glEvalPoint1$descriptor() {
        return glEvalPoint1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static MethodHandle glEvalPoint1$handle() {
        return glEvalPoint1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static MemorySegment glEvalPoint1$address() {
        return glEvalPoint1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static void glEvalPoint1(int i) {
        var mh$ = glEvalPoint1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint1", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glEvalPoint2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static FunctionDescriptor glEvalPoint2$descriptor() {
        return glEvalPoint2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MethodHandle glEvalPoint2$handle() {
        return glEvalPoint2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MemorySegment glEvalPoint2$address() {
        return glEvalPoint2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static void glEvalPoint2(int i, int j) {
        var mh$ = glEvalPoint2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint2", i, j);
            }
            mh$.invokeExact(i, j);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFeedbackBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glFeedbackBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static FunctionDescriptor glFeedbackBuffer$descriptor() {
        return glFeedbackBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MethodHandle glFeedbackBuffer$handle() {
        return glFeedbackBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MemorySegment glFeedbackBuffer$address() {
        return glFeedbackBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static void glFeedbackBuffer(int size, int type, MemorySegment buffer) {
        var mh$ = glFeedbackBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFeedbackBuffer", size, type, buffer);
            }
            mh$.invokeExact(size, type, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFinish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glFinish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static FunctionDescriptor glFinish$descriptor() {
        return glFinish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static MethodHandle glFinish$handle() {
        return glFinish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static MemorySegment glFinish$address() {
        return glFinish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static void glFinish() {
        var mh$ = glFinish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFinish");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glFlush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static FunctionDescriptor glFlush$descriptor() {
        return glFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static MethodHandle glFlush$handle() {
        return glFlush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static MemorySegment glFlush$address() {
        return glFlush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static void glFlush() {
        var mh$ = glFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFlush");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glFogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glFogf$descriptor() {
        return glFogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glFogf$handle() {
        return glFogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glFogf$address() {
        return glFogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static void glFogf(int pname, float param) {
        var mh$ = glFogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glFogfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glFogfv$descriptor() {
        return glFogfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glFogfv$handle() {
        return glFogfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glFogfv$address() {
        return glFogfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glFogfv(int pname, MemorySegment params) {
        var mh$ = glFogfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glFogi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glFogi$descriptor() {
        return glFogi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glFogi$handle() {
        return glFogi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glFogi$address() {
        return glFogi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static void glFogi(int pname, int param) {
        var mh$ = glFogi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glFogiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glFogiv$descriptor() {
        return glFogiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glFogiv$handle() {
        return glFogiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glFogiv$address() {
        return glFogiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static void glFogiv(int pname, MemorySegment params) {
        var mh$ = glFogiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogiv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFrontFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glFrontFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static FunctionDescriptor glFrontFace$descriptor() {
        return glFrontFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static MethodHandle glFrontFace$handle() {
        return glFrontFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static MemorySegment glFrontFace$address() {
        return glFrontFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static void glFrontFace(int mode) {
        var mh$ = glFrontFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFrontFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFrustum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glFrustum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static FunctionDescriptor glFrustum$descriptor() {
        return glFrustum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MethodHandle glFrustum$handle() {
        return glFrustum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MemorySegment glFrustum$address() {
        return glFrustum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static void glFrustum(double left, double right, double bottom, double top, double zNear, double zFar) {
        var mh$ = glFrustum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFrustum", left, right, bottom, top, zNear, zFar);
            }
            mh$.invokeExact(left, right, bottom, top, zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGenLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static FunctionDescriptor glGenLists$descriptor() {
        return glGenLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static MethodHandle glGenLists$handle() {
        return glGenLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static MemorySegment glGenLists$address() {
        return glGenLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static int glGenLists(int range) {
        var mh$ = glGenLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenLists", range);
            }
            return (int)mh$.invokeExact(range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGenTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static FunctionDescriptor glGenTextures$descriptor() {
        return glGenTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MethodHandle glGenTextures$handle() {
        return glGenTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MemorySegment glGenTextures$address() {
        return glGenTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static void glGenTextures(int n, MemorySegment textures) {
        var mh$ = glGenTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBooleanv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetBooleanv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static FunctionDescriptor glGetBooleanv$descriptor() {
        return glGetBooleanv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static MethodHandle glGetBooleanv$handle() {
        return glGetBooleanv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static MemorySegment glGetBooleanv$address() {
        return glGetBooleanv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static void glGetBooleanv(int pname, MemorySegment params) {
        var mh$ = glGetBooleanv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBooleanv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetClipPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetClipPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static FunctionDescriptor glGetClipPlane$descriptor() {
        return glGetClipPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static MethodHandle glGetClipPlane$handle() {
        return glGetClipPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static MemorySegment glGetClipPlane$address() {
        return glGetClipPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static void glGetClipPlane(int plane, MemorySegment equation) {
        var mh$ = glGetClipPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetClipPlane", plane, equation);
            }
            mh$.invokeExact(plane, equation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetDoublev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetDoublev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetDoublev$descriptor() {
        return glGetDoublev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetDoublev$handle() {
        return glGetDoublev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetDoublev$address() {
        return glGetDoublev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetDoublev(int pname, MemorySegment params) {
        var mh$ = glGetDoublev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetDoublev", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static FunctionDescriptor glGetError$descriptor() {
        return glGetError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static MethodHandle glGetError$handle() {
        return glGetError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static MemorySegment glGetError$address() {
        return glGetError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static int glGetError() {
        var mh$ = glGetError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetFloatv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetFloatv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetFloatv$descriptor() {
        return glGetFloatv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetFloatv$handle() {
        return glGetFloatv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetFloatv$address() {
        return glGetFloatv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetFloatv(int pname, MemorySegment params) {
        var mh$ = glGetFloatv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetFloatv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetIntegerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetIntegerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetIntegerv$descriptor() {
        return glGetIntegerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetIntegerv$handle() {
        return glGetIntegerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetIntegerv$address() {
        return glGetIntegerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static void glGetIntegerv(int pname, MemorySegment params) {
        var mh$ = glGetIntegerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetIntegerv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetLightfv$descriptor() {
        return glGetLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetLightfv$handle() {
        return glGetLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetLightfv$address() {
        return glGetLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetLightiv$descriptor() {
        return glGetLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetLightiv$handle() {
        return glGetLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetLightiv$address() {
        return glGetLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static void glGetLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetMapdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static FunctionDescriptor glGetMapdv$descriptor() {
        return glGetMapdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MethodHandle glGetMapdv$handle() {
        return glGetMapdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MemorySegment glGetMapdv$address() {
        return glGetMapdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static void glGetMapdv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapdv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static FunctionDescriptor glGetMapfv$descriptor() {
        return glGetMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MethodHandle glGetMapfv$handle() {
        return glGetMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MemorySegment glGetMapfv$address() {
        return glGetMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static void glGetMapfv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapfv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetMapiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static FunctionDescriptor glGetMapiv$descriptor() {
        return glGetMapiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MethodHandle glGetMapiv$handle() {
        return glGetMapiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MemorySegment glGetMapiv$address() {
        return glGetMapiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static void glGetMapiv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapiv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialfv$descriptor() {
        return glGetMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetMaterialfv$handle() {
        return glGetMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetMaterialfv$address() {
        return glGetMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialiv$descriptor() {
        return glGetMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetMaterialiv$handle() {
        return glGetMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetMaterialiv$address() {
        return glGetMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static void glGetMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapfv$descriptor() {
        return glGetPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MethodHandle glGetPixelMapfv$handle() {
        return glGetPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MemorySegment glGetPixelMapfv$address() {
        return glGetPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static void glGetPixelMapfv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapfv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapuiv$descriptor() {
        return glGetPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MethodHandle glGetPixelMapuiv$handle() {
        return glGetPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MemorySegment glGetPixelMapuiv$address() {
        return glGetPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static void glGetPixelMapuiv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapuiv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapusv$descriptor() {
        return glGetPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MethodHandle glGetPixelMapusv$handle() {
        return glGetPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MemorySegment glGetPixelMapusv$address() {
        return glGetPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static void glGetPixelMapusv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapusv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPointerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetPointerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static FunctionDescriptor glGetPointerv$descriptor() {
        return glGetPointerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MethodHandle glGetPointerv$handle() {
        return glGetPointerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MemorySegment glGetPointerv$address() {
        return glGetPointerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static void glGetPointerv(int pname, MemorySegment params) {
        var mh$ = glGetPointerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPointerv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPolygonStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetPolygonStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static FunctionDescriptor glGetPolygonStipple$descriptor() {
        return glGetPolygonStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static MethodHandle glGetPolygonStipple$handle() {
        return glGetPolygonStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static MemorySegment glGetPolygonStipple$address() {
        return glGetPolygonStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static void glGetPolygonStipple(MemorySegment mask) {
        var mh$ = glGetPolygonStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPolygonStipple", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static FunctionDescriptor glGetString$descriptor() {
        return glGetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MethodHandle glGetString$handle() {
        return glGetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MemorySegment glGetString$address() {
        return glGetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MemorySegment glGetString(int name) {
        var mh$ = glGetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetString", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnvfv$descriptor() {
        return glGetTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexEnvfv$handle() {
        return glGetTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexEnvfv$address() {
        return glGetTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnviv$descriptor() {
        return glGetTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexEnviv$handle() {
        return glGetTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexEnviv$address() {
        return glGetTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetTexGendv$descriptor() {
        return glGetTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetTexGendv$handle() {
        return glGetTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetTexGendv$address() {
        return glGetTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexGenfv$descriptor() {
        return glGetTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexGenfv$handle() {
        return glGetTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexGenfv$address() {
        return glGetTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexGeniv$descriptor() {
        return glGetTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexGeniv$handle() {
        return glGetTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexGeniv$address() {
        return glGetTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetTexImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glGetTexImage$descriptor() {
        return glGetTexImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glGetTexImage$handle() {
        return glGetTexImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glGetTexImage$address() {
        return glGetTexImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glGetTexImage(int target, int level, int format, int type, MemorySegment pixels) {
        var mh$ = glGetTexImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexImage", target, level, format, type, pixels);
            }
            mh$.invokeExact(target, level, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetTexLevelParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameterfv$descriptor() {
        return glGetTexLevelParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameterfv$handle() {
        return glGetTexLevelParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameterfv$address() {
        return glGetTexLevelParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexLevelParameterfv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameterfv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetTexLevelParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameteriv$descriptor() {
        return glGetTexLevelParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameteriv$handle() {
        return glGetTexLevelParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameteriv$address() {
        return glGetTexLevelParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexLevelParameteriv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameteriv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameterfv$descriptor() {
        return glGetTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexParameterfv$handle() {
        return glGetTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexParameterfv$address() {
        return glGetTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glGetTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameteriv$descriptor() {
        return glGetTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexParameteriv$handle() {
        return glGetTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexParameteriv$address() {
        return glGetTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glHint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glHint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static FunctionDescriptor glHint$descriptor() {
        return glHint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static MethodHandle glHint$handle() {
        return glHint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static MemorySegment glHint$address() {
        return glHint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static void glHint(int target, int mode) {
        var mh$ = glHint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glHint", target, mode);
            }
            mh$.invokeExact(target, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static FunctionDescriptor glIndexMask$descriptor() {
        return glIndexMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static MethodHandle glIndexMask$handle() {
        return glIndexMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static MemorySegment glIndexMask$address() {
        return glIndexMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static void glIndexMask(int mask) {
        var mh$ = glIndexMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexMask", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glIndexPointer$descriptor() {
        return glIndexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glIndexPointer$handle() {
        return glIndexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glIndexPointer$address() {
        return glIndexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glIndexPointer(int type, int stride, MemorySegment pointer) {
        var mh$ = glIndexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexPointer", type, stride, pointer);
            }
            mh$.invokeExact(type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static FunctionDescriptor glIndexd$descriptor() {
        return glIndexd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static MethodHandle glIndexd$handle() {
        return glIndexd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static MemorySegment glIndexd$address() {
        return glIndexd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static void glIndexd(double c) {
        var mh$ = glIndexd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexd", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static FunctionDescriptor glIndexdv$descriptor() {
        return glIndexdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static MethodHandle glIndexdv$handle() {
        return glIndexdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static MemorySegment glIndexdv$address() {
        return glIndexdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static void glIndexdv(MemorySegment c) {
        var mh$ = glIndexdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexdv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static FunctionDescriptor glIndexf$descriptor() {
        return glIndexf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static MethodHandle glIndexf$handle() {
        return glIndexf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static MemorySegment glIndexf$address() {
        return glIndexf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static void glIndexf(float c) {
        var mh$ = glIndexf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexf", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static FunctionDescriptor glIndexfv$descriptor() {
        return glIndexfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static MethodHandle glIndexfv$handle() {
        return glIndexfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static MemorySegment glIndexfv$address() {
        return glIndexfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static void glIndexfv(MemorySegment c) {
        var mh$ = glIndexfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexfv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static FunctionDescriptor glIndexi$descriptor() {
        return glIndexi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static MethodHandle glIndexi$handle() {
        return glIndexi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static MemorySegment glIndexi$address() {
        return glIndexi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static void glIndexi(int c) {
        var mh$ = glIndexi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexi", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static FunctionDescriptor glIndexiv$descriptor() {
        return glIndexiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static MethodHandle glIndexiv$handle() {
        return glIndexiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static MemorySegment glIndexiv$address() {
        return glIndexiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static void glIndexiv(MemorySegment c) {
        var mh$ = glIndexiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexiv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static FunctionDescriptor glIndexs$descriptor() {
        return glIndexs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static MethodHandle glIndexs$handle() {
        return glIndexs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static MemorySegment glIndexs$address() {
        return glIndexs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static void glIndexs(short c) {
        var mh$ = glIndexs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexs", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static FunctionDescriptor glIndexsv$descriptor() {
        return glIndexsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static MethodHandle glIndexsv$handle() {
        return glIndexsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static MemorySegment glIndexsv$address() {
        return glIndexsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static void glIndexsv(MemorySegment c) {
        var mh$ = glIndexsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexsv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static FunctionDescriptor glIndexub$descriptor() {
        return glIndexub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static MethodHandle glIndexub$handle() {
        return glIndexub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static MemorySegment glIndexub$address() {
        return glIndexub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static void glIndexub(byte c) {
        var mh$ = glIndexub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexub", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIndexubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static FunctionDescriptor glIndexubv$descriptor() {
        return glIndexubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static MethodHandle glIndexubv$handle() {
        return glIndexubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static MemorySegment glIndexubv$address() {
        return glIndexubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static void glIndexubv(MemorySegment c) {
        var mh$ = glIndexubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexubv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInitNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glInitNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static FunctionDescriptor glInitNames$descriptor() {
        return glInitNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static MethodHandle glInitNames$handle() {
        return glInitNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static MemorySegment glInitNames$address() {
        return glInitNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static void glInitNames() {
        var mh$ = glInitNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInitNames");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInterleavedArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glInterleavedArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glInterleavedArrays$descriptor() {
        return glInterleavedArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glInterleavedArrays$handle() {
        return glInterleavedArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glInterleavedArrays$address() {
        return glInterleavedArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glInterleavedArrays(int format, int stride, MemorySegment pointer) {
        var mh$ = glInterleavedArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInterleavedArrays", format, stride, pointer);
            }
            mh$.invokeExact(format, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static FunctionDescriptor glIsEnabled$descriptor() {
        return glIsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static MethodHandle glIsEnabled$handle() {
        return glIsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static MemorySegment glIsEnabled$address() {
        return glIsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static byte glIsEnabled(int cap) {
        var mh$ = glIsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsEnabled", cap);
            }
            return (byte)mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIsList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static FunctionDescriptor glIsList$descriptor() {
        return glIsList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static MethodHandle glIsList$handle() {
        return glIsList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static MemorySegment glIsList$address() {
        return glIsList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static byte glIsList(int list) {
        var mh$ = glIsList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsList", list);
            }
            return (byte)mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glIsTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static FunctionDescriptor glIsTexture$descriptor() {
        return glIsTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MethodHandle glIsTexture$handle() {
        return glIsTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MemorySegment glIsTexture$address() {
        return glIsTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static byte glIsTexture(int texture) {
        var mh$ = glIsTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsTexture", texture);
            }
            return (byte)mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLightModelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightModelf$descriptor() {
        return glLightModelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightModelf$handle() {
        return glLightModelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightModelf$address() {
        return glLightModelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static void glLightModelf(int pname, float param) {
        var mh$ = glLightModelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLightModelfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightModelfv$descriptor() {
        return glLightModelfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightModelfv$handle() {
        return glLightModelfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightModelfv$address() {
        return glLightModelfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightModelfv(int pname, MemorySegment params) {
        var mh$ = glLightModelfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeli {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLightModeli");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLightModeli$descriptor() {
        return glLightModeli.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLightModeli$handle() {
        return glLightModeli.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLightModeli$address() {
        return glLightModeli.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static void glLightModeli(int pname, int param) {
        var mh$ = glLightModeli.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeli", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeliv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLightModeliv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightModeliv$descriptor() {
        return glLightModeliv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightModeliv$handle() {
        return glLightModeliv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightModeliv$address() {
        return glLightModeliv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static void glLightModeliv(int pname, MemorySegment params) {
        var mh$ = glLightModeliv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeliv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLightf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightf$descriptor() {
        return glLightf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightf$handle() {
        return glLightf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightf$address() {
        return glLightf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static void glLightf(int light, int pname, float param) {
        var mh$ = glLightf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightf", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightfv$descriptor() {
        return glLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightfv$handle() {
        return glLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightfv$address() {
        return glLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLighti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLighti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLighti$descriptor() {
        return glLighti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLighti$handle() {
        return glLighti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLighti$address() {
        return glLighti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static void glLighti(int light, int pname, int param) {
        var mh$ = glLighti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLighti", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightiv$descriptor() {
        return glLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightiv$handle() {
        return glLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightiv$address() {
        return glLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static void glLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLineStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLineStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static FunctionDescriptor glLineStipple$descriptor() {
        return glLineStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static MethodHandle glLineStipple$handle() {
        return glLineStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static MemorySegment glLineStipple$address() {
        return glLineStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static void glLineStipple(int factor, short pattern) {
        var mh$ = glLineStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLineStipple", factor, pattern);
            }
            mh$.invokeExact(factor, pattern);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLineWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLineWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static FunctionDescriptor glLineWidth$descriptor() {
        return glLineWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static MethodHandle glLineWidth$handle() {
        return glLineWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static MemorySegment glLineWidth$address() {
        return glLineWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static void glLineWidth(float width) {
        var mh$ = glLineWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLineWidth", width);
            }
            mh$.invokeExact(width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glListBase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glListBase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static FunctionDescriptor glListBase$descriptor() {
        return glListBase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static MethodHandle glListBase$handle() {
        return glListBase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static MemorySegment glListBase$address() {
        return glListBase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static void glListBase(int base) {
        var mh$ = glListBase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glListBase", base);
            }
            mh$.invokeExact(base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLoadIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static FunctionDescriptor glLoadIdentity$descriptor() {
        return glLoadIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static MethodHandle glLoadIdentity$handle() {
        return glLoadIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static MemorySegment glLoadIdentity$address() {
        return glLoadIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static void glLoadIdentity() {
        var mh$ = glLoadIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadIdentity");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLoadMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glLoadMatrixd$descriptor() {
        return glLoadMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glLoadMatrixd$handle() {
        return glLoadMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glLoadMatrixd$address() {
        return glLoadMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static void glLoadMatrixd(MemorySegment m) {
        var mh$ = glLoadMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLoadMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glLoadMatrixf$descriptor() {
        return glLoadMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glLoadMatrixf$handle() {
        return glLoadMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glLoadMatrixf$address() {
        return glLoadMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static void glLoadMatrixf(MemorySegment m) {
        var mh$ = glLoadMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLoadName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static FunctionDescriptor glLoadName$descriptor() {
        return glLoadName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static MethodHandle glLoadName$handle() {
        return glLoadName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static MemorySegment glLoadName$address() {
        return glLoadName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static void glLoadName(int name) {
        var mh$ = glLoadName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLogicOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glLogicOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static FunctionDescriptor glLogicOp$descriptor() {
        return glLogicOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static MethodHandle glLogicOp$handle() {
        return glLogicOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static MemorySegment glLogicOp$address() {
        return glLogicOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static void glLogicOp(int opcode) {
        var mh$ = glLogicOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLogicOp", opcode);
            }
            mh$.invokeExact(opcode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMap1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap1d$descriptor() {
        return glMap1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap1d$handle() {
        return glMap1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap1d$address() {
        return glMap1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static void glMap1d(int target, double u1, double u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1d", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMap1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap1f$descriptor() {
        return glMap1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap1f$handle() {
        return glMap1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap1f$address() {
        return glMap1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static void glMap1f(int target, float u1, float u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1f", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMap2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap2d$descriptor() {
        return glMap2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap2d$handle() {
        return glMap2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap2d$address() {
        return glMap2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2d", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMap2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap2f$descriptor() {
        return glMap2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap2f$handle() {
        return glMap2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap2f$address() {
        return glMap2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2f", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMapGrid1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1d$descriptor() {
        return glMapGrid1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MethodHandle glMapGrid1d$handle() {
        return glMapGrid1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MemorySegment glMapGrid1d$address() {
        return glMapGrid1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static void glMapGrid1d(int un, double u1, double u2) {
        var mh$ = glMapGrid1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1d", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMapGrid1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1f$descriptor() {
        return glMapGrid1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MethodHandle glMapGrid1f$handle() {
        return glMapGrid1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MemorySegment glMapGrid1f$address() {
        return glMapGrid1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static void glMapGrid1f(int un, float u1, float u2) {
        var mh$ = glMapGrid1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1f", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_INT,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMapGrid2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2d$descriptor() {
        return glMapGrid2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MethodHandle glMapGrid2d$handle() {
        return glMapGrid2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MemorySegment glMapGrid2d$address() {
        return glMapGrid2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static void glMapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) {
        var mh$ = glMapGrid2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2d", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_INT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMapGrid2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2f$descriptor() {
        return glMapGrid2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MethodHandle glMapGrid2f$handle() {
        return glMapGrid2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MemorySegment glMapGrid2f$address() {
        return glMapGrid2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static void glMapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) {
        var mh$ = glMapGrid2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2f", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMaterialf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glMaterialf$descriptor() {
        return glMaterialf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glMaterialf$handle() {
        return glMaterialf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glMaterialf$address() {
        return glMaterialf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static void glMaterialf(int face, int pname, float param) {
        var mh$ = glMaterialf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialf", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glMaterialfv$descriptor() {
        return glMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glMaterialfv$handle() {
        return glMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glMaterialfv$address() {
        return glMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMateriali {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMateriali");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glMateriali$descriptor() {
        return glMateriali.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glMateriali$handle() {
        return glMateriali.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glMateriali$address() {
        return glMateriali.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static void glMateriali(int face, int pname, int param) {
        var mh$ = glMateriali.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMateriali", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glMaterialiv$descriptor() {
        return glMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glMaterialiv$handle() {
        return glMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glMaterialiv$address() {
        return glMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static void glMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMatrixMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMatrixMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static FunctionDescriptor glMatrixMode$descriptor() {
        return glMatrixMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static MethodHandle glMatrixMode$handle() {
        return glMatrixMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static MemorySegment glMatrixMode$address() {
        return glMatrixMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static void glMatrixMode(int mode) {
        var mh$ = glMatrixMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMatrixMode", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMultMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glMultMatrixd$descriptor() {
        return glMultMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glMultMatrixd$handle() {
        return glMultMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glMultMatrixd$address() {
        return glMultMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static void glMultMatrixd(MemorySegment m) {
        var mh$ = glMultMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glMultMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glMultMatrixf$descriptor() {
        return glMultMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glMultMatrixf$handle() {
        return glMultMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glMultMatrixf$address() {
        return glMultMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static void glMultMatrixf(MemorySegment m) {
        var mh$ = glMultMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNewList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNewList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static FunctionDescriptor glNewList$descriptor() {
        return glNewList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static MethodHandle glNewList$handle() {
        return glNewList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static MemorySegment glNewList$address() {
        return glNewList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static void glNewList(int list, int mode) {
        var mh$ = glNewList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNewList", list, mode);
            }
            mh$.invokeExact(list, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_CHAR,
            wgl_h.C_CHAR,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNormal3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static FunctionDescriptor glNormal3b$descriptor() {
        return glNormal3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static MethodHandle glNormal3b$handle() {
        return glNormal3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static MemorySegment glNormal3b$address() {
        return glNormal3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static void glNormal3b(byte nx, byte ny, byte nz) {
        var mh$ = glNormal3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3b", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNormal3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glNormal3bv$descriptor() {
        return glNormal3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glNormal3bv$handle() {
        return glNormal3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glNormal3bv$address() {
        return glNormal3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static void glNormal3bv(MemorySegment v) {
        var mh$ = glNormal3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNormal3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static FunctionDescriptor glNormal3d$descriptor() {
        return glNormal3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static MethodHandle glNormal3d$handle() {
        return glNormal3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static MemorySegment glNormal3d$address() {
        return glNormal3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static void glNormal3d(double nx, double ny, double nz) {
        var mh$ = glNormal3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3d", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNormal3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glNormal3dv$descriptor() {
        return glNormal3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glNormal3dv$handle() {
        return glNormal3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glNormal3dv$address() {
        return glNormal3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static void glNormal3dv(MemorySegment v) {
        var mh$ = glNormal3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNormal3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static FunctionDescriptor glNormal3f$descriptor() {
        return glNormal3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static MethodHandle glNormal3f$handle() {
        return glNormal3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static MemorySegment glNormal3f$address() {
        return glNormal3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static void glNormal3f(float nx, float ny, float nz) {
        var mh$ = glNormal3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3f", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNormal3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glNormal3fv$descriptor() {
        return glNormal3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glNormal3fv$handle() {
        return glNormal3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glNormal3fv$address() {
        return glNormal3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static void glNormal3fv(MemorySegment v) {
        var mh$ = glNormal3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNormal3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static FunctionDescriptor glNormal3i$descriptor() {
        return glNormal3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static MethodHandle glNormal3i$handle() {
        return glNormal3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static MemorySegment glNormal3i$address() {
        return glNormal3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static void glNormal3i(int nx, int ny, int nz) {
        var mh$ = glNormal3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3i", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNormal3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glNormal3iv$descriptor() {
        return glNormal3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static MethodHandle glNormal3iv$handle() {
        return glNormal3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static MemorySegment glNormal3iv$address() {
        return glNormal3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static void glNormal3iv(MemorySegment v) {
        var mh$ = glNormal3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNormal3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static FunctionDescriptor glNormal3s$descriptor() {
        return glNormal3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static MethodHandle glNormal3s$handle() {
        return glNormal3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static MemorySegment glNormal3s$address() {
        return glNormal3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static void glNormal3s(short nx, short ny, short nz) {
        var mh$ = glNormal3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3s", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNormal3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glNormal3sv$descriptor() {
        return glNormal3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glNormal3sv$handle() {
        return glNormal3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glNormal3sv$address() {
        return glNormal3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static void glNormal3sv(MemorySegment v) {
        var mh$ = glNormal3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormalPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glNormalPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glNormalPointer$descriptor() {
        return glNormalPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glNormalPointer$handle() {
        return glNormalPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glNormalPointer$address() {
        return glNormalPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glNormalPointer(int type, int stride, MemorySegment pointer) {
        var mh$ = glNormalPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormalPointer", type, stride, pointer);
            }
            mh$.invokeExact(type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glOrtho {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glOrtho");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static FunctionDescriptor glOrtho$descriptor() {
        return glOrtho.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MethodHandle glOrtho$handle() {
        return glOrtho.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MemorySegment glOrtho$address() {
        return glOrtho.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static void glOrtho(double left, double right, double bottom, double top, double zNear, double zFar) {
        var mh$ = glOrtho.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glOrtho", left, right, bottom, top, zNear, zFar);
            }
            mh$.invokeExact(left, right, bottom, top, zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPassThrough {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPassThrough");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static FunctionDescriptor glPassThrough$descriptor() {
        return glPassThrough.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static MethodHandle glPassThrough$handle() {
        return glPassThrough.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static MemorySegment glPassThrough$address() {
        return glPassThrough.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static void glPassThrough(float token) {
        var mh$ = glPassThrough.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPassThrough", token);
            }
            mh$.invokeExact(token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static FunctionDescriptor glPixelMapfv$descriptor() {
        return glPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static MethodHandle glPixelMapfv$handle() {
        return glPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static MemorySegment glPixelMapfv$address() {
        return glPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static void glPixelMapfv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapfv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static FunctionDescriptor glPixelMapuiv$descriptor() {
        return glPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static MethodHandle glPixelMapuiv$handle() {
        return glPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static MemorySegment glPixelMapuiv$address() {
        return glPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static void glPixelMapuiv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapuiv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static FunctionDescriptor glPixelMapusv$descriptor() {
        return glPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static MethodHandle glPixelMapusv$handle() {
        return glPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static MemorySegment glPixelMapusv$address() {
        return glPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static void glPixelMapusv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapusv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStoref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPixelStoref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelStoref$descriptor() {
        return glPixelStoref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelStoref$handle() {
        return glPixelStoref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelStoref$address() {
        return glPixelStoref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelStoref(int pname, float param) {
        var mh$ = glPixelStoref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStoref", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStorei {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPixelStorei");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelStorei$descriptor() {
        return glPixelStorei.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelStorei$handle() {
        return glPixelStorei.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelStorei$address() {
        return glPixelStorei.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static void glPixelStorei(int pname, int param) {
        var mh$ = glPixelStorei.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStorei", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPixelTransferf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelTransferf$descriptor() {
        return glPixelTransferf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelTransferf$handle() {
        return glPixelTransferf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelTransferf$address() {
        return glPixelTransferf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelTransferf(int pname, float param) {
        var mh$ = glPixelTransferf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPixelTransferi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelTransferi$descriptor() {
        return glPixelTransferi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelTransferi$handle() {
        return glPixelTransferi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelTransferi$address() {
        return glPixelTransferi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static void glPixelTransferi(int pname, int param) {
        var mh$ = glPixelTransferi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelZoom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPixelZoom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static FunctionDescriptor glPixelZoom$descriptor() {
        return glPixelZoom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MethodHandle glPixelZoom$handle() {
        return glPixelZoom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MemorySegment glPixelZoom$address() {
        return glPixelZoom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static void glPixelZoom(float xfactor, float yfactor) {
        var mh$ = glPixelZoom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelZoom", xfactor, yfactor);
            }
            mh$.invokeExact(xfactor, yfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPointSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static FunctionDescriptor glPointSize$descriptor() {
        return glPointSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static MethodHandle glPointSize$handle() {
        return glPointSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static MemorySegment glPointSize$address() {
        return glPointSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static void glPointSize(float size) {
        var mh$ = glPointSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointSize", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPolygonMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static FunctionDescriptor glPolygonMode$descriptor() {
        return glPolygonMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static MethodHandle glPolygonMode$handle() {
        return glPolygonMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static MemorySegment glPolygonMode$address() {
        return glPolygonMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static void glPolygonMode(int face, int mode) {
        var mh$ = glPolygonMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonMode", face, mode);
            }
            mh$.invokeExact(face, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPolygonOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static FunctionDescriptor glPolygonOffset$descriptor() {
        return glPolygonOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static MethodHandle glPolygonOffset$handle() {
        return glPolygonOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static MemorySegment glPolygonOffset$address() {
        return glPolygonOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static void glPolygonOffset(float factor, float units) {
        var mh$ = glPolygonOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonOffset", factor, units);
            }
            mh$.invokeExact(factor, units);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPolygonStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static FunctionDescriptor glPolygonStipple$descriptor() {
        return glPolygonStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static MethodHandle glPolygonStipple$handle() {
        return glPolygonStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static MemorySegment glPolygonStipple$address() {
        return glPolygonStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static void glPolygonStipple(MemorySegment mask) {
        var mh$ = glPolygonStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonStipple", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPopAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static FunctionDescriptor glPopAttrib$descriptor() {
        return glPopAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static MethodHandle glPopAttrib$handle() {
        return glPopAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static MemorySegment glPopAttrib$address() {
        return glPopAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static void glPopAttrib() {
        var mh$ = glPopAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopAttrib");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopClientAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPopClientAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static FunctionDescriptor glPopClientAttrib$descriptor() {
        return glPopClientAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static MethodHandle glPopClientAttrib$handle() {
        return glPopClientAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static MemorySegment glPopClientAttrib$address() {
        return glPopClientAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static void glPopClientAttrib() {
        var mh$ = glPopClientAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopClientAttrib");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPopMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static FunctionDescriptor glPopMatrix$descriptor() {
        return glPopMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static MethodHandle glPopMatrix$handle() {
        return glPopMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static MemorySegment glPopMatrix$address() {
        return glPopMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static void glPopMatrix() {
        var mh$ = glPopMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPopName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static FunctionDescriptor glPopName$descriptor() {
        return glPopName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static MethodHandle glPopName$handle() {
        return glPopName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static MemorySegment glPopName$address() {
        return glPopName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static void glPopName() {
        var mh$ = glPopName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopName");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPrioritizeTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPrioritizeTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static FunctionDescriptor glPrioritizeTextures$descriptor() {
        return glPrioritizeTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MethodHandle glPrioritizeTextures$handle() {
        return glPrioritizeTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MemorySegment glPrioritizeTextures$address() {
        return glPrioritizeTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static void glPrioritizeTextures(int n, MemorySegment textures, MemorySegment priorities) {
        var mh$ = glPrioritizeTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPrioritizeTextures", n, textures, priorities);
            }
            mh$.invokeExact(n, textures, priorities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPushAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glPushAttrib$descriptor() {
        return glPushAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static MethodHandle glPushAttrib$handle() {
        return glPushAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static MemorySegment glPushAttrib$address() {
        return glPushAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static void glPushAttrib(int mask) {
        var mh$ = glPushAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushAttrib", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushClientAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPushClientAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glPushClientAttrib$descriptor() {
        return glPushClientAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static MethodHandle glPushClientAttrib$handle() {
        return glPushClientAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static MemorySegment glPushClientAttrib$address() {
        return glPushClientAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static void glPushClientAttrib(int mask) {
        var mh$ = glPushClientAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushClientAttrib", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPushMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static FunctionDescriptor glPushMatrix$descriptor() {
        return glPushMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static MethodHandle glPushMatrix$handle() {
        return glPushMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static MemorySegment glPushMatrix$address() {
        return glPushMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static void glPushMatrix() {
        var mh$ = glPushMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glPushName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static FunctionDescriptor glPushName$descriptor() {
        return glPushName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static MethodHandle glPushName$handle() {
        return glPushName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static MemorySegment glPushName$address() {
        return glPushName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static void glPushName(int name) {
        var mh$ = glPushName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glRasterPos2d$descriptor() {
        return glRasterPos2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glRasterPos2d$handle() {
        return glRasterPos2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glRasterPos2d$address() {
        return glRasterPos2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glRasterPos2d(double x, double y) {
        var mh$ = glRasterPos2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2dv$descriptor() {
        return glRasterPos2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos2dv$handle() {
        return glRasterPos2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos2dv$address() {
        return glRasterPos2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos2dv(MemorySegment v) {
        var mh$ = glRasterPos2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glRasterPos2f$descriptor() {
        return glRasterPos2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glRasterPos2f$handle() {
        return glRasterPos2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glRasterPos2f$address() {
        return glRasterPos2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glRasterPos2f(float x, float y) {
        var mh$ = glRasterPos2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2fv$descriptor() {
        return glRasterPos2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos2fv$handle() {
        return glRasterPos2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos2fv$address() {
        return glRasterPos2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos2fv(MemorySegment v) {
        var mh$ = glRasterPos2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glRasterPos2i$descriptor() {
        return glRasterPos2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glRasterPos2i$handle() {
        return glRasterPos2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glRasterPos2i$address() {
        return glRasterPos2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static void glRasterPos2i(int x, int y) {
        var mh$ = glRasterPos2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2iv$descriptor() {
        return glRasterPos2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos2iv$handle() {
        return glRasterPos2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos2iv$address() {
        return glRasterPos2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static void glRasterPos2iv(MemorySegment v) {
        var mh$ = glRasterPos2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glRasterPos2s$descriptor() {
        return glRasterPos2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glRasterPos2s$handle() {
        return glRasterPos2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glRasterPos2s$address() {
        return glRasterPos2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static void glRasterPos2s(short x, short y) {
        var mh$ = glRasterPos2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2sv$descriptor() {
        return glRasterPos2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos2sv$handle() {
        return glRasterPos2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos2sv$address() {
        return glRasterPos2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static void glRasterPos2sv(MemorySegment v) {
        var mh$ = glRasterPos2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glRasterPos3d$descriptor() {
        return glRasterPos3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glRasterPos3d$handle() {
        return glRasterPos3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glRasterPos3d$address() {
        return glRasterPos3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glRasterPos3d(double x, double y, double z) {
        var mh$ = glRasterPos3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3dv$descriptor() {
        return glRasterPos3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos3dv$handle() {
        return glRasterPos3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos3dv$address() {
        return glRasterPos3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos3dv(MemorySegment v) {
        var mh$ = glRasterPos3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glRasterPos3f$descriptor() {
        return glRasterPos3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glRasterPos3f$handle() {
        return glRasterPos3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glRasterPos3f$address() {
        return glRasterPos3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glRasterPos3f(float x, float y, float z) {
        var mh$ = glRasterPos3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3fv$descriptor() {
        return glRasterPos3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos3fv$handle() {
        return glRasterPos3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos3fv$address() {
        return glRasterPos3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos3fv(MemorySegment v) {
        var mh$ = glRasterPos3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glRasterPos3i$descriptor() {
        return glRasterPos3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glRasterPos3i$handle() {
        return glRasterPos3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glRasterPos3i$address() {
        return glRasterPos3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glRasterPos3i(int x, int y, int z) {
        var mh$ = glRasterPos3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3iv$descriptor() {
        return glRasterPos3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos3iv$handle() {
        return glRasterPos3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos3iv$address() {
        return glRasterPos3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static void glRasterPos3iv(MemorySegment v) {
        var mh$ = glRasterPos3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glRasterPos3s$descriptor() {
        return glRasterPos3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glRasterPos3s$handle() {
        return glRasterPos3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glRasterPos3s$address() {
        return glRasterPos3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glRasterPos3s(short x, short y, short z) {
        var mh$ = glRasterPos3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3sv$descriptor() {
        return glRasterPos3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos3sv$handle() {
        return glRasterPos3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos3sv$address() {
        return glRasterPos3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static void glRasterPos3sv(MemorySegment v) {
        var mh$ = glRasterPos3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glRasterPos4d$descriptor() {
        return glRasterPos4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glRasterPos4d$handle() {
        return glRasterPos4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glRasterPos4d$address() {
        return glRasterPos4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glRasterPos4d(double x, double y, double z, double w) {
        var mh$ = glRasterPos4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4d", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4dv$descriptor() {
        return glRasterPos4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos4dv$handle() {
        return glRasterPos4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos4dv$address() {
        return glRasterPos4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos4dv(MemorySegment v) {
        var mh$ = glRasterPos4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glRasterPos4f$descriptor() {
        return glRasterPos4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glRasterPos4f$handle() {
        return glRasterPos4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glRasterPos4f$address() {
        return glRasterPos4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glRasterPos4f(float x, float y, float z, float w) {
        var mh$ = glRasterPos4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4fv$descriptor() {
        return glRasterPos4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos4fv$handle() {
        return glRasterPos4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos4fv$address() {
        return glRasterPos4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos4fv(MemorySegment v) {
        var mh$ = glRasterPos4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glRasterPos4i$descriptor() {
        return glRasterPos4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glRasterPos4i$handle() {
        return glRasterPos4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glRasterPos4i$address() {
        return glRasterPos4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glRasterPos4i(int x, int y, int z, int w) {
        var mh$ = glRasterPos4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4i", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4iv$descriptor() {
        return glRasterPos4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos4iv$handle() {
        return glRasterPos4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos4iv$address() {
        return glRasterPos4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static void glRasterPos4iv(MemorySegment v) {
        var mh$ = glRasterPos4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glRasterPos4s$descriptor() {
        return glRasterPos4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glRasterPos4s$handle() {
        return glRasterPos4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glRasterPos4s$address() {
        return glRasterPos4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glRasterPos4s(short x, short y, short z, short w) {
        var mh$ = glRasterPos4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4s", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRasterPos4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4sv$descriptor() {
        return glRasterPos4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos4sv$handle() {
        return glRasterPos4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos4sv$address() {
        return glRasterPos4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static void glRasterPos4sv(MemorySegment v) {
        var mh$ = glRasterPos4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glReadBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glReadBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static FunctionDescriptor glReadBuffer$descriptor() {
        return glReadBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static MethodHandle glReadBuffer$handle() {
        return glReadBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static MemorySegment glReadBuffer$address() {
        return glReadBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static void glReadBuffer(int mode) {
        var mh$ = glReadBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glReadBuffer", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glReadPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glReadPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glReadPixels$descriptor() {
        return glReadPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glReadPixels$handle() {
        return glReadPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glReadPixels$address() {
        return glReadPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glReadPixels(int x, int y, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glReadPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glReadPixels", x, y, width, height, format, type, pixels);
            }
            mh$.invokeExact(x, y, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRectd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static FunctionDescriptor glRectd$descriptor() {
        return glRectd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MethodHandle glRectd$handle() {
        return glRectd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MemorySegment glRectd$address() {
        return glRectd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static void glRectd(double x1, double y1, double x2, double y2) {
        var mh$ = glRectd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectd", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRectdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static FunctionDescriptor glRectdv$descriptor() {
        return glRectdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MethodHandle glRectdv$handle() {
        return glRectdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MemorySegment glRectdv$address() {
        return glRectdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static void glRectdv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectdv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRectf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static FunctionDescriptor glRectf$descriptor() {
        return glRectf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MethodHandle glRectf$handle() {
        return glRectf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MemorySegment glRectf$address() {
        return glRectf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static void glRectf(float x1, float y1, float x2, float y2) {
        var mh$ = glRectf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectf", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRectfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static FunctionDescriptor glRectfv$descriptor() {
        return glRectfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MethodHandle glRectfv$handle() {
        return glRectfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MemorySegment glRectfv$address() {
        return glRectfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static void glRectfv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectfv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRecti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRecti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static FunctionDescriptor glRecti$descriptor() {
        return glRecti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MethodHandle glRecti$handle() {
        return glRecti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MemorySegment glRecti$address() {
        return glRecti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static void glRecti(int x1, int y1, int x2, int y2) {
        var mh$ = glRecti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRecti", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRectiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static FunctionDescriptor glRectiv$descriptor() {
        return glRectiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MethodHandle glRectiv$handle() {
        return glRectiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MemorySegment glRectiv$address() {
        return glRectiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static void glRectiv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectiv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static FunctionDescriptor glRects$descriptor() {
        return glRects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MethodHandle glRects$handle() {
        return glRects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MemorySegment glRects$address() {
        return glRects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static void glRects(short x1, short y1, short x2, short y2) {
        var mh$ = glRects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRects", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRectsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static FunctionDescriptor glRectsv$descriptor() {
        return glRectsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MethodHandle glRectsv$handle() {
        return glRectsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MemorySegment glRectsv$address() {
        return glRectsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static void glRectsv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectsv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRenderMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRenderMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static FunctionDescriptor glRenderMode$descriptor() {
        return glRenderMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static MethodHandle glRenderMode$handle() {
        return glRenderMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static MemorySegment glRenderMode$address() {
        return glRenderMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static int glRenderMode(int mode) {
        var mh$ = glRenderMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRenderMode", mode);
            }
            return (int)mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRotated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRotated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glRotated$descriptor() {
        return glRotated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glRotated$handle() {
        return glRotated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glRotated$address() {
        return glRotated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glRotated(double angle, double x, double y, double z) {
        var mh$ = glRotated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRotated", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRotatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glRotatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glRotatef$descriptor() {
        return glRotatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glRotatef$handle() {
        return glRotatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glRotatef$address() {
        return glRotatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glRotatef(float angle, float x, float y, float z) {
        var mh$ = glRotatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRotatef", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScaled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glScaled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glScaled$descriptor() {
        return glScaled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glScaled$handle() {
        return glScaled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glScaled$address() {
        return glScaled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glScaled(double x, double y, double z) {
        var mh$ = glScaled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScaled", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScalef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glScalef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glScalef$descriptor() {
        return glScalef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glScalef$handle() {
        return glScalef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glScalef$address() {
        return glScalef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glScalef(float x, float y, float z) {
        var mh$ = glScalef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScalef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScissor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glScissor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glScissor$descriptor() {
        return glScissor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glScissor$handle() {
        return glScissor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glScissor$address() {
        return glScissor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glScissor(int x, int y, int width, int height) {
        var mh$ = glScissor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScissor", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSelectBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glSelectBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static FunctionDescriptor glSelectBuffer$descriptor() {
        return glSelectBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MethodHandle glSelectBuffer$handle() {
        return glSelectBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MemorySegment glSelectBuffer$address() {
        return glSelectBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static void glSelectBuffer(int size, MemorySegment buffer) {
        var mh$ = glSelectBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSelectBuffer", size, buffer);
            }
            mh$.invokeExact(size, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glShadeModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glShadeModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static FunctionDescriptor glShadeModel$descriptor() {
        return glShadeModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static MethodHandle glShadeModel$handle() {
        return glShadeModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static MemorySegment glShadeModel$address() {
        return glShadeModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static void glShadeModel(int mode) {
        var mh$ = glShadeModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glShadeModel", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glStencilFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilFunc$descriptor() {
        return glStencilFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MethodHandle glStencilFunc$handle() {
        return glStencilFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MemorySegment glStencilFunc$address() {
        return glStencilFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static void glStencilFunc(int func, int ref, int mask) {
        var mh$ = glStencilFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilFunc", func, ref, mask);
            }
            mh$.invokeExact(func, ref, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glStencilMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilMask$descriptor() {
        return glStencilMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static MethodHandle glStencilMask$handle() {
        return glStencilMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static MemorySegment glStencilMask$address() {
        return glStencilMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static void glStencilMask(int mask) {
        var mh$ = glStencilMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilMask", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glStencilOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static FunctionDescriptor glStencilOp$descriptor() {
        return glStencilOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MethodHandle glStencilOp$handle() {
        return glStencilOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MemorySegment glStencilOp$address() {
        return glStencilOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static void glStencilOp(int fail, int zfail, int zpass) {
        var mh$ = glStencilOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilOp", fail, zfail, zpass);
            }
            mh$.invokeExact(fail, zfail, zpass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static FunctionDescriptor glTexCoord1d$descriptor() {
        return glTexCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static MethodHandle glTexCoord1d$handle() {
        return glTexCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static MemorySegment glTexCoord1d$address() {
        return glTexCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static void glTexCoord1d(double s) {
        var mh$ = glTexCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1d", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1dv$descriptor() {
        return glTexCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord1dv$handle() {
        return glTexCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord1dv$address() {
        return glTexCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord1dv(MemorySegment v) {
        var mh$ = glTexCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static FunctionDescriptor glTexCoord1f$descriptor() {
        return glTexCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static MethodHandle glTexCoord1f$handle() {
        return glTexCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static MemorySegment glTexCoord1f$address() {
        return glTexCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static void glTexCoord1f(float s) {
        var mh$ = glTexCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1f", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1fv$descriptor() {
        return glTexCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord1fv$handle() {
        return glTexCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord1fv$address() {
        return glTexCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord1fv(MemorySegment v) {
        var mh$ = glTexCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord1i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static FunctionDescriptor glTexCoord1i$descriptor() {
        return glTexCoord1i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static MethodHandle glTexCoord1i$handle() {
        return glTexCoord1i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static MemorySegment glTexCoord1i$address() {
        return glTexCoord1i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static void glTexCoord1i(int s) {
        var mh$ = glTexCoord1i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1i", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord1iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1iv$descriptor() {
        return glTexCoord1iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord1iv$handle() {
        return glTexCoord1iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord1iv$address() {
        return glTexCoord1iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static void glTexCoord1iv(MemorySegment v) {
        var mh$ = glTexCoord1iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord1s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static FunctionDescriptor glTexCoord1s$descriptor() {
        return glTexCoord1s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static MethodHandle glTexCoord1s$handle() {
        return glTexCoord1s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static MemorySegment glTexCoord1s$address() {
        return glTexCoord1s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static void glTexCoord1s(short s) {
        var mh$ = glTexCoord1s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1s", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord1sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1sv$descriptor() {
        return glTexCoord1sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord1sv$handle() {
        return glTexCoord1sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord1sv$address() {
        return glTexCoord1sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static void glTexCoord1sv(MemorySegment v) {
        var mh$ = glTexCoord1sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glTexCoord2d$descriptor() {
        return glTexCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glTexCoord2d$handle() {
        return glTexCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glTexCoord2d$address() {
        return glTexCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static void glTexCoord2d(double s, double t) {
        var mh$ = glTexCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2d", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2dv$descriptor() {
        return glTexCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord2dv$handle() {
        return glTexCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord2dv$address() {
        return glTexCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord2dv(MemorySegment v) {
        var mh$ = glTexCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glTexCoord2f$descriptor() {
        return glTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glTexCoord2f$handle() {
        return glTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glTexCoord2f$address() {
        return glTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static void glTexCoord2f(float s, float t) {
        var mh$ = glTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2f", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2fv$descriptor() {
        return glTexCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord2fv$handle() {
        return glTexCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord2fv$address() {
        return glTexCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord2fv(MemorySegment v) {
        var mh$ = glTexCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glTexCoord2i$descriptor() {
        return glTexCoord2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MethodHandle glTexCoord2i$handle() {
        return glTexCoord2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MemorySegment glTexCoord2i$address() {
        return glTexCoord2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static void glTexCoord2i(int s, int t) {
        var mh$ = glTexCoord2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2i", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2iv$descriptor() {
        return glTexCoord2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord2iv$handle() {
        return glTexCoord2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord2iv$address() {
        return glTexCoord2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static void glTexCoord2iv(MemorySegment v) {
        var mh$ = glTexCoord2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glTexCoord2s$descriptor() {
        return glTexCoord2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glTexCoord2s$handle() {
        return glTexCoord2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glTexCoord2s$address() {
        return glTexCoord2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static void glTexCoord2s(short s, short t) {
        var mh$ = glTexCoord2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2s", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2sv$descriptor() {
        return glTexCoord2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord2sv$handle() {
        return glTexCoord2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord2sv$address() {
        return glTexCoord2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static void glTexCoord2sv(MemorySegment v) {
        var mh$ = glTexCoord2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glTexCoord3d$descriptor() {
        return glTexCoord3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glTexCoord3d$handle() {
        return glTexCoord3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glTexCoord3d$address() {
        return glTexCoord3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glTexCoord3d(double s, double t, double r) {
        var mh$ = glTexCoord3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3d", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3dv$descriptor() {
        return glTexCoord3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord3dv$handle() {
        return glTexCoord3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord3dv$address() {
        return glTexCoord3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord3dv(MemorySegment v) {
        var mh$ = glTexCoord3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glTexCoord3f$descriptor() {
        return glTexCoord3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glTexCoord3f$handle() {
        return glTexCoord3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glTexCoord3f$address() {
        return glTexCoord3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glTexCoord3f(float s, float t, float r) {
        var mh$ = glTexCoord3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3f", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3fv$descriptor() {
        return glTexCoord3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord3fv$handle() {
        return glTexCoord3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord3fv$address() {
        return glTexCoord3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord3fv(MemorySegment v) {
        var mh$ = glTexCoord3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glTexCoord3i$descriptor() {
        return glTexCoord3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glTexCoord3i$handle() {
        return glTexCoord3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glTexCoord3i$address() {
        return glTexCoord3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static void glTexCoord3i(int s, int t, int r) {
        var mh$ = glTexCoord3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3i", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3iv$descriptor() {
        return glTexCoord3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord3iv$handle() {
        return glTexCoord3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord3iv$address() {
        return glTexCoord3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static void glTexCoord3iv(MemorySegment v) {
        var mh$ = glTexCoord3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glTexCoord3s$descriptor() {
        return glTexCoord3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glTexCoord3s$handle() {
        return glTexCoord3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glTexCoord3s$address() {
        return glTexCoord3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glTexCoord3s(short s, short t, short r) {
        var mh$ = glTexCoord3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3s", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3sv$descriptor() {
        return glTexCoord3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord3sv$handle() {
        return glTexCoord3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord3sv$address() {
        return glTexCoord3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static void glTexCoord3sv(MemorySegment v) {
        var mh$ = glTexCoord3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glTexCoord4d$descriptor() {
        return glTexCoord4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glTexCoord4d$handle() {
        return glTexCoord4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glTexCoord4d$address() {
        return glTexCoord4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glTexCoord4d(double s, double t, double r, double q) {
        var mh$ = glTexCoord4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4d", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4dv$descriptor() {
        return glTexCoord4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord4dv$handle() {
        return glTexCoord4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord4dv$address() {
        return glTexCoord4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord4dv(MemorySegment v) {
        var mh$ = glTexCoord4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glTexCoord4f$descriptor() {
        return glTexCoord4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glTexCoord4f$handle() {
        return glTexCoord4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glTexCoord4f$address() {
        return glTexCoord4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glTexCoord4f(float s, float t, float r, float q) {
        var mh$ = glTexCoord4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4f", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4fv$descriptor() {
        return glTexCoord4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord4fv$handle() {
        return glTexCoord4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord4fv$address() {
        return glTexCoord4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord4fv(MemorySegment v) {
        var mh$ = glTexCoord4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glTexCoord4i$descriptor() {
        return glTexCoord4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glTexCoord4i$handle() {
        return glTexCoord4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glTexCoord4i$address() {
        return glTexCoord4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glTexCoord4i(int s, int t, int r, int q) {
        var mh$ = glTexCoord4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4i", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4iv$descriptor() {
        return glTexCoord4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord4iv$handle() {
        return glTexCoord4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord4iv$address() {
        return glTexCoord4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static void glTexCoord4iv(MemorySegment v) {
        var mh$ = glTexCoord4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glTexCoord4s$descriptor() {
        return glTexCoord4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glTexCoord4s$handle() {
        return glTexCoord4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glTexCoord4s$address() {
        return glTexCoord4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glTexCoord4s(short s, short t, short r, short q) {
        var mh$ = glTexCoord4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4s", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoord4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4sv$descriptor() {
        return glTexCoord4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord4sv$handle() {
        return glTexCoord4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord4sv$address() {
        return glTexCoord4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static void glTexCoord4sv(MemorySegment v) {
        var mh$ = glTexCoord4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoordPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexCoordPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glTexCoordPointer$descriptor() {
        return glTexCoordPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glTexCoordPointer$handle() {
        return glTexCoordPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glTexCoordPointer$address() {
        return glTexCoordPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glTexCoordPointer(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glTexCoordPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoordPointer", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexEnvf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexEnvf$descriptor() {
        return glTexEnvf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexEnvf$handle() {
        return glTexEnvf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexEnvf$address() {
        return glTexEnvf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexEnvf(int target, int pname, float param) {
        var mh$ = glTexEnvf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexEnvfv$descriptor() {
        return glTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexEnvfv$handle() {
        return glTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexEnvfv$address() {
        return glTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexEnvi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexEnvi$descriptor() {
        return glTexEnvi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexEnvi$handle() {
        return glTexEnvi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexEnvi$address() {
        return glTexEnvi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexEnvi(int target, int pname, int param) {
        var mh$ = glTexEnvi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvi", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexEnviv$descriptor() {
        return glTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexEnviv$handle() {
        return glTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexEnviv$address() {
        return glTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexGend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static FunctionDescriptor glTexGend$descriptor() {
        return glTexGend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MethodHandle glTexGend$handle() {
        return glTexGend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MemorySegment glTexGend$address() {
        return glTexGend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static void glTexGend(int coord, int pname, double param) {
        var mh$ = glTexGend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGend", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static FunctionDescriptor glTexGendv$descriptor() {
        return glTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MethodHandle glTexGendv$handle() {
        return glTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MemorySegment glTexGendv$address() {
        return glTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static void glTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexGenf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexGenf$descriptor() {
        return glTexGenf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexGenf$handle() {
        return glTexGenf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexGenf$address() {
        return glTexGenf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexGenf(int coord, int pname, float param) {
        var mh$ = glTexGenf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenf", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexGenfv$descriptor() {
        return glTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexGenfv$handle() {
        return glTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexGenfv$address() {
        return glTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeni {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexGeni");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexGeni$descriptor() {
        return glTexGeni.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexGeni$handle() {
        return glTexGeni.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexGeni$address() {
        return glTexGeni.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static void glTexGeni(int coord, int pname, int param) {
        var mh$ = glTexGeni.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeni", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexGeniv$descriptor() {
        return glTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexGeniv$handle() {
        return glTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexGeniv$address() {
        return glTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage1D$descriptor() {
        return glTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage1D$handle() {
        return glTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage1D$address() {
        return glTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage1D(int target, int level, int internalformat, int width, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage1D", target, level, internalformat, width, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalformat, width, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage2D$descriptor() {
        return glTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage2D$handle() {
        return glTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage2D$address() {
        return glTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage2D", target, level, internalformat, width, height, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalformat, width, height, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexParameterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexParameterf$descriptor() {
        return glTexParameterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexParameterf$handle() {
        return glTexParameterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexParameterf$address() {
        return glTexParameterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexParameterf(int target, int pname, float param) {
        var mh$ = glTexParameterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexParameterfv$descriptor() {
        return glTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexParameterfv$handle() {
        return glTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexParameterfv$address() {
        return glTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexParameteri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexParameteri$descriptor() {
        return glTexParameteri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexParameteri$handle() {
        return glTexParameteri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexParameteri$address() {
        return glTexParameteri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexParameteri(int target, int pname, int param) {
        var mh$ = glTexParameteri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteri", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexParameteriv$descriptor() {
        return glTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexParameteriv$handle() {
        return glTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexParameteriv$address() {
        return glTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage1D$descriptor() {
        return glTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage1D$handle() {
        return glTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage1D$address() {
        return glTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage1D(int target, int level, int xoffset, int width, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage1D", target, level, xoffset, width, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, width, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage2D$descriptor() {
        return glTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage2D$handle() {
        return glTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage2D$address() {
        return glTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage2D", target, level, xoffset, yoffset, width, height, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTranslated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTranslated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glTranslated$descriptor() {
        return glTranslated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glTranslated$handle() {
        return glTranslated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glTranslated$address() {
        return glTranslated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glTranslated(double x, double y, double z) {
        var mh$ = glTranslated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTranslated", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTranslatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glTranslatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glTranslatef$descriptor() {
        return glTranslatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glTranslatef$handle() {
        return glTranslatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glTranslatef$address() {
        return glTranslatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glTranslatef(float x, float y, float z) {
        var mh$ = glTranslatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTranslatef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glVertex2d$descriptor() {
        return glVertex2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glVertex2d$handle() {
        return glVertex2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glVertex2d$address() {
        return glVertex2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glVertex2d(double x, double y) {
        var mh$ = glVertex2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex2dv$descriptor() {
        return glVertex2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex2dv$handle() {
        return glVertex2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex2dv$address() {
        return glVertex2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static void glVertex2dv(MemorySegment v) {
        var mh$ = glVertex2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glVertex2f$descriptor() {
        return glVertex2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glVertex2f$handle() {
        return glVertex2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glVertex2f$address() {
        return glVertex2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glVertex2f(float x, float y) {
        var mh$ = glVertex2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex2fv$descriptor() {
        return glVertex2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex2fv$handle() {
        return glVertex2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex2fv$address() {
        return glVertex2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static void glVertex2fv(MemorySegment v) {
        var mh$ = glVertex2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glVertex2i$descriptor() {
        return glVertex2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glVertex2i$handle() {
        return glVertex2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glVertex2i$address() {
        return glVertex2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static void glVertex2i(int x, int y) {
        var mh$ = glVertex2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex2iv$descriptor() {
        return glVertex2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex2iv$handle() {
        return glVertex2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex2iv$address() {
        return glVertex2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static void glVertex2iv(MemorySegment v) {
        var mh$ = glVertex2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glVertex2s$descriptor() {
        return glVertex2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glVertex2s$handle() {
        return glVertex2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glVertex2s$address() {
        return glVertex2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static void glVertex2s(short x, short y) {
        var mh$ = glVertex2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex2sv$descriptor() {
        return glVertex2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex2sv$handle() {
        return glVertex2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex2sv$address() {
        return glVertex2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static void glVertex2sv(MemorySegment v) {
        var mh$ = glVertex2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glVertex3d$descriptor() {
        return glVertex3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glVertex3d$handle() {
        return glVertex3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glVertex3d$address() {
        return glVertex3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glVertex3d(double x, double y, double z) {
        var mh$ = glVertex3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex3dv$descriptor() {
        return glVertex3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex3dv$handle() {
        return glVertex3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex3dv$address() {
        return glVertex3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static void glVertex3dv(MemorySegment v) {
        var mh$ = glVertex3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glVertex3f$descriptor() {
        return glVertex3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glVertex3f$handle() {
        return glVertex3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glVertex3f$address() {
        return glVertex3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glVertex3f(float x, float y, float z) {
        var mh$ = glVertex3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex3fv$descriptor() {
        return glVertex3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex3fv$handle() {
        return glVertex3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex3fv$address() {
        return glVertex3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static void glVertex3fv(MemorySegment v) {
        var mh$ = glVertex3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glVertex3i$descriptor() {
        return glVertex3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glVertex3i$handle() {
        return glVertex3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glVertex3i$address() {
        return glVertex3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glVertex3i(int x, int y, int z) {
        var mh$ = glVertex3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex3iv$descriptor() {
        return glVertex3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex3iv$handle() {
        return glVertex3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex3iv$address() {
        return glVertex3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static void glVertex3iv(MemorySegment v) {
        var mh$ = glVertex3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glVertex3s$descriptor() {
        return glVertex3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glVertex3s$handle() {
        return glVertex3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glVertex3s$address() {
        return glVertex3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glVertex3s(short x, short y, short z) {
        var mh$ = glVertex3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex3sv$descriptor() {
        return glVertex3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex3sv$handle() {
        return glVertex3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex3sv$address() {
        return glVertex3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static void glVertex3sv(MemorySegment v) {
        var mh$ = glVertex3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glVertex4d$descriptor() {
        return glVertex4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glVertex4d$handle() {
        return glVertex4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glVertex4d$address() {
        return glVertex4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glVertex4d(double x, double y, double z, double w) {
        var mh$ = glVertex4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4d", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex4dv$descriptor() {
        return glVertex4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex4dv$handle() {
        return glVertex4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex4dv$address() {
        return glVertex4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static void glVertex4dv(MemorySegment v) {
        var mh$ = glVertex4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glVertex4f$descriptor() {
        return glVertex4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glVertex4f$handle() {
        return glVertex4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glVertex4f$address() {
        return glVertex4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glVertex4f(float x, float y, float z, float w) {
        var mh$ = glVertex4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex4fv$descriptor() {
        return glVertex4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex4fv$handle() {
        return glVertex4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex4fv$address() {
        return glVertex4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static void glVertex4fv(MemorySegment v) {
        var mh$ = glVertex4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glVertex4i$descriptor() {
        return glVertex4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glVertex4i$handle() {
        return glVertex4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glVertex4i$address() {
        return glVertex4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glVertex4i(int x, int y, int z, int w) {
        var mh$ = glVertex4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4i", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex4iv$descriptor() {
        return glVertex4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex4iv$handle() {
        return glVertex4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex4iv$address() {
        return glVertex4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static void glVertex4iv(MemorySegment v) {
        var mh$ = glVertex4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glVertex4s$descriptor() {
        return glVertex4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glVertex4s$handle() {
        return glVertex4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glVertex4s$address() {
        return glVertex4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glVertex4s(short x, short y, short z, short w) {
        var mh$ = glVertex4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4s", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertex4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex4sv$descriptor() {
        return glVertex4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex4sv$handle() {
        return glVertex4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex4sv$address() {
        return glVertex4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static void glVertex4sv(MemorySegment v) {
        var mh$ = glVertex4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glVertexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glVertexPointer$descriptor() {
        return glVertexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glVertexPointer$handle() {
        return glVertexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glVertexPointer$address() {
        return glVertexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glVertexPointer(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glVertexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexPointer", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glViewport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("glViewport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glViewport$descriptor() {
        return glViewport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glViewport$handle() {
        return glViewport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glViewport$address() {
        return glViewport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glViewport(int x, int y, int width, int height) {
        var mh$ = glViewport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glViewport", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluErrorString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluErrorString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum errCode)
     * }
     */
    public static FunctionDescriptor gluErrorString$descriptor() {
        return gluErrorString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum errCode)
     * }
     */
    public static MethodHandle gluErrorString$handle() {
        return gluErrorString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum errCode)
     * }
     */
    public static MemorySegment gluErrorString$address() {
        return gluErrorString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum errCode)
     * }
     */
    public static MemorySegment gluErrorString(int errCode) {
        var mh$ = gluErrorString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluErrorString", errCode);
            }
            return (MemorySegment)mh$.invokeExact(errCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluErrorUnicodeStringEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluErrorUnicodeStringEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wchar_t *gluErrorUnicodeStringEXT(GLenum errCode)
     * }
     */
    public static FunctionDescriptor gluErrorUnicodeStringEXT$descriptor() {
        return gluErrorUnicodeStringEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wchar_t *gluErrorUnicodeStringEXT(GLenum errCode)
     * }
     */
    public static MethodHandle gluErrorUnicodeStringEXT$handle() {
        return gluErrorUnicodeStringEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wchar_t *gluErrorUnicodeStringEXT(GLenum errCode)
     * }
     */
    public static MemorySegment gluErrorUnicodeStringEXT$address() {
        return gluErrorUnicodeStringEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wchar_t *gluErrorUnicodeStringEXT(GLenum errCode)
     * }
     */
    public static MemorySegment gluErrorUnicodeStringEXT(int errCode) {
        var mh$ = gluErrorUnicodeStringEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluErrorUnicodeStringEXT", errCode);
            }
            return (MemorySegment)mh$.invokeExact(errCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluGetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static FunctionDescriptor gluGetString$descriptor() {
        return gluGetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MethodHandle gluGetString$handle() {
        return gluGetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MemorySegment gluGetString$address() {
        return gluGetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MemorySegment gluGetString(int name) {
        var mh$ = gluGetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetString", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluOrtho2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluOrtho2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static FunctionDescriptor gluOrtho2D$descriptor() {
        return gluOrtho2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static MethodHandle gluOrtho2D$handle() {
        return gluOrtho2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static MemorySegment gluOrtho2D$address() {
        return gluOrtho2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static void gluOrtho2D(double left, double right, double bottom, double top) {
        var mh$ = gluOrtho2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluOrtho2D", left, right, bottom, top);
            }
            mh$.invokeExact(left, right, bottom, top);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPerspective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluPerspective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static FunctionDescriptor gluPerspective$descriptor() {
        return gluPerspective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MethodHandle gluPerspective$handle() {
        return gluPerspective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MemorySegment gluPerspective$address() {
        return gluPerspective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static void gluPerspective(double fovy, double aspect, double zNear, double zFar) {
        var mh$ = gluPerspective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPerspective", fovy, aspect, zNear, zFar);
            }
            mh$.invokeExact(fovy, aspect, zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPickMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluPickMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4])
     * }
     */
    public static FunctionDescriptor gluPickMatrix$descriptor() {
        return gluPickMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4])
     * }
     */
    public static MethodHandle gluPickMatrix$handle() {
        return gluPickMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4])
     * }
     */
    public static MemorySegment gluPickMatrix$address() {
        return gluPickMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4])
     * }
     */
    public static void gluPickMatrix(double x, double y, double width, double height, MemorySegment viewport) {
        var mh$ = gluPickMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPickMatrix", x, y, width, height, viewport);
            }
            mh$.invokeExact(x, y, width, height, viewport);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluLookAt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluLookAt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz)
     * }
     */
    public static FunctionDescriptor gluLookAt$descriptor() {
        return gluLookAt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz)
     * }
     */
    public static MethodHandle gluLookAt$handle() {
        return gluLookAt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz)
     * }
     */
    public static MemorySegment gluLookAt$address() {
        return gluLookAt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz)
     * }
     */
    public static void gluLookAt(double eyex, double eyey, double eyez, double centerx, double centery, double centerz, double upx, double upy, double upz) {
        var mh$ = gluLookAt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluLookAt", eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz);
            }
            mh$.invokeExact(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluProject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluProject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gluProject(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz)
     * }
     */
    public static FunctionDescriptor gluProject$descriptor() {
        return gluProject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gluProject(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz)
     * }
     */
    public static MethodHandle gluProject$handle() {
        return gluProject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gluProject(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz)
     * }
     */
    public static MemorySegment gluProject$address() {
        return gluProject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gluProject(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz)
     * }
     */
    public static int gluProject(double objx, double objy, double objz, MemorySegment modelMatrix, MemorySegment projMatrix, MemorySegment viewport, MemorySegment winx, MemorySegment winy, MemorySegment winz) {
        var mh$ = gluProject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluProject", objx, objy, objz, modelMatrix, projMatrix, viewport, winx, winy, winz);
            }
            return (int)mh$.invokeExact(objx, objy, objz, modelMatrix, projMatrix, viewport, winx, winy, winz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluUnProject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluUnProject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gluUnProject(GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz)
     * }
     */
    public static FunctionDescriptor gluUnProject$descriptor() {
        return gluUnProject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gluUnProject(GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz)
     * }
     */
    public static MethodHandle gluUnProject$handle() {
        return gluUnProject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gluUnProject(GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz)
     * }
     */
    public static MemorySegment gluUnProject$address() {
        return gluUnProject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gluUnProject(GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz)
     * }
     */
    public static int gluUnProject(double winx, double winy, double winz, MemorySegment modelMatrix, MemorySegment projMatrix, MemorySegment viewport, MemorySegment objx, MemorySegment objy, MemorySegment objz) {
        var mh$ = gluUnProject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluUnProject", winx, winy, winz, modelMatrix, projMatrix, viewport, objx, objy, objz);
            }
            return (int)mh$.invokeExact(winx, winy, winz, modelMatrix, projMatrix, viewport, objx, objy, objz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluScaleImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluScaleImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gluScaleImage(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout)
     * }
     */
    public static FunctionDescriptor gluScaleImage$descriptor() {
        return gluScaleImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gluScaleImage(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout)
     * }
     */
    public static MethodHandle gluScaleImage$handle() {
        return gluScaleImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gluScaleImage(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout)
     * }
     */
    public static MemorySegment gluScaleImage$address() {
        return gluScaleImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gluScaleImage(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout)
     * }
     */
    public static int gluScaleImage(int format, int widthin, int heightin, int typein, MemorySegment datain, int widthout, int heightout, int typeout, MemorySegment dataout) {
        var mh$ = gluScaleImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluScaleImage", format, widthin, heightin, typein, datain, widthout, heightout, typeout, dataout);
            }
            return (int)mh$.invokeExact(format, widthin, heightin, typein, datain, widthout, heightout, typeout, dataout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild1DMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluBuild1DMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gluBuild1DMipmaps(GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild1DMipmaps$descriptor() {
        return gluBuild1DMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gluBuild1DMipmaps(GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MethodHandle gluBuild1DMipmaps$handle() {
        return gluBuild1DMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gluBuild1DMipmaps(GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MemorySegment gluBuild1DMipmaps$address() {
        return gluBuild1DMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gluBuild1DMipmaps(GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static int gluBuild1DMipmaps(int target, int components, int width, int format, int type, MemorySegment data) {
        var mh$ = gluBuild1DMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild1DMipmaps", target, components, width, format, type, data);
            }
            return (int)mh$.invokeExact(target, components, width, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild2DMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluBuild2DMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gluBuild2DMipmaps(GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild2DMipmaps$descriptor() {
        return gluBuild2DMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gluBuild2DMipmaps(GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MethodHandle gluBuild2DMipmaps$handle() {
        return gluBuild2DMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gluBuild2DMipmaps(GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MemorySegment gluBuild2DMipmaps$address() {
        return gluBuild2DMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gluBuild2DMipmaps(GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static int gluBuild2DMipmaps(int target, int components, int width, int height, int format, int type, MemorySegment data) {
        var mh$ = gluBuild2DMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild2DMipmaps", target, components, width, height, format, type, data);
            }
            return (int)mh$.invokeExact(target, components, width, height, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewQuadric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluNewQuadric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static FunctionDescriptor gluNewQuadric$descriptor() {
        return gluNewQuadric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static MethodHandle gluNewQuadric$handle() {
        return gluNewQuadric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static MemorySegment gluNewQuadric$address() {
        return gluNewQuadric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static MemorySegment gluNewQuadric() {
        var mh$ = gluNewQuadric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewQuadric");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteQuadric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluDeleteQuadric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *state)
     * }
     */
    public static FunctionDescriptor gluDeleteQuadric$descriptor() {
        return gluDeleteQuadric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *state)
     * }
     */
    public static MethodHandle gluDeleteQuadric$handle() {
        return gluDeleteQuadric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *state)
     * }
     */
    public static MemorySegment gluDeleteQuadric$address() {
        return gluDeleteQuadric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *state)
     * }
     */
    public static void gluDeleteQuadric(MemorySegment state) {
        var mh$ = gluDeleteQuadric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteQuadric", state);
            }
            mh$.invokeExact(state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricNormals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluQuadricNormals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quadObject, GLenum normals)
     * }
     */
    public static FunctionDescriptor gluQuadricNormals$descriptor() {
        return gluQuadricNormals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quadObject, GLenum normals)
     * }
     */
    public static MethodHandle gluQuadricNormals$handle() {
        return gluQuadricNormals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quadObject, GLenum normals)
     * }
     */
    public static MemorySegment gluQuadricNormals$address() {
        return gluQuadricNormals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quadObject, GLenum normals)
     * }
     */
    public static void gluQuadricNormals(MemorySegment quadObject, int normals) {
        var mh$ = gluQuadricNormals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricNormals", quadObject, normals);
            }
            mh$.invokeExact(quadObject, normals);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluQuadricTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quadObject, GLboolean textureCoords)
     * }
     */
    public static FunctionDescriptor gluQuadricTexture$descriptor() {
        return gluQuadricTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quadObject, GLboolean textureCoords)
     * }
     */
    public static MethodHandle gluQuadricTexture$handle() {
        return gluQuadricTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quadObject, GLboolean textureCoords)
     * }
     */
    public static MemorySegment gluQuadricTexture$address() {
        return gluQuadricTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quadObject, GLboolean textureCoords)
     * }
     */
    public static void gluQuadricTexture(MemorySegment quadObject, byte textureCoords) {
        var mh$ = gluQuadricTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricTexture", quadObject, textureCoords);
            }
            mh$.invokeExact(quadObject, textureCoords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricOrientation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluQuadricOrientation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quadObject, GLenum orientation)
     * }
     */
    public static FunctionDescriptor gluQuadricOrientation$descriptor() {
        return gluQuadricOrientation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quadObject, GLenum orientation)
     * }
     */
    public static MethodHandle gluQuadricOrientation$handle() {
        return gluQuadricOrientation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quadObject, GLenum orientation)
     * }
     */
    public static MemorySegment gluQuadricOrientation$address() {
        return gluQuadricOrientation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quadObject, GLenum orientation)
     * }
     */
    public static void gluQuadricOrientation(MemorySegment quadObject, int orientation) {
        var mh$ = gluQuadricOrientation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricOrientation", quadObject, orientation);
            }
            mh$.invokeExact(quadObject, orientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricDrawStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluQuadricDrawStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quadObject, GLenum drawStyle)
     * }
     */
    public static FunctionDescriptor gluQuadricDrawStyle$descriptor() {
        return gluQuadricDrawStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quadObject, GLenum drawStyle)
     * }
     */
    public static MethodHandle gluQuadricDrawStyle$handle() {
        return gluQuadricDrawStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quadObject, GLenum drawStyle)
     * }
     */
    public static MemorySegment gluQuadricDrawStyle$address() {
        return gluQuadricDrawStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quadObject, GLenum drawStyle)
     * }
     */
    public static void gluQuadricDrawStyle(MemorySegment quadObject, int drawStyle) {
        var mh$ = gluQuadricDrawStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricDrawStyle", quadObject, drawStyle);
            }
            mh$.invokeExact(quadObject, drawStyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor gluCylinder$descriptor() {
        return gluCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle gluCylinder$handle() {
        return gluCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment gluCylinder$address() {
        return gluCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static void gluCylinder(MemorySegment qobj, double baseRadius, double topRadius, double height, int slices, int stacks) {
        var mh$ = gluCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluCylinder", qobj, baseRadius, topRadius, height, slices, stacks);
            }
            mh$.invokeExact(qobj, baseRadius, topRadius, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDisk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluDisk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops)
     * }
     */
    public static FunctionDescriptor gluDisk$descriptor() {
        return gluDisk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops)
     * }
     */
    public static MethodHandle gluDisk$handle() {
        return gluDisk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops)
     * }
     */
    public static MemorySegment gluDisk$address() {
        return gluDisk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops)
     * }
     */
    public static void gluDisk(MemorySegment qobj, double innerRadius, double outerRadius, int slices, int loops) {
        var mh$ = gluDisk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDisk", qobj, innerRadius, outerRadius, slices, loops);
            }
            mh$.invokeExact(qobj, innerRadius, outerRadius, slices, loops);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPartialDisk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluPartialDisk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle)
     * }
     */
    public static FunctionDescriptor gluPartialDisk$descriptor() {
        return gluPartialDisk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle)
     * }
     */
    public static MethodHandle gluPartialDisk$handle() {
        return gluPartialDisk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle)
     * }
     */
    public static MemorySegment gluPartialDisk$address() {
        return gluPartialDisk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle)
     * }
     */
    public static void gluPartialDisk(MemorySegment qobj, double innerRadius, double outerRadius, int slices, int loops, double startAngle, double sweepAngle) {
        var mh$ = gluPartialDisk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPartialDisk", qobj, innerRadius, outerRadius, slices, loops, startAngle, sweepAngle);
            }
            mh$.invokeExact(qobj, innerRadius, outerRadius, slices, loops, startAngle, sweepAngle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_DOUBLE,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor gluSphere$descriptor() {
        return gluSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle gluSphere$handle() {
        return gluSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment gluSphere$address() {
        return gluSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static void gluSphere(MemorySegment qobj, double radius, int slices, int stacks) {
        var mh$ = gluSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluSphere", qobj, radius, slices, stacks);
            }
            mh$.invokeExact(qobj, radius, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluQuadricCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *qobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static FunctionDescriptor gluQuadricCallback$descriptor() {
        return gluQuadricCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *qobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MethodHandle gluQuadricCallback$handle() {
        return gluQuadricCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *qobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MemorySegment gluQuadricCallback$address() {
        return gluQuadricCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *qobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static void gluQuadricCallback(MemorySegment qobj, int which, MemorySegment fn) {
        var mh$ = gluQuadricCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricCallback", qobj, which, fn);
            }
            mh$.invokeExact(qobj, which, fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewTess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluNewTess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static FunctionDescriptor gluNewTess$descriptor() {
        return gluNewTess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static MethodHandle gluNewTess$handle() {
        return gluNewTess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static MemorySegment gluNewTess$address() {
        return gluNewTess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static MemorySegment gluNewTess() {
        var mh$ = gluNewTess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewTess");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteTess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluDeleteTess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluDeleteTess$descriptor() {
        return gluDeleteTess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluDeleteTess$handle() {
        return gluDeleteTess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluDeleteTess$address() {
        return gluDeleteTess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static void gluDeleteTess(MemorySegment tess) {
        var mh$ = gluDeleteTess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteTess", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessBeginPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluTessBeginPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data)
     * }
     */
    public static FunctionDescriptor gluTessBeginPolygon$descriptor() {
        return gluTessBeginPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data)
     * }
     */
    public static MethodHandle gluTessBeginPolygon$handle() {
        return gluTessBeginPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data)
     * }
     */
    public static MemorySegment gluTessBeginPolygon$address() {
        return gluTessBeginPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data)
     * }
     */
    public static void gluTessBeginPolygon(MemorySegment tess, MemorySegment polygon_data) {
        var mh$ = gluTessBeginPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessBeginPolygon", tess, polygon_data);
            }
            mh$.invokeExact(tess, polygon_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessBeginContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluTessBeginContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessBeginContour$descriptor() {
        return gluTessBeginContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessBeginContour$handle() {
        return gluTessBeginContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessBeginContour$address() {
        return gluTessBeginContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static void gluTessBeginContour(MemorySegment tess) {
        var mh$ = gluTessBeginContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessBeginContour", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessVertex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluTessVertex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data)
     * }
     */
    public static FunctionDescriptor gluTessVertex$descriptor() {
        return gluTessVertex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data)
     * }
     */
    public static MethodHandle gluTessVertex$handle() {
        return gluTessVertex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data)
     * }
     */
    public static MemorySegment gluTessVertex$address() {
        return gluTessVertex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data)
     * }
     */
    public static void gluTessVertex(MemorySegment tess, MemorySegment coords, MemorySegment data) {
        var mh$ = gluTessVertex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessVertex", tess, coords, data);
            }
            mh$.invokeExact(tess, coords, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessEndContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluTessEndContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessEndContour$descriptor() {
        return gluTessEndContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessEndContour$handle() {
        return gluTessEndContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessEndContour$address() {
        return gluTessEndContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static void gluTessEndContour(MemorySegment tess) {
        var mh$ = gluTessEndContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessEndContour", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessEndPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluTessEndPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessEndPolygon$descriptor() {
        return gluTessEndPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessEndPolygon$handle() {
        return gluTessEndPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessEndPolygon$address() {
        return gluTessEndPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluTessEndPolygon(MemorySegment tess) {
        var mh$ = gluTessEndPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessEndPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluTessProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble value)
     * }
     */
    public static FunctionDescriptor gluTessProperty$descriptor() {
        return gluTessProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble value)
     * }
     */
    public static MethodHandle gluTessProperty$handle() {
        return gluTessProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble value)
     * }
     */
    public static MemorySegment gluTessProperty$address() {
        return gluTessProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble value)
     * }
     */
    public static void gluTessProperty(MemorySegment tess, int which, double value) {
        var mh$ = gluTessProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessProperty", tess, which, value);
            }
            mh$.invokeExact(tess, which, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessNormal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE,
            wgl_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluTessNormal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor gluTessNormal$descriptor() {
        return gluTessNormal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle gluTessNormal$handle() {
        return gluTessNormal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment gluTessNormal$address() {
        return gluTessNormal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void gluTessNormal(MemorySegment tess, double x, double y, double z) {
        var mh$ = gluTessNormal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessNormal", tess, x, y, z);
            }
            mh$.invokeExact(tess, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluTessCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static FunctionDescriptor gluTessCallback$descriptor() {
        return gluTessCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MethodHandle gluTessCallback$handle() {
        return gluTessCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MemorySegment gluTessCallback$address() {
        return gluTessCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static void gluTessCallback(MemorySegment tess, int which, MemorySegment fn) {
        var mh$ = gluTessCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessCallback", tess, which, fn);
            }
            mh$.invokeExact(tess, which, fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetTessProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluGetTessProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *value)
     * }
     */
    public static FunctionDescriptor gluGetTessProperty$descriptor() {
        return gluGetTessProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *value)
     * }
     */
    public static MethodHandle gluGetTessProperty$handle() {
        return gluGetTessProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *value)
     * }
     */
    public static MemorySegment gluGetTessProperty$address() {
        return gluGetTessProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *value)
     * }
     */
    public static void gluGetTessProperty(MemorySegment tess, int which, MemorySegment value) {
        var mh$ = gluGetTessProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetTessProperty", tess, which, value);
            }
            mh$.invokeExact(tess, which, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewNurbsRenderer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluNewNurbsRenderer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static FunctionDescriptor gluNewNurbsRenderer$descriptor() {
        return gluNewNurbsRenderer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MethodHandle gluNewNurbsRenderer$handle() {
        return gluNewNurbsRenderer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MemorySegment gluNewNurbsRenderer$address() {
        return gluNewNurbsRenderer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MemorySegment gluNewNurbsRenderer() {
        var mh$ = gluNewNurbsRenderer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewNurbsRenderer");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteNurbsRenderer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluDeleteNurbsRenderer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluDeleteNurbsRenderer$descriptor() {
        return gluDeleteNurbsRenderer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluDeleteNurbsRenderer$handle() {
        return gluDeleteNurbsRenderer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluDeleteNurbsRenderer$address() {
        return gluDeleteNurbsRenderer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nobj)
     * }
     */
    public static void gluDeleteNurbsRenderer(MemorySegment nobj) {
        var mh$ = gluDeleteNurbsRenderer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteNurbsRenderer", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluBeginSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluBeginSurface$descriptor() {
        return gluBeginSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluBeginSurface$handle() {
        return gluBeginSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluBeginSurface$address() {
        return gluBeginSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nobj)
     * }
     */
    public static void gluBeginSurface(MemorySegment nobj) {
        var mh$ = gluBeginSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginSurface", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluBeginCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluBeginCurve$descriptor() {
        return gluBeginCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluBeginCurve$handle() {
        return gluBeginCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluBeginCurve$address() {
        return gluBeginCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nobj)
     * }
     */
    public static void gluBeginCurve(MemorySegment nobj) {
        var mh$ = gluBeginCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginCurve", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluEndCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluEndCurve$descriptor() {
        return gluEndCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluEndCurve$handle() {
        return gluEndCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluEndCurve$address() {
        return gluEndCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nobj)
     * }
     */
    public static void gluEndCurve(MemorySegment nobj) {
        var mh$ = gluEndCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndCurve", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluEndSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluEndSurface$descriptor() {
        return gluEndSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluEndSurface$handle() {
        return gluEndSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluEndSurface$address() {
        return gluEndSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nobj)
     * }
     */
    public static void gluEndSurface(MemorySegment nobj) {
        var mh$ = gluEndSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndSurface", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginTrim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluBeginTrim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluBeginTrim$descriptor() {
        return gluBeginTrim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluBeginTrim$handle() {
        return gluBeginTrim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluBeginTrim$address() {
        return gluBeginTrim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nobj)
     * }
     */
    public static void gluBeginTrim(MemorySegment nobj) {
        var mh$ = gluBeginTrim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginTrim", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndTrim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluEndTrim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluEndTrim$descriptor() {
        return gluEndTrim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluEndTrim$handle() {
        return gluEndTrim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluEndTrim$address() {
        return gluEndTrim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nobj)
     * }
     */
    public static void gluEndTrim(MemorySegment nobj) {
        var mh$ = gluEndTrim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndTrim", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPwlCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluPwlCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type)
     * }
     */
    public static FunctionDescriptor gluPwlCurve$descriptor() {
        return gluPwlCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type)
     * }
     */
    public static MethodHandle gluPwlCurve$handle() {
        return gluPwlCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type)
     * }
     */
    public static MemorySegment gluPwlCurve$address() {
        return gluPwlCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type)
     * }
     */
    public static void gluPwlCurve(MemorySegment nobj, int count, MemorySegment array, int stride, int type) {
        var mh$ = gluPwlCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPwlCurve", nobj, count, array, stride, type);
            }
            mh$.invokeExact(nobj, count, array, stride, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluNurbsCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNurbsCurve$descriptor() {
        return gluNurbsCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type)
     * }
     */
    public static MethodHandle gluNurbsCurve$handle() {
        return gluNurbsCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type)
     * }
     */
    public static MemorySegment gluNurbsCurve$address() {
        return gluNurbsCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type)
     * }
     */
    public static void gluNurbsCurve(MemorySegment nobj, int nknots, MemorySegment knot, int stride, MemorySegment ctlarray, int order, int type) {
        var mh$ = gluNurbsCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCurve", nobj, nknots, knot, stride, ctlarray, order, type);
            }
            mh$.invokeExact(nobj, nknots, knot, stride, ctlarray, order, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluNurbsSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nobj, GLint sknot_count, float *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNurbsSurface$descriptor() {
        return gluNurbsSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nobj, GLint sknot_count, float *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type)
     * }
     */
    public static MethodHandle gluNurbsSurface$handle() {
        return gluNurbsSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nobj, GLint sknot_count, float *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type)
     * }
     */
    public static MemorySegment gluNurbsSurface$address() {
        return gluNurbsSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nobj, GLint sknot_count, float *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type)
     * }
     */
    public static void gluNurbsSurface(MemorySegment nobj, int sknot_count, MemorySegment sknot, int tknot_count, MemorySegment tknot, int s_stride, int t_stride, MemorySegment ctlarray, int sorder, int torder, int type) {
        var mh$ = gluNurbsSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsSurface", nobj, sknot_count, sknot, tknot_count, tknot, s_stride, t_stride, ctlarray, sorder, torder, type);
            }
            mh$.invokeExact(nobj, sknot_count, sknot, tknot_count, tknot, s_stride, t_stride, ctlarray, sorder, torder, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluLoadSamplingMatrices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluLoadSamplingMatrices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nobj, const GLfloat modelMatrix[16], const GLfloat projMatrix[16], const GLint viewport[4])
     * }
     */
    public static FunctionDescriptor gluLoadSamplingMatrices$descriptor() {
        return gluLoadSamplingMatrices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nobj, const GLfloat modelMatrix[16], const GLfloat projMatrix[16], const GLint viewport[4])
     * }
     */
    public static MethodHandle gluLoadSamplingMatrices$handle() {
        return gluLoadSamplingMatrices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nobj, const GLfloat modelMatrix[16], const GLfloat projMatrix[16], const GLint viewport[4])
     * }
     */
    public static MemorySegment gluLoadSamplingMatrices$address() {
        return gluLoadSamplingMatrices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nobj, const GLfloat modelMatrix[16], const GLfloat projMatrix[16], const GLint viewport[4])
     * }
     */
    public static void gluLoadSamplingMatrices(MemorySegment nobj, MemorySegment modelMatrix, MemorySegment projMatrix, MemorySegment viewport) {
        var mh$ = gluLoadSamplingMatrices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluLoadSamplingMatrices", nobj, modelMatrix, projMatrix, viewport);
            }
            mh$.invokeExact(nobj, modelMatrix, projMatrix, viewport);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_FLOAT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluNurbsProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat value)
     * }
     */
    public static FunctionDescriptor gluNurbsProperty$descriptor() {
        return gluNurbsProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat value)
     * }
     */
    public static MethodHandle gluNurbsProperty$handle() {
        return gluNurbsProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat value)
     * }
     */
    public static MemorySegment gluNurbsProperty$address() {
        return gluNurbsProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat value)
     * }
     */
    public static void gluNurbsProperty(MemorySegment nobj, int property, float value) {
        var mh$ = gluNurbsProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsProperty", nobj, property, value);
            }
            mh$.invokeExact(nobj, property, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetNurbsProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluGetNurbsProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat *value)
     * }
     */
    public static FunctionDescriptor gluGetNurbsProperty$descriptor() {
        return gluGetNurbsProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat *value)
     * }
     */
    public static MethodHandle gluGetNurbsProperty$handle() {
        return gluGetNurbsProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat *value)
     * }
     */
    public static MemorySegment gluGetNurbsProperty$address() {
        return gluGetNurbsProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat *value)
     * }
     */
    public static void gluGetNurbsProperty(MemorySegment nobj, int property, MemorySegment value) {
        var mh$ = gluGetNurbsProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetNurbsProperty", nobj, property, value);
            }
            mh$.invokeExact(nobj, property, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluNurbsCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static FunctionDescriptor gluNurbsCallback$descriptor() {
        return gluNurbsCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MethodHandle gluNurbsCallback$handle() {
        return gluNurbsCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MemorySegment gluNurbsCallback$address() {
        return gluNurbsCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static void gluNurbsCallback(MemorySegment nobj, int which, MemorySegment fn) {
        var mh$ = gluNurbsCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCallback", nobj, which, fn);
            }
            mh$.invokeExact(nobj, which, fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluBeginPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluBeginPolygon$descriptor() {
        return gluBeginPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluBeginPolygon$handle() {
        return gluBeginPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluBeginPolygon$address() {
        return gluBeginPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluBeginPolygon(MemorySegment tess) {
        var mh$ = gluBeginPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNextContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluNextContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNextContour$descriptor() {
        return gluNextContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static MethodHandle gluNextContour$handle() {
        return gluNextContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static MemorySegment gluNextContour$address() {
        return gluNextContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static void gluNextContour(MemorySegment tess, int type) {
        var mh$ = gluNextContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNextContour", tess, type);
            }
            mh$.invokeExact(tess, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("gluEndPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluEndPolygon$descriptor() {
        return gluEndPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluEndPolygon$handle() {
        return gluEndPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluEndPolygon$address() {
        return gluEndPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluEndPolygon(MemorySegment tess) {
        var mh$ = gluEndPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HPBUFFERARB__ {
     *     int unused;
     * } *HPBUFFERARB
     * }
     */
    public static final AddressLayout HPBUFFERARB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HPBUFFEREXT__ {
     *     int unused;
     * } *HPBUFFEREXT
     * }
     */
    public static final AddressLayout HPBUFFEREXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HGPUNV__ {
     *     int unused;
     * } *HGPUNV
     * }
     */
    public static final AddressLayout HGPUNV = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GPU_DEVICE {
     *     DWORD cb;
     *     CHAR DeviceName[32];
     *     CHAR DeviceString[128];
     *     DWORD Flags;
     *     RECT rcVirtualScreen;
     * } *PGPU_DEVICE
     * }
     */
    public static final AddressLayout PGPU_DEVICE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HVIDEOOUTPUTDEVICENV__ {
     *     int unused;
     * } *HVIDEOOUTPUTDEVICENV
     * }
     */
    public static final AddressLayout HVIDEOOUTPUTDEVICENV = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HVIDEOINPUTDEVICENV__ {
     *     int unused;
     * } *HVIDEOINPUTDEVICENV
     * }
     */
    public static final AddressLayout HVIDEOINPUTDEVICENV = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HPVIDEODEV__ {
     *     int unused;
     * } *HPVIDEODEV
     * }
     */
    public static final AddressLayout HPVIDEODEV = wgl_h.C_POINTER;
    private static final int WINAPI_PARTITION_SERVER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_SERVER 0
     * }
     */
    public static int WINAPI_PARTITION_SERVER() {
        return WINAPI_PARTITION_SERVER;
    }
    private static final int WINAPI_PARTITION_PKG_WINTRUST = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_WINTRUST 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_WINTRUST() {
        return WINAPI_PARTITION_PKG_WINTRUST;
    }
    private static final int WINAPI_PARTITION_PKG_WEBSERVICES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_WEBSERVICES 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_WEBSERVICES() {
        return WINAPI_PARTITION_PKG_WEBSERVICES;
    }
    private static final int WINAPI_PARTITION_PKG_EVENTLOGSERVICE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_EVENTLOGSERVICE 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_EVENTLOGSERVICE() {
        return WINAPI_PARTITION_PKG_EVENTLOGSERVICE;
    }
    private static final int WINAPI_PARTITION_PKG_VHD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_VHD 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_VHD() {
        return WINAPI_PARTITION_PKG_VHD;
    }
    private static final int WINAPI_PARTITION_PKG_PERFCOUNTER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_PERFCOUNTER 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_PERFCOUNTER() {
        return WINAPI_PARTITION_PKG_PERFCOUNTER;
    }
    private static final int WINAPI_PARTITION_PKG_SECURESTARTUP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_SECURESTARTUP 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_SECURESTARTUP() {
        return WINAPI_PARTITION_PKG_SECURESTARTUP;
    }
    private static final int WINAPI_PARTITION_PKG_REMOTEFS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_REMOTEFS 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_REMOTEFS() {
        return WINAPI_PARTITION_PKG_REMOTEFS;
    }
    private static final int WINAPI_PARTITION_PKG_BOOTABLESKU = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_BOOTABLESKU 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_BOOTABLESKU() {
        return WINAPI_PARTITION_PKG_BOOTABLESKU;
    }
    private static final int WINAPI_PARTITION_PKG_CMDTOOLS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_CMDTOOLS 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_CMDTOOLS() {
        return WINAPI_PARTITION_PKG_CMDTOOLS;
    }
    private static final int WINAPI_PARTITION_PKG_DISM = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_DISM 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_DISM() {
        return WINAPI_PARTITION_PKG_DISM;
    }
    private static final int WINAPI_PARTITION_PKG_CORESETUP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_CORESETUP 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_CORESETUP() {
        return WINAPI_PARTITION_PKG_CORESETUP;
    }
    private static final int WINAPI_PARTITION_PKG_APPRUNTIME = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_APPRUNTIME 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_APPRUNTIME() {
        return WINAPI_PARTITION_PKG_APPRUNTIME;
    }
    private static final int WINAPI_PARTITION_PKG_ESENT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_ESENT 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_ESENT() {
        return WINAPI_PARTITION_PKG_ESENT;
    }
    private static final int WINAPI_PARTITION_PKG_WINMGMT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_WINMGMT 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_WINMGMT() {
        return WINAPI_PARTITION_PKG_WINMGMT;
    }
    private static final int WINAPI_PARTITION_PKG_WNV = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_WNV 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_WNV() {
        return WINAPI_PARTITION_PKG_WNV;
    }
    private static final int WINAPI_PARTITION_PKG_CLUSTER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_CLUSTER 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_CLUSTER() {
        return WINAPI_PARTITION_PKG_CLUSTER;
    }
    private static final int WINAPI_PARTITION_PKG_VSS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_VSS 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_VSS() {
        return WINAPI_PARTITION_PKG_VSS;
    }
    private static final int WINAPI_PARTITION_PKG_TRAFFIC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_TRAFFIC 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_TRAFFIC() {
        return WINAPI_PARTITION_PKG_TRAFFIC;
    }
    private static final int WINAPI_PARTITION_PKG_ISCSI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_ISCSI 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_ISCSI() {
        return WINAPI_PARTITION_PKG_ISCSI;
    }
    private static final int WINAPI_PARTITION_PKG_STORAGE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_STORAGE 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_STORAGE() {
        return WINAPI_PARTITION_PKG_STORAGE;
    }
    private static final int WINAPI_PARTITION_PKG_MPSSVC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_MPSSVC 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_MPSSVC() {
        return WINAPI_PARTITION_PKG_MPSSVC;
    }
    private static final int WINAPI_PARTITION_PKG_APPXDEPLOYMENT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_APPXDEPLOYMENT 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_APPXDEPLOYMENT() {
        return WINAPI_PARTITION_PKG_APPXDEPLOYMENT;
    }
    private static final int WINAPI_PARTITION_PKG_WER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_WER 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_WER() {
        return WINAPI_PARTITION_PKG_WER;
    }
    private static final int WINAPI_FAMILY_APP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_FAMILY_APP 2
     * }
     */
    public static int WINAPI_FAMILY_APP() {
        return WINAPI_FAMILY_APP;
    }
    private static final int WINAPI_FAMILY = (int)100L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_FAMILY 100
     * }
     */
    public static int WINAPI_FAMILY() {
        return WINAPI_FAMILY;
    }
    private static final int WINAPI_PARTITION_DESKTOP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_DESKTOP 1
     * }
     */
    public static int WINAPI_PARTITION_DESKTOP() {
        return WINAPI_PARTITION_DESKTOP;
    }
    private static final int WINAPI_PARTITION_APP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_APP 1
     * }
     */
    public static int WINAPI_PARTITION_APP() {
        return WINAPI_PARTITION_APP;
    }
    private static final int WINAPI_PARTITION_PC_APP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PC_APP 1
     * }
     */
    public static int WINAPI_PARTITION_PC_APP() {
        return WINAPI_PARTITION_PC_APP;
    }
    private static final int WINAPI_PARTITION_PHONE_APP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PHONE_APP 0
     * }
     */
    public static int WINAPI_PARTITION_PHONE_APP() {
        return WINAPI_PARTITION_PHONE_APP;
    }
    private static final int WINAPI_PARTITION_GAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_GAMES 1
     * }
     */
    public static int WINAPI_PARTITION_GAMES() {
        return WINAPI_PARTITION_GAMES;
    }
    private static final int WINAPI_PARTITION_SYSTEM = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_SYSTEM 0
     * }
     */
    public static int WINAPI_PARTITION_SYSTEM() {
        return WINAPI_PARTITION_SYSTEM;
    }
    private static final int WINAPI_PARTITION_PHONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PHONE 0
     * }
     */
    public static int WINAPI_PARTITION_PHONE() {
        return WINAPI_PARTITION_PHONE;
    }
    private static final int _WIN32_IE_NT4 = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4 512
     * }
     */
    public static int _WIN32_IE_NT4() {
        return _WIN32_IE_NT4;
    }
    private static final int _WIN32_IE_NT4SP1 = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP1 512
     * }
     */
    public static int _WIN32_IE_NT4SP1() {
        return _WIN32_IE_NT4SP1;
    }
    private static final int _WIN32_IE_NT4SP2 = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP2 512
     * }
     */
    public static int _WIN32_IE_NT4SP2() {
        return _WIN32_IE_NT4SP2;
    }
    private static final int _WIN32_IE_NT4SP3 = (int)770L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP3 770
     * }
     */
    public static int _WIN32_IE_NT4SP3() {
        return _WIN32_IE_NT4SP3;
    }
    private static final int _WIN32_IE_NT4SP4 = (int)1025L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP4 1025
     * }
     */
    public static int _WIN32_IE_NT4SP4() {
        return _WIN32_IE_NT4SP4;
    }
    private static final int _WIN32_IE_NT4SP5 = (int)1025L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP5 1025
     * }
     */
    public static int _WIN32_IE_NT4SP5() {
        return _WIN32_IE_NT4SP5;
    }
    private static final int _WIN32_IE_NT4SP6 = (int)1280L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP6 1280
     * }
     */
    public static int _WIN32_IE_NT4SP6() {
        return _WIN32_IE_NT4SP6;
    }
    private static final int _WIN32_IE_WIN98 = (int)1025L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN98 1025
     * }
     */
    public static int _WIN32_IE_WIN98() {
        return _WIN32_IE_WIN98;
    }
    private static final int _WIN32_IE_WIN98SE = (int)1280L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN98SE 1280
     * }
     */
    public static int _WIN32_IE_WIN98SE() {
        return _WIN32_IE_WIN98SE;
    }
    private static final int _WIN32_IE_WINME = (int)1360L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WINME 1360
     * }
     */
    public static int _WIN32_IE_WINME() {
        return _WIN32_IE_WINME;
    }
    private static final int _WIN32_IE_WIN2K = (int)1281L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN2K 1281
     * }
     */
    public static int _WIN32_IE_WIN2K() {
        return _WIN32_IE_WIN2K;
    }
    private static final int _WIN32_IE_WIN2KSP1 = (int)1281L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN2KSP1 1281
     * }
     */
    public static int _WIN32_IE_WIN2KSP1() {
        return _WIN32_IE_WIN2KSP1;
    }
    private static final int _WIN32_IE_WIN2KSP2 = (int)1281L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN2KSP2 1281
     * }
     */
    public static int _WIN32_IE_WIN2KSP2() {
        return _WIN32_IE_WIN2KSP2;
    }
    private static final int _WIN32_IE_WIN2KSP3 = (int)1281L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN2KSP3 1281
     * }
     */
    public static int _WIN32_IE_WIN2KSP3() {
        return _WIN32_IE_WIN2KSP3;
    }
    private static final int _WIN32_IE_WIN2KSP4 = (int)1281L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN2KSP4 1281
     * }
     */
    public static int _WIN32_IE_WIN2KSP4() {
        return _WIN32_IE_WIN2KSP4;
    }
    private static final int _WIN32_IE_XP = (int)1536L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_XP 1536
     * }
     */
    public static int _WIN32_IE_XP() {
        return _WIN32_IE_XP;
    }
    private static final int _WIN32_IE_XPSP1 = (int)1537L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_XPSP1 1537
     * }
     */
    public static int _WIN32_IE_XPSP1() {
        return _WIN32_IE_XPSP1;
    }
    private static final int _WIN32_IE_XPSP2 = (int)1539L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_XPSP2 1539
     * }
     */
    public static int _WIN32_IE_XPSP2() {
        return _WIN32_IE_XPSP2;
    }
    private static final int _WIN32_IE_WS03SP1 = (int)1539L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WS03SP1 1539
     * }
     */
    public static int _WIN32_IE_WS03SP1() {
        return _WIN32_IE_WS03SP1;
    }
    private static final int _WIN32_IE_WIN6 = (int)1792L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN6 1792
     * }
     */
    public static int _WIN32_IE_WIN6() {
        return _WIN32_IE_WIN6;
    }
    private static final int _WIN32_IE_LONGHORN = (int)1792L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_LONGHORN 1792
     * }
     */
    public static int _WIN32_IE_LONGHORN() {
        return _WIN32_IE_LONGHORN;
    }
    private static final int _WIN32_IE_WIN7 = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN7 2048
     * }
     */
    public static int _WIN32_IE_WIN7() {
        return _WIN32_IE_WIN7;
    }
    private static final int _WIN32_IE_WIN8 = (int)2560L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN8 2560
     * }
     */
    public static int _WIN32_IE_WIN8() {
        return _WIN32_IE_WIN8;
    }
    private static final int _WIN32_IE_WINBLUE = (int)2560L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WINBLUE 2560
     * }
     */
    public static int _WIN32_IE_WINBLUE() {
        return _WIN32_IE_WINBLUE;
    }
    private static final int _WIN32_IE_WINTHRESHOLD = (int)2560L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WINTHRESHOLD 2560
     * }
     */
    public static int _WIN32_IE_WINTHRESHOLD() {
        return _WIN32_IE_WINTHRESHOLD;
    }
    private static final int _WIN32_IE_WIN10 = (int)2560L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN10 2560
     * }
     */
    public static int _WIN32_IE_WIN10() {
        return _WIN32_IE_WIN10;
    }
    private static final int NTDDI_VISTA = (int)100663296L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VISTA 100663296
     * }
     */
    public static int NTDDI_VISTA() {
        return NTDDI_VISTA;
    }
    private static final int NTDDI_VISTASP1 = (int)100663552L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VISTASP1 100663552
     * }
     */
    public static int NTDDI_VISTASP1() {
        return NTDDI_VISTASP1;
    }
    private static final int NTDDI_VISTASP2 = (int)100663808L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VISTASP2 100663808
     * }
     */
    public static int NTDDI_VISTASP2() {
        return NTDDI_VISTASP2;
    }
    private static final int NTDDI_VISTASP3 = (int)100664064L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VISTASP3 100664064
     * }
     */
    public static int NTDDI_VISTASP3() {
        return NTDDI_VISTASP3;
    }
    private static final int NTDDI_VISTASP4 = (int)100664320L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VISTASP4 100664320
     * }
     */
    public static int NTDDI_VISTASP4() {
        return NTDDI_VISTASP4;
    }
    private static final int NTDDI_LONGHORN = (int)100663296L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_LONGHORN 100663296
     * }
     */
    public static int NTDDI_LONGHORN() {
        return NTDDI_LONGHORN;
    }
    private static final int NTDDI_WS08 = (int)100663552L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_WS08 100663552
     * }
     */
    public static int NTDDI_WS08() {
        return NTDDI_WS08;
    }
    private static final int NTDDI_WS08SP2 = (int)100663808L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_WS08SP2 100663808
     * }
     */
    public static int NTDDI_WS08SP2() {
        return NTDDI_WS08SP2;
    }
    private static final int NTDDI_WS08SP3 = (int)100664064L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_WS08SP3 100664064
     * }
     */
    public static int NTDDI_WS08SP3() {
        return NTDDI_WS08SP3;
    }
    private static final int NTDDI_WS08SP4 = (int)100664320L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_WS08SP4 100664320
     * }
     */
    public static int NTDDI_WS08SP4() {
        return NTDDI_WS08SP4;
    }
    private static final int WDK_NTDDI_VERSION = (int)167772168L;
    /**
     * {@snippet lang=c :
     * #define WDK_NTDDI_VERSION 167772168
     * }
     */
    public static int WDK_NTDDI_VERSION() {
        return WDK_NTDDI_VERSION;
    }
    private static final int OSVERSION_MASK = (int)4294901760L;
    /**
     * {@snippet lang=c :
     * #define OSVERSION_MASK 4294901760
     * }
     */
    public static int OSVERSION_MASK() {
        return OSVERSION_MASK;
    }
    private static final int NTDDI_VERSION = (int)167772168L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VERSION 167772168
     * }
     */
    public static int NTDDI_VERSION() {
        return NTDDI_VERSION;
    }
    private static final int WINVER = (int)2560L;
    /**
     * {@snippet lang=c :
     * #define WINVER 2560
     * }
     */
    public static int WINVER() {
        return WINVER;
    }
    private static final int _VCRUNTIME_DISABLED_WARNINGS = (int)4514L;
    /**
     * {@snippet lang=c :
     * #define _VCRUNTIME_DISABLED_WARNINGS 4514
     * }
     */
    public static int _VCRUNTIME_DISABLED_WARNINGS() {
        return _VCRUNTIME_DISABLED_WARNINGS;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int EXCEPTION_CONTINUE_EXECUTION = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EXCEPTION_CONTINUE_EXECUTION -1
     * }
     */
    public static int EXCEPTION_CONTINUE_EXECUTION() {
        return EXCEPTION_CONTINUE_EXECUTION;
    }
    private static final int _UCRT_DISABLED_WARNINGS = (int)4324L;
    /**
     * {@snippet lang=c :
     * #define _UCRT_DISABLED_WARNINGS 4324
     * }
     */
    public static int _UCRT_DISABLED_WARNINGS() {
        return _UCRT_DISABLED_WARNINGS;
    }
    private static final long _TRUNCATE = -1L;
    /**
     * {@snippet lang=c :
     * #define _TRUNCATE -1
     * }
     */
    public static long _TRUNCATE() {
        return _TRUNCATE;
    }
    private static final long _CRT_SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SIZE_MAX -1
     * }
     */
    public static long _CRT_SIZE_MAX() {
        return _CRT_SIZE_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __FILEW__ "C"
     * }
     */
    public static MemorySegment __FILEW__() {
        class Holder {
            static final MemorySegment __FILEW__
                = wgl_h.LIBRARY_ARENA.allocateFrom("C");
        }
        return Holder.__FILEW__;
    }
    private static final int __STDC_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __STDC_SECURE_LIB__ 200411
     * }
     */
    public static int __STDC_SECURE_LIB__() {
        return __STDC_SECURE_LIB__;
    }
    private static final int __GOT_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __GOT_SECURE_LIB__ 200411
     * }
     */
    public static int __GOT_SECURE_LIB__() {
        return __GOT_SECURE_LIB__;
    }
    private static final short WEOF = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define WEOF 65535
     * }
     */
    public static short WEOF() {
        return WEOF;
    }
    private static final int _ALPHA = (int)259L;
    /**
     * {@snippet lang=c :
     * #define _ALPHA 259
     * }
     */
    public static int _ALPHA() {
        return _ALPHA;
    }
    private static final long MAX_NATURAL_ALIGNMENT = 8L;
    /**
     * {@snippet lang=c :
     * #define MAX_NATURAL_ALIGNMENT 8
     * }
     */
    public static long MAX_NATURAL_ALIGNMENT() {
        return MAX_NATURAL_ALIGNMENT;
    }
    private static final long ADDRESS_TAG_BIT = 4398046511104L;
    /**
     * {@snippet lang=c :
     * #define ADDRESS_TAG_BIT 4398046511104
     * }
     */
    public static long ADDRESS_TAG_BIT() {
        return ADDRESS_TAG_BIT;
    }
    private static final long MAXUINT_PTR = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT_PTR -1
     * }
     */
    public static long MAXUINT_PTR() {
        return MAXUINT_PTR;
    }
    private static final long MAXINT_PTR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXINT_PTR 9223372036854775807
     * }
     */
    public static long MAXINT_PTR() {
        return MAXINT_PTR;
    }
    private static final long MININT_PTR = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MININT_PTR -9223372036854775808
     * }
     */
    public static long MININT_PTR() {
        return MININT_PTR;
    }
    private static final long MAXULONG_PTR = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXULONG_PTR -1
     * }
     */
    public static long MAXULONG_PTR() {
        return MAXULONG_PTR;
    }
    private static final long MAXLONG_PTR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXLONG_PTR 9223372036854775807
     * }
     */
    public static long MAXLONG_PTR() {
        return MAXLONG_PTR;
    }
    private static final long MINLONG_PTR = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MINLONG_PTR -9223372036854775808
     * }
     */
    public static long MINLONG_PTR() {
        return MINLONG_PTR;
    }
    private static final int MAXUHALF_PTR = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXUHALF_PTR 4294967295
     * }
     */
    public static int MAXUHALF_PTR() {
        return MAXUHALF_PTR;
    }
    private static final int MAXHALF_PTR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define MAXHALF_PTR 2147483647
     * }
     */
    public static int MAXHALF_PTR() {
        return MAXHALF_PTR;
    }
    private static final int MINHALF_PTR = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define MINHALF_PTR -2147483648
     * }
     */
    public static int MINHALF_PTR() {
        return MINHALF_PTR;
    }
    private static final byte MAXUINT8 = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT8 255
     * }
     */
    public static byte MAXUINT8() {
        return MAXUINT8;
    }
    private static final byte MAXINT8 = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define MAXINT8 127
     * }
     */
    public static byte MAXINT8() {
        return MAXINT8;
    }
    private static final byte MININT8 = (byte)-128L;
    /**
     * {@snippet lang=c :
     * #define MININT8 -128
     * }
     */
    public static byte MININT8() {
        return MININT8;
    }
    private static final short MAXUINT16 = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT16 65535
     * }
     */
    public static short MAXUINT16() {
        return MAXUINT16;
    }
    private static final short MAXINT16 = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define MAXINT16 32767
     * }
     */
    public static short MAXINT16() {
        return MAXINT16;
    }
    private static final short MININT16 = (short)-32768L;
    /**
     * {@snippet lang=c :
     * #define MININT16 -32768
     * }
     */
    public static short MININT16() {
        return MININT16;
    }
    private static final int MAXUINT32 = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT32 4294967295
     * }
     */
    public static int MAXUINT32() {
        return MAXUINT32;
    }
    private static final int MAXINT32 = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define MAXINT32 2147483647
     * }
     */
    public static int MAXINT32() {
        return MAXINT32;
    }
    private static final int MININT32 = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define MININT32 -2147483648
     * }
     */
    public static int MININT32() {
        return MININT32;
    }
    private static final long MAXUINT64 = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT64 -1
     * }
     */
    public static long MAXUINT64() {
        return MAXUINT64;
    }
    private static final long MAXINT64 = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXINT64 9223372036854775807
     * }
     */
    public static long MAXINT64() {
        return MAXINT64;
    }
    private static final long MININT64 = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MININT64 -9223372036854775808
     * }
     */
    public static long MININT64() {
        return MININT64;
    }
    private static final int MAXULONG32 = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXULONG32 4294967295
     * }
     */
    public static int MAXULONG32() {
        return MAXULONG32;
    }
    private static final int MAXLONG32 = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define MAXLONG32 2147483647
     * }
     */
    public static int MAXLONG32() {
        return MAXLONG32;
    }
    private static final int MINLONG32 = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define MINLONG32 -2147483648
     * }
     */
    public static int MINLONG32() {
        return MINLONG32;
    }
    private static final long MAXULONG64 = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXULONG64 -1
     * }
     */
    public static long MAXULONG64() {
        return MAXULONG64;
    }
    private static final long MAXLONG64 = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXLONG64 9223372036854775807
     * }
     */
    public static long MAXLONG64() {
        return MAXLONG64;
    }
    private static final long MINLONG64 = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MINLONG64 -9223372036854775808
     * }
     */
    public static long MINLONG64() {
        return MINLONG64;
    }
    private static final long MAXULONGLONG = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXULONGLONG -1
     * }
     */
    public static long MAXULONGLONG() {
        return MAXULONGLONG;
    }
    private static final long MINLONGLONG = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MINLONGLONG -9223372036854775808
     * }
     */
    public static long MINLONGLONG() {
        return MINLONGLONG;
    }
    private static final long MAXSIZE_T = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXSIZE_T -1
     * }
     */
    public static long MAXSIZE_T() {
        return MAXSIZE_T;
    }
    private static final long MAXSSIZE_T = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXSSIZE_T 9223372036854775807
     * }
     */
    public static long MAXSSIZE_T() {
        return MAXSSIZE_T;
    }
    private static final long MINSSIZE_T = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MINSSIZE_T -9223372036854775808
     * }
     */
    public static long MINSSIZE_T() {
        return MINSSIZE_T;
    }
    private static final int MAXUINT = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT 4294967295
     * }
     */
    public static int MAXUINT() {
        return MAXUINT;
    }
    private static final int MAXINT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define MAXINT 2147483647
     * }
     */
    public static int MAXINT() {
        return MAXINT;
    }
    private static final int MININT = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define MININT -2147483648
     * }
     */
    public static int MININT() {
        return MININT;
    }
    private static final int MAXDWORD32 = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXDWORD32 4294967295
     * }
     */
    public static int MAXDWORD32() {
        return MAXDWORD32;
    }
    private static final long MAXDWORD64 = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXDWORD64 -1
     * }
     */
    public static long MAXDWORD64() {
        return MAXDWORD64;
    }
    private static final int UCSCHAR_INVALID_CHARACTER = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UCSCHAR_INVALID_CHARACTER 4294967295
     * }
     */
    public static int UCSCHAR_INVALID_CHARACTER() {
        return UCSCHAR_INVALID_CHARACTER;
    }
    private static final int MIN_UCSCHAR = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MIN_UCSCHAR 0
     * }
     */
    public static int MIN_UCSCHAR() {
        return MIN_UCSCHAR;
    }
    private static final int MAX_UCSCHAR = (int)1114111L;
    /**
     * {@snippet lang=c :
     * #define MAX_UCSCHAR 1114111
     * }
     */
    public static int MAX_UCSCHAR() {
        return MAX_UCSCHAR;
    }
    private static final int MAXIMUM_PROCESSORS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define MAXIMUM_PROCESSORS 64
     * }
     */
    public static int MAXIMUM_PROCESSORS() {
        return MAXIMUM_PROCESSORS;
    }
    private static final int ERROR_SEVERITY_WARNING = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define ERROR_SEVERITY_WARNING 2147483648
     * }
     */
    public static int ERROR_SEVERITY_WARNING() {
        return ERROR_SEVERITY_WARNING;
    }
    private static final int ERROR_SEVERITY_ERROR = (int)3221225472L;
    /**
     * {@snippet lang=c :
     * #define ERROR_SEVERITY_ERROR 3221225472
     * }
     */
    public static int ERROR_SEVERITY_ERROR() {
        return ERROR_SEVERITY_ERROR;
    }
    private static final long MAXLONGLONG = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXLONGLONG 9223372036854775807
     * }
     */
    public static long MAXLONGLONG() {
        return MAXLONGLONG;
    }
    private static final byte ANSI_NULL = (byte)0L;
    /**
     * {@snippet lang=c :
     * #define ANSI_NULL 0
     * }
     */
    public static byte ANSI_NULL() {
        return ANSI_NULL;
    }
    private static final short UNICODE_NULL = (short)0L;
    /**
     * {@snippet lang=c :
     * #define UNICODE_NULL 0
     * }
     */
    public static short UNICODE_NULL() {
        return UNICODE_NULL;
    }
    private static final short UNICODE_STRING_MAX_BYTES = (short)65534L;
    /**
     * {@snippet lang=c :
     * #define UNICODE_STRING_MAX_BYTES 65534
     * }
     */
    public static short UNICODE_STRING_MAX_BYTES() {
        return UNICODE_STRING_MAX_BYTES;
    }
    private static final int UNICODE_STRING_MAX_CHARS = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define UNICODE_STRING_MAX_CHARS 32767
     * }
     */
    public static int UNICODE_STRING_MAX_CHARS() {
        return UNICODE_STRING_MAX_CHARS;
    }
    private static final int EDEADLOCK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define EDEADLOCK 36
     * }
     */
    public static int EDEADLOCK() {
        return EDEADLOCK;
    }
    private static final int _NLSCMPERROR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _NLSCMPERROR 2147483647
     * }
     */
    public static int _NLSCMPERROR() {
        return _NLSCMPERROR;
    }
    private static final int MINLONG = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define MINLONG 2147483648
     * }
     */
    public static int MINLONG() {
        return MINLONG;
    }
    private static final int MAXDWORD = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXDWORD 4294967295
     * }
     */
    public static int MAXDWORD() {
        return MAXDWORD;
    }
    private static final int VER_SERVER_NT = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define VER_SERVER_NT 2147483648
     * }
     */
    public static int VER_SERVER_NT() {
        return VER_SERVER_NT;
    }
    private static final int PRODUCT_UNLICENSED = (int)2882382797L;
    /**
     * {@snippet lang=c :
     * #define PRODUCT_UNLICENSED 2882382797
     * }
     */
    public static int PRODUCT_UNLICENSED() {
        return PRODUCT_UNLICENSED;
    }
    private static final int LANG_SYSTEM_DEFAULT = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define LANG_SYSTEM_DEFAULT 2048
     * }
     */
    public static int LANG_SYSTEM_DEFAULT() {
        return LANG_SYSTEM_DEFAULT;
    }
    private static final int LANG_USER_DEFAULT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define LANG_USER_DEFAULT 1024
     * }
     */
    public static int LANG_USER_DEFAULT() {
        return LANG_USER_DEFAULT;
    }
    private static final int LOCALE_SYSTEM_DEFAULT = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_SYSTEM_DEFAULT 2048
     * }
     */
    public static int LOCALE_SYSTEM_DEFAULT() {
        return LOCALE_SYSTEM_DEFAULT;
    }
    private static final int LOCALE_USER_DEFAULT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_USER_DEFAULT 1024
     * }
     */
    public static int LOCALE_USER_DEFAULT() {
        return LOCALE_USER_DEFAULT;
    }
    private static final int LOCALE_CUSTOM_DEFAULT = (int)3072L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_CUSTOM_DEFAULT 3072
     * }
     */
    public static int LOCALE_CUSTOM_DEFAULT() {
        return LOCALE_CUSTOM_DEFAULT;
    }
    private static final int LOCALE_CUSTOM_UNSPECIFIED = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_CUSTOM_UNSPECIFIED 4096
     * }
     */
    public static int LOCALE_CUSTOM_UNSPECIFIED() {
        return LOCALE_CUSTOM_UNSPECIFIED;
    }
    private static final int LOCALE_CUSTOM_UI_DEFAULT = (int)5120L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_CUSTOM_UI_DEFAULT 5120
     * }
     */
    public static int LOCALE_CUSTOM_UI_DEFAULT() {
        return LOCALE_CUSTOM_UI_DEFAULT;
    }
    private static final int LOCALE_NEUTRAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_NEUTRAL 0
     * }
     */
    public static int LOCALE_NEUTRAL() {
        return LOCALE_NEUTRAL;
    }
    private static final int LOCALE_INVARIANT = (int)127L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_INVARIANT 127
     * }
     */
    public static int LOCALE_INVARIANT() {
        return LOCALE_INVARIANT;
    }
    private static final int LOCALE_UNASSIGNED_LCID = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_UNASSIGNED_LCID 4096
     * }
     */
    public static int LOCALE_UNASSIGNED_LCID() {
        return LOCALE_UNASSIGNED_LCID;
    }
    private static final int STATUS_WAIT_0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define STATUS_WAIT_0 0
     * }
     */
    public static int STATUS_WAIT_0() {
        return STATUS_WAIT_0;
    }
    private static final int STATUS_ABANDONED_WAIT_0 = (int)128L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ABANDONED_WAIT_0 128
     * }
     */
    public static int STATUS_ABANDONED_WAIT_0() {
        return STATUS_ABANDONED_WAIT_0;
    }
    private static final int STATUS_USER_APC = (int)192L;
    /**
     * {@snippet lang=c :
     * #define STATUS_USER_APC 192
     * }
     */
    public static int STATUS_USER_APC() {
        return STATUS_USER_APC;
    }
    private static final int STATUS_TIMEOUT = (int)258L;
    /**
     * {@snippet lang=c :
     * #define STATUS_TIMEOUT 258
     * }
     */
    public static int STATUS_TIMEOUT() {
        return STATUS_TIMEOUT;
    }
    private static final int STATUS_PENDING = (int)259L;
    /**
     * {@snippet lang=c :
     * #define STATUS_PENDING 259
     * }
     */
    public static int STATUS_PENDING() {
        return STATUS_PENDING;
    }
    private static final int DBG_EXCEPTION_HANDLED = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define DBG_EXCEPTION_HANDLED 65537
     * }
     */
    public static int DBG_EXCEPTION_HANDLED() {
        return DBG_EXCEPTION_HANDLED;
    }
    private static final int DBG_CONTINUE = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define DBG_CONTINUE 65538
     * }
     */
    public static int DBG_CONTINUE() {
        return DBG_CONTINUE;
    }
    private static final int STATUS_SEGMENT_NOTIFICATION = (int)1073741829L;
    /**
     * {@snippet lang=c :
     * #define STATUS_SEGMENT_NOTIFICATION 1073741829
     * }
     */
    public static int STATUS_SEGMENT_NOTIFICATION() {
        return STATUS_SEGMENT_NOTIFICATION;
    }
    private static final int STATUS_FATAL_APP_EXIT = (int)1073741845L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FATAL_APP_EXIT 1073741845
     * }
     */
    public static int STATUS_FATAL_APP_EXIT() {
        return STATUS_FATAL_APP_EXIT;
    }
    private static final int DBG_REPLY_LATER = (int)1073807361L;
    /**
     * {@snippet lang=c :
     * #define DBG_REPLY_LATER 1073807361
     * }
     */
    public static int DBG_REPLY_LATER() {
        return DBG_REPLY_LATER;
    }
    private static final int DBG_TERMINATE_THREAD = (int)1073807363L;
    /**
     * {@snippet lang=c :
     * #define DBG_TERMINATE_THREAD 1073807363
     * }
     */
    public static int DBG_TERMINATE_THREAD() {
        return DBG_TERMINATE_THREAD;
    }
    private static final int DBG_TERMINATE_PROCESS = (int)1073807364L;
    /**
     * {@snippet lang=c :
     * #define DBG_TERMINATE_PROCESS 1073807364
     * }
     */
    public static int DBG_TERMINATE_PROCESS() {
        return DBG_TERMINATE_PROCESS;
    }
    private static final int DBG_CONTROL_C = (int)1073807365L;
    /**
     * {@snippet lang=c :
     * #define DBG_CONTROL_C 1073807365
     * }
     */
    public static int DBG_CONTROL_C() {
        return DBG_CONTROL_C;
    }
    private static final int DBG_PRINTEXCEPTION_C = (int)1073807366L;
    /**
     * {@snippet lang=c :
     * #define DBG_PRINTEXCEPTION_C 1073807366
     * }
     */
    public static int DBG_PRINTEXCEPTION_C() {
        return DBG_PRINTEXCEPTION_C;
    }
    private static final int DBG_RIPEXCEPTION = (int)1073807367L;
    /**
     * {@snippet lang=c :
     * #define DBG_RIPEXCEPTION 1073807367
     * }
     */
    public static int DBG_RIPEXCEPTION() {
        return DBG_RIPEXCEPTION;
    }
    private static final int DBG_CONTROL_BREAK = (int)1073807368L;
    /**
     * {@snippet lang=c :
     * #define DBG_CONTROL_BREAK 1073807368
     * }
     */
    public static int DBG_CONTROL_BREAK() {
        return DBG_CONTROL_BREAK;
    }
    private static final int DBG_COMMAND_EXCEPTION = (int)1073807369L;
    /**
     * {@snippet lang=c :
     * #define DBG_COMMAND_EXCEPTION 1073807369
     * }
     */
    public static int DBG_COMMAND_EXCEPTION() {
        return DBG_COMMAND_EXCEPTION;
    }
    private static final int DBG_PRINTEXCEPTION_WIDE_C = (int)1073807370L;
    /**
     * {@snippet lang=c :
     * #define DBG_PRINTEXCEPTION_WIDE_C 1073807370
     * }
     */
    public static int DBG_PRINTEXCEPTION_WIDE_C() {
        return DBG_PRINTEXCEPTION_WIDE_C;
    }
    private static final int STATUS_GUARD_PAGE_VIOLATION = (int)2147483649L;
    /**
     * {@snippet lang=c :
     * #define STATUS_GUARD_PAGE_VIOLATION 2147483649
     * }
     */
    public static int STATUS_GUARD_PAGE_VIOLATION() {
        return STATUS_GUARD_PAGE_VIOLATION;
    }
    private static final int STATUS_DATATYPE_MISALIGNMENT = (int)2147483650L;
    /**
     * {@snippet lang=c :
     * #define STATUS_DATATYPE_MISALIGNMENT 2147483650
     * }
     */
    public static int STATUS_DATATYPE_MISALIGNMENT() {
        return STATUS_DATATYPE_MISALIGNMENT;
    }
    private static final int STATUS_BREAKPOINT = (int)2147483651L;
    /**
     * {@snippet lang=c :
     * #define STATUS_BREAKPOINT 2147483651
     * }
     */
    public static int STATUS_BREAKPOINT() {
        return STATUS_BREAKPOINT;
    }
    private static final int STATUS_SINGLE_STEP = (int)2147483652L;
    /**
     * {@snippet lang=c :
     * #define STATUS_SINGLE_STEP 2147483652
     * }
     */
    public static int STATUS_SINGLE_STEP() {
        return STATUS_SINGLE_STEP;
    }
    private static final int STATUS_LONGJUMP = (int)2147483686L;
    /**
     * {@snippet lang=c :
     * #define STATUS_LONGJUMP 2147483686
     * }
     */
    public static int STATUS_LONGJUMP() {
        return STATUS_LONGJUMP;
    }
    private static final int STATUS_UNWIND_CONSOLIDATE = (int)2147483689L;
    /**
     * {@snippet lang=c :
     * #define STATUS_UNWIND_CONSOLIDATE 2147483689
     * }
     */
    public static int STATUS_UNWIND_CONSOLIDATE() {
        return STATUS_UNWIND_CONSOLIDATE;
    }
    private static final int DBG_EXCEPTION_NOT_HANDLED = (int)2147549185L;
    /**
     * {@snippet lang=c :
     * #define DBG_EXCEPTION_NOT_HANDLED 2147549185
     * }
     */
    public static int DBG_EXCEPTION_NOT_HANDLED() {
        return DBG_EXCEPTION_NOT_HANDLED;
    }
    private static final int STATUS_ACCESS_VIOLATION = (int)3221225477L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ACCESS_VIOLATION 3221225477
     * }
     */
    public static int STATUS_ACCESS_VIOLATION() {
        return STATUS_ACCESS_VIOLATION;
    }
    private static final int STATUS_IN_PAGE_ERROR = (int)3221225478L;
    /**
     * {@snippet lang=c :
     * #define STATUS_IN_PAGE_ERROR 3221225478
     * }
     */
    public static int STATUS_IN_PAGE_ERROR() {
        return STATUS_IN_PAGE_ERROR;
    }
    private static final int STATUS_INVALID_HANDLE = (int)3221225480L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INVALID_HANDLE 3221225480
     * }
     */
    public static int STATUS_INVALID_HANDLE() {
        return STATUS_INVALID_HANDLE;
    }
    private static final int STATUS_INVALID_PARAMETER = (int)3221225485L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INVALID_PARAMETER 3221225485
     * }
     */
    public static int STATUS_INVALID_PARAMETER() {
        return STATUS_INVALID_PARAMETER;
    }
    private static final int STATUS_NO_MEMORY = (int)3221225495L;
    /**
     * {@snippet lang=c :
     * #define STATUS_NO_MEMORY 3221225495
     * }
     */
    public static int STATUS_NO_MEMORY() {
        return STATUS_NO_MEMORY;
    }
    private static final int STATUS_ILLEGAL_INSTRUCTION = (int)3221225501L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ILLEGAL_INSTRUCTION 3221225501
     * }
     */
    public static int STATUS_ILLEGAL_INSTRUCTION() {
        return STATUS_ILLEGAL_INSTRUCTION;
    }
    private static final int STATUS_NONCONTINUABLE_EXCEPTION = (int)3221225509L;
    /**
     * {@snippet lang=c :
     * #define STATUS_NONCONTINUABLE_EXCEPTION 3221225509
     * }
     */
    public static int STATUS_NONCONTINUABLE_EXCEPTION() {
        return STATUS_NONCONTINUABLE_EXCEPTION;
    }
    private static final int STATUS_INVALID_DISPOSITION = (int)3221225510L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INVALID_DISPOSITION 3221225510
     * }
     */
    public static int STATUS_INVALID_DISPOSITION() {
        return STATUS_INVALID_DISPOSITION;
    }
    private static final int STATUS_ARRAY_BOUNDS_EXCEEDED = (int)3221225612L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ARRAY_BOUNDS_EXCEEDED 3221225612
     * }
     */
    public static int STATUS_ARRAY_BOUNDS_EXCEEDED() {
        return STATUS_ARRAY_BOUNDS_EXCEEDED;
    }
    private static final int STATUS_FLOAT_DENORMAL_OPERAND = (int)3221225613L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_DENORMAL_OPERAND 3221225613
     * }
     */
    public static int STATUS_FLOAT_DENORMAL_OPERAND() {
        return STATUS_FLOAT_DENORMAL_OPERAND;
    }
    private static final int STATUS_FLOAT_DIVIDE_BY_ZERO = (int)3221225614L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_DIVIDE_BY_ZERO 3221225614
     * }
     */
    public static int STATUS_FLOAT_DIVIDE_BY_ZERO() {
        return STATUS_FLOAT_DIVIDE_BY_ZERO;
    }
    private static final int STATUS_FLOAT_INEXACT_RESULT = (int)3221225615L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_INEXACT_RESULT 3221225615
     * }
     */
    public static int STATUS_FLOAT_INEXACT_RESULT() {
        return STATUS_FLOAT_INEXACT_RESULT;
    }
    private static final int STATUS_FLOAT_INVALID_OPERATION = (int)3221225616L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_INVALID_OPERATION 3221225616
     * }
     */
    public static int STATUS_FLOAT_INVALID_OPERATION() {
        return STATUS_FLOAT_INVALID_OPERATION;
    }
    private static final int STATUS_FLOAT_OVERFLOW = (int)3221225617L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_OVERFLOW 3221225617
     * }
     */
    public static int STATUS_FLOAT_OVERFLOW() {
        return STATUS_FLOAT_OVERFLOW;
    }
    private static final int STATUS_FLOAT_STACK_CHECK = (int)3221225618L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_STACK_CHECK 3221225618
     * }
     */
    public static int STATUS_FLOAT_STACK_CHECK() {
        return STATUS_FLOAT_STACK_CHECK;
    }
    private static final int STATUS_FLOAT_UNDERFLOW = (int)3221225619L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_UNDERFLOW 3221225619
     * }
     */
    public static int STATUS_FLOAT_UNDERFLOW() {
        return STATUS_FLOAT_UNDERFLOW;
    }
    private static final int STATUS_INTEGER_DIVIDE_BY_ZERO = (int)3221225620L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INTEGER_DIVIDE_BY_ZERO 3221225620
     * }
     */
    public static int STATUS_INTEGER_DIVIDE_BY_ZERO() {
        return STATUS_INTEGER_DIVIDE_BY_ZERO;
    }
    private static final int STATUS_INTEGER_OVERFLOW = (int)3221225621L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INTEGER_OVERFLOW 3221225621
     * }
     */
    public static int STATUS_INTEGER_OVERFLOW() {
        return STATUS_INTEGER_OVERFLOW;
    }
    private static final int STATUS_PRIVILEGED_INSTRUCTION = (int)3221225622L;
    /**
     * {@snippet lang=c :
     * #define STATUS_PRIVILEGED_INSTRUCTION 3221225622
     * }
     */
    public static int STATUS_PRIVILEGED_INSTRUCTION() {
        return STATUS_PRIVILEGED_INSTRUCTION;
    }
    private static final int STATUS_STACK_OVERFLOW = (int)3221225725L;
    /**
     * {@snippet lang=c :
     * #define STATUS_STACK_OVERFLOW 3221225725
     * }
     */
    public static int STATUS_STACK_OVERFLOW() {
        return STATUS_STACK_OVERFLOW;
    }
    private static final int STATUS_DLL_NOT_FOUND = (int)3221225781L;
    /**
     * {@snippet lang=c :
     * #define STATUS_DLL_NOT_FOUND 3221225781
     * }
     */
    public static int STATUS_DLL_NOT_FOUND() {
        return STATUS_DLL_NOT_FOUND;
    }
    private static final int STATUS_ORDINAL_NOT_FOUND = (int)3221225784L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ORDINAL_NOT_FOUND 3221225784
     * }
     */
    public static int STATUS_ORDINAL_NOT_FOUND() {
        return STATUS_ORDINAL_NOT_FOUND;
    }
    private static final int STATUS_ENTRYPOINT_NOT_FOUND = (int)3221225785L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ENTRYPOINT_NOT_FOUND 3221225785
     * }
     */
    public static int STATUS_ENTRYPOINT_NOT_FOUND() {
        return STATUS_ENTRYPOINT_NOT_FOUND;
    }
    private static final int STATUS_CONTROL_C_EXIT = (int)3221225786L;
    /**
     * {@snippet lang=c :
     * #define STATUS_CONTROL_C_EXIT 3221225786
     * }
     */
    public static int STATUS_CONTROL_C_EXIT() {
        return STATUS_CONTROL_C_EXIT;
    }
    private static final int STATUS_DLL_INIT_FAILED = (int)3221225794L;
    /**
     * {@snippet lang=c :
     * #define STATUS_DLL_INIT_FAILED 3221225794
     * }
     */
    public static int STATUS_DLL_INIT_FAILED() {
        return STATUS_DLL_INIT_FAILED;
    }
    private static final int STATUS_CONTROL_STACK_VIOLATION = (int)3221225906L;
    /**
     * {@snippet lang=c :
     * #define STATUS_CONTROL_STACK_VIOLATION 3221225906
     * }
     */
    public static int STATUS_CONTROL_STACK_VIOLATION() {
        return STATUS_CONTROL_STACK_VIOLATION;
    }
    private static final int STATUS_FLOAT_MULTIPLE_FAULTS = (int)3221226164L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_MULTIPLE_FAULTS 3221226164
     * }
     */
    public static int STATUS_FLOAT_MULTIPLE_FAULTS() {
        return STATUS_FLOAT_MULTIPLE_FAULTS;
    }
    private static final int STATUS_FLOAT_MULTIPLE_TRAPS = (int)3221226165L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_MULTIPLE_TRAPS 3221226165
     * }
     */
    public static int STATUS_FLOAT_MULTIPLE_TRAPS() {
        return STATUS_FLOAT_MULTIPLE_TRAPS;
    }
    private static final int STATUS_REG_NAT_CONSUMPTION = (int)3221226185L;
    /**
     * {@snippet lang=c :
     * #define STATUS_REG_NAT_CONSUMPTION 3221226185
     * }
     */
    public static int STATUS_REG_NAT_CONSUMPTION() {
        return STATUS_REG_NAT_CONSUMPTION;
    }
    private static final int STATUS_HEAP_CORRUPTION = (int)3221226356L;
    /**
     * {@snippet lang=c :
     * #define STATUS_HEAP_CORRUPTION 3221226356
     * }
     */
    public static int STATUS_HEAP_CORRUPTION() {
        return STATUS_HEAP_CORRUPTION;
    }
    private static final int STATUS_STACK_BUFFER_OVERRUN = (int)3221226505L;
    /**
     * {@snippet lang=c :
     * #define STATUS_STACK_BUFFER_OVERRUN 3221226505
     * }
     */
    public static int STATUS_STACK_BUFFER_OVERRUN() {
        return STATUS_STACK_BUFFER_OVERRUN;
    }
    private static final int STATUS_INVALID_CRUNTIME_PARAMETER = (int)3221226519L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INVALID_CRUNTIME_PARAMETER 3221226519
     * }
     */
    public static int STATUS_INVALID_CRUNTIME_PARAMETER() {
        return STATUS_INVALID_CRUNTIME_PARAMETER;
    }
    private static final int STATUS_ASSERTION_FAILURE = (int)3221226528L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ASSERTION_FAILURE 3221226528
     * }
     */
    public static int STATUS_ASSERTION_FAILURE() {
        return STATUS_ASSERTION_FAILURE;
    }
    private static final int STATUS_ENCLAVE_VIOLATION = (int)3221226658L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ENCLAVE_VIOLATION 3221226658
     * }
     */
    public static int STATUS_ENCLAVE_VIOLATION() {
        return STATUS_ENCLAVE_VIOLATION;
    }
    private static final int STATUS_INTERRUPTED = (int)3221226773L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INTERRUPTED 3221226773
     * }
     */
    public static int STATUS_INTERRUPTED() {
        return STATUS_INTERRUPTED;
    }
    private static final int STATUS_THREAD_NOT_RUNNING = (int)3221226774L;
    /**
     * {@snippet lang=c :
     * #define STATUS_THREAD_NOT_RUNNING 3221226774
     * }
     */
    public static int STATUS_THREAD_NOT_RUNNING() {
        return STATUS_THREAD_NOT_RUNNING;
    }
    private static final int STATUS_ALREADY_REGISTERED = (int)3221227288L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ALREADY_REGISTERED 3221227288
     * }
     */
    public static int STATUS_ALREADY_REGISTERED() {
        return STATUS_ALREADY_REGISTERED;
    }
    private static final int STATUS_SXS_EARLY_DEACTIVATION = (int)3222601743L;
    /**
     * {@snippet lang=c :
     * #define STATUS_SXS_EARLY_DEACTIVATION 3222601743
     * }
     */
    public static int STATUS_SXS_EARLY_DEACTIVATION() {
        return STATUS_SXS_EARLY_DEACTIVATION;
    }
    private static final int STATUS_SXS_INVALID_DEACTIVATION = (int)3222601744L;
    /**
     * {@snippet lang=c :
     * #define STATUS_SXS_INVALID_DEACTIVATION 3222601744
     * }
     */
    public static int STATUS_SXS_INVALID_DEACTIVATION() {
        return STATUS_SXS_INVALID_DEACTIVATION;
    }
    private static final int MAXIMUM_SUSPEND_COUNT = (int)127L;
    /**
     * {@snippet lang=c :
     * #define MAXIMUM_SUSPEND_COUNT 127
     * }
     */
    public static int MAXIMUM_SUSPEND_COUNT() {
        return MAXIMUM_SUSPEND_COUNT;
    }
    private static final int PF_TEMPORAL_LEVEL_1 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PF_TEMPORAL_LEVEL_1 1
     * }
     */
    public static int PF_TEMPORAL_LEVEL_1() {
        return PF_TEMPORAL_LEVEL_1;
    }
    private static final int PF_TEMPORAL_LEVEL_2 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PF_TEMPORAL_LEVEL_2 2
     * }
     */
    public static int PF_TEMPORAL_LEVEL_2() {
        return PF_TEMPORAL_LEVEL_2;
    }
    private static final int PF_TEMPORAL_LEVEL_3 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PF_TEMPORAL_LEVEL_3 3
     * }
     */
    public static int PF_TEMPORAL_LEVEL_3() {
        return PF_TEMPORAL_LEVEL_3;
    }
    private static final int PF_NON_TEMPORAL_LEVEL_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PF_NON_TEMPORAL_LEVEL_ALL 0
     * }
     */
    public static int PF_NON_TEMPORAL_LEVEL_ALL() {
        return PF_NON_TEMPORAL_LEVEL_ALL;
    }
    private static final int CONTEXT_AMD64 = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_AMD64 1048576
     * }
     */
    public static int CONTEXT_AMD64() {
        return CONTEXT_AMD64;
    }
    private static final int CONTEXT_CONTROL = (int)1048577L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_CONTROL 1048577
     * }
     */
    public static int CONTEXT_CONTROL() {
        return CONTEXT_CONTROL;
    }
    private static final int CONTEXT_INTEGER = (int)1048578L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_INTEGER 1048578
     * }
     */
    public static int CONTEXT_INTEGER() {
        return CONTEXT_INTEGER;
    }
    private static final int CONTEXT_SEGMENTS = (int)1048580L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_SEGMENTS 1048580
     * }
     */
    public static int CONTEXT_SEGMENTS() {
        return CONTEXT_SEGMENTS;
    }
    private static final int CONTEXT_FLOATING_POINT = (int)1048584L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_FLOATING_POINT 1048584
     * }
     */
    public static int CONTEXT_FLOATING_POINT() {
        return CONTEXT_FLOATING_POINT;
    }
    private static final int CONTEXT_DEBUG_REGISTERS = (int)1048592L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_DEBUG_REGISTERS 1048592
     * }
     */
    public static int CONTEXT_DEBUG_REGISTERS() {
        return CONTEXT_DEBUG_REGISTERS;
    }
}

