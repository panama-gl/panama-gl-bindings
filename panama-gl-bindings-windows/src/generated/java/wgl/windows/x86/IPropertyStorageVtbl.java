// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class IPropertyStorageVtbl {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("QueryInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("AddRef"),
        Constants$root.C_POINTER$LAYOUT.withName("Release"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadMultiple"),
        Constants$root.C_POINTER$LAYOUT.withName("WriteMultiple"),
        Constants$root.C_POINTER$LAYOUT.withName("DeleteMultiple"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadPropertyNames"),
        Constants$root.C_POINTER$LAYOUT.withName("WritePropertyNames"),
        Constants$root.C_POINTER$LAYOUT.withName("DeletePropertyNames"),
        Constants$root.C_POINTER$LAYOUT.withName("Commit"),
        Constants$root.C_POINTER$LAYOUT.withName("Revert"),
        Constants$root.C_POINTER$LAYOUT.withName("Enum"),
        Constants$root.C_POINTER$LAYOUT.withName("SetTimes"),
        Constants$root.C_POINTER$LAYOUT.withName("SetClass"),
        Constants$root.C_POINTER$LAYOUT.withName("Stat")
    ).withName("IPropertyStorageVtbl");
    public static MemoryLayout $LAYOUT() {
        return IPropertyStorageVtbl.$struct$LAYOUT;
    }
    static final FunctionDescriptor QueryInterface$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.QueryInterface$FUNC
    );
    public interface QueryInterface {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(QueryInterface fi, MemorySession session) {
            return RuntimeHelper.upcallStub(QueryInterface.class, fi, IPropertyStorageVtbl.QueryInterface$FUNC, session);
        }
        static QueryInterface ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IPropertyStorageVtbl.QueryInterface$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle QueryInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("QueryInterface"));
    public static VarHandle QueryInterface$VH() {
        return IPropertyStorageVtbl.QueryInterface$VH;
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.QueryInterface$VH.get(seg);
    }
    public static void QueryInterface$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.QueryInterface$VH.set(seg, x);
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.QueryInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void QueryInterface$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.QueryInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static QueryInterface QueryInterface (MemorySegment segment, MemorySession session) {
        return QueryInterface.ofAddress(QueryInterface$get(segment), session);
    }
    static final FunctionDescriptor AddRef$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.AddRef$FUNC
    );
    public interface AddRef {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(AddRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AddRef.class, fi, IPropertyStorageVtbl.AddRef$FUNC, session);
        }
        static AddRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IPropertyStorageVtbl.AddRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AddRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AddRef"));
    public static VarHandle AddRef$VH() {
        return IPropertyStorageVtbl.AddRef$VH;
    }
    public static MemoryAddress AddRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.AddRef$VH.get(seg);
    }
    public static void AddRef$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.AddRef$VH.set(seg, x);
    }
    public static MemoryAddress AddRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.AddRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AddRef$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.AddRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AddRef AddRef (MemorySegment segment, MemorySession session) {
        return AddRef.ofAddress(AddRef$get(segment), session);
    }
    static final FunctionDescriptor Release$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.Release$FUNC
    );
    public interface Release {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(Release fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Release.class, fi, IPropertyStorageVtbl.Release$FUNC, session);
        }
        static Release ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IPropertyStorageVtbl.Release$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Release"));
    public static VarHandle Release$VH() {
        return IPropertyStorageVtbl.Release$VH;
    }
    public static MemoryAddress Release$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.Release$VH.get(seg);
    }
    public static void Release$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.Release$VH.set(seg, x);
    }
    public static MemoryAddress Release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.Release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Release$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.Release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Release Release (MemorySegment segment, MemorySession session) {
        return Release.ofAddress(Release$get(segment), session);
    }
    static final FunctionDescriptor ReadMultiple$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReadMultiple$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.ReadMultiple$FUNC
    );
    public interface ReadMultiple {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(ReadMultiple fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadMultiple.class, fi, IPropertyStorageVtbl.ReadMultiple$FUNC, session);
        }
        static ReadMultiple ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)IPropertyStorageVtbl.ReadMultiple$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadMultiple$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadMultiple"));
    public static VarHandle ReadMultiple$VH() {
        return IPropertyStorageVtbl.ReadMultiple$VH;
    }
    public static MemoryAddress ReadMultiple$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.ReadMultiple$VH.get(seg);
    }
    public static void ReadMultiple$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.ReadMultiple$VH.set(seg, x);
    }
    public static MemoryAddress ReadMultiple$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.ReadMultiple$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadMultiple$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.ReadMultiple$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadMultiple ReadMultiple (MemorySegment segment, MemorySession session) {
        return ReadMultiple.ofAddress(ReadMultiple$get(segment), session);
    }
    static final FunctionDescriptor WriteMultiple$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle WriteMultiple$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.WriteMultiple$FUNC
    );
    public interface WriteMultiple {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, int _x4);
        static MemorySegment allocate(WriteMultiple fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WriteMultiple.class, fi, IPropertyStorageVtbl.WriteMultiple$FUNC, session);
        }
        static WriteMultiple ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, int __x4) -> {
                try {
                    return (int)IPropertyStorageVtbl.WriteMultiple$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WriteMultiple$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WriteMultiple"));
    public static VarHandle WriteMultiple$VH() {
        return IPropertyStorageVtbl.WriteMultiple$VH;
    }
    public static MemoryAddress WriteMultiple$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.WriteMultiple$VH.get(seg);
    }
    public static void WriteMultiple$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.WriteMultiple$VH.set(seg, x);
    }
    public static MemoryAddress WriteMultiple$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.WriteMultiple$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WriteMultiple$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.WriteMultiple$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WriteMultiple WriteMultiple (MemorySegment segment, MemorySession session) {
        return WriteMultiple.ofAddress(WriteMultiple$get(segment), session);
    }
    static final FunctionDescriptor DeleteMultiple$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle DeleteMultiple$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.DeleteMultiple$FUNC
    );
    public interface DeleteMultiple {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(DeleteMultiple fi, MemorySession session) {
            return RuntimeHelper.upcallStub(DeleteMultiple.class, fi, IPropertyStorageVtbl.DeleteMultiple$FUNC, session);
        }
        static DeleteMultiple ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IPropertyStorageVtbl.DeleteMultiple$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle DeleteMultiple$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DeleteMultiple"));
    public static VarHandle DeleteMultiple$VH() {
        return IPropertyStorageVtbl.DeleteMultiple$VH;
    }
    public static MemoryAddress DeleteMultiple$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.DeleteMultiple$VH.get(seg);
    }
    public static void DeleteMultiple$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.DeleteMultiple$VH.set(seg, x);
    }
    public static MemoryAddress DeleteMultiple$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.DeleteMultiple$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DeleteMultiple$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.DeleteMultiple$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static DeleteMultiple DeleteMultiple (MemorySegment segment, MemorySession session) {
        return DeleteMultiple.ofAddress(DeleteMultiple$get(segment), session);
    }
    static final FunctionDescriptor ReadPropertyNames$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReadPropertyNames$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.ReadPropertyNames$FUNC
    );
    public interface ReadPropertyNames {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(ReadPropertyNames fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadPropertyNames.class, fi, IPropertyStorageVtbl.ReadPropertyNames$FUNC, session);
        }
        static ReadPropertyNames ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)IPropertyStorageVtbl.ReadPropertyNames$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadPropertyNames$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadPropertyNames"));
    public static VarHandle ReadPropertyNames$VH() {
        return IPropertyStorageVtbl.ReadPropertyNames$VH;
    }
    public static MemoryAddress ReadPropertyNames$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.ReadPropertyNames$VH.get(seg);
    }
    public static void ReadPropertyNames$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.ReadPropertyNames$VH.set(seg, x);
    }
    public static MemoryAddress ReadPropertyNames$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.ReadPropertyNames$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadPropertyNames$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.ReadPropertyNames$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadPropertyNames ReadPropertyNames (MemorySegment segment, MemorySession session) {
        return ReadPropertyNames.ofAddress(ReadPropertyNames$get(segment), session);
    }
    static final FunctionDescriptor WritePropertyNames$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle WritePropertyNames$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.WritePropertyNames$FUNC
    );
    public interface WritePropertyNames {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(WritePropertyNames fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WritePropertyNames.class, fi, IPropertyStorageVtbl.WritePropertyNames$FUNC, session);
        }
        static WritePropertyNames ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)IPropertyStorageVtbl.WritePropertyNames$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WritePropertyNames$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WritePropertyNames"));
    public static VarHandle WritePropertyNames$VH() {
        return IPropertyStorageVtbl.WritePropertyNames$VH;
    }
    public static MemoryAddress WritePropertyNames$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.WritePropertyNames$VH.get(seg);
    }
    public static void WritePropertyNames$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.WritePropertyNames$VH.set(seg, x);
    }
    public static MemoryAddress WritePropertyNames$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.WritePropertyNames$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WritePropertyNames$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.WritePropertyNames$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WritePropertyNames WritePropertyNames (MemorySegment segment, MemorySession session) {
        return WritePropertyNames.ofAddress(WritePropertyNames$get(segment), session);
    }
    static final FunctionDescriptor DeletePropertyNames$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle DeletePropertyNames$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.DeletePropertyNames$FUNC
    );
    public interface DeletePropertyNames {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(DeletePropertyNames fi, MemorySession session) {
            return RuntimeHelper.upcallStub(DeletePropertyNames.class, fi, IPropertyStorageVtbl.DeletePropertyNames$FUNC, session);
        }
        static DeletePropertyNames ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IPropertyStorageVtbl.DeletePropertyNames$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle DeletePropertyNames$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DeletePropertyNames"));
    public static VarHandle DeletePropertyNames$VH() {
        return IPropertyStorageVtbl.DeletePropertyNames$VH;
    }
    public static MemoryAddress DeletePropertyNames$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.DeletePropertyNames$VH.get(seg);
    }
    public static void DeletePropertyNames$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.DeletePropertyNames$VH.set(seg, x);
    }
    public static MemoryAddress DeletePropertyNames$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.DeletePropertyNames$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DeletePropertyNames$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.DeletePropertyNames$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static DeletePropertyNames DeletePropertyNames (MemorySegment segment, MemorySession session) {
        return DeletePropertyNames.ofAddress(DeletePropertyNames$get(segment), session);
    }
    static final FunctionDescriptor Commit$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle Commit$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.Commit$FUNC
    );
    public interface Commit {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(Commit fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Commit.class, fi, IPropertyStorageVtbl.Commit$FUNC, session);
        }
        static Commit ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (int)IPropertyStorageVtbl.Commit$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Commit$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Commit"));
    public static VarHandle Commit$VH() {
        return IPropertyStorageVtbl.Commit$VH;
    }
    public static MemoryAddress Commit$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.Commit$VH.get(seg);
    }
    public static void Commit$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.Commit$VH.set(seg, x);
    }
    public static MemoryAddress Commit$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.Commit$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Commit$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.Commit$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Commit Commit (MemorySegment segment, MemorySession session) {
        return Commit.ofAddress(Commit$get(segment), session);
    }
    static final FunctionDescriptor Revert$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Revert$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.Revert$FUNC
    );
    public interface Revert {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(Revert fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Revert.class, fi, IPropertyStorageVtbl.Revert$FUNC, session);
        }
        static Revert ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IPropertyStorageVtbl.Revert$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Revert$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Revert"));
    public static VarHandle Revert$VH() {
        return IPropertyStorageVtbl.Revert$VH;
    }
    public static MemoryAddress Revert$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.Revert$VH.get(seg);
    }
    public static void Revert$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.Revert$VH.set(seg, x);
    }
    public static MemoryAddress Revert$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.Revert$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Revert$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.Revert$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Revert Revert (MemorySegment segment, MemorySession session) {
        return Revert.ofAddress(Revert$get(segment), session);
    }
    static final FunctionDescriptor Enum$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Enum$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.Enum$FUNC
    );
    public interface Enum {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(Enum fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Enum.class, fi, IPropertyStorageVtbl.Enum$FUNC, session);
        }
        static Enum ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IPropertyStorageVtbl.Enum$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Enum$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Enum"));
    public static VarHandle Enum$VH() {
        return IPropertyStorageVtbl.Enum$VH;
    }
    public static MemoryAddress Enum$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.Enum$VH.get(seg);
    }
    public static void Enum$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.Enum$VH.set(seg, x);
    }
    public static MemoryAddress Enum$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.Enum$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Enum$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.Enum$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Enum Enum (MemorySegment segment, MemorySession session) {
        return Enum.ofAddress(Enum$get(segment), session);
    }
    static final FunctionDescriptor SetTimes$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetTimes$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.SetTimes$FUNC
    );
    public interface SetTimes {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(SetTimes fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetTimes.class, fi, IPropertyStorageVtbl.SetTimes$FUNC, session);
        }
        static SetTimes ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)IPropertyStorageVtbl.SetTimes$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetTimes$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetTimes"));
    public static VarHandle SetTimes$VH() {
        return IPropertyStorageVtbl.SetTimes$VH;
    }
    public static MemoryAddress SetTimes$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.SetTimes$VH.get(seg);
    }
    public static void SetTimes$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.SetTimes$VH.set(seg, x);
    }
    public static MemoryAddress SetTimes$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.SetTimes$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetTimes$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.SetTimes$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetTimes SetTimes (MemorySegment segment, MemorySession session) {
        return SetTimes.ofAddress(SetTimes$get(segment), session);
    }
    static final FunctionDescriptor SetClass$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetClass$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.SetClass$FUNC
    );
    public interface SetClass {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(SetClass fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetClass.class, fi, IPropertyStorageVtbl.SetClass$FUNC, session);
        }
        static SetClass ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IPropertyStorageVtbl.SetClass$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetClass$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetClass"));
    public static VarHandle SetClass$VH() {
        return IPropertyStorageVtbl.SetClass$VH;
    }
    public static MemoryAddress SetClass$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.SetClass$VH.get(seg);
    }
    public static void SetClass$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.SetClass$VH.set(seg, x);
    }
    public static MemoryAddress SetClass$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.SetClass$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetClass$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.SetClass$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetClass SetClass (MemorySegment segment, MemorySession session) {
        return SetClass.ofAddress(SetClass$get(segment), session);
    }
    static final FunctionDescriptor Stat$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Stat$MH = RuntimeHelper.downcallHandle(
        IPropertyStorageVtbl.Stat$FUNC
    );
    public interface Stat {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(Stat fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Stat.class, fi, IPropertyStorageVtbl.Stat$FUNC, session);
        }
        static Stat ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IPropertyStorageVtbl.Stat$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Stat$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Stat"));
    public static VarHandle Stat$VH() {
        return IPropertyStorageVtbl.Stat$VH;
    }
    public static MemoryAddress Stat$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.Stat$VH.get(seg);
    }
    public static void Stat$set( MemorySegment seg, MemoryAddress x) {
        IPropertyStorageVtbl.Stat$VH.set(seg, x);
    }
    public static MemoryAddress Stat$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IPropertyStorageVtbl.Stat$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Stat$set(MemorySegment seg, long index, MemoryAddress x) {
        IPropertyStorageVtbl.Stat$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Stat Stat (MemorySegment segment, MemorySession session) {
        return Stat.ofAddress(Stat$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


