// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ITypeInfoVtbl {
 *     HRESULT (*QueryInterface)(ITypeInfo *, const IID *const, void **) __attribute__((stdcall));
 *     ULONG (*AddRef)(ITypeInfo *) __attribute__((stdcall));
 *     ULONG (*Release)(ITypeInfo *) __attribute__((stdcall));
 *     HRESULT (*GetTypeAttr)(ITypeInfo *, TYPEATTR **) __attribute__((stdcall));
 *     HRESULT (*GetTypeComp)(ITypeInfo *, ITypeComp **) __attribute__((stdcall));
 *     HRESULT (*GetFuncDesc)(ITypeInfo *, UINT, FUNCDESC **) __attribute__((stdcall));
 *     HRESULT (*GetVarDesc)(ITypeInfo *, UINT, VARDESC **) __attribute__((stdcall));
 *     HRESULT (*GetNames)(ITypeInfo *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall));
 *     HRESULT (*GetRefTypeOfImplType)(ITypeInfo *, UINT, HREFTYPE *) __attribute__((stdcall));
 *     HRESULT (*GetImplTypeFlags)(ITypeInfo *, UINT, INT *) __attribute__((stdcall));
 *     HRESULT (*GetIDsOfNames)(ITypeInfo *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall));
 *     HRESULT (*Invoke)(ITypeInfo *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall));
 *     HRESULT (*GetDocumentation)(ITypeInfo *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetDllEntry)(ITypeInfo *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall));
 *     HRESULT (*GetRefTypeInfo)(ITypeInfo *, HREFTYPE, ITypeInfo **) __attribute__((stdcall));
 *     HRESULT (*AddressOfMember)(ITypeInfo *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall));
 *     HRESULT (*CreateInstance)(ITypeInfo *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall));
 *     HRESULT (*GetMops)(ITypeInfo *, MEMBERID, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetContainingTypeLib)(ITypeInfo *, ITypeLib **, UINT *) __attribute__((stdcall));
 *     void (*ReleaseTypeAttr)(ITypeInfo *, TYPEATTR *) __attribute__((stdcall));
 *     void (*ReleaseFuncDesc)(ITypeInfo *, FUNCDESC *) __attribute__((stdcall));
 *     void (*ReleaseVarDesc)(ITypeInfo *, VARDESC *) __attribute__((stdcall));
 * }
 * }
 */
public class ITypeInfoVtbl {

    ITypeInfoVtbl() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        wgl_h.C_POINTER.withName("QueryInterface"),
        wgl_h.C_POINTER.withName("AddRef"),
        wgl_h.C_POINTER.withName("Release"),
        wgl_h.C_POINTER.withName("GetTypeAttr"),
        wgl_h.C_POINTER.withName("GetTypeComp"),
        wgl_h.C_POINTER.withName("GetFuncDesc"),
        wgl_h.C_POINTER.withName("GetVarDesc"),
        wgl_h.C_POINTER.withName("GetNames"),
        wgl_h.C_POINTER.withName("GetRefTypeOfImplType"),
        wgl_h.C_POINTER.withName("GetImplTypeFlags"),
        wgl_h.C_POINTER.withName("GetIDsOfNames"),
        wgl_h.C_POINTER.withName("Invoke"),
        wgl_h.C_POINTER.withName("GetDocumentation"),
        wgl_h.C_POINTER.withName("GetDllEntry"),
        wgl_h.C_POINTER.withName("GetRefTypeInfo"),
        wgl_h.C_POINTER.withName("AddressOfMember"),
        wgl_h.C_POINTER.withName("CreateInstance"),
        wgl_h.C_POINTER.withName("GetMops"),
        wgl_h.C_POINTER.withName("GetContainingTypeLib"),
        wgl_h.C_POINTER.withName("ReleaseTypeAttr"),
        wgl_h.C_POINTER.withName("ReleaseFuncDesc"),
        wgl_h.C_POINTER.withName("ReleaseVarDesc")
    ).withName("ITypeInfoVtbl");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(ITypeInfo *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static class QueryInterface {

        QueryInterface() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(QueryInterface.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(QueryInterface.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout QueryInterface$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("QueryInterface"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(ITypeInfo *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout QueryInterface$layout() {
        return QueryInterface$LAYOUT;
    }

    private static final long QueryInterface$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(ITypeInfo *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static final long QueryInterface$offset() {
        return QueryInterface$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(ITypeInfo *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment QueryInterface(MemorySegment struct) {
        return struct.get(QueryInterface$LAYOUT, QueryInterface$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(ITypeInfo *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static void QueryInterface(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(QueryInterface$LAYOUT, QueryInterface$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ULONG (*AddRef)(ITypeInfo *) __attribute__((stdcall))
     * }
     */
    public static class AddRef {

        AddRef() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(AddRef.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddRef.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddRef$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddRef"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(ITypeInfo *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout AddRef$layout() {
        return AddRef$LAYOUT;
    }

    private static final long AddRef$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(ITypeInfo *) __attribute__((stdcall))
     * }
     */
    public static final long AddRef$offset() {
        return AddRef$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(ITypeInfo *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment AddRef(MemorySegment struct) {
        return struct.get(AddRef$LAYOUT, AddRef$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(ITypeInfo *) __attribute__((stdcall))
     * }
     */
    public static void AddRef(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddRef$LAYOUT, AddRef$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ULONG (*Release)(ITypeInfo *) __attribute__((stdcall))
     * }
     */
    public static class Release {

        Release() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(Release.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Release.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Release$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Release"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG (*Release)(ITypeInfo *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout Release$layout() {
        return Release$LAYOUT;
    }

    private static final long Release$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG (*Release)(ITypeInfo *) __attribute__((stdcall))
     * }
     */
    public static final long Release$offset() {
        return Release$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG (*Release)(ITypeInfo *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment Release(MemorySegment struct) {
        return struct.get(Release$LAYOUT, Release$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG (*Release)(ITypeInfo *) __attribute__((stdcall))
     * }
     */
    public static void Release(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Release$LAYOUT, Release$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetTypeAttr)(ITypeInfo *, TYPEATTR **) __attribute__((stdcall))
     * }
     */
    public static class GetTypeAttr {

        GetTypeAttr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetTypeAttr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTypeAttr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTypeAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTypeAttr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeAttr)(ITypeInfo *, TYPEATTR **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetTypeAttr$layout() {
        return GetTypeAttr$LAYOUT;
    }

    private static final long GetTypeAttr$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeAttr)(ITypeInfo *, TYPEATTR **) __attribute__((stdcall))
     * }
     */
    public static final long GetTypeAttr$offset() {
        return GetTypeAttr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeAttr)(ITypeInfo *, TYPEATTR **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetTypeAttr(MemorySegment struct) {
        return struct.get(GetTypeAttr$LAYOUT, GetTypeAttr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeAttr)(ITypeInfo *, TYPEATTR **) __attribute__((stdcall))
     * }
     */
    public static void GetTypeAttr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTypeAttr$LAYOUT, GetTypeAttr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetTypeComp)(ITypeInfo *, ITypeComp **) __attribute__((stdcall))
     * }
     */
    public static class GetTypeComp {

        GetTypeComp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetTypeComp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTypeComp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTypeComp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTypeComp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeComp)(ITypeInfo *, ITypeComp **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetTypeComp$layout() {
        return GetTypeComp$LAYOUT;
    }

    private static final long GetTypeComp$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeComp)(ITypeInfo *, ITypeComp **) __attribute__((stdcall))
     * }
     */
    public static final long GetTypeComp$offset() {
        return GetTypeComp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeComp)(ITypeInfo *, ITypeComp **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetTypeComp(MemorySegment struct) {
        return struct.get(GetTypeComp$LAYOUT, GetTypeComp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetTypeComp)(ITypeInfo *, ITypeComp **) __attribute__((stdcall))
     * }
     */
    public static void GetTypeComp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTypeComp$LAYOUT, GetTypeComp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetFuncDesc)(ITypeInfo *, UINT, FUNCDESC **) __attribute__((stdcall))
     * }
     */
    public static class GetFuncDesc {

        GetFuncDesc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetFuncDesc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFuncDesc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFuncDesc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFuncDesc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncDesc)(ITypeInfo *, UINT, FUNCDESC **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetFuncDesc$layout() {
        return GetFuncDesc$LAYOUT;
    }

    private static final long GetFuncDesc$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncDesc)(ITypeInfo *, UINT, FUNCDESC **) __attribute__((stdcall))
     * }
     */
    public static final long GetFuncDesc$offset() {
        return GetFuncDesc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncDesc)(ITypeInfo *, UINT, FUNCDESC **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetFuncDesc(MemorySegment struct) {
        return struct.get(GetFuncDesc$LAYOUT, GetFuncDesc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetFuncDesc)(ITypeInfo *, UINT, FUNCDESC **) __attribute__((stdcall))
     * }
     */
    public static void GetFuncDesc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFuncDesc$LAYOUT, GetFuncDesc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetVarDesc)(ITypeInfo *, UINT, VARDESC **) __attribute__((stdcall))
     * }
     */
    public static class GetVarDesc {

        GetVarDesc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetVarDesc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetVarDesc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetVarDesc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetVarDesc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarDesc)(ITypeInfo *, UINT, VARDESC **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetVarDesc$layout() {
        return GetVarDesc$LAYOUT;
    }

    private static final long GetVarDesc$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarDesc)(ITypeInfo *, UINT, VARDESC **) __attribute__((stdcall))
     * }
     */
    public static final long GetVarDesc$offset() {
        return GetVarDesc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarDesc)(ITypeInfo *, UINT, VARDESC **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetVarDesc(MemorySegment struct) {
        return struct.get(GetVarDesc$LAYOUT, GetVarDesc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetVarDesc)(ITypeInfo *, UINT, VARDESC **) __attribute__((stdcall))
     * }
     */
    public static void GetVarDesc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetVarDesc$LAYOUT, GetVarDesc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetNames)(ITypeInfo *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall))
     * }
     */
    public static class GetNames {

        GetNames() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetNames.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetNames.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetNames$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetNames"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetNames)(ITypeInfo *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetNames$layout() {
        return GetNames$LAYOUT;
    }

    private static final long GetNames$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetNames)(ITypeInfo *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall))
     * }
     */
    public static final long GetNames$offset() {
        return GetNames$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetNames)(ITypeInfo *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetNames(MemorySegment struct) {
        return struct.get(GetNames$LAYOUT, GetNames$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetNames)(ITypeInfo *, MEMBERID, BSTR *, UINT, UINT *) __attribute__((stdcall))
     * }
     */
    public static void GetNames(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetNames$LAYOUT, GetNames$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeOfImplType)(ITypeInfo *, UINT, HREFTYPE *) __attribute__((stdcall))
     * }
     */
    public static class GetRefTypeOfImplType {

        GetRefTypeOfImplType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetRefTypeOfImplType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetRefTypeOfImplType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetRefTypeOfImplType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetRefTypeOfImplType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeOfImplType)(ITypeInfo *, UINT, HREFTYPE *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetRefTypeOfImplType$layout() {
        return GetRefTypeOfImplType$LAYOUT;
    }

    private static final long GetRefTypeOfImplType$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeOfImplType)(ITypeInfo *, UINT, HREFTYPE *) __attribute__((stdcall))
     * }
     */
    public static final long GetRefTypeOfImplType$offset() {
        return GetRefTypeOfImplType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeOfImplType)(ITypeInfo *, UINT, HREFTYPE *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetRefTypeOfImplType(MemorySegment struct) {
        return struct.get(GetRefTypeOfImplType$LAYOUT, GetRefTypeOfImplType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeOfImplType)(ITypeInfo *, UINT, HREFTYPE *) __attribute__((stdcall))
     * }
     */
    public static void GetRefTypeOfImplType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetRefTypeOfImplType$LAYOUT, GetRefTypeOfImplType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeFlags)(ITypeInfo *, UINT, INT *) __attribute__((stdcall))
     * }
     */
    public static class GetImplTypeFlags {

        GetImplTypeFlags() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetImplTypeFlags.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetImplTypeFlags.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetImplTypeFlags$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetImplTypeFlags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeFlags)(ITypeInfo *, UINT, INT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetImplTypeFlags$layout() {
        return GetImplTypeFlags$LAYOUT;
    }

    private static final long GetImplTypeFlags$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeFlags)(ITypeInfo *, UINT, INT *) __attribute__((stdcall))
     * }
     */
    public static final long GetImplTypeFlags$offset() {
        return GetImplTypeFlags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeFlags)(ITypeInfo *, UINT, INT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetImplTypeFlags(MemorySegment struct) {
        return struct.get(GetImplTypeFlags$LAYOUT, GetImplTypeFlags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetImplTypeFlags)(ITypeInfo *, UINT, INT *) __attribute__((stdcall))
     * }
     */
    public static void GetImplTypeFlags(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetImplTypeFlags$LAYOUT, GetImplTypeFlags$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(ITypeInfo *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall))
     * }
     */
    public static class GetIDsOfNames {

        GetIDsOfNames() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetIDsOfNames.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetIDsOfNames.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetIDsOfNames$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetIDsOfNames"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(ITypeInfo *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetIDsOfNames$layout() {
        return GetIDsOfNames$LAYOUT;
    }

    private static final long GetIDsOfNames$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(ITypeInfo *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall))
     * }
     */
    public static final long GetIDsOfNames$offset() {
        return GetIDsOfNames$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(ITypeInfo *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetIDsOfNames(MemorySegment struct) {
        return struct.get(GetIDsOfNames$LAYOUT, GetIDsOfNames$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetIDsOfNames)(ITypeInfo *, LPOLESTR *, UINT, MEMBERID *) __attribute__((stdcall))
     * }
     */
    public static void GetIDsOfNames(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetIDsOfNames$LAYOUT, GetIDsOfNames$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*Invoke)(ITypeInfo *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static class Invoke {

        Invoke() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, short _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(Invoke.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Invoke.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, short _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Invoke$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Invoke"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(ITypeInfo *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout Invoke$layout() {
        return Invoke$LAYOUT;
    }

    private static final long Invoke$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(ITypeInfo *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static final long Invoke$offset() {
        return Invoke$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(ITypeInfo *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment Invoke(MemorySegment struct) {
        return struct.get(Invoke$LAYOUT, Invoke$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*Invoke)(ITypeInfo *, PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) __attribute__((stdcall))
     * }
     */
    public static void Invoke(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Invoke$LAYOUT, Invoke$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation)(ITypeInfo *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetDocumentation {

        GetDocumentation() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetDocumentation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDocumentation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDocumentation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDocumentation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation)(ITypeInfo *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetDocumentation$layout() {
        return GetDocumentation$LAYOUT;
    }

    private static final long GetDocumentation$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation)(ITypeInfo *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetDocumentation$offset() {
        return GetDocumentation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation)(ITypeInfo *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetDocumentation(MemorySegment struct) {
        return struct.get(GetDocumentation$LAYOUT, GetDocumentation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDocumentation)(ITypeInfo *, MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetDocumentation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDocumentation$LAYOUT, GetDocumentation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetDllEntry)(ITypeInfo *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall))
     * }
     */
    public static class GetDllEntry {

        GetDllEntry() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetDllEntry.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDllEntry.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDllEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDllEntry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetDllEntry)(ITypeInfo *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetDllEntry$layout() {
        return GetDllEntry$LAYOUT;
    }

    private static final long GetDllEntry$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetDllEntry)(ITypeInfo *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall))
     * }
     */
    public static final long GetDllEntry$offset() {
        return GetDllEntry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDllEntry)(ITypeInfo *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetDllEntry(MemorySegment struct) {
        return struct.get(GetDllEntry$LAYOUT, GetDllEntry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDllEntry)(ITypeInfo *, MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) __attribute__((stdcall))
     * }
     */
    public static void GetDllEntry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDllEntry$LAYOUT, GetDllEntry$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeInfo)(ITypeInfo *, HREFTYPE, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static class GetRefTypeInfo {

        GetRefTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetRefTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetRefTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetRefTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetRefTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeInfo)(ITypeInfo *, HREFTYPE, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetRefTypeInfo$layout() {
        return GetRefTypeInfo$LAYOUT;
    }

    private static final long GetRefTypeInfo$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeInfo)(ITypeInfo *, HREFTYPE, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static final long GetRefTypeInfo$offset() {
        return GetRefTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeInfo)(ITypeInfo *, HREFTYPE, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetRefTypeInfo(MemorySegment struct) {
        return struct.get(GetRefTypeInfo$LAYOUT, GetRefTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetRefTypeInfo)(ITypeInfo *, HREFTYPE, ITypeInfo **) __attribute__((stdcall))
     * }
     */
    public static void GetRefTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetRefTypeInfo$LAYOUT, GetRefTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*AddressOfMember)(ITypeInfo *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall))
     * }
     */
    public static class AddressOfMember {

        AddressOfMember() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(AddressOfMember.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddressOfMember.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddressOfMember$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddressOfMember"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*AddressOfMember)(ITypeInfo *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout AddressOfMember$layout() {
        return AddressOfMember$LAYOUT;
    }

    private static final long AddressOfMember$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*AddressOfMember)(ITypeInfo *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall))
     * }
     */
    public static final long AddressOfMember$offset() {
        return AddressOfMember$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*AddressOfMember)(ITypeInfo *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment AddressOfMember(MemorySegment struct) {
        return struct.get(AddressOfMember$LAYOUT, AddressOfMember$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*AddressOfMember)(ITypeInfo *, MEMBERID, INVOKEKIND, PVOID *) __attribute__((stdcall))
     * }
     */
    public static void AddressOfMember(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddressOfMember$LAYOUT, AddressOfMember$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*CreateInstance)(ITypeInfo *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall))
     * }
     */
    public static class CreateInstance {

        CreateInstance() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(CreateInstance.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateInstance.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateInstance$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateInstance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*CreateInstance)(ITypeInfo *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout CreateInstance$layout() {
        return CreateInstance$LAYOUT;
    }

    private static final long CreateInstance$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*CreateInstance)(ITypeInfo *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall))
     * }
     */
    public static final long CreateInstance$offset() {
        return CreateInstance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*CreateInstance)(ITypeInfo *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment CreateInstance(MemorySegment struct) {
        return struct.get(CreateInstance$LAYOUT, CreateInstance$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*CreateInstance)(ITypeInfo *, IUnknown *, const IID *const, PVOID *) __attribute__((stdcall))
     * }
     */
    public static void CreateInstance(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateInstance$LAYOUT, CreateInstance$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetMops)(ITypeInfo *, MEMBERID, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetMops {

        GetMops() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetMops.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMops.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMops$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMops"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetMops)(ITypeInfo *, MEMBERID, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetMops$layout() {
        return GetMops$LAYOUT;
    }

    private static final long GetMops$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetMops)(ITypeInfo *, MEMBERID, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetMops$offset() {
        return GetMops$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetMops)(ITypeInfo *, MEMBERID, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetMops(MemorySegment struct) {
        return struct.get(GetMops$LAYOUT, GetMops$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetMops)(ITypeInfo *, MEMBERID, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetMops(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMops$LAYOUT, GetMops$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetContainingTypeLib)(ITypeInfo *, ITypeLib **, UINT *) __attribute__((stdcall))
     * }
     */
    public static class GetContainingTypeLib {

        GetContainingTypeLib() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetContainingTypeLib.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetContainingTypeLib.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetContainingTypeLib$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetContainingTypeLib"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetContainingTypeLib)(ITypeInfo *, ITypeLib **, UINT *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetContainingTypeLib$layout() {
        return GetContainingTypeLib$LAYOUT;
    }

    private static final long GetContainingTypeLib$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetContainingTypeLib)(ITypeInfo *, ITypeLib **, UINT *) __attribute__((stdcall))
     * }
     */
    public static final long GetContainingTypeLib$offset() {
        return GetContainingTypeLib$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetContainingTypeLib)(ITypeInfo *, ITypeLib **, UINT *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetContainingTypeLib(MemorySegment struct) {
        return struct.get(GetContainingTypeLib$LAYOUT, GetContainingTypeLib$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetContainingTypeLib)(ITypeInfo *, ITypeLib **, UINT *) __attribute__((stdcall))
     * }
     */
    public static void GetContainingTypeLib(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetContainingTypeLib$LAYOUT, GetContainingTypeLib$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseTypeAttr)(ITypeInfo *, TYPEATTR *) __attribute__((stdcall))
     * }
     */
    public static class ReleaseTypeAttr {

        ReleaseTypeAttr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(ReleaseTypeAttr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseTypeAttr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseTypeAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseTypeAttr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeAttr)(ITypeInfo *, TYPEATTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout ReleaseTypeAttr$layout() {
        return ReleaseTypeAttr$LAYOUT;
    }

    private static final long ReleaseTypeAttr$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeAttr)(ITypeInfo *, TYPEATTR *) __attribute__((stdcall))
     * }
     */
    public static final long ReleaseTypeAttr$offset() {
        return ReleaseTypeAttr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeAttr)(ITypeInfo *, TYPEATTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment ReleaseTypeAttr(MemorySegment struct) {
        return struct.get(ReleaseTypeAttr$LAYOUT, ReleaseTypeAttr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeAttr)(ITypeInfo *, TYPEATTR *) __attribute__((stdcall))
     * }
     */
    public static void ReleaseTypeAttr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseTypeAttr$LAYOUT, ReleaseTypeAttr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseFuncDesc)(ITypeInfo *, FUNCDESC *) __attribute__((stdcall))
     * }
     */
    public static class ReleaseFuncDesc {

        ReleaseFuncDesc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(ReleaseFuncDesc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseFuncDesc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseFuncDesc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseFuncDesc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseFuncDesc)(ITypeInfo *, FUNCDESC *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout ReleaseFuncDesc$layout() {
        return ReleaseFuncDesc$LAYOUT;
    }

    private static final long ReleaseFuncDesc$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseFuncDesc)(ITypeInfo *, FUNCDESC *) __attribute__((stdcall))
     * }
     */
    public static final long ReleaseFuncDesc$offset() {
        return ReleaseFuncDesc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseFuncDesc)(ITypeInfo *, FUNCDESC *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment ReleaseFuncDesc(MemorySegment struct) {
        return struct.get(ReleaseFuncDesc$LAYOUT, ReleaseFuncDesc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseFuncDesc)(ITypeInfo *, FUNCDESC *) __attribute__((stdcall))
     * }
     */
    public static void ReleaseFuncDesc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseFuncDesc$LAYOUT, ReleaseFuncDesc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseVarDesc)(ITypeInfo *, VARDESC *) __attribute__((stdcall))
     * }
     */
    public static class ReleaseVarDesc {

        ReleaseVarDesc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(ReleaseVarDesc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseVarDesc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseVarDesc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseVarDesc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseVarDesc)(ITypeInfo *, VARDESC *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout ReleaseVarDesc$layout() {
        return ReleaseVarDesc$LAYOUT;
    }

    private static final long ReleaseVarDesc$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseVarDesc)(ITypeInfo *, VARDESC *) __attribute__((stdcall))
     * }
     */
    public static final long ReleaseVarDesc$offset() {
        return ReleaseVarDesc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseVarDesc)(ITypeInfo *, VARDESC *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment ReleaseVarDesc(MemorySegment struct) {
        return struct.get(ReleaseVarDesc$LAYOUT, ReleaseVarDesc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseVarDesc)(ITypeInfo *, VARDESC *) __attribute__((stdcall))
     * }
     */
    public static void ReleaseVarDesc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseVarDesc$LAYOUT, ReleaseVarDesc$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

