// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct tagRPC_EXTENDED_ERROR_INFO {
 *     ULONG Version;
 *     LPWSTR ComputerName;
 *     ULONG ProcessID;
 *     union {
 *         SYSTEMTIME SystemTime;
 *         FILETIME FileTime;
 *     } u;
 *     ULONG GeneratingComponent;
 *     ULONG Status;
 *     USHORT DetectionLocation;
 *     USHORT Flags;
 *     int NumberOfParameters;
 *     RPC_EE_INFO_PARAM Parameters[4];
 * }
 * }
 */
public class tagRPC_EXTENDED_ERROR_INFO {

    tagRPC_EXTENDED_ERROR_INFO() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        wgl_h.C_LONG.withName("Version"),
        MemoryLayout.paddingLayout(4),
        wgl_h.C_POINTER.withName("ComputerName"),
        wgl_h.C_LONG.withName("ProcessID"),
        tagRPC_EXTENDED_ERROR_INFO.u.layout().withName("u"),
        wgl_h.C_LONG.withName("GeneratingComponent"),
        wgl_h.C_LONG.withName("Status"),
        wgl_h.C_SHORT.withName("DetectionLocation"),
        wgl_h.C_SHORT.withName("Flags"),
        wgl_h.C_INT.withName("NumberOfParameters"),
        MemoryLayout.paddingLayout(4),
        MemoryLayout.sequenceLayout(4, tagRPC_EE_INFO_PARAM.layout()).withName("Parameters")
    ).withName("tagRPC_EXTENDED_ERROR_INFO");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt Version$LAYOUT = (OfInt)$LAYOUT.select(groupElement("Version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG Version
     * }
     */
    public static final OfInt Version$layout() {
        return Version$LAYOUT;
    }

    private static final long Version$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG Version
     * }
     */
    public static final long Version$offset() {
        return Version$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG Version
     * }
     */
    public static int Version(MemorySegment struct) {
        return struct.get(Version$LAYOUT, Version$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG Version
     * }
     */
    public static void Version(MemorySegment struct, int fieldValue) {
        struct.set(Version$LAYOUT, Version$OFFSET, fieldValue);
    }

    private static final AddressLayout ComputerName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ComputerName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * LPWSTR ComputerName
     * }
     */
    public static final AddressLayout ComputerName$layout() {
        return ComputerName$LAYOUT;
    }

    private static final long ComputerName$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * LPWSTR ComputerName
     * }
     */
    public static final long ComputerName$offset() {
        return ComputerName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * LPWSTR ComputerName
     * }
     */
    public static MemorySegment ComputerName(MemorySegment struct) {
        return struct.get(ComputerName$LAYOUT, ComputerName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * LPWSTR ComputerName
     * }
     */
    public static void ComputerName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ComputerName$LAYOUT, ComputerName$OFFSET, fieldValue);
    }

    private static final OfInt ProcessID$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ProcessID"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG ProcessID
     * }
     */
    public static final OfInt ProcessID$layout() {
        return ProcessID$LAYOUT;
    }

    private static final long ProcessID$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG ProcessID
     * }
     */
    public static final long ProcessID$offset() {
        return ProcessID$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG ProcessID
     * }
     */
    public static int ProcessID(MemorySegment struct) {
        return struct.get(ProcessID$LAYOUT, ProcessID$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG ProcessID
     * }
     */
    public static void ProcessID(MemorySegment struct, int fieldValue) {
        struct.set(ProcessID$LAYOUT, ProcessID$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * union {
     *     SYSTEMTIME SystemTime;
     *     FILETIME FileTime;
     * }
     * }
     */
    public static class u {

        u() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
            _SYSTEMTIME.layout().withName("SystemTime"),
            _FILETIME.layout().withName("FileTime")
        ).withName("$anon$287:5");

        /**
         * The layout of this union
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout SystemTime$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("SystemTime"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * SYSTEMTIME SystemTime
         * }
         */
        public static final GroupLayout SystemTime$layout() {
            return SystemTime$LAYOUT;
        }

        private static final long SystemTime$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * SYSTEMTIME SystemTime
         * }
         */
        public static final long SystemTime$offset() {
            return SystemTime$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * SYSTEMTIME SystemTime
         * }
         */
        public static MemorySegment SystemTime(MemorySegment union) {
            return union.asSlice(SystemTime$OFFSET, SystemTime$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * SYSTEMTIME SystemTime
         * }
         */
        public static void SystemTime(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, SystemTime$OFFSET, SystemTime$LAYOUT.byteSize());
        }

        private static final GroupLayout FileTime$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("FileTime"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * FILETIME FileTime
         * }
         */
        public static final GroupLayout FileTime$layout() {
            return FileTime$LAYOUT;
        }

        private static final long FileTime$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * FILETIME FileTime
         * }
         */
        public static final long FileTime$offset() {
            return FileTime$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * FILETIME FileTime
         * }
         */
        public static MemorySegment FileTime(MemorySegment union) {
            return union.asSlice(FileTime$OFFSET, FileTime$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * FILETIME FileTime
         * }
         */
        public static void FileTime(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, FileTime$OFFSET, FileTime$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this union
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout u$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("u"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * union {
     *     SYSTEMTIME SystemTime;
     *     FILETIME FileTime;
     * } u
     * }
     */
    public static final GroupLayout u$layout() {
        return u$LAYOUT;
    }

    private static final long u$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * union {
     *     SYSTEMTIME SystemTime;
     *     FILETIME FileTime;
     * } u
     * }
     */
    public static final long u$offset() {
        return u$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * union {
     *     SYSTEMTIME SystemTime;
     *     FILETIME FileTime;
     * } u
     * }
     */
    public static MemorySegment u(MemorySegment struct) {
        return struct.asSlice(u$OFFSET, u$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * union {
     *     SYSTEMTIME SystemTime;
     *     FILETIME FileTime;
     * } u
     * }
     */
    public static void u(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, u$OFFSET, u$LAYOUT.byteSize());
    }

    private static final OfInt GeneratingComponent$LAYOUT = (OfInt)$LAYOUT.select(groupElement("GeneratingComponent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG GeneratingComponent
     * }
     */
    public static final OfInt GeneratingComponent$layout() {
        return GeneratingComponent$LAYOUT;
    }

    private static final long GeneratingComponent$OFFSET = 36;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG GeneratingComponent
     * }
     */
    public static final long GeneratingComponent$offset() {
        return GeneratingComponent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG GeneratingComponent
     * }
     */
    public static int GeneratingComponent(MemorySegment struct) {
        return struct.get(GeneratingComponent$LAYOUT, GeneratingComponent$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG GeneratingComponent
     * }
     */
    public static void GeneratingComponent(MemorySegment struct, int fieldValue) {
        struct.set(GeneratingComponent$LAYOUT, GeneratingComponent$OFFSET, fieldValue);
    }

    private static final OfInt Status$LAYOUT = (OfInt)$LAYOUT.select(groupElement("Status"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG Status
     * }
     */
    public static final OfInt Status$layout() {
        return Status$LAYOUT;
    }

    private static final long Status$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG Status
     * }
     */
    public static final long Status$offset() {
        return Status$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG Status
     * }
     */
    public static int Status(MemorySegment struct) {
        return struct.get(Status$LAYOUT, Status$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG Status
     * }
     */
    public static void Status(MemorySegment struct, int fieldValue) {
        struct.set(Status$LAYOUT, Status$OFFSET, fieldValue);
    }

    private static final OfShort DetectionLocation$LAYOUT = (OfShort)$LAYOUT.select(groupElement("DetectionLocation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * USHORT DetectionLocation
     * }
     */
    public static final OfShort DetectionLocation$layout() {
        return DetectionLocation$LAYOUT;
    }

    private static final long DetectionLocation$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * USHORT DetectionLocation
     * }
     */
    public static final long DetectionLocation$offset() {
        return DetectionLocation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * USHORT DetectionLocation
     * }
     */
    public static short DetectionLocation(MemorySegment struct) {
        return struct.get(DetectionLocation$LAYOUT, DetectionLocation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * USHORT DetectionLocation
     * }
     */
    public static void DetectionLocation(MemorySegment struct, short fieldValue) {
        struct.set(DetectionLocation$LAYOUT, DetectionLocation$OFFSET, fieldValue);
    }

    private static final OfShort Flags$LAYOUT = (OfShort)$LAYOUT.select(groupElement("Flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * USHORT Flags
     * }
     */
    public static final OfShort Flags$layout() {
        return Flags$LAYOUT;
    }

    private static final long Flags$OFFSET = 46;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * USHORT Flags
     * }
     */
    public static final long Flags$offset() {
        return Flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * USHORT Flags
     * }
     */
    public static short Flags(MemorySegment struct) {
        return struct.get(Flags$LAYOUT, Flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * USHORT Flags
     * }
     */
    public static void Flags(MemorySegment struct, short fieldValue) {
        struct.set(Flags$LAYOUT, Flags$OFFSET, fieldValue);
    }

    private static final OfInt NumberOfParameters$LAYOUT = (OfInt)$LAYOUT.select(groupElement("NumberOfParameters"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int NumberOfParameters
     * }
     */
    public static final OfInt NumberOfParameters$layout() {
        return NumberOfParameters$LAYOUT;
    }

    private static final long NumberOfParameters$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int NumberOfParameters
     * }
     */
    public static final long NumberOfParameters$offset() {
        return NumberOfParameters$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int NumberOfParameters
     * }
     */
    public static int NumberOfParameters(MemorySegment struct) {
        return struct.get(NumberOfParameters$LAYOUT, NumberOfParameters$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int NumberOfParameters
     * }
     */
    public static void NumberOfParameters(MemorySegment struct, int fieldValue) {
        struct.set(NumberOfParameters$LAYOUT, NumberOfParameters$OFFSET, fieldValue);
    }

    private static final SequenceLayout Parameters$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("Parameters"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * RPC_EE_INFO_PARAM Parameters[4]
     * }
     */
    public static final SequenceLayout Parameters$layout() {
        return Parameters$LAYOUT;
    }

    private static final long Parameters$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * RPC_EE_INFO_PARAM Parameters[4]
     * }
     */
    public static final long Parameters$offset() {
        return Parameters$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * RPC_EE_INFO_PARAM Parameters[4]
     * }
     */
    public static MemorySegment Parameters(MemorySegment struct) {
        return struct.asSlice(Parameters$OFFSET, Parameters$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * RPC_EE_INFO_PARAM Parameters[4]
     * }
     */
    public static void Parameters(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, Parameters$OFFSET, Parameters$LAYOUT.byteSize());
    }

    private static long[] Parameters$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * RPC_EE_INFO_PARAM Parameters[4]
     * }
     */
    public static long[] Parameters$dimensions() {
        return Parameters$DIMS;
    }
    private static final MethodHandle Parameters$ELEM_HANDLE = Parameters$LAYOUT.sliceHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * RPC_EE_INFO_PARAM Parameters[4]
     * }
     */
    public static MemorySegment Parameters(MemorySegment struct, long index0) {
        try {
            return (MemorySegment)Parameters$ELEM_HANDLE.invokeExact(struct, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * RPC_EE_INFO_PARAM Parameters[4]
     * }
     */
    public static void Parameters(MemorySegment struct, long index0, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, Parameters(struct, index0), 0L, tagRPC_EE_INFO_PARAM.layout().byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

