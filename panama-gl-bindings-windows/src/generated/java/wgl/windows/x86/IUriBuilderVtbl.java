// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class IUriBuilderVtbl {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("QueryInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("AddRef"),
        Constants$root.C_POINTER$LAYOUT.withName("Release"),
        Constants$root.C_POINTER$LAYOUT.withName("CreateUriSimple"),
        Constants$root.C_POINTER$LAYOUT.withName("CreateUri"),
        Constants$root.C_POINTER$LAYOUT.withName("CreateUriWithFlags"),
        Constants$root.C_POINTER$LAYOUT.withName("GetIUri"),
        Constants$root.C_POINTER$LAYOUT.withName("SetIUri"),
        Constants$root.C_POINTER$LAYOUT.withName("GetFragment"),
        Constants$root.C_POINTER$LAYOUT.withName("GetHost"),
        Constants$root.C_POINTER$LAYOUT.withName("GetPassword"),
        Constants$root.C_POINTER$LAYOUT.withName("GetPath"),
        Constants$root.C_POINTER$LAYOUT.withName("GetPort"),
        Constants$root.C_POINTER$LAYOUT.withName("GetQuery"),
        Constants$root.C_POINTER$LAYOUT.withName("GetSchemeName"),
        Constants$root.C_POINTER$LAYOUT.withName("GetUserNameA"),
        Constants$root.C_POINTER$LAYOUT.withName("SetFragment"),
        Constants$root.C_POINTER$LAYOUT.withName("SetHost"),
        Constants$root.C_POINTER$LAYOUT.withName("SetPassword"),
        Constants$root.C_POINTER$LAYOUT.withName("SetPath"),
        Constants$root.C_POINTER$LAYOUT.withName("SetPortA"),
        Constants$root.C_POINTER$LAYOUT.withName("SetQuery"),
        Constants$root.C_POINTER$LAYOUT.withName("SetSchemeName"),
        Constants$root.C_POINTER$LAYOUT.withName("SetUserName"),
        Constants$root.C_POINTER$LAYOUT.withName("RemoveProperties"),
        Constants$root.C_POINTER$LAYOUT.withName("HasBeenModified")
    ).withName("IUriBuilderVtbl");
    public static MemoryLayout $LAYOUT() {
        return IUriBuilderVtbl.$struct$LAYOUT;
    }
    static final FunctionDescriptor QueryInterface$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.QueryInterface$FUNC
    );
    public interface QueryInterface {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(QueryInterface fi, MemorySession session) {
            return RuntimeHelper.upcallStub(QueryInterface.class, fi, IUriBuilderVtbl.QueryInterface$FUNC, session);
        }
        static QueryInterface ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IUriBuilderVtbl.QueryInterface$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle QueryInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("QueryInterface"));
    public static VarHandle QueryInterface$VH() {
        return IUriBuilderVtbl.QueryInterface$VH;
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.QueryInterface$VH.get(seg);
    }
    public static void QueryInterface$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.QueryInterface$VH.set(seg, x);
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.QueryInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void QueryInterface$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.QueryInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static QueryInterface QueryInterface (MemorySegment segment, MemorySession session) {
        return QueryInterface.ofAddress(QueryInterface$get(segment), session);
    }
    static final FunctionDescriptor AddRef$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.AddRef$FUNC
    );
    public interface AddRef {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(AddRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AddRef.class, fi, IUriBuilderVtbl.AddRef$FUNC, session);
        }
        static AddRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IUriBuilderVtbl.AddRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AddRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AddRef"));
    public static VarHandle AddRef$VH() {
        return IUriBuilderVtbl.AddRef$VH;
    }
    public static MemoryAddress AddRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.AddRef$VH.get(seg);
    }
    public static void AddRef$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.AddRef$VH.set(seg, x);
    }
    public static MemoryAddress AddRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.AddRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AddRef$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.AddRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AddRef AddRef (MemorySegment segment, MemorySession session) {
        return AddRef.ofAddress(AddRef$get(segment), session);
    }
    static final FunctionDescriptor Release$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.Release$FUNC
    );
    public interface Release {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(Release fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Release.class, fi, IUriBuilderVtbl.Release$FUNC, session);
        }
        static Release ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IUriBuilderVtbl.Release$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Release"));
    public static VarHandle Release$VH() {
        return IUriBuilderVtbl.Release$VH;
    }
    public static MemoryAddress Release$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.Release$VH.get(seg);
    }
    public static void Release$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.Release$VH.set(seg, x);
    }
    public static MemoryAddress Release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.Release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Release$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.Release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Release Release (MemorySegment segment, MemorySession session) {
        return Release.ofAddress(Release$get(segment), session);
    }
    static final FunctionDescriptor CreateUriSimple$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CreateUriSimple$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.CreateUriSimple$FUNC
    );
    public interface CreateUriSimple {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, long _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CreateUriSimple fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CreateUriSimple.class, fi, IUriBuilderVtbl.CreateUriSimple$FUNC, session);
        }
        static CreateUriSimple ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, long __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)IUriBuilderVtbl.CreateUriSimple$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CreateUriSimple$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CreateUriSimple"));
    public static VarHandle CreateUriSimple$VH() {
        return IUriBuilderVtbl.CreateUriSimple$VH;
    }
    public static MemoryAddress CreateUriSimple$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.CreateUriSimple$VH.get(seg);
    }
    public static void CreateUriSimple$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.CreateUriSimple$VH.set(seg, x);
    }
    public static MemoryAddress CreateUriSimple$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.CreateUriSimple$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CreateUriSimple$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.CreateUriSimple$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CreateUriSimple CreateUriSimple (MemorySegment segment, MemorySession session) {
        return CreateUriSimple.ofAddress(CreateUriSimple$get(segment), session);
    }
    static final FunctionDescriptor CreateUri$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CreateUri$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.CreateUri$FUNC
    );
    public interface CreateUri {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, int _x2, long _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CreateUri fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CreateUri.class, fi, IUriBuilderVtbl.CreateUri$FUNC, session);
        }
        static CreateUri ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, int __x2, long __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)IUriBuilderVtbl.CreateUri$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CreateUri$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CreateUri"));
    public static VarHandle CreateUri$VH() {
        return IUriBuilderVtbl.CreateUri$VH;
    }
    public static MemoryAddress CreateUri$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.CreateUri$VH.get(seg);
    }
    public static void CreateUri$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.CreateUri$VH.set(seg, x);
    }
    public static MemoryAddress CreateUri$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.CreateUri$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CreateUri$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.CreateUri$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CreateUri CreateUri (MemorySegment segment, MemorySession session) {
        return CreateUri.ofAddress(CreateUri$get(segment), session);
    }
    static final FunctionDescriptor CreateUriWithFlags$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CreateUriWithFlags$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.CreateUriWithFlags$FUNC
    );
    public interface CreateUriWithFlags {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, int _x2, int _x3, long _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(CreateUriWithFlags fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CreateUriWithFlags.class, fi, IUriBuilderVtbl.CreateUriWithFlags$FUNC, session);
        }
        static CreateUriWithFlags ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, int __x2, int __x3, long __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    return (int)IUriBuilderVtbl.CreateUriWithFlags$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, __x3, __x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CreateUriWithFlags$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CreateUriWithFlags"));
    public static VarHandle CreateUriWithFlags$VH() {
        return IUriBuilderVtbl.CreateUriWithFlags$VH;
    }
    public static MemoryAddress CreateUriWithFlags$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.CreateUriWithFlags$VH.get(seg);
    }
    public static void CreateUriWithFlags$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.CreateUriWithFlags$VH.set(seg, x);
    }
    public static MemoryAddress CreateUriWithFlags$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.CreateUriWithFlags$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CreateUriWithFlags$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.CreateUriWithFlags$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CreateUriWithFlags CreateUriWithFlags (MemorySegment segment, MemorySession session) {
        return CreateUriWithFlags.ofAddress(CreateUriWithFlags$get(segment), session);
    }
    static final FunctionDescriptor GetIUri$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetIUri$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.GetIUri$FUNC
    );
    public interface GetIUri {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetIUri fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetIUri.class, fi, IUriBuilderVtbl.GetIUri$FUNC, session);
        }
        static GetIUri ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IUriBuilderVtbl.GetIUri$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetIUri$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetIUri"));
    public static VarHandle GetIUri$VH() {
        return IUriBuilderVtbl.GetIUri$VH;
    }
    public static MemoryAddress GetIUri$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetIUri$VH.get(seg);
    }
    public static void GetIUri$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.GetIUri$VH.set(seg, x);
    }
    public static MemoryAddress GetIUri$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetIUri$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetIUri$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.GetIUri$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetIUri GetIUri (MemorySegment segment, MemorySession session) {
        return GetIUri.ofAddress(GetIUri$get(segment), session);
    }
    static final FunctionDescriptor SetIUri$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetIUri$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.SetIUri$FUNC
    );
    public interface SetIUri {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(SetIUri fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetIUri.class, fi, IUriBuilderVtbl.SetIUri$FUNC, session);
        }
        static SetIUri ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IUriBuilderVtbl.SetIUri$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetIUri$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetIUri"));
    public static VarHandle SetIUri$VH() {
        return IUriBuilderVtbl.SetIUri$VH;
    }
    public static MemoryAddress SetIUri$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetIUri$VH.get(seg);
    }
    public static void SetIUri$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.SetIUri$VH.set(seg, x);
    }
    public static MemoryAddress SetIUri$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetIUri$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetIUri$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.SetIUri$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetIUri SetIUri (MemorySegment segment, MemorySession session) {
        return SetIUri.ofAddress(SetIUri$get(segment), session);
    }
    static final FunctionDescriptor GetFragment$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFragment$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.GetFragment$FUNC
    );
    public interface GetFragment {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetFragment fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetFragment.class, fi, IUriBuilderVtbl.GetFragment$FUNC, session);
        }
        static GetFragment ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IUriBuilderVtbl.GetFragment$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFragment$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetFragment"));
    public static VarHandle GetFragment$VH() {
        return IUriBuilderVtbl.GetFragment$VH;
    }
    public static MemoryAddress GetFragment$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetFragment$VH.get(seg);
    }
    public static void GetFragment$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.GetFragment$VH.set(seg, x);
    }
    public static MemoryAddress GetFragment$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetFragment$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFragment$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.GetFragment$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFragment GetFragment (MemorySegment segment, MemorySession session) {
        return GetFragment.ofAddress(GetFragment$get(segment), session);
    }
    static final FunctionDescriptor GetHost$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetHost$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.GetHost$FUNC
    );
    public interface GetHost {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetHost fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetHost.class, fi, IUriBuilderVtbl.GetHost$FUNC, session);
        }
        static GetHost ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IUriBuilderVtbl.GetHost$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetHost$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetHost"));
    public static VarHandle GetHost$VH() {
        return IUriBuilderVtbl.GetHost$VH;
    }
    public static MemoryAddress GetHost$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetHost$VH.get(seg);
    }
    public static void GetHost$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.GetHost$VH.set(seg, x);
    }
    public static MemoryAddress GetHost$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetHost$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetHost$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.GetHost$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetHost GetHost (MemorySegment segment, MemorySession session) {
        return GetHost.ofAddress(GetHost$get(segment), session);
    }
    static final FunctionDescriptor GetPassword$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetPassword$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.GetPassword$FUNC
    );
    public interface GetPassword {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetPassword fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetPassword.class, fi, IUriBuilderVtbl.GetPassword$FUNC, session);
        }
        static GetPassword ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IUriBuilderVtbl.GetPassword$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetPassword$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetPassword"));
    public static VarHandle GetPassword$VH() {
        return IUriBuilderVtbl.GetPassword$VH;
    }
    public static MemoryAddress GetPassword$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetPassword$VH.get(seg);
    }
    public static void GetPassword$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.GetPassword$VH.set(seg, x);
    }
    public static MemoryAddress GetPassword$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetPassword$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetPassword$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.GetPassword$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetPassword GetPassword (MemorySegment segment, MemorySession session) {
        return GetPassword.ofAddress(GetPassword$get(segment), session);
    }
    static final FunctionDescriptor GetPath$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetPath$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.GetPath$FUNC
    );
    public interface GetPath {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetPath fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetPath.class, fi, IUriBuilderVtbl.GetPath$FUNC, session);
        }
        static GetPath ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IUriBuilderVtbl.GetPath$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetPath$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetPath"));
    public static VarHandle GetPath$VH() {
        return IUriBuilderVtbl.GetPath$VH;
    }
    public static MemoryAddress GetPath$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetPath$VH.get(seg);
    }
    public static void GetPath$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.GetPath$VH.set(seg, x);
    }
    public static MemoryAddress GetPath$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetPath$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetPath$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.GetPath$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetPath GetPath (MemorySegment segment, MemorySession session) {
        return GetPath.ofAddress(GetPath$get(segment), session);
    }
    static final FunctionDescriptor GetPort$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetPort$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.GetPort$FUNC
    );
    public interface GetPort {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetPort fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetPort.class, fi, IUriBuilderVtbl.GetPort$FUNC, session);
        }
        static GetPort ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IUriBuilderVtbl.GetPort$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetPort$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetPort"));
    public static VarHandle GetPort$VH() {
        return IUriBuilderVtbl.GetPort$VH;
    }
    public static MemoryAddress GetPort$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetPort$VH.get(seg);
    }
    public static void GetPort$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.GetPort$VH.set(seg, x);
    }
    public static MemoryAddress GetPort$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetPort$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetPort$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.GetPort$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetPort GetPort (MemorySegment segment, MemorySession session) {
        return GetPort.ofAddress(GetPort$get(segment), session);
    }
    static final FunctionDescriptor GetQuery$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetQuery$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.GetQuery$FUNC
    );
    public interface GetQuery {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetQuery fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetQuery.class, fi, IUriBuilderVtbl.GetQuery$FUNC, session);
        }
        static GetQuery ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IUriBuilderVtbl.GetQuery$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetQuery$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetQuery"));
    public static VarHandle GetQuery$VH() {
        return IUriBuilderVtbl.GetQuery$VH;
    }
    public static MemoryAddress GetQuery$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetQuery$VH.get(seg);
    }
    public static void GetQuery$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.GetQuery$VH.set(seg, x);
    }
    public static MemoryAddress GetQuery$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetQuery$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetQuery$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.GetQuery$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetQuery GetQuery (MemorySegment segment, MemorySession session) {
        return GetQuery.ofAddress(GetQuery$get(segment), session);
    }
    static final FunctionDescriptor GetSchemeName$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetSchemeName$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.GetSchemeName$FUNC
    );
    public interface GetSchemeName {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetSchemeName fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetSchemeName.class, fi, IUriBuilderVtbl.GetSchemeName$FUNC, session);
        }
        static GetSchemeName ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IUriBuilderVtbl.GetSchemeName$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetSchemeName$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetSchemeName"));
    public static VarHandle GetSchemeName$VH() {
        return IUriBuilderVtbl.GetSchemeName$VH;
    }
    public static MemoryAddress GetSchemeName$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetSchemeName$VH.get(seg);
    }
    public static void GetSchemeName$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.GetSchemeName$VH.set(seg, x);
    }
    public static MemoryAddress GetSchemeName$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetSchemeName$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetSchemeName$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.GetSchemeName$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetSchemeName GetSchemeName (MemorySegment segment, MemorySession session) {
        return GetSchemeName.ofAddress(GetSchemeName$get(segment), session);
    }
    static final FunctionDescriptor GetUserNameA$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetUserNameA$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.GetUserNameA$FUNC
    );
    public interface GetUserNameA {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetUserNameA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetUserNameA.class, fi, IUriBuilderVtbl.GetUserNameA$FUNC, session);
        }
        static GetUserNameA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IUriBuilderVtbl.GetUserNameA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetUserNameA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetUserNameA"));
    public static VarHandle GetUserNameA$VH() {
        return IUriBuilderVtbl.GetUserNameA$VH;
    }
    public static MemoryAddress GetUserNameA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetUserNameA$VH.get(seg);
    }
    public static void GetUserNameA$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.GetUserNameA$VH.set(seg, x);
    }
    public static MemoryAddress GetUserNameA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.GetUserNameA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetUserNameA$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.GetUserNameA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetUserNameA GetUserNameA (MemorySegment segment, MemorySession session) {
        return GetUserNameA.ofAddress(GetUserNameA$get(segment), session);
    }
    static final FunctionDescriptor SetFragment$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetFragment$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.SetFragment$FUNC
    );
    public interface SetFragment {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(SetFragment fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetFragment.class, fi, IUriBuilderVtbl.SetFragment$FUNC, session);
        }
        static SetFragment ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IUriBuilderVtbl.SetFragment$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetFragment$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetFragment"));
    public static VarHandle SetFragment$VH() {
        return IUriBuilderVtbl.SetFragment$VH;
    }
    public static MemoryAddress SetFragment$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetFragment$VH.get(seg);
    }
    public static void SetFragment$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.SetFragment$VH.set(seg, x);
    }
    public static MemoryAddress SetFragment$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetFragment$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetFragment$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.SetFragment$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetFragment SetFragment (MemorySegment segment, MemorySession session) {
        return SetFragment.ofAddress(SetFragment$get(segment), session);
    }
    static final FunctionDescriptor SetHost$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetHost$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.SetHost$FUNC
    );
    public interface SetHost {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(SetHost fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetHost.class, fi, IUriBuilderVtbl.SetHost$FUNC, session);
        }
        static SetHost ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IUriBuilderVtbl.SetHost$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetHost$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetHost"));
    public static VarHandle SetHost$VH() {
        return IUriBuilderVtbl.SetHost$VH;
    }
    public static MemoryAddress SetHost$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetHost$VH.get(seg);
    }
    public static void SetHost$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.SetHost$VH.set(seg, x);
    }
    public static MemoryAddress SetHost$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetHost$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetHost$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.SetHost$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetHost SetHost (MemorySegment segment, MemorySession session) {
        return SetHost.ofAddress(SetHost$get(segment), session);
    }
    static final FunctionDescriptor SetPassword$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetPassword$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.SetPassword$FUNC
    );
    public interface SetPassword {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(SetPassword fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetPassword.class, fi, IUriBuilderVtbl.SetPassword$FUNC, session);
        }
        static SetPassword ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IUriBuilderVtbl.SetPassword$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetPassword$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetPassword"));
    public static VarHandle SetPassword$VH() {
        return IUriBuilderVtbl.SetPassword$VH;
    }
    public static MemoryAddress SetPassword$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetPassword$VH.get(seg);
    }
    public static void SetPassword$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.SetPassword$VH.set(seg, x);
    }
    public static MemoryAddress SetPassword$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetPassword$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetPassword$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.SetPassword$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetPassword SetPassword (MemorySegment segment, MemorySession session) {
        return SetPassword.ofAddress(SetPassword$get(segment), session);
    }
    static final FunctionDescriptor SetPath$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetPath$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.SetPath$FUNC
    );
    public interface SetPath {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(SetPath fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetPath.class, fi, IUriBuilderVtbl.SetPath$FUNC, session);
        }
        static SetPath ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IUriBuilderVtbl.SetPath$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetPath$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetPath"));
    public static VarHandle SetPath$VH() {
        return IUriBuilderVtbl.SetPath$VH;
    }
    public static MemoryAddress SetPath$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetPath$VH.get(seg);
    }
    public static void SetPath$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.SetPath$VH.set(seg, x);
    }
    public static MemoryAddress SetPath$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetPath$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetPath$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.SetPath$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetPath SetPath (MemorySegment segment, MemorySession session) {
        return SetPath.ofAddress(SetPath$get(segment), session);
    }
    static final FunctionDescriptor SetPortA$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle SetPortA$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.SetPortA$FUNC
    );
    public interface SetPortA {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, int _x2);
        static MemorySegment allocate(SetPortA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetPortA.class, fi, IUriBuilderVtbl.SetPortA$FUNC, session);
        }
        static SetPortA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, int __x2) -> {
                try {
                    return (int)IUriBuilderVtbl.SetPortA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetPortA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetPortA"));
    public static VarHandle SetPortA$VH() {
        return IUriBuilderVtbl.SetPortA$VH;
    }
    public static MemoryAddress SetPortA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetPortA$VH.get(seg);
    }
    public static void SetPortA$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.SetPortA$VH.set(seg, x);
    }
    public static MemoryAddress SetPortA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetPortA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetPortA$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.SetPortA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetPortA SetPortA (MemorySegment segment, MemorySession session) {
        return SetPortA.ofAddress(SetPortA$get(segment), session);
    }
    static final FunctionDescriptor SetQuery$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetQuery$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.SetQuery$FUNC
    );
    public interface SetQuery {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(SetQuery fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetQuery.class, fi, IUriBuilderVtbl.SetQuery$FUNC, session);
        }
        static SetQuery ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IUriBuilderVtbl.SetQuery$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetQuery$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetQuery"));
    public static VarHandle SetQuery$VH() {
        return IUriBuilderVtbl.SetQuery$VH;
    }
    public static MemoryAddress SetQuery$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetQuery$VH.get(seg);
    }
    public static void SetQuery$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.SetQuery$VH.set(seg, x);
    }
    public static MemoryAddress SetQuery$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetQuery$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetQuery$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.SetQuery$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetQuery SetQuery (MemorySegment segment, MemorySession session) {
        return SetQuery.ofAddress(SetQuery$get(segment), session);
    }
    static final FunctionDescriptor SetSchemeName$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetSchemeName$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.SetSchemeName$FUNC
    );
    public interface SetSchemeName {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(SetSchemeName fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetSchemeName.class, fi, IUriBuilderVtbl.SetSchemeName$FUNC, session);
        }
        static SetSchemeName ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IUriBuilderVtbl.SetSchemeName$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetSchemeName$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetSchemeName"));
    public static VarHandle SetSchemeName$VH() {
        return IUriBuilderVtbl.SetSchemeName$VH;
    }
    public static MemoryAddress SetSchemeName$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetSchemeName$VH.get(seg);
    }
    public static void SetSchemeName$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.SetSchemeName$VH.set(seg, x);
    }
    public static MemoryAddress SetSchemeName$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetSchemeName$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetSchemeName$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.SetSchemeName$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetSchemeName SetSchemeName (MemorySegment segment, MemorySession session) {
        return SetSchemeName.ofAddress(SetSchemeName$get(segment), session);
    }
    static final FunctionDescriptor SetUserName$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetUserName$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.SetUserName$FUNC
    );
    public interface SetUserName {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(SetUserName fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetUserName.class, fi, IUriBuilderVtbl.SetUserName$FUNC, session);
        }
        static SetUserName ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IUriBuilderVtbl.SetUserName$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetUserName$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetUserName"));
    public static VarHandle SetUserName$VH() {
        return IUriBuilderVtbl.SetUserName$VH;
    }
    public static MemoryAddress SetUserName$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetUserName$VH.get(seg);
    }
    public static void SetUserName$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.SetUserName$VH.set(seg, x);
    }
    public static MemoryAddress SetUserName$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.SetUserName$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetUserName$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.SetUserName$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetUserName SetUserName (MemorySegment segment, MemorySession session) {
        return SetUserName.ofAddress(SetUserName$get(segment), session);
    }
    static final FunctionDescriptor RemoveProperties$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle RemoveProperties$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.RemoveProperties$FUNC
    );
    public interface RemoveProperties {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(RemoveProperties fi, MemorySession session) {
            return RuntimeHelper.upcallStub(RemoveProperties.class, fi, IUriBuilderVtbl.RemoveProperties$FUNC, session);
        }
        static RemoveProperties ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (int)IUriBuilderVtbl.RemoveProperties$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RemoveProperties$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RemoveProperties"));
    public static VarHandle RemoveProperties$VH() {
        return IUriBuilderVtbl.RemoveProperties$VH;
    }
    public static MemoryAddress RemoveProperties$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.RemoveProperties$VH.get(seg);
    }
    public static void RemoveProperties$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.RemoveProperties$VH.set(seg, x);
    }
    public static MemoryAddress RemoveProperties$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.RemoveProperties$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RemoveProperties$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.RemoveProperties$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RemoveProperties RemoveProperties (MemorySegment segment, MemorySession session) {
        return RemoveProperties.ofAddress(RemoveProperties$get(segment), session);
    }
    static final FunctionDescriptor HasBeenModified$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle HasBeenModified$MH = RuntimeHelper.downcallHandle(
        IUriBuilderVtbl.HasBeenModified$FUNC
    );
    public interface HasBeenModified {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(HasBeenModified fi, MemorySession session) {
            return RuntimeHelper.upcallStub(HasBeenModified.class, fi, IUriBuilderVtbl.HasBeenModified$FUNC, session);
        }
        static HasBeenModified ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IUriBuilderVtbl.HasBeenModified$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle HasBeenModified$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("HasBeenModified"));
    public static VarHandle HasBeenModified$VH() {
        return IUriBuilderVtbl.HasBeenModified$VH;
    }
    public static MemoryAddress HasBeenModified$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.HasBeenModified$VH.get(seg);
    }
    public static void HasBeenModified$set( MemorySegment seg, MemoryAddress x) {
        IUriBuilderVtbl.HasBeenModified$VH.set(seg, x);
    }
    public static MemoryAddress HasBeenModified$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IUriBuilderVtbl.HasBeenModified$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void HasBeenModified$set(MemorySegment seg, long index, MemoryAddress x) {
        IUriBuilderVtbl.HasBeenModified$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static HasBeenModified HasBeenModified (MemorySegment segment, MemorySession session) {
        return HasBeenModified.ofAddress(HasBeenModified$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


