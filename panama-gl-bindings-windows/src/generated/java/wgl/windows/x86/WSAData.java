// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct WSAData {
 *     WORD wVersion;
 *     WORD wHighVersion;
 *     unsigned short iMaxSockets;
 *     unsigned short iMaxUdpDg;
 *     char *lpVendorInfo;
 *     char szDescription[257];
 *     char szSystemStatus[129];
 * }
 * }
 */
public class WSAData {

    WSAData() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        wgl_h.C_SHORT.withName("wVersion"),
        wgl_h.C_SHORT.withName("wHighVersion"),
        wgl_h.C_SHORT.withName("iMaxSockets"),
        wgl_h.C_SHORT.withName("iMaxUdpDg"),
        wgl_h.C_POINTER.withName("lpVendorInfo"),
        MemoryLayout.sequenceLayout(257, wgl_h.C_CHAR).withName("szDescription"),
        MemoryLayout.sequenceLayout(129, wgl_h.C_CHAR).withName("szSystemStatus"),
        MemoryLayout.paddingLayout(6)
    ).withName("WSAData");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfShort wVersion$LAYOUT = (OfShort)$LAYOUT.select(groupElement("wVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * WORD wVersion
     * }
     */
    public static final OfShort wVersion$layout() {
        return wVersion$LAYOUT;
    }

    private static final long wVersion$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * WORD wVersion
     * }
     */
    public static final long wVersion$offset() {
        return wVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * WORD wVersion
     * }
     */
    public static short wVersion(MemorySegment struct) {
        return struct.get(wVersion$LAYOUT, wVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * WORD wVersion
     * }
     */
    public static void wVersion(MemorySegment struct, short fieldValue) {
        struct.set(wVersion$LAYOUT, wVersion$OFFSET, fieldValue);
    }

    private static final OfShort wHighVersion$LAYOUT = (OfShort)$LAYOUT.select(groupElement("wHighVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * WORD wHighVersion
     * }
     */
    public static final OfShort wHighVersion$layout() {
        return wHighVersion$LAYOUT;
    }

    private static final long wHighVersion$OFFSET = 2;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * WORD wHighVersion
     * }
     */
    public static final long wHighVersion$offset() {
        return wHighVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * WORD wHighVersion
     * }
     */
    public static short wHighVersion(MemorySegment struct) {
        return struct.get(wHighVersion$LAYOUT, wHighVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * WORD wHighVersion
     * }
     */
    public static void wHighVersion(MemorySegment struct, short fieldValue) {
        struct.set(wHighVersion$LAYOUT, wHighVersion$OFFSET, fieldValue);
    }

    private static final OfShort iMaxSockets$LAYOUT = (OfShort)$LAYOUT.select(groupElement("iMaxSockets"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned short iMaxSockets
     * }
     */
    public static final OfShort iMaxSockets$layout() {
        return iMaxSockets$LAYOUT;
    }

    private static final long iMaxSockets$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned short iMaxSockets
     * }
     */
    public static final long iMaxSockets$offset() {
        return iMaxSockets$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned short iMaxSockets
     * }
     */
    public static short iMaxSockets(MemorySegment struct) {
        return struct.get(iMaxSockets$LAYOUT, iMaxSockets$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned short iMaxSockets
     * }
     */
    public static void iMaxSockets(MemorySegment struct, short fieldValue) {
        struct.set(iMaxSockets$LAYOUT, iMaxSockets$OFFSET, fieldValue);
    }

    private static final OfShort iMaxUdpDg$LAYOUT = (OfShort)$LAYOUT.select(groupElement("iMaxUdpDg"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned short iMaxUdpDg
     * }
     */
    public static final OfShort iMaxUdpDg$layout() {
        return iMaxUdpDg$LAYOUT;
    }

    private static final long iMaxUdpDg$OFFSET = 6;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned short iMaxUdpDg
     * }
     */
    public static final long iMaxUdpDg$offset() {
        return iMaxUdpDg$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned short iMaxUdpDg
     * }
     */
    public static short iMaxUdpDg(MemorySegment struct) {
        return struct.get(iMaxUdpDg$LAYOUT, iMaxUdpDg$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned short iMaxUdpDg
     * }
     */
    public static void iMaxUdpDg(MemorySegment struct, short fieldValue) {
        struct.set(iMaxUdpDg$LAYOUT, iMaxUdpDg$OFFSET, fieldValue);
    }

    private static final AddressLayout lpVendorInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("lpVendorInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *lpVendorInfo
     * }
     */
    public static final AddressLayout lpVendorInfo$layout() {
        return lpVendorInfo$LAYOUT;
    }

    private static final long lpVendorInfo$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *lpVendorInfo
     * }
     */
    public static final long lpVendorInfo$offset() {
        return lpVendorInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *lpVendorInfo
     * }
     */
    public static MemorySegment lpVendorInfo(MemorySegment struct) {
        return struct.get(lpVendorInfo$LAYOUT, lpVendorInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *lpVendorInfo
     * }
     */
    public static void lpVendorInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(lpVendorInfo$LAYOUT, lpVendorInfo$OFFSET, fieldValue);
    }

    private static final SequenceLayout szDescription$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("szDescription"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char szDescription[257]
     * }
     */
    public static final SequenceLayout szDescription$layout() {
        return szDescription$LAYOUT;
    }

    private static final long szDescription$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char szDescription[257]
     * }
     */
    public static final long szDescription$offset() {
        return szDescription$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char szDescription[257]
     * }
     */
    public static MemorySegment szDescription(MemorySegment struct) {
        return struct.asSlice(szDescription$OFFSET, szDescription$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char szDescription[257]
     * }
     */
    public static void szDescription(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, szDescription$OFFSET, szDescription$LAYOUT.byteSize());
    }

    private static long[] szDescription$DIMS = { 257 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char szDescription[257]
     * }
     */
    public static long[] szDescription$dimensions() {
        return szDescription$DIMS;
    }
    private static final VarHandle szDescription$ELEM_HANDLE = szDescription$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char szDescription[257]
     * }
     */
    public static byte szDescription(MemorySegment struct, long index0) {
        return (byte)szDescription$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char szDescription[257]
     * }
     */
    public static void szDescription(MemorySegment struct, long index0, byte fieldValue) {
        szDescription$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout szSystemStatus$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("szSystemStatus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char szSystemStatus[129]
     * }
     */
    public static final SequenceLayout szSystemStatus$layout() {
        return szSystemStatus$LAYOUT;
    }

    private static final long szSystemStatus$OFFSET = 273;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char szSystemStatus[129]
     * }
     */
    public static final long szSystemStatus$offset() {
        return szSystemStatus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char szSystemStatus[129]
     * }
     */
    public static MemorySegment szSystemStatus(MemorySegment struct) {
        return struct.asSlice(szSystemStatus$OFFSET, szSystemStatus$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char szSystemStatus[129]
     * }
     */
    public static void szSystemStatus(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, szSystemStatus$OFFSET, szSystemStatus$LAYOUT.byteSize());
    }

    private static long[] szSystemStatus$DIMS = { 129 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char szSystemStatus[129]
     * }
     */
    public static long[] szSystemStatus$dimensions() {
        return szSystemStatus$DIMS;
    }
    private static final VarHandle szSystemStatus$ELEM_HANDLE = szSystemStatus$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char szSystemStatus[129]
     * }
     */
    public static byte szSystemStatus(MemorySegment struct, long index0) {
        return (byte)szSystemStatus$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char szSystemStatus[129]
     * }
     */
    public static void szSystemStatus(MemorySegment struct, long index0, byte fieldValue) {
        szSystemStatus$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

