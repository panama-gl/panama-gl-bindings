// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct IUriVtbl {
 *     HRESULT (*QueryInterface)(IUri *, const IID *const, void **) __attribute__((stdcall));
 *     ULONG (*AddRef)(IUri *) __attribute__((stdcall));
 *     ULONG (*Release)(IUri *) __attribute__((stdcall));
 *     HRESULT (*GetPropertyBSTR)(IUri *, Uri_PROPERTY, BSTR *, DWORD) __attribute__((stdcall));
 *     HRESULT (*GetPropertyLength)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall));
 *     HRESULT (*GetPropertyDWORD)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall));
 *     HRESULT (*HasProperty)(IUri *, Uri_PROPERTY, BOOL *) __attribute__((stdcall));
 *     HRESULT (*GetAbsoluteUri)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetAuthority)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetDisplayUri)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetDomain)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetExtension)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetFragment)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetHost)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetPassword)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetPath)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetPathAndQuery)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetQuery)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetRawUri)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetSchemeName)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetUserInfo)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetUserNameA)(IUri *, BSTR *) __attribute__((stdcall));
 *     HRESULT (*GetHostType)(IUri *, DWORD *) __attribute__((stdcall));
 *     HRESULT (*GetPort)(IUri *, DWORD *) __attribute__((stdcall));
 *     HRESULT (*GetScheme)(IUri *, DWORD *) __attribute__((stdcall));
 *     HRESULT (*GetZone)(IUri *, DWORD *) __attribute__((stdcall));
 *     HRESULT (*GetProperties)(IUri *, LPDWORD) __attribute__((stdcall));
 *     HRESULT (*IsEqual)(IUri *, IUri *, BOOL *) __attribute__((stdcall));
 * }
 * }
 */
public class IUriVtbl {

    IUriVtbl() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        wgl_h.C_POINTER.withName("QueryInterface"),
        wgl_h.C_POINTER.withName("AddRef"),
        wgl_h.C_POINTER.withName("Release"),
        wgl_h.C_POINTER.withName("GetPropertyBSTR"),
        wgl_h.C_POINTER.withName("GetPropertyLength"),
        wgl_h.C_POINTER.withName("GetPropertyDWORD"),
        wgl_h.C_POINTER.withName("HasProperty"),
        wgl_h.C_POINTER.withName("GetAbsoluteUri"),
        wgl_h.C_POINTER.withName("GetAuthority"),
        wgl_h.C_POINTER.withName("GetDisplayUri"),
        wgl_h.C_POINTER.withName("GetDomain"),
        wgl_h.C_POINTER.withName("GetExtension"),
        wgl_h.C_POINTER.withName("GetFragment"),
        wgl_h.C_POINTER.withName("GetHost"),
        wgl_h.C_POINTER.withName("GetPassword"),
        wgl_h.C_POINTER.withName("GetPath"),
        wgl_h.C_POINTER.withName("GetPathAndQuery"),
        wgl_h.C_POINTER.withName("GetQuery"),
        wgl_h.C_POINTER.withName("GetRawUri"),
        wgl_h.C_POINTER.withName("GetSchemeName"),
        wgl_h.C_POINTER.withName("GetUserInfo"),
        wgl_h.C_POINTER.withName("GetUserNameA"),
        wgl_h.C_POINTER.withName("GetHostType"),
        wgl_h.C_POINTER.withName("GetPort"),
        wgl_h.C_POINTER.withName("GetScheme"),
        wgl_h.C_POINTER.withName("GetZone"),
        wgl_h.C_POINTER.withName("GetProperties"),
        wgl_h.C_POINTER.withName("IsEqual")
    ).withName("IUriVtbl");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(IUri *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static class QueryInterface {

        QueryInterface() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(QueryInterface.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(QueryInterface.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout QueryInterface$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("QueryInterface"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(IUri *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout QueryInterface$layout() {
        return QueryInterface$LAYOUT;
    }

    private static final long QueryInterface$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(IUri *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static final long QueryInterface$offset() {
        return QueryInterface$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(IUri *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static MemorySegment QueryInterface(MemorySegment struct) {
        return struct.get(QueryInterface$LAYOUT, QueryInterface$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*QueryInterface)(IUri *, const IID *const, void **) __attribute__((stdcall))
     * }
     */
    public static void QueryInterface(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(QueryInterface$LAYOUT, QueryInterface$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ULONG (*AddRef)(IUri *) __attribute__((stdcall))
     * }
     */
    public static class AddRef {

        AddRef() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(AddRef.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddRef.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddRef$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddRef"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(IUri *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout AddRef$layout() {
        return AddRef$LAYOUT;
    }

    private static final long AddRef$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(IUri *) __attribute__((stdcall))
     * }
     */
    public static final long AddRef$offset() {
        return AddRef$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(IUri *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment AddRef(MemorySegment struct) {
        return struct.get(AddRef$LAYOUT, AddRef$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG (*AddRef)(IUri *) __attribute__((stdcall))
     * }
     */
    public static void AddRef(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddRef$LAYOUT, AddRef$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ULONG (*Release)(IUri *) __attribute__((stdcall))
     * }
     */
    public static class Release {

        Release() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(Release.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Release.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Release$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Release"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ULONG (*Release)(IUri *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout Release$layout() {
        return Release$LAYOUT;
    }

    private static final long Release$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ULONG (*Release)(IUri *) __attribute__((stdcall))
     * }
     */
    public static final long Release$offset() {
        return Release$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ULONG (*Release)(IUri *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment Release(MemorySegment struct) {
        return struct.get(Release$LAYOUT, Release$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ULONG (*Release)(IUri *) __attribute__((stdcall))
     * }
     */
    public static void Release(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Release$LAYOUT, Release$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetPropertyBSTR)(IUri *, Uri_PROPERTY, BSTR *, DWORD) __attribute__((stdcall))
     * }
     */
    public static class GetPropertyBSTR {

        GetPropertyBSTR() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetPropertyBSTR.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetPropertyBSTR.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetPropertyBSTR$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetPropertyBSTR"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyBSTR)(IUri *, Uri_PROPERTY, BSTR *, DWORD) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetPropertyBSTR$layout() {
        return GetPropertyBSTR$LAYOUT;
    }

    private static final long GetPropertyBSTR$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyBSTR)(IUri *, Uri_PROPERTY, BSTR *, DWORD) __attribute__((stdcall))
     * }
     */
    public static final long GetPropertyBSTR$offset() {
        return GetPropertyBSTR$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyBSTR)(IUri *, Uri_PROPERTY, BSTR *, DWORD) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetPropertyBSTR(MemorySegment struct) {
        return struct.get(GetPropertyBSTR$LAYOUT, GetPropertyBSTR$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyBSTR)(IUri *, Uri_PROPERTY, BSTR *, DWORD) __attribute__((stdcall))
     * }
     */
    public static void GetPropertyBSTR(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetPropertyBSTR$LAYOUT, GetPropertyBSTR$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetPropertyLength)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall))
     * }
     */
    public static class GetPropertyLength {

        GetPropertyLength() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetPropertyLength.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetPropertyLength.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetPropertyLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetPropertyLength"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyLength)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetPropertyLength$layout() {
        return GetPropertyLength$LAYOUT;
    }

    private static final long GetPropertyLength$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyLength)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall))
     * }
     */
    public static final long GetPropertyLength$offset() {
        return GetPropertyLength$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyLength)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetPropertyLength(MemorySegment struct) {
        return struct.get(GetPropertyLength$LAYOUT, GetPropertyLength$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyLength)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall))
     * }
     */
    public static void GetPropertyLength(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetPropertyLength$LAYOUT, GetPropertyLength$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetPropertyDWORD)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall))
     * }
     */
    public static class GetPropertyDWORD {

        GetPropertyDWORD() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetPropertyDWORD.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetPropertyDWORD.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetPropertyDWORD$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetPropertyDWORD"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyDWORD)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetPropertyDWORD$layout() {
        return GetPropertyDWORD$LAYOUT;
    }

    private static final long GetPropertyDWORD$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyDWORD)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall))
     * }
     */
    public static final long GetPropertyDWORD$offset() {
        return GetPropertyDWORD$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyDWORD)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetPropertyDWORD(MemorySegment struct) {
        return struct.get(GetPropertyDWORD$LAYOUT, GetPropertyDWORD$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPropertyDWORD)(IUri *, Uri_PROPERTY, DWORD *, DWORD) __attribute__((stdcall))
     * }
     */
    public static void GetPropertyDWORD(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetPropertyDWORD$LAYOUT, GetPropertyDWORD$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*HasProperty)(IUri *, Uri_PROPERTY, BOOL *) __attribute__((stdcall))
     * }
     */
    public static class HasProperty {

        HasProperty() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(HasProperty.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(HasProperty.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout HasProperty$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("HasProperty"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*HasProperty)(IUri *, Uri_PROPERTY, BOOL *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout HasProperty$layout() {
        return HasProperty$LAYOUT;
    }

    private static final long HasProperty$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*HasProperty)(IUri *, Uri_PROPERTY, BOOL *) __attribute__((stdcall))
     * }
     */
    public static final long HasProperty$offset() {
        return HasProperty$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*HasProperty)(IUri *, Uri_PROPERTY, BOOL *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment HasProperty(MemorySegment struct) {
        return struct.get(HasProperty$LAYOUT, HasProperty$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*HasProperty)(IUri *, Uri_PROPERTY, BOOL *) __attribute__((stdcall))
     * }
     */
    public static void HasProperty(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(HasProperty$LAYOUT, HasProperty$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetAbsoluteUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetAbsoluteUri {

        GetAbsoluteUri() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetAbsoluteUri.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAbsoluteUri.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAbsoluteUri$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAbsoluteUri"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetAbsoluteUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetAbsoluteUri$layout() {
        return GetAbsoluteUri$LAYOUT;
    }

    private static final long GetAbsoluteUri$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetAbsoluteUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetAbsoluteUri$offset() {
        return GetAbsoluteUri$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAbsoluteUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetAbsoluteUri(MemorySegment struct) {
        return struct.get(GetAbsoluteUri$LAYOUT, GetAbsoluteUri$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAbsoluteUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetAbsoluteUri(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAbsoluteUri$LAYOUT, GetAbsoluteUri$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetAuthority)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetAuthority {

        GetAuthority() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetAuthority.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAuthority.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAuthority$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAuthority"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetAuthority)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetAuthority$layout() {
        return GetAuthority$LAYOUT;
    }

    private static final long GetAuthority$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetAuthority)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetAuthority$offset() {
        return GetAuthority$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAuthority)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetAuthority(MemorySegment struct) {
        return struct.get(GetAuthority$LAYOUT, GetAuthority$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetAuthority)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetAuthority(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAuthority$LAYOUT, GetAuthority$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetDisplayUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetDisplayUri {

        GetDisplayUri() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetDisplayUri.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDisplayUri.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDisplayUri$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDisplayUri"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetDisplayUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetDisplayUri$layout() {
        return GetDisplayUri$LAYOUT;
    }

    private static final long GetDisplayUri$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetDisplayUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetDisplayUri$offset() {
        return GetDisplayUri$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDisplayUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetDisplayUri(MemorySegment struct) {
        return struct.get(GetDisplayUri$LAYOUT, GetDisplayUri$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDisplayUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetDisplayUri(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDisplayUri$LAYOUT, GetDisplayUri$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetDomain)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetDomain {

        GetDomain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetDomain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDomain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetDomain)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetDomain$layout() {
        return GetDomain$LAYOUT;
    }

    private static final long GetDomain$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetDomain)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetDomain$offset() {
        return GetDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDomain)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetDomain(MemorySegment struct) {
        return struct.get(GetDomain$LAYOUT, GetDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetDomain)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetDomain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDomain$LAYOUT, GetDomain$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetExtension)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetExtension {

        GetExtension() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetExtension.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetExtension.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetExtension$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetExtension"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetExtension)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetExtension$layout() {
        return GetExtension$LAYOUT;
    }

    private static final long GetExtension$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetExtension)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetExtension$offset() {
        return GetExtension$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetExtension)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetExtension(MemorySegment struct) {
        return struct.get(GetExtension$LAYOUT, GetExtension$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetExtension)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetExtension(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetExtension$LAYOUT, GetExtension$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetFragment)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetFragment {

        GetFragment() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetFragment.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFragment.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFragment$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFragment"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetFragment)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetFragment$layout() {
        return GetFragment$LAYOUT;
    }

    private static final long GetFragment$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetFragment)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetFragment$offset() {
        return GetFragment$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetFragment)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetFragment(MemorySegment struct) {
        return struct.get(GetFragment$LAYOUT, GetFragment$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetFragment)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetFragment(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFragment$LAYOUT, GetFragment$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetHost)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetHost {

        GetHost() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetHost.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetHost.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetHost$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetHost"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetHost)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetHost$layout() {
        return GetHost$LAYOUT;
    }

    private static final long GetHost$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetHost)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetHost$offset() {
        return GetHost$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetHost)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetHost(MemorySegment struct) {
        return struct.get(GetHost$LAYOUT, GetHost$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetHost)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetHost(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetHost$LAYOUT, GetHost$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetPassword)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetPassword {

        GetPassword() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetPassword.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetPassword.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetPassword$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetPassword"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetPassword)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetPassword$layout() {
        return GetPassword$LAYOUT;
    }

    private static final long GetPassword$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetPassword)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetPassword$offset() {
        return GetPassword$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPassword)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetPassword(MemorySegment struct) {
        return struct.get(GetPassword$LAYOUT, GetPassword$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPassword)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetPassword(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetPassword$LAYOUT, GetPassword$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetPath)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetPath {

        GetPath() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetPath.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetPath.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetPath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetPath"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetPath)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetPath$layout() {
        return GetPath$LAYOUT;
    }

    private static final long GetPath$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetPath)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetPath$offset() {
        return GetPath$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPath)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetPath(MemorySegment struct) {
        return struct.get(GetPath$LAYOUT, GetPath$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPath)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetPath(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetPath$LAYOUT, GetPath$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetPathAndQuery)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetPathAndQuery {

        GetPathAndQuery() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetPathAndQuery.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetPathAndQuery.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetPathAndQuery$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetPathAndQuery"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetPathAndQuery)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetPathAndQuery$layout() {
        return GetPathAndQuery$LAYOUT;
    }

    private static final long GetPathAndQuery$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetPathAndQuery)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetPathAndQuery$offset() {
        return GetPathAndQuery$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPathAndQuery)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetPathAndQuery(MemorySegment struct) {
        return struct.get(GetPathAndQuery$LAYOUT, GetPathAndQuery$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPathAndQuery)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetPathAndQuery(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetPathAndQuery$LAYOUT, GetPathAndQuery$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetQuery)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetQuery {

        GetQuery() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetQuery.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetQuery.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetQuery$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetQuery"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetQuery)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetQuery$layout() {
        return GetQuery$LAYOUT;
    }

    private static final long GetQuery$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetQuery)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetQuery$offset() {
        return GetQuery$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetQuery)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetQuery(MemorySegment struct) {
        return struct.get(GetQuery$LAYOUT, GetQuery$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetQuery)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetQuery(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetQuery$LAYOUT, GetQuery$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetRawUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetRawUri {

        GetRawUri() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetRawUri.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetRawUri.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetRawUri$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetRawUri"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetRawUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetRawUri$layout() {
        return GetRawUri$LAYOUT;
    }

    private static final long GetRawUri$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetRawUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetRawUri$offset() {
        return GetRawUri$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetRawUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetRawUri(MemorySegment struct) {
        return struct.get(GetRawUri$LAYOUT, GetRawUri$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetRawUri)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetRawUri(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetRawUri$LAYOUT, GetRawUri$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetSchemeName)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetSchemeName {

        GetSchemeName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetSchemeName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSchemeName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSchemeName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSchemeName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetSchemeName)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetSchemeName$layout() {
        return GetSchemeName$LAYOUT;
    }

    private static final long GetSchemeName$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetSchemeName)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetSchemeName$offset() {
        return GetSchemeName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetSchemeName)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetSchemeName(MemorySegment struct) {
        return struct.get(GetSchemeName$LAYOUT, GetSchemeName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetSchemeName)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetSchemeName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSchemeName$LAYOUT, GetSchemeName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetUserInfo)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetUserInfo {

        GetUserInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetUserInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetUserInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetUserInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetUserInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetUserInfo)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetUserInfo$layout() {
        return GetUserInfo$LAYOUT;
    }

    private static final long GetUserInfo$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetUserInfo)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetUserInfo$offset() {
        return GetUserInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetUserInfo)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetUserInfo(MemorySegment struct) {
        return struct.get(GetUserInfo$LAYOUT, GetUserInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetUserInfo)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetUserInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetUserInfo$LAYOUT, GetUserInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetUserNameA)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static class GetUserNameA {

        GetUserNameA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetUserNameA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetUserNameA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetUserNameA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetUserNameA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetUserNameA)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetUserNameA$layout() {
        return GetUserNameA$LAYOUT;
    }

    private static final long GetUserNameA$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetUserNameA)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static final long GetUserNameA$offset() {
        return GetUserNameA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetUserNameA)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetUserNameA(MemorySegment struct) {
        return struct.get(GetUserNameA$LAYOUT, GetUserNameA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetUserNameA)(IUri *, BSTR *) __attribute__((stdcall))
     * }
     */
    public static void GetUserNameA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetUserNameA$LAYOUT, GetUserNameA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetHostType)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static class GetHostType {

        GetHostType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetHostType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetHostType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetHostType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetHostType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetHostType)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetHostType$layout() {
        return GetHostType$LAYOUT;
    }

    private static final long GetHostType$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetHostType)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static final long GetHostType$offset() {
        return GetHostType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetHostType)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetHostType(MemorySegment struct) {
        return struct.get(GetHostType$LAYOUT, GetHostType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetHostType)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static void GetHostType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetHostType$LAYOUT, GetHostType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetPort)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static class GetPort {

        GetPort() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetPort.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetPort.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetPort$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetPort"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetPort)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetPort$layout() {
        return GetPort$LAYOUT;
    }

    private static final long GetPort$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetPort)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static final long GetPort$offset() {
        return GetPort$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPort)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetPort(MemorySegment struct) {
        return struct.get(GetPort$LAYOUT, GetPort$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetPort)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static void GetPort(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetPort$LAYOUT, GetPort$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetScheme)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static class GetScheme {

        GetScheme() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetScheme.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetScheme.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetScheme$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetScheme"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetScheme)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetScheme$layout() {
        return GetScheme$LAYOUT;
    }

    private static final long GetScheme$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetScheme)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static final long GetScheme$offset() {
        return GetScheme$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetScheme)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetScheme(MemorySegment struct) {
        return struct.get(GetScheme$LAYOUT, GetScheme$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetScheme)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static void GetScheme(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetScheme$LAYOUT, GetScheme$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetZone)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static class GetZone {

        GetZone() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetZone.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetZone.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetZone$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetZone"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetZone)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetZone$layout() {
        return GetZone$LAYOUT;
    }

    private static final long GetZone$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetZone)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static final long GetZone$offset() {
        return GetZone$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetZone)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetZone(MemorySegment struct) {
        return struct.get(GetZone$LAYOUT, GetZone$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetZone)(IUri *, DWORD *) __attribute__((stdcall))
     * }
     */
    public static void GetZone(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetZone$LAYOUT, GetZone$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*GetProperties)(IUri *, LPDWORD) __attribute__((stdcall))
     * }
     */
    public static class GetProperties {

        GetProperties() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(GetProperties.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetProperties.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetProperties$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetProperties"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*GetProperties)(IUri *, LPDWORD) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout GetProperties$layout() {
        return GetProperties$LAYOUT;
    }

    private static final long GetProperties$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*GetProperties)(IUri *, LPDWORD) __attribute__((stdcall))
     * }
     */
    public static final long GetProperties$offset() {
        return GetProperties$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*GetProperties)(IUri *, LPDWORD) __attribute__((stdcall))
     * }
     */
    public static MemorySegment GetProperties(MemorySegment struct) {
        return struct.get(GetProperties$LAYOUT, GetProperties$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*GetProperties)(IUri *, LPDWORD) __attribute__((stdcall))
     * }
     */
    public static void GetProperties(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetProperties$LAYOUT, GetProperties$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * HRESULT (*IsEqual)(IUri *, IUri *, BOOL *) __attribute__((stdcall))
     * }
     */
    public static class IsEqual {

        IsEqual() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = wgl_h.upcallHandle(IsEqual.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsEqual.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsEqual$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsEqual"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * HRESULT (*IsEqual)(IUri *, IUri *, BOOL *) __attribute__((stdcall))
     * }
     */
    public static final AddressLayout IsEqual$layout() {
        return IsEqual$LAYOUT;
    }

    private static final long IsEqual$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * HRESULT (*IsEqual)(IUri *, IUri *, BOOL *) __attribute__((stdcall))
     * }
     */
    public static final long IsEqual$offset() {
        return IsEqual$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * HRESULT (*IsEqual)(IUri *, IUri *, BOOL *) __attribute__((stdcall))
     * }
     */
    public static MemorySegment IsEqual(MemorySegment struct) {
        return struct.get(IsEqual$LAYOUT, IsEqual$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * HRESULT (*IsEqual)(IUri *, IUri *, BOOL *) __attribute__((stdcall))
     * }
     */
    public static void IsEqual(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsEqual$LAYOUT, IsEqual$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

