// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class wgl_h_25 extends wgl_h_26 {

    wgl_h_25() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef GUID *PUOW
     * }
     */
    public static final AddressLayout PUOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GUID *PCRM_PROTOCOL_ID
     * }
     */
    public static final AddressLayout PCRM_PROTOCOL_ID = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG NOTIFICATION_MASK
     * }
     */
    public static final OfInt NOTIFICATION_MASK = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION {
     *     PVOID TransactionKey;
     *     ULONG TransactionNotification;
     *     LARGE_INTEGER TmVirtualClock;
     *     ULONG ArgumentLength;
     * } *PTRANSACTION_NOTIFICATION
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
     *     GUID EnlistmentId;
     *     UOW UOW;
     * } *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
     *     GUID TmIdentity;
     *     ULONG Flags;
     * } *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG SAVEPOINT_ID
     * }
     */
    public static final OfInt SAVEPOINT_ID = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG *PSAVEPOINT_ID
     * }
     */
    public static final AddressLayout PSAVEPOINT_ID = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
     *     SAVEPOINT_ID SavepointId;
     * } *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
     *     ULONG PropagationCookie;
     *     GUID UOW;
     *     GUID TmIdentity;
     *     ULONG BufferLength;
     * } *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
     *     ULONG MarshalCookie;
     *     GUID UOW;
     * } *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_MARSHAL_HEADER {
     *     ULONG VersionMajor;
     *     ULONG VersionMinor;
     *     ULONG NumProtocols;
     *     ULONG Unused;
     * } *PKCRM_MARSHAL_HEADER
     * }
     */
    public static final AddressLayout PKCRM_MARSHAL_HEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_MARSHAL_HEADER {
     *     ULONG VersionMajor;
     *     ULONG VersionMinor;
     *     ULONG NumProtocols;
     *     ULONG Unused;
     * } *PRKCRM_MARSHAL_HEADER
     * }
     */
    public static final AddressLayout PRKCRM_MARSHAL_HEADER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_TRANSACTION_BLOB {
     *     UOW UOW;
     *     GUID TmIdentity;
     *     ULONG IsolationLevel;
     *     ULONG IsolationFlags;
     *     ULONG Timeout;
     *     WCHAR Description[64];
     * } *PKCRM_TRANSACTION_BLOB
     * }
     */
    public static final AddressLayout PKCRM_TRANSACTION_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_TRANSACTION_BLOB {
     *     UOW UOW;
     *     GUID TmIdentity;
     *     ULONG IsolationLevel;
     *     ULONG IsolationFlags;
     *     ULONG Timeout;
     *     WCHAR Description[64];
     * } *PRKCRM_TRANSACTION_BLOB
     * }
     */
    public static final AddressLayout PRKCRM_TRANSACTION_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_PROTOCOL_BLOB {
     *     CRM_PROTOCOL_ID ProtocolId;
     *     ULONG StaticInfoLength;
     *     ULONG TransactionIdInfoLength;
     *     ULONG Unused1;
     *     ULONG Unused2;
     * } *PKCRM_PROTOCOL_BLOB
     * }
     */
    public static final AddressLayout PKCRM_PROTOCOL_BLOB = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_PROTOCOL_BLOB {
     *     CRM_PROTOCOL_ID ProtocolId;
     *     ULONG StaticInfoLength;
     *     ULONG TransactionIdInfoLength;
     *     ULONG Unused1;
     *     ULONG Unused2;
     * } *PRKCRM_PROTOCOL_BLOB
     * }
     */
    public static final AddressLayout PRKCRM_PROTOCOL_BLOB = wgl_h.C_POINTER;
    private static final int TransactionOutcomeUndetermined = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_OUTCOME.TransactionOutcomeUndetermined = 1
     * }
     */
    public static int TransactionOutcomeUndetermined() {
        return TransactionOutcomeUndetermined;
    }
    private static final int TransactionOutcomeCommitted = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_OUTCOME.TransactionOutcomeCommitted = 2
     * }
     */
    public static int TransactionOutcomeCommitted() {
        return TransactionOutcomeCommitted;
    }
    private static final int TransactionOutcomeAborted = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_OUTCOME.TransactionOutcomeAborted = 3
     * }
     */
    public static int TransactionOutcomeAborted() {
        return TransactionOutcomeAborted;
    }
    private static final int TransactionStateNormal = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_STATE.TransactionStateNormal = 1
     * }
     */
    public static int TransactionStateNormal() {
        return TransactionStateNormal;
    }
    private static final int TransactionStateIndoubt = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_STATE.TransactionStateIndoubt = 2
     * }
     */
    public static int TransactionStateIndoubt() {
        return TransactionStateIndoubt;
    }
    private static final int TransactionStateCommittedNotify = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_STATE.TransactionStateCommittedNotify = 3
     * }
     */
    public static int TransactionStateCommittedNotify() {
        return TransactionStateCommittedNotify;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_BASIC_INFORMATION {
     *     GUID TransactionId;
     *     DWORD State;
     *     DWORD Outcome;
     * } *PTRANSACTION_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_BASIC_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
     *     GUID TmIdentity;
     *     LARGE_INTEGER VirtualClock;
     * } *PTRANSACTIONMANAGER_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_BASIC_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
     *     GUID LogIdentity;
     * } *PTRANSACTIONMANAGER_LOG_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_LOG_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
     *     DWORD LogPathLength;
     *     WCHAR LogPath[1];
     * } *PTRANSACTIONMANAGER_LOGPATH_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_LOGPATH_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
     *     ULONGLONG LastRecoveredLsn;
     * } *PTRANSACTIONMANAGER_RECOVERY_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_RECOVERY_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
     *     GUID OldestTransactionGuid;
     * } *PTRANSACTIONMANAGER_OLDEST_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_OLDEST_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
     *     DWORD IsolationLevel;
     *     DWORD IsolationFlags;
     *     LARGE_INTEGER Timeout;
     *     DWORD Outcome;
     *     DWORD DescriptionLength;
     *     WCHAR Description[1];
     * } *PTRANSACTION_PROPERTIES_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_PROPERTIES_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_BIND_INFORMATION {
     *     HANDLE TmHandle;
     * } *PTRANSACTION_BIND_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_BIND_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_ENLISTMENT_PAIR {
     *     GUID EnlistmentId;
     *     GUID ResourceManagerId;
     * } *PTRANSACTION_ENLISTMENT_PAIR
     * }
     */
    public static final AddressLayout PTRANSACTION_ENLISTMENT_PAIR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
     *     DWORD NumberOfEnlistments;
     *     TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1];
     * } *PTRANSACTION_ENLISTMENTS_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_ENLISTMENTS_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
     *     TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
     * } *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
     *     GUID ResourceManagerId;
     *     DWORD DescriptionLength;
     *     WCHAR Description[1];
     * } *PRESOURCEMANAGER_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PRESOURCEMANAGER_BASIC_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
     *     HANDLE IoCompletionPortHandle;
     *     ULONG_PTR CompletionKey;
     * } *PRESOURCEMANAGER_COMPLETION_INFORMATION
     * }
     */
    public static final AddressLayout PRESOURCEMANAGER_COMPLETION_INFORMATION = wgl_h.C_POINTER;
    private static final int TransactionBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionBasicInformation = 0
     * }
     */
    public static int TransactionBasicInformation() {
        return TransactionBasicInformation;
    }
    private static final int TransactionPropertiesInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionPropertiesInformation = 1
     * }
     */
    public static int TransactionPropertiesInformation() {
        return TransactionPropertiesInformation;
    }
    private static final int TransactionEnlistmentInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionEnlistmentInformation = 2
     * }
     */
    public static int TransactionEnlistmentInformation() {
        return TransactionEnlistmentInformation;
    }
    private static final int TransactionSuperiorEnlistmentInformation = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionSuperiorEnlistmentInformation = 3
     * }
     */
    public static int TransactionSuperiorEnlistmentInformation() {
        return TransactionSuperiorEnlistmentInformation;
    }
    private static final int TransactionBindInformation = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionBindInformation = 4
     * }
     */
    public static int TransactionBindInformation() {
        return TransactionBindInformation;
    }
    private static final int TransactionDTCPrivateInformation = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionDTCPrivateInformation = 5
     * }
     */
    public static int TransactionDTCPrivateInformation() {
        return TransactionDTCPrivateInformation;
    }
    private static final int TransactionManagerBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerBasicInformation = 0
     * }
     */
    public static int TransactionManagerBasicInformation() {
        return TransactionManagerBasicInformation;
    }
    private static final int TransactionManagerLogInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerLogInformation = 1
     * }
     */
    public static int TransactionManagerLogInformation() {
        return TransactionManagerLogInformation;
    }
    private static final int TransactionManagerLogPathInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerLogPathInformation = 2
     * }
     */
    public static int TransactionManagerLogPathInformation() {
        return TransactionManagerLogPathInformation;
    }
    private static final int TransactionManagerRecoveryInformation = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerRecoveryInformation = 4
     * }
     */
    public static int TransactionManagerRecoveryInformation() {
        return TransactionManagerRecoveryInformation;
    }
    private static final int TransactionManagerOnlineProbeInformation = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerOnlineProbeInformation = 3
     * }
     */
    public static int TransactionManagerOnlineProbeInformation() {
        return TransactionManagerOnlineProbeInformation;
    }
    private static final int TransactionManagerOldestTransactionInformation = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerOldestTransactionInformation = 5
     * }
     */
    public static int TransactionManagerOldestTransactionInformation() {
        return TransactionManagerOldestTransactionInformation;
    }
    private static final int ResourceManagerBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _RESOURCEMANAGER_INFORMATION_CLASS.ResourceManagerBasicInformation = 0
     * }
     */
    public static int ResourceManagerBasicInformation() {
        return ResourceManagerBasicInformation;
    }
    private static final int ResourceManagerCompletionInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _RESOURCEMANAGER_INFORMATION_CLASS.ResourceManagerCompletionInformation = 1
     * }
     */
    public static int ResourceManagerCompletionInformation() {
        return ResourceManagerCompletionInformation;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ENLISTMENT_BASIC_INFORMATION {
     *     GUID EnlistmentId;
     *     GUID TransactionId;
     *     GUID ResourceManagerId;
     * } *PENLISTMENT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PENLISTMENT_BASIC_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENLISTMENT_CRM_INFORMATION {
     *     GUID CrmTransactionManagerId;
     *     GUID CrmResourceManagerId;
     *     GUID CrmEnlistmentId;
     * } *PENLISTMENT_CRM_INFORMATION
     * }
     */
    public static final AddressLayout PENLISTMENT_CRM_INFORMATION = wgl_h.C_POINTER;
    private static final int EnlistmentBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _ENLISTMENT_INFORMATION_CLASS.EnlistmentBasicInformation = 0
     * }
     */
    public static int EnlistmentBasicInformation() {
        return EnlistmentBasicInformation;
    }
    private static final int EnlistmentRecoveryInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _ENLISTMENT_INFORMATION_CLASS.EnlistmentRecoveryInformation = 1
     * }
     */
    public static int EnlistmentRecoveryInformation() {
        return EnlistmentRecoveryInformation;
    }
    private static final int EnlistmentCrmInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _ENLISTMENT_INFORMATION_CLASS.EnlistmentCrmInformation = 2
     * }
     */
    public static int EnlistmentCrmInformation() {
        return EnlistmentCrmInformation;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_LIST_ENTRY {
     *     UOW UOW;
     * } *PTRANSACTION_LIST_ENTRY
     * }
     */
    public static final AddressLayout PTRANSACTION_LIST_ENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_LIST_INFORMATION {
     *     DWORD NumberOfTransactions;
     *     TRANSACTION_LIST_ENTRY TransactionInformation[1];
     * } *PTRANSACTION_LIST_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_LIST_INFORMATION = wgl_h.C_POINTER;
    private static final int KTMOBJECT_TRANSACTION = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_TRANSACTION = 0
     * }
     */
    public static int KTMOBJECT_TRANSACTION() {
        return KTMOBJECT_TRANSACTION;
    }
    private static final int KTMOBJECT_TRANSACTION_MANAGER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_TRANSACTION_MANAGER = 1
     * }
     */
    public static int KTMOBJECT_TRANSACTION_MANAGER() {
        return KTMOBJECT_TRANSACTION_MANAGER;
    }
    private static final int KTMOBJECT_RESOURCE_MANAGER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_RESOURCE_MANAGER = 2
     * }
     */
    public static int KTMOBJECT_RESOURCE_MANAGER() {
        return KTMOBJECT_RESOURCE_MANAGER;
    }
    private static final int KTMOBJECT_ENLISTMENT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_ENLISTMENT = 3
     * }
     */
    public static int KTMOBJECT_ENLISTMENT() {
        return KTMOBJECT_ENLISTMENT;
    }
    private static final int KTMOBJECT_INVALID = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_INVALID = 4
     * }
     */
    public static int KTMOBJECT_INVALID() {
        return KTMOBJECT_INVALID;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _KTMOBJECT_TYPE {
     *     KTMOBJECT_TRANSACTION,
     *     KTMOBJECT_TRANSACTION_MANAGER,
     *     KTMOBJECT_RESOURCE_MANAGER,
     *     KTMOBJECT_ENLISTMENT,
     *     KTMOBJECT_INVALID
     * } *PKTMOBJECT_TYPE
     * }
     */
    public static final AddressLayout PKTMOBJECT_TYPE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KTMOBJECT_CURSOR {
     *     GUID LastQuery;
     *     DWORD ObjectIdCount;
     *     GUID ObjectIds[1];
     * } *PKTMOBJECT_CURSOR
     * }
     */
    public static final AddressLayout PKTMOBJECT_CURSOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD TP_VERSION
     * }
     */
    public static final OfInt TP_VERSION = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD *PTP_VERSION
     * }
     */
    public static final AddressLayout PTP_VERSION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_CALLBACK_INSTANCE *PTP_CALLBACK_INSTANCE
     * }
     */
    public static final AddressLayout PTP_CALLBACK_INSTANCE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_POOL *PTP_POOL
     * }
     */
    public static final AddressLayout PTP_POOL = wgl_h.C_POINTER;
    private static final int TP_CALLBACK_PRIORITY_HIGH = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_HIGH = 0
     * }
     */
    public static int TP_CALLBACK_PRIORITY_HIGH() {
        return TP_CALLBACK_PRIORITY_HIGH;
    }
    private static final int TP_CALLBACK_PRIORITY_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL = 1
     * }
     */
    public static int TP_CALLBACK_PRIORITY_NORMAL() {
        return TP_CALLBACK_PRIORITY_NORMAL;
    }
    private static final int TP_CALLBACK_PRIORITY_LOW = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_LOW = 2
     * }
     */
    public static int TP_CALLBACK_PRIORITY_LOW() {
        return TP_CALLBACK_PRIORITY_LOW;
    }
    private static final int TP_CALLBACK_PRIORITY_INVALID = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_INVALID = 3
     * }
     */
    public static int TP_CALLBACK_PRIORITY_INVALID() {
        return TP_CALLBACK_PRIORITY_INVALID;
    }
    private static final int TP_CALLBACK_PRIORITY_COUNT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_COUNT = 3
     * }
     */
    public static int TP_CALLBACK_PRIORITY_COUNT() {
        return TP_CALLBACK_PRIORITY_COUNT;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TP_POOL_STACK_INFORMATION {
     *     SIZE_T StackReserve;
     *     SIZE_T StackCommit;
     * } *PTP_POOL_STACK_INFORMATION
     * }
     */
    public static final AddressLayout PTP_POOL_STACK_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_CLEANUP_GROUP *PTP_CLEANUP_GROUP
     * }
     */
    public static final AddressLayout PTP_CLEANUP_GROUP = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef TP_CALLBACK_ENVIRON_V3 *PTP_CALLBACK_ENVIRON
     * }
     */
    public static final AddressLayout PTP_CALLBACK_ENVIRON = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_WORK *PTP_WORK
     * }
     */
    public static final AddressLayout PTP_WORK = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_TIMER *PTP_TIMER
     * }
     */
    public static final AddressLayout PTP_TIMER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD TP_WAIT_RESULT
     * }
     */
    public static final OfInt TP_WAIT_RESULT = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_WAIT *PTP_WAIT
     * }
     */
    public static final AddressLayout PTP_WAIT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_IO *PTP_IO
     * }
     */
    public static final AddressLayout PTP_IO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef UINT_PTR WPARAM
     * }
     */
    public static final OfLong WPARAM = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG_PTR LPARAM
     * }
     */
    public static final OfLong LPARAM = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG_PTR LRESULT
     * }
     */
    public static final OfLong LRESULT = wgl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef HANDLE *SPHANDLE
     * }
     */
    public static final AddressLayout SPHANDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE *LPHANDLE
     * }
     */
    public static final AddressLayout LPHANDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE HGLOBAL
     * }
     */
    public static final AddressLayout HGLOBAL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE HLOCAL
     * }
     */
    public static final AddressLayout HLOCAL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE GLOBALHANDLE
     * }
     */
    public static final AddressLayout GLOBALHANDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE LOCALHANDLE
     * }
     */
    public static final AddressLayout LOCALHANDLE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WORD ATOM
     * }
     */
    public static final OfShort ATOM = wgl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct HKEY__ {
     *     int unused;
     * } *HKEY
     * }
     */
    public static final AddressLayout HKEY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HKEY *PHKEY
     * }
     */
    public static final AddressLayout PHKEY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMETAFILE__ {
     *     int unused;
     * } *HMETAFILE
     * }
     */
    public static final AddressLayout HMETAFILE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HINSTANCE__ {
     *     int unused;
     * } *HINSTANCE
     * }
     */
    public static final AddressLayout HINSTANCE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HINSTANCE HMODULE
     * }
     */
    public static final AddressLayout HMODULE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HRGN__ {
     *     int unused;
     * } *HRGN
     * }
     */
    public static final AddressLayout HRGN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HRSRC__ {
     *     int unused;
     * } *HRSRC
     * }
     */
    public static final AddressLayout HRSRC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HSPRITE__ {
     *     int unused;
     * } *HSPRITE
     * }
     */
    public static final AddressLayout HSPRITE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HLSURF__ {
     *     int unused;
     * } *HLSURF
     * }
     */
    public static final AddressLayout HLSURF = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HSTR__ {
     *     int unused;
     * } *HSTR
     * }
     */
    public static final AddressLayout HSTR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HTASK__ {
     *     int unused;
     * } *HTASK
     * }
     */
    public static final AddressLayout HTASK = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HWINSTA__ {
     *     int unused;
     * } *HWINSTA
     * }
     */
    public static final AddressLayout HWINSTA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HKL__ {
     *     int unused;
     * } *HKL
     * }
     */
    public static final AddressLayout HKL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int HFILE
     * }
     */
    public static final OfInt HFILE = wgl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct _FILETIME {
     *     DWORD dwLowDateTime;
     *     DWORD dwHighDateTime;
     * } *PFILETIME
     * }
     */
    public static final AddressLayout PFILETIME = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILETIME {
     *     DWORD dwLowDateTime;
     *     DWORD dwHighDateTime;
     * } *LPFILETIME
     * }
     */
    public static final AddressLayout LPFILETIME = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HWND__ {
     *     int unused;
     * } *HWND
     * }
     */
    public static final AddressLayout HWND = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HHOOK__ {
     *     int unused;
     * } *HHOOK
     * }
     */
    public static final AddressLayout HHOOK = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HGDIOBJ
     * }
     */
    public static final AddressLayout HGDIOBJ = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HACCEL__ {
     *     int unused;
     * } *HACCEL
     * }
     */
    public static final AddressLayout HACCEL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HBITMAP__ {
     *     int unused;
     * } *HBITMAP
     * }
     */
    public static final AddressLayout HBITMAP = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HBRUSH__ {
     *     int unused;
     * } *HBRUSH
     * }
     */
    public static final AddressLayout HBRUSH = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HCOLORSPACE__ {
     *     int unused;
     * } *HCOLORSPACE
     * }
     */
    public static final AddressLayout HCOLORSPACE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HDC__ {
     *     int unused;
     * } *HDC
     * }
     */
    public static final AddressLayout HDC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HGLRC__ {
     *     int unused;
     * } *HGLRC
     * }
     */
    public static final AddressLayout HGLRC = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HDESK__ {
     *     int unused;
     * } *HDESK
     * }
     */
    public static final AddressLayout HDESK = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HENHMETAFILE__ {
     *     int unused;
     * } *HENHMETAFILE
     * }
     */
    public static final AddressLayout HENHMETAFILE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HFONT__ {
     *     int unused;
     * } *HFONT
     * }
     */
    public static final AddressLayout HFONT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HICON__ {
     *     int unused;
     * } *HICON
     * }
     */
    public static final AddressLayout HICON = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMENU__ {
     *     int unused;
     * } *HMENU
     * }
     */
    public static final AddressLayout HMENU = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HPALETTE__ {
     *     int unused;
     * } *HPALETTE
     * }
     */
    public static final AddressLayout HPALETTE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HPEN__ {
     *     int unused;
     * } *HPEN
     * }
     */
    public static final AddressLayout HPEN = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HWINEVENTHOOK__ {
     *     int unused;
     * } *HWINEVENTHOOK
     * }
     */
    public static final AddressLayout HWINEVENTHOOK = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMONITOR__ {
     *     int unused;
     * } *HMONITOR
     * }
     */
    public static final AddressLayout HMONITOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HUMPD__ {
     *     int unused;
     * } *HUMPD
     * }
     */
    public static final AddressLayout HUMPD = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HICON HCURSOR
     * }
     */
    public static final AddressLayout HCURSOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD COLORREF
     * }
     */
    public static final OfInt COLORREF = wgl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD *LPCOLORREF
     * }
     */
    public static final AddressLayout LPCOLORREF = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECT {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *PRECT
     * }
     */
    public static final AddressLayout PRECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECT {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *NPRECT
     * }
     */
    public static final AddressLayout NPRECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECT {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *LPRECT
     * }
     */
    public static final AddressLayout LPRECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const RECT *LPCRECT
     * }
     */
    public static final AddressLayout LPCRECT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RECTL {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *PRECTL
     * }
     */
    public static final AddressLayout PRECTL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RECTL {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *LPRECTL
     * }
     */
    public static final AddressLayout LPRECTL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const RECTL *LPCRECTL
     * }
     */
    public static final AddressLayout LPCRECTL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINT {
     *     LONG x;
     *     LONG y;
     * } *PPOINT
     * }
     */
    public static final AddressLayout PPOINT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINT {
     *     LONG x;
     *     LONG y;
     * } *NPPOINT
     * }
     */
    public static final AddressLayout NPPOINT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINT {
     *     LONG x;
     *     LONG y;
     * } *LPPOINT
     * }
     */
    public static final AddressLayout LPPOINT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _POINTL {
     *     LONG x;
     *     LONG y;
     * } *PPOINTL
     * }
     */
    public static final AddressLayout PPOINTL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSIZE {
     *     LONG cx;
     *     LONG cy;
     * } *PSIZE
     * }
     */
    public static final AddressLayout PSIZE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSIZE {
     *     LONG cx;
     *     LONG cy;
     * } *LPSIZE
     * }
     */
    public static final AddressLayout LPSIZE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SIZE *PSIZEL
     * }
     */
    public static final AddressLayout PSIZEL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SIZE *LPSIZEL
     * }
     */
    public static final AddressLayout LPSIZEL = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTS {
     *     SHORT x;
     *     SHORT y;
     * } *PPOINTS
     * }
     */
    public static final AddressLayout PPOINTS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTS {
     *     SHORT x;
     *     SHORT y;
     * } *LPPOINTS
     * }
     */
    public static final AddressLayout LPPOINTS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct DPI_AWARENESS_CONTEXT__ {
     *     int unused;
     * } *DPI_AWARENESS_CONTEXT
     * }
     */
    public static final AddressLayout DPI_AWARENESS_CONTEXT = wgl_h.C_POINTER;
    private static final int DPI_AWARENESS_INVALID = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_INVALID = -1
     * }
     */
    public static int DPI_AWARENESS_INVALID() {
        return DPI_AWARENESS_INVALID;
    }
    private static final int DPI_AWARENESS_UNAWARE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_UNAWARE = 0
     * }
     */
    public static int DPI_AWARENESS_UNAWARE() {
        return DPI_AWARENESS_UNAWARE;
    }
    private static final int DPI_AWARENESS_SYSTEM_AWARE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_SYSTEM_AWARE = 1
     * }
     */
    public static int DPI_AWARENESS_SYSTEM_AWARE() {
        return DPI_AWARENESS_SYSTEM_AWARE;
    }
    private static final int DPI_AWARENESS_PER_MONITOR_AWARE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_PER_MONITOR_AWARE = 2
     * }
     */
    public static int DPI_AWARENESS_PER_MONITOR_AWARE() {
        return DPI_AWARENESS_PER_MONITOR_AWARE;
    }
    private static final int DPI_HOSTING_BEHAVIOR_INVALID = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_INVALID = -1
     * }
     */
    public static int DPI_HOSTING_BEHAVIOR_INVALID() {
        return DPI_HOSTING_BEHAVIOR_INVALID;
    }
    private static final int DPI_HOSTING_BEHAVIOR_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_DEFAULT = 0
     * }
     */
    public static int DPI_HOSTING_BEHAVIOR_DEFAULT() {
        return DPI_HOSTING_BEHAVIOR_DEFAULT;
    }
    private static final int DPI_HOSTING_BEHAVIOR_MIXED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_MIXED = 1
     * }
     */
    public static int DPI_HOSTING_BEHAVIOR_MIXED() {
        return DPI_HOSTING_BEHAVIOR_MIXED;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_ATTRIBUTES {
     *     DWORD nLength;
     *     LPVOID lpSecurityDescriptor;
     *     BOOL bInheritHandle;
     * } *PSECURITY_ATTRIBUTES
     * }
     */
    public static final AddressLayout PSECURITY_ATTRIBUTES = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_ATTRIBUTES {
     *     DWORD nLength;
     *     LPVOID lpSecurityDescriptor;
     *     BOOL bInheritHandle;
     * } *LPSECURITY_ATTRIBUTES
     * }
     */
    public static final AddressLayout LPSECURITY_ATTRIBUTES = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OVERLAPPED {
     *     ULONG_PTR Internal;
     *     ULONG_PTR InternalHigh;
     *     union {
     *         struct {
     *             DWORD Offset;
     *             DWORD OffsetHigh;
     *         };
     *         PVOID Pointer;
     *     };
     *     HANDLE hEvent;
     * } *LPOVERLAPPED
     * }
     */
    public static final AddressLayout LPOVERLAPPED = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OVERLAPPED_ENTRY {
     *     ULONG_PTR lpCompletionKey;
     *     LPOVERLAPPED lpOverlapped;
     *     ULONG_PTR Internal;
     *     DWORD dwNumberOfBytesTransferred;
     * } *LPOVERLAPPED_ENTRY
     * }
     */
    public static final AddressLayout LPOVERLAPPED_ENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEMTIME {
     *     WORD wYear;
     *     WORD wMonth;
     *     WORD wDayOfWeek;
     *     WORD wDay;
     *     WORD wHour;
     *     WORD wMinute;
     *     WORD wSecond;
     *     WORD wMilliseconds;
     * } *PSYSTEMTIME
     * }
     */
    public static final AddressLayout PSYSTEMTIME = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEMTIME {
     *     WORD wYear;
     *     WORD wMonth;
     *     WORD wDayOfWeek;
     *     WORD wDay;
     *     WORD wHour;
     *     WORD wMinute;
     *     WORD wSecond;
     *     WORD wMilliseconds;
     * } *LPSYSTEMTIME
     * }
     */
    public static final AddressLayout LPSYSTEMTIME = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAA {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     CHAR cFileName[260];
     *     CHAR cAlternateFileName[14];
     * } *PWIN32_FIND_DATAA
     * }
     */
    public static final AddressLayout PWIN32_FIND_DATAA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAA {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     CHAR cFileName[260];
     *     CHAR cAlternateFileName[14];
     * } *LPWIN32_FIND_DATAA
     * }
     */
    public static final AddressLayout LPWIN32_FIND_DATAA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAW {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     WCHAR cFileName[260];
     *     WCHAR cAlternateFileName[14];
     * } *PWIN32_FIND_DATAW
     * }
     */
    public static final AddressLayout PWIN32_FIND_DATAW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAW {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     WCHAR cFileName[260];
     *     WCHAR cAlternateFileName[14];
     * } *LPWIN32_FIND_DATAW
     * }
     */
    public static final AddressLayout LPWIN32_FIND_DATAW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA
     * }
     */
    public static final AddressLayout PWIN32_FIND_DATA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA
     * }
     */
    public static final AddressLayout LPWIN32_FIND_DATA = wgl_h.C_POINTER;
    private static final int FindExInfoStandard = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_INFO_LEVELS.FindExInfoStandard = 0
     * }
     */
    public static int FindExInfoStandard() {
        return FindExInfoStandard;
    }
    private static final int FindExInfoBasic = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_INFO_LEVELS.FindExInfoBasic = 1
     * }
     */
    public static int FindExInfoBasic() {
        return FindExInfoBasic;
    }
    private static final int FindExInfoMaxInfoLevel = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_INFO_LEVELS.FindExInfoMaxInfoLevel = 2
     * }
     */
    public static int FindExInfoMaxInfoLevel() {
        return FindExInfoMaxInfoLevel;
    }
    private static final int FindExSearchNameMatch = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchNameMatch = 0
     * }
     */
    public static int FindExSearchNameMatch() {
        return FindExSearchNameMatch;
    }
    private static final int FindExSearchLimitToDirectories = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchLimitToDirectories = 1
     * }
     */
    public static int FindExSearchLimitToDirectories() {
        return FindExSearchLimitToDirectories;
    }
    private static final int FindExSearchLimitToDevices = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchLimitToDevices = 2
     * }
     */
    public static int FindExSearchLimitToDevices() {
        return FindExSearchLimitToDevices;
    }
    private static final int FindExSearchMaxSearchOp = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchMaxSearchOp = 3
     * }
     */
    public static int FindExSearchMaxSearchOp() {
        return FindExSearchMaxSearchOp;
    }
    private static final int ReadDirectoryNotifyInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ReadDirectoryNotifyInformation = 1
     * }
     */
    public static int ReadDirectoryNotifyInformation() {
        return ReadDirectoryNotifyInformation;
    }
    private static final int ReadDirectoryNotifyExtendedInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ReadDirectoryNotifyExtendedInformation = 2
     * }
     */
    public static int ReadDirectoryNotifyExtendedInformation() {
        return ReadDirectoryNotifyExtendedInformation;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS {
     *     ReadDirectoryNotifyInformation = 1,
     *     ReadDirectoryNotifyExtendedInformation
     * } *PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS
     * }
     */
    public static final AddressLayout PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS = wgl_h.C_POINTER;
    private static final int GetFileExInfoStandard = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _GET_FILEEX_INFO_LEVELS.GetFileExInfoStandard = 0
     * }
     */
    public static int GetFileExInfoStandard() {
        return GetFileExInfoStandard;
    }
    private static final int GetFileExMaxInfoLevel = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _GET_FILEEX_INFO_LEVELS.GetFileExMaxInfoLevel = 1
     * }
     */
    public static int GetFileExMaxInfoLevel() {
        return GetFileExMaxInfoLevel;
    }
    private static final int FileBasicInfo = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileBasicInfo = 0
     * }
     */
    public static int FileBasicInfo() {
        return FileBasicInfo;
    }
    private static final int FileStandardInfo = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileStandardInfo = 1
     * }
     */
    public static int FileStandardInfo() {
        return FileStandardInfo;
    }
    private static final int FileNameInfo = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileNameInfo = 2
     * }
     */
    public static int FileNameInfo() {
        return FileNameInfo;
    }
    private static final int FileRenameInfo = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileRenameInfo = 3
     * }
     */
    public static int FileRenameInfo() {
        return FileRenameInfo;
    }
    private static final int FileDispositionInfo = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfo = 4
     * }
     */
    public static int FileDispositionInfo() {
        return FileDispositionInfo;
    }
    private static final int FileAllocationInfo = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileAllocationInfo = 5
     * }
     */
    public static int FileAllocationInfo() {
        return FileAllocationInfo;
    }
    private static final int FileEndOfFileInfo = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileEndOfFileInfo = 6
     * }
     */
    public static int FileEndOfFileInfo() {
        return FileEndOfFileInfo;
    }
    private static final int FileStreamInfo = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileStreamInfo = 7
     * }
     */
    public static int FileStreamInfo() {
        return FileStreamInfo;
    }
    private static final int FileCompressionInfo = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileCompressionInfo = 8
     * }
     */
    public static int FileCompressionInfo() {
        return FileCompressionInfo;
    }
    private static final int FileAttributeTagInfo = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileAttributeTagInfo = 9
     * }
     */
    public static int FileAttributeTagInfo() {
        return FileAttributeTagInfo;
    }
    private static final int FileIdBothDirectoryInfo = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryInfo = 10
     * }
     */
    public static int FileIdBothDirectoryInfo() {
        return FileIdBothDirectoryInfo;
    }
    private static final int FileIdBothDirectoryRestartInfo = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryRestartInfo = 11
     * }
     */
    public static int FileIdBothDirectoryRestartInfo() {
        return FileIdBothDirectoryRestartInfo;
    }
    private static final int FileIoPriorityHintInfo = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIoPriorityHintInfo = 12
     * }
     */
    public static int FileIoPriorityHintInfo() {
        return FileIoPriorityHintInfo;
    }
    private static final int FileRemoteProtocolInfo = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileRemoteProtocolInfo = 13
     * }
     */
    public static int FileRemoteProtocolInfo() {
        return FileRemoteProtocolInfo;
    }
    private static final int FileFullDirectoryInfo = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryInfo = 14
     * }
     */
    public static int FileFullDirectoryInfo() {
        return FileFullDirectoryInfo;
    }
    private static final int FileFullDirectoryRestartInfo = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryRestartInfo = 15
     * }
     */
    public static int FileFullDirectoryRestartInfo() {
        return FileFullDirectoryRestartInfo;
    }
    private static final int FileStorageInfo = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileStorageInfo = 16
     * }
     */
    public static int FileStorageInfo() {
        return FileStorageInfo;
    }
    private static final int FileAlignmentInfo = (int)17L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileAlignmentInfo = 17
     * }
     */
    public static int FileAlignmentInfo() {
        return FileAlignmentInfo;
    }
    private static final int FileIdInfo = (int)18L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdInfo = 18
     * }
     */
    public static int FileIdInfo() {
        return FileIdInfo;
    }
    private static final int FileIdExtdDirectoryInfo = (int)19L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryInfo = 19
     * }
     */
    public static int FileIdExtdDirectoryInfo() {
        return FileIdExtdDirectoryInfo;
    }
    private static final int FileIdExtdDirectoryRestartInfo = (int)20L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryRestartInfo = 20
     * }
     */
    public static int FileIdExtdDirectoryRestartInfo() {
        return FileIdExtdDirectoryRestartInfo;
    }
    private static final int FileDispositionInfoEx = (int)21L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfoEx = 21
     * }
     */
    public static int FileDispositionInfoEx() {
        return FileDispositionInfoEx;
    }
    private static final int FileRenameInfoEx = (int)22L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileRenameInfoEx = 22
     * }
     */
    public static int FileRenameInfoEx() {
        return FileRenameInfoEx;
    }
    private static final int FileCaseSensitiveInfo = (int)23L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileCaseSensitiveInfo = 23
     * }
     */
    public static int FileCaseSensitiveInfo() {
        return FileCaseSensitiveInfo;
    }
    private static final int FileNormalizedNameInfo = (int)24L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileNormalizedNameInfo = 24
     * }
     */
    public static int FileNormalizedNameInfo() {
        return FileNormalizedNameInfo;
    }
    private static final int MaximumFileInfoByHandleClass = (int)25L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.MaximumFileInfoByHandleClass = 25
     * }
     */
    public static int MaximumFileInfoByHandleClass() {
        return MaximumFileInfoByHandleClass;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _FILE_INFO_BY_HANDLE_CLASS {
     *     FileBasicInfo,
     *     FileStandardInfo,
     *     FileNameInfo,
     *     FileRenameInfo,
     *     FileDispositionInfo,
     *     FileAllocationInfo,
     *     FileEndOfFileInfo,
     *     FileStreamInfo,
     *     FileCompressionInfo,
     *     FileAttributeTagInfo,
     *     FileIdBothDirectoryInfo,
     *     FileIdBothDirectoryRestartInfo,
     *     FileIoPriorityHintInfo,
     *     FileRemoteProtocolInfo,
     *     FileFullDirectoryInfo,
     *     FileFullDirectoryRestartInfo,
     *     FileStorageInfo,
     *     FileAlignmentInfo,
     *     FileIdInfo,
     *     FileIdExtdDirectoryInfo,
     *     FileIdExtdDirectoryRestartInfo,
     *     FileDispositionInfoEx,
     *     FileRenameInfoEx,
     *     FileCaseSensitiveInfo,
     *     FileNormalizedNameInfo,
     *     MaximumFileInfoByHandleClass
     * } *PFILE_INFO_BY_HANDLE_CLASS
     * }
     */
    public static final AddressLayout PFILE_INFO_BY_HANDLE_CLASS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION
     * }
     */
    public static final AddressLayout PCRITICAL_SECTION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION
     * }
     */
    public static final AddressLayout LPCRITICAL_SECTION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG
     * }
     */
    public static final AddressLayout PCRITICAL_SECTION_DEBUG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG
     * }
     */
    public static final AddressLayout LPCRITICAL_SECTION_DEBUG = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_HEAP_ENTRY {
     *     PVOID lpData;
     *     DWORD cbData;
     *     BYTE cbOverhead;
     *     BYTE iRegionIndex;
     *     WORD wFlags;
     *     union {
     *         struct {
     *             HANDLE hMem;
     *             DWORD dwReserved[3];
     *         } Block;
     *         struct {
     *             DWORD dwCommittedSize;
     *             DWORD dwUnCommittedSize;
     *             LPVOID lpFirstBlock;
     *             LPVOID lpLastBlock;
     *         } Region;
     *     };
     * } *LPPROCESS_HEAP_ENTRY
     * }
     */
    public static final AddressLayout LPPROCESS_HEAP_ENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_HEAP_ENTRY {
     *     PVOID lpData;
     *     DWORD cbData;
     *     BYTE cbOverhead;
     *     BYTE iRegionIndex;
     *     WORD wFlags;
     *     union {
     *         struct {
     *             HANDLE hMem;
     *             DWORD dwReserved[3];
     *         } Block;
     *         struct {
     *             DWORD dwCommittedSize;
     *             DWORD dwUnCommittedSize;
     *             LPVOID lpFirstBlock;
     *             LPVOID lpLastBlock;
     *         } Region;
     *     };
     * } *PPROCESS_HEAP_ENTRY
     * }
     */
    public static final AddressLayout PPROCESS_HEAP_ENTRY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REASON_CONTEXT {
     *     ULONG Version;
     *     DWORD Flags;
     *     union {
     *         struct {
     *             HMODULE LocalizedReasonModule;
     *             ULONG LocalizedReasonId;
     *             ULONG ReasonStringCount;
     *             LPWSTR *ReasonStrings;
     *         } Detailed;
     *         LPWSTR SimpleReasonString;
     *     } Reason;
     * } *PREASON_CONTEXT
     * }
     */
    public static final AddressLayout PREASON_CONTEXT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXCEPTION_DEBUG_INFO {
     *     EXCEPTION_RECORD ExceptionRecord;
     *     DWORD dwFirstChance;
     * } *LPEXCEPTION_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPEXCEPTION_DEBUG_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CREATE_THREAD_DEBUG_INFO {
     *     HANDLE hThread;
     *     LPVOID lpThreadLocalBase;
     *     LPTHREAD_START_ROUTINE lpStartAddress;
     * } *LPCREATE_THREAD_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPCREATE_THREAD_DEBUG_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CREATE_PROCESS_DEBUG_INFO {
     *     HANDLE hFile;
     *     HANDLE hProcess;
     *     HANDLE hThread;
     *     LPVOID lpBaseOfImage;
     *     DWORD dwDebugInfoFileOffset;
     *     DWORD nDebugInfoSize;
     *     LPVOID lpThreadLocalBase;
     *     LPTHREAD_START_ROUTINE lpStartAddress;
     *     LPVOID lpImageName;
     *     WORD fUnicode;
     * } *LPCREATE_PROCESS_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPCREATE_PROCESS_DEBUG_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXIT_THREAD_DEBUG_INFO {
     *     DWORD dwExitCode;
     * } *LPEXIT_THREAD_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPEXIT_THREAD_DEBUG_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXIT_PROCESS_DEBUG_INFO {
     *     DWORD dwExitCode;
     * } *LPEXIT_PROCESS_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPEXIT_PROCESS_DEBUG_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _LOAD_DLL_DEBUG_INFO {
     *     HANDLE hFile;
     *     LPVOID lpBaseOfDll;
     *     DWORD dwDebugInfoFileOffset;
     *     DWORD nDebugInfoSize;
     *     LPVOID lpImageName;
     *     WORD fUnicode;
     * } *LPLOAD_DLL_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPLOAD_DLL_DEBUG_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UNLOAD_DLL_DEBUG_INFO {
     *     LPVOID lpBaseOfDll;
     * } *LPUNLOAD_DLL_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPUNLOAD_DLL_DEBUG_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTPUT_DEBUG_STRING_INFO {
     *     LPSTR lpDebugStringData;
     *     WORD fUnicode;
     *     WORD nDebugStringLength;
     * } *LPOUTPUT_DEBUG_STRING_INFO
     * }
     */
    public static final AddressLayout LPOUTPUT_DEBUG_STRING_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RIP_INFO {
     *     DWORD dwError;
     *     DWORD dwType;
     * } *LPRIP_INFO
     * }
     */
    public static final AddressLayout LPRIP_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DEBUG_EVENT {
     *     DWORD dwDebugEventCode;
     *     DWORD dwProcessId;
     *     DWORD dwThreadId;
     *     union {
     *         EXCEPTION_DEBUG_INFO Exception;
     *         CREATE_THREAD_DEBUG_INFO CreateThread;
     *         CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
     *         EXIT_THREAD_DEBUG_INFO ExitThread;
     *         EXIT_PROCESS_DEBUG_INFO ExitProcess;
     *         LOAD_DLL_DEBUG_INFO LoadDll;
     *         UNLOAD_DLL_DEBUG_INFO UnloadDll;
     *         OUTPUT_DEBUG_STRING_INFO DebugString;
     *         RIP_INFO RipInfo;
     *     } u;
     * } *LPDEBUG_EVENT
     * }
     */
    public static final AddressLayout LPDEBUG_EVENT = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCONTEXT LPCONTEXT
     * }
     */
    public static final AddressLayout LPCONTEXT = wgl_h.C_POINTER;

    private static class IsApiSetImplemented {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsApiSetImplemented");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsApiSetImplemented(PCSTR Contract)
     * }
     */
    public static FunctionDescriptor IsApiSetImplemented$descriptor() {
        return IsApiSetImplemented.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsApiSetImplemented(PCSTR Contract)
     * }
     */
    public static MethodHandle IsApiSetImplemented$handle() {
        return IsApiSetImplemented.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsApiSetImplemented(PCSTR Contract)
     * }
     */
    public static MemorySegment IsApiSetImplemented$address() {
        return IsApiSetImplemented.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsApiSetImplemented(PCSTR Contract)
     * }
     */
    public static int IsApiSetImplemented(MemorySegment Contract) {
        var mh$ = IsApiSetImplemented.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsApiSetImplemented", Contract);
            }
            return (int)mh$.invokeExact(Contract);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetEnvironmentStringsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsW(LPWCH NewEnvironment)
     * }
     */
    public static FunctionDescriptor SetEnvironmentStringsW$descriptor() {
        return SetEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsW(LPWCH NewEnvironment)
     * }
     */
    public static MethodHandle SetEnvironmentStringsW$handle() {
        return SetEnvironmentStringsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsW(LPWCH NewEnvironment)
     * }
     */
    public static MemorySegment SetEnvironmentStringsW$address() {
        return SetEnvironmentStringsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsW(LPWCH NewEnvironment)
     * }
     */
    public static int SetEnvironmentStringsW(MemorySegment NewEnvironment) {
        var mh$ = SetEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentStringsW", NewEnvironment);
            }
            return (int)mh$.invokeExact(NewEnvironment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStdHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetStdHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetStdHandle(DWORD nStdHandle)
     * }
     */
    public static FunctionDescriptor GetStdHandle$descriptor() {
        return GetStdHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetStdHandle(DWORD nStdHandle)
     * }
     */
    public static MethodHandle GetStdHandle$handle() {
        return GetStdHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetStdHandle(DWORD nStdHandle)
     * }
     */
    public static MemorySegment GetStdHandle$address() {
        return GetStdHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetStdHandle(DWORD nStdHandle)
     * }
     */
    public static MemorySegment GetStdHandle(int nStdHandle) {
        var mh$ = GetStdHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStdHandle", nStdHandle);
            }
            return (MemorySegment)mh$.invokeExact(nStdHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetStdHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetStdHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
     * }
     */
    public static FunctionDescriptor SetStdHandle$descriptor() {
        return SetStdHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
     * }
     */
    public static MethodHandle SetStdHandle$handle() {
        return SetStdHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
     * }
     */
    public static MemorySegment SetStdHandle$address() {
        return SetStdHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
     * }
     */
    public static int SetStdHandle(int nStdHandle, MemorySegment hHandle) {
        var mh$ = SetStdHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetStdHandle", nStdHandle, hHandle);
            }
            return (int)mh$.invokeExact(nStdHandle, hHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetStdHandleEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetStdHandleEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
     * }
     */
    public static FunctionDescriptor SetStdHandleEx$descriptor() {
        return SetStdHandleEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
     * }
     */
    public static MethodHandle SetStdHandleEx$handle() {
        return SetStdHandleEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
     * }
     */
    public static MemorySegment SetStdHandleEx$address() {
        return SetStdHandleEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
     * }
     */
    public static int SetStdHandleEx(int nStdHandle, MemorySegment hHandle, MemorySegment phPrevValue) {
        var mh$ = SetStdHandleEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetStdHandleEx", nStdHandle, hHandle, phPrevValue);
            }
            return (int)mh$.invokeExact(nStdHandle, hHandle, phPrevValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommandLineA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCommandLineA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR GetCommandLineA()
     * }
     */
    public static FunctionDescriptor GetCommandLineA$descriptor() {
        return GetCommandLineA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR GetCommandLineA()
     * }
     */
    public static MethodHandle GetCommandLineA$handle() {
        return GetCommandLineA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR GetCommandLineA()
     * }
     */
    public static MemorySegment GetCommandLineA$address() {
        return GetCommandLineA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR GetCommandLineA()
     * }
     */
    public static MemorySegment GetCommandLineA() {
        var mh$ = GetCommandLineA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommandLineA");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommandLineW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCommandLineW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR GetCommandLineW()
     * }
     */
    public static FunctionDescriptor GetCommandLineW$descriptor() {
        return GetCommandLineW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR GetCommandLineW()
     * }
     */
    public static MethodHandle GetCommandLineW$handle() {
        return GetCommandLineW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR GetCommandLineW()
     * }
     */
    public static MemorySegment GetCommandLineW$address() {
        return GetCommandLineW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR GetCommandLineW()
     * }
     */
    public static MemorySegment GetCommandLineW() {
        var mh$ = GetCommandLineW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommandLineW");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentStrings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnvironmentStrings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPCH GetEnvironmentStrings()
     * }
     */
    public static FunctionDescriptor GetEnvironmentStrings$descriptor() {
        return GetEnvironmentStrings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPCH GetEnvironmentStrings()
     * }
     */
    public static MethodHandle GetEnvironmentStrings$handle() {
        return GetEnvironmentStrings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPCH GetEnvironmentStrings()
     * }
     */
    public static MemorySegment GetEnvironmentStrings$address() {
        return GetEnvironmentStrings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPCH GetEnvironmentStrings()
     * }
     */
    public static MemorySegment GetEnvironmentStrings() {
        var mh$ = GetEnvironmentStrings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentStrings");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnvironmentStringsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWCH GetEnvironmentStringsW()
     * }
     */
    public static FunctionDescriptor GetEnvironmentStringsW$descriptor() {
        return GetEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWCH GetEnvironmentStringsW()
     * }
     */
    public static MethodHandle GetEnvironmentStringsW$handle() {
        return GetEnvironmentStringsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWCH GetEnvironmentStringsW()
     * }
     */
    public static MemorySegment GetEnvironmentStringsW$address() {
        return GetEnvironmentStringsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWCH GetEnvironmentStringsW()
     * }
     */
    public static MemorySegment GetEnvironmentStringsW() {
        var mh$ = GetEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentStringsW");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeEnvironmentStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FreeEnvironmentStringsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsA(LPCH penv)
     * }
     */
    public static FunctionDescriptor FreeEnvironmentStringsA$descriptor() {
        return FreeEnvironmentStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsA(LPCH penv)
     * }
     */
    public static MethodHandle FreeEnvironmentStringsA$handle() {
        return FreeEnvironmentStringsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsA(LPCH penv)
     * }
     */
    public static MemorySegment FreeEnvironmentStringsA$address() {
        return FreeEnvironmentStringsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsA(LPCH penv)
     * }
     */
    public static int FreeEnvironmentStringsA(MemorySegment penv) {
        var mh$ = FreeEnvironmentStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeEnvironmentStringsA", penv);
            }
            return (int)mh$.invokeExact(penv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FreeEnvironmentStringsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsW(LPWCH penv)
     * }
     */
    public static FunctionDescriptor FreeEnvironmentStringsW$descriptor() {
        return FreeEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsW(LPWCH penv)
     * }
     */
    public static MethodHandle FreeEnvironmentStringsW$handle() {
        return FreeEnvironmentStringsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsW(LPWCH penv)
     * }
     */
    public static MemorySegment FreeEnvironmentStringsW$address() {
        return FreeEnvironmentStringsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsW(LPWCH penv)
     * }
     */
    public static int FreeEnvironmentStringsW(MemorySegment penv) {
        var mh$ = FreeEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeEnvironmentStringsW", penv);
            }
            return (int)mh$.invokeExact(penv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnvironmentVariableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetEnvironmentVariableA$descriptor() {
        return GetEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetEnvironmentVariableA$handle() {
        return GetEnvironmentVariableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetEnvironmentVariableA$address() {
        return GetEnvironmentVariableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
     * }
     */
    public static int GetEnvironmentVariableA(MemorySegment lpName, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentVariableA", lpName, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetEnvironmentVariableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetEnvironmentVariableW$descriptor() {
        return GetEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetEnvironmentVariableW$handle() {
        return GetEnvironmentVariableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetEnvironmentVariableW$address() {
        return GetEnvironmentVariableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
     * }
     */
    public static int GetEnvironmentVariableW(MemorySegment lpName, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentVariableW", lpName, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetEnvironmentVariableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue)
     * }
     */
    public static FunctionDescriptor SetEnvironmentVariableA$descriptor() {
        return SetEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue)
     * }
     */
    public static MethodHandle SetEnvironmentVariableA$handle() {
        return SetEnvironmentVariableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue)
     * }
     */
    public static MemorySegment SetEnvironmentVariableA$address() {
        return SetEnvironmentVariableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue)
     * }
     */
    public static int SetEnvironmentVariableA(MemorySegment lpName, MemorySegment lpValue) {
        var mh$ = SetEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentVariableA", lpName, lpValue);
            }
            return (int)mh$.invokeExact(lpName, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetEnvironmentVariableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
     * }
     */
    public static FunctionDescriptor SetEnvironmentVariableW$descriptor() {
        return SetEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
     * }
     */
    public static MethodHandle SetEnvironmentVariableW$handle() {
        return SetEnvironmentVariableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
     * }
     */
    public static MemorySegment SetEnvironmentVariableW$address() {
        return SetEnvironmentVariableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
     * }
     */
    public static int SetEnvironmentVariableW(MemorySegment lpName, MemorySegment lpValue) {
        var mh$ = SetEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentVariableW", lpName, lpValue);
            }
            return (int)mh$.invokeExact(lpName, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpandEnvironmentStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExpandEnvironmentStringsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
     * }
     */
    public static FunctionDescriptor ExpandEnvironmentStringsA$descriptor() {
        return ExpandEnvironmentStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
     * }
     */
    public static MethodHandle ExpandEnvironmentStringsA$handle() {
        return ExpandEnvironmentStringsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
     * }
     */
    public static MemorySegment ExpandEnvironmentStringsA$address() {
        return ExpandEnvironmentStringsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
     * }
     */
    public static int ExpandEnvironmentStringsA(MemorySegment lpSrc, MemorySegment lpDst, int nSize) {
        var mh$ = ExpandEnvironmentStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpandEnvironmentStringsA", lpSrc, lpDst, nSize);
            }
            return (int)mh$.invokeExact(lpSrc, lpDst, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpandEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExpandEnvironmentStringsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
     * }
     */
    public static FunctionDescriptor ExpandEnvironmentStringsW$descriptor() {
        return ExpandEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
     * }
     */
    public static MethodHandle ExpandEnvironmentStringsW$handle() {
        return ExpandEnvironmentStringsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
     * }
     */
    public static MemorySegment ExpandEnvironmentStringsW$address() {
        return ExpandEnvironmentStringsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
     * }
     */
    public static int ExpandEnvironmentStringsW(MemorySegment lpSrc, MemorySegment lpDst, int nSize) {
        var mh$ = ExpandEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpandEnvironmentStringsW", lpSrc, lpDst, nSize);
            }
            return (int)mh$.invokeExact(lpSrc, lpDst, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCurrentDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetCurrentDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetCurrentDirectoryA$descriptor() {
        return SetCurrentDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MethodHandle SetCurrentDirectoryA$handle() {
        return SetCurrentDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MemorySegment SetCurrentDirectoryA$address() {
        return SetCurrentDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static int SetCurrentDirectoryA(MemorySegment lpPathName) {
        var mh$ = SetCurrentDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCurrentDirectoryA", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCurrentDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetCurrentDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetCurrentDirectoryW$descriptor() {
        return SetCurrentDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle SetCurrentDirectoryW$handle() {
        return SetCurrentDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MemorySegment SetCurrentDirectoryW$address() {
        return SetCurrentDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static int SetCurrentDirectoryW(MemorySegment lpPathName) {
        var mh$ = SetCurrentDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCurrentDirectoryW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCurrentDirectoryA$descriptor() {
        return GetCurrentDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetCurrentDirectoryA$handle() {
        return GetCurrentDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MemorySegment GetCurrentDirectoryA$address() {
        return GetCurrentDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetCurrentDirectoryA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetCurrentDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentDirectoryA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCurrentDirectoryW$descriptor() {
        return GetCurrentDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetCurrentDirectoryW$handle() {
        return GetCurrentDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MemorySegment GetCurrentDirectoryW$address() {
        return GetCurrentDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetCurrentDirectoryW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetCurrentDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentDirectoryW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SearchPathW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SearchPathW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor SearchPathW$descriptor() {
        return SearchPathW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MethodHandle SearchPathW$handle() {
        return SearchPathW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MemorySegment SearchPathW$address() {
        return SearchPathW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static int SearchPathW(MemorySegment lpPath, MemorySegment lpFileName, MemorySegment lpExtension, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = SearchPathW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SearchPathW", lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SearchPathA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SearchPathA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor SearchPathA$descriptor() {
        return SearchPathA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MethodHandle SearchPathA$handle() {
        return SearchPathA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MemorySegment SearchPathA$address() {
        return SearchPathA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static int SearchPathA(MemorySegment lpPath, MemorySegment lpFileName, MemorySegment lpExtension, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = SearchPathA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SearchPathA", lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NeedCurrentDirectoryForExePathA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NeedCurrentDirectoryForExePathA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathA(LPCSTR ExeName)
     * }
     */
    public static FunctionDescriptor NeedCurrentDirectoryForExePathA$descriptor() {
        return NeedCurrentDirectoryForExePathA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathA(LPCSTR ExeName)
     * }
     */
    public static MethodHandle NeedCurrentDirectoryForExePathA$handle() {
        return NeedCurrentDirectoryForExePathA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathA(LPCSTR ExeName)
     * }
     */
    public static MemorySegment NeedCurrentDirectoryForExePathA$address() {
        return NeedCurrentDirectoryForExePathA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathA(LPCSTR ExeName)
     * }
     */
    public static int NeedCurrentDirectoryForExePathA(MemorySegment ExeName) {
        var mh$ = NeedCurrentDirectoryForExePathA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NeedCurrentDirectoryForExePathA", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NeedCurrentDirectoryForExePathW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("NeedCurrentDirectoryForExePathW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathW(LPCWSTR ExeName)
     * }
     */
    public static FunctionDescriptor NeedCurrentDirectoryForExePathW$descriptor() {
        return NeedCurrentDirectoryForExePathW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathW(LPCWSTR ExeName)
     * }
     */
    public static MethodHandle NeedCurrentDirectoryForExePathW$handle() {
        return NeedCurrentDirectoryForExePathW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathW(LPCWSTR ExeName)
     * }
     */
    public static MemorySegment NeedCurrentDirectoryForExePathW$address() {
        return NeedCurrentDirectoryForExePathW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathW(LPCWSTR ExeName)
     * }
     */
    public static int NeedCurrentDirectoryForExePathW(MemorySegment ExeName) {
        var mh$ = NeedCurrentDirectoryForExePathW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NeedCurrentDirectoryForExePathW", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CompareFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
     * }
     */
    public static FunctionDescriptor CompareFileTime$descriptor() {
        return CompareFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
     * }
     */
    public static MethodHandle CompareFileTime$handle() {
        return CompareFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
     * }
     */
    public static MemorySegment CompareFileTime$address() {
        return CompareFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
     * }
     */
    public static int CompareFileTime(MemorySegment lpFileTime1, MemorySegment lpFileTime2) {
        var mh$ = CompareFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareFileTime", lpFileTime1, lpFileTime2);
            }
            return (int)mh$.invokeExact(lpFileTime1, lpFileTime2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryA$descriptor() {
        return CreateDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryA$handle() {
        return CreateDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectoryA$address() {
        return CreateDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryA(MemorySegment lpPathName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryA", lpPathName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpPathName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryW$descriptor() {
        return CreateDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryW$handle() {
        return CreateDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectoryW$address() {
        return CreateDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryW(MemorySegment lpPathName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryW", lpPathName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpPathName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static FunctionDescriptor CreateFileA$descriptor() {
        return CreateFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MethodHandle CreateFileA$handle() {
        return CreateFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileA$address() {
        return CreateFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileA(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileA", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static FunctionDescriptor CreateFileW$descriptor() {
        return CreateFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MethodHandle CreateFileW$handle() {
        return CreateFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileW$address() {
        return CreateFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefineDosDeviceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DefineDosDeviceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
     * }
     */
    public static FunctionDescriptor DefineDosDeviceW$descriptor() {
        return DefineDosDeviceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
     * }
     */
    public static MethodHandle DefineDosDeviceW$handle() {
        return DefineDosDeviceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
     * }
     */
    public static MemorySegment DefineDosDeviceW$address() {
        return DefineDosDeviceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
     * }
     */
    public static int DefineDosDeviceW(int dwFlags, MemorySegment lpDeviceName, MemorySegment lpTargetPath) {
        var mh$ = DefineDosDeviceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefineDosDeviceW", dwFlags, lpDeviceName, lpTargetPath);
            }
            return (int)mh$.invokeExact(dwFlags, lpDeviceName, lpTargetPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor DeleteFileA$descriptor() {
        return DeleteFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle DeleteFileA$handle() {
        return DeleteFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFileA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment DeleteFileA$address() {
        return DeleteFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFileA(LPCSTR lpFileName)
     * }
     */
    public static int DeleteFileA(MemorySegment lpFileName) {
        var mh$ = DeleteFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor DeleteFileW$descriptor() {
        return DeleteFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle DeleteFileW$handle() {
        return DeleteFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFileW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment DeleteFileW$address() {
        return DeleteFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFileW(LPCWSTR lpFileName)
     * }
     */
    public static int DeleteFileW(MemorySegment lpFileName) {
        var mh$ = DeleteFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
     * }
     */
    public static FunctionDescriptor DeleteVolumeMountPointW$descriptor() {
        return DeleteVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
     * }
     */
    public static MethodHandle DeleteVolumeMountPointW$handle() {
        return DeleteVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
     * }
     */
    public static MemorySegment DeleteVolumeMountPointW$address() {
        return DeleteVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
     * }
     */
    public static int DeleteVolumeMountPointW(MemorySegment lpszVolumeMountPoint) {
        var mh$ = DeleteVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteVolumeMountPointW", lpszVolumeMountPoint);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileTimeToLocalFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FileTimeToLocalFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
     * }
     */
    public static FunctionDescriptor FileTimeToLocalFileTime$descriptor() {
        return FileTimeToLocalFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
     * }
     */
    public static MethodHandle FileTimeToLocalFileTime$handle() {
        return FileTimeToLocalFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
     * }
     */
    public static MemorySegment FileTimeToLocalFileTime$address() {
        return FileTimeToLocalFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
     * }
     */
    public static int FileTimeToLocalFileTime(MemorySegment lpFileTime, MemorySegment lpLocalFileTime) {
        var mh$ = FileTimeToLocalFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileTimeToLocalFileTime", lpFileTime, lpLocalFileTime);
            }
            return (int)mh$.invokeExact(lpFileTime, lpLocalFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindClose(HANDLE hFindFile)
     * }
     */
    public static FunctionDescriptor FindClose$descriptor() {
        return FindClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindClose(HANDLE hFindFile)
     * }
     */
    public static MethodHandle FindClose$handle() {
        return FindClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindClose(HANDLE hFindFile)
     * }
     */
    public static MemorySegment FindClose$address() {
        return FindClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindClose(HANDLE hFindFile)
     * }
     */
    public static int FindClose(MemorySegment hFindFile) {
        var mh$ = FindClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindClose", hFindFile);
            }
            return (int)mh$.invokeExact(hFindFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindCloseChangeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindCloseChangeNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindCloseChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static FunctionDescriptor FindCloseChangeNotification$descriptor() {
        return FindCloseChangeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindCloseChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static MethodHandle FindCloseChangeNotification$handle() {
        return FindCloseChangeNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindCloseChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static MemorySegment FindCloseChangeNotification$address() {
        return FindCloseChangeNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindCloseChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static int FindCloseChangeNotification(MemorySegment hChangeHandle) {
        var mh$ = FindCloseChangeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindCloseChangeNotification", hChangeHandle);
            }
            return (int)mh$.invokeExact(hChangeHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstChangeNotificationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstChangeNotificationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static FunctionDescriptor FindFirstChangeNotificationA$descriptor() {
        return FindFirstChangeNotificationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MethodHandle FindFirstChangeNotificationA$handle() {
        return FindFirstChangeNotificationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MemorySegment FindFirstChangeNotificationA$address() {
        return FindFirstChangeNotificationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MemorySegment FindFirstChangeNotificationA(MemorySegment lpPathName, int bWatchSubtree, int dwNotifyFilter) {
        var mh$ = FindFirstChangeNotificationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstChangeNotificationA", lpPathName, bWatchSubtree, dwNotifyFilter);
            }
            return (MemorySegment)mh$.invokeExact(lpPathName, bWatchSubtree, dwNotifyFilter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstChangeNotificationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstChangeNotificationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static FunctionDescriptor FindFirstChangeNotificationW$descriptor() {
        return FindFirstChangeNotificationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MethodHandle FindFirstChangeNotificationW$handle() {
        return FindFirstChangeNotificationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MemorySegment FindFirstChangeNotificationW$address() {
        return FindFirstChangeNotificationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MemorySegment FindFirstChangeNotificationW(MemorySegment lpPathName, int bWatchSubtree, int dwNotifyFilter) {
        var mh$ = FindFirstChangeNotificationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstChangeNotificationW", lpPathName, bWatchSubtree, dwNotifyFilter);
            }
            return (MemorySegment)mh$.invokeExact(lpPathName, bWatchSubtree, dwNotifyFilter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindFirstFileA$descriptor() {
        return FindFirstFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MethodHandle FindFirstFileA$handle() {
        return FindFirstFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MemorySegment FindFirstFileA$address() {
        return FindFirstFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MemorySegment FindFirstFileA(MemorySegment lpFileName, MemorySegment lpFindFileData) {
        var mh$ = FindFirstFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileA", lpFileName, lpFindFileData);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindFirstFileW$descriptor() {
        return FindFirstFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MethodHandle FindFirstFileW$handle() {
        return FindFirstFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MemorySegment FindFirstFileW$address() {
        return FindFirstFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MemorySegment FindFirstFileW(MemorySegment lpFileName, MemorySegment lpFindFileData) {
        var mh$ = FindFirstFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileW", lpFileName, lpFindFileData);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstFileExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static FunctionDescriptor FindFirstFileExA$descriptor() {
        return FindFirstFileExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MethodHandle FindFirstFileExA$handle() {
        return FindFirstFileExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExA$address() {
        return FindFirstFileExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
        var mh$ = FindFirstFileExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileExA", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstFileExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static FunctionDescriptor FindFirstFileExW$descriptor() {
        return FindFirstFileExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MethodHandle FindFirstFileExW$handle() {
        return FindFirstFileExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExW$address() {
        return FindFirstFileExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
        var mh$ = FindFirstFileExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileExW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstVolumeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeW$descriptor() {
        return FindFirstVolumeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeW$handle() {
        return FindFirstVolumeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeW$address() {
        return FindFirstVolumeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeW(MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindFirstVolumeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeW", lpszVolumeName, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextChangeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindNextChangeNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static FunctionDescriptor FindNextChangeNotification$descriptor() {
        return FindNextChangeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static MethodHandle FindNextChangeNotification$handle() {
        return FindNextChangeNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static MemorySegment FindNextChangeNotification$address() {
        return FindNextChangeNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static int FindNextChangeNotification(MemorySegment hChangeHandle) {
        var mh$ = FindNextChangeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextChangeNotification", hChangeHandle);
            }
            return (int)mh$.invokeExact(hChangeHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindNextFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindNextFileA$descriptor() {
        return FindNextFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MethodHandle FindNextFileA$handle() {
        return FindNextFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MemorySegment FindNextFileA$address() {
        return FindNextFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static int FindNextFileA(MemorySegment hFindFile, MemorySegment lpFindFileData) {
        var mh$ = FindNextFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextFileA", hFindFile, lpFindFileData);
            }
            return (int)mh$.invokeExact(hFindFile, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindNextFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindNextFileW$descriptor() {
        return FindNextFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MethodHandle FindNextFileW$handle() {
        return FindNextFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MemorySegment FindNextFileW$address() {
        return FindNextFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static int FindNextFileW(MemorySegment hFindFile, MemorySegment lpFindFileData) {
        var mh$ = FindNextFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextFileW", hFindFile, lpFindFileData);
            }
            return (int)mh$.invokeExact(hFindFile, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindNextVolumeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeW$descriptor() {
        return FindNextVolumeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeW$handle() {
        return FindNextVolumeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindNextVolumeW$address() {
        return FindNextVolumeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeW(MemorySegment hFindVolume, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindNextVolumeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeW", hFindVolume, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolume, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindVolumeClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindVolumeClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindVolumeClose(HANDLE hFindVolume)
     * }
     */
    public static FunctionDescriptor FindVolumeClose$descriptor() {
        return FindVolumeClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindVolumeClose(HANDLE hFindVolume)
     * }
     */
    public static MethodHandle FindVolumeClose$handle() {
        return FindVolumeClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindVolumeClose(HANDLE hFindVolume)
     * }
     */
    public static MemorySegment FindVolumeClose$address() {
        return FindVolumeClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindVolumeClose(HANDLE hFindVolume)
     * }
     */
    public static int FindVolumeClose(MemorySegment hFindVolume) {
        var mh$ = FindVolumeClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindVolumeClose", hFindVolume);
            }
            return (int)mh$.invokeExact(hFindVolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushFileBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FlushFileBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor FlushFileBuffers$descriptor() {
        return FlushFileBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static MethodHandle FlushFileBuffers$handle() {
        return FlushFileBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static MemorySegment FlushFileBuffers$address() {
        return FlushFileBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static int FlushFileBuffers(MemorySegment hFile) {
        var mh$ = FlushFileBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushFileBuffers", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDiskFreeSpaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceA$descriptor() {
        return GetDiskFreeSpaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceA$handle() {
        return GetDiskFreeSpaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static MemorySegment GetDiskFreeSpaceA$address() {
        return GetDiskFreeSpaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static int GetDiskFreeSpaceA(MemorySegment lpRootPathName, MemorySegment lpSectorsPerCluster, MemorySegment lpBytesPerSector, MemorySegment lpNumberOfFreeClusters, MemorySegment lpTotalNumberOfClusters) {
        var mh$ = GetDiskFreeSpaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceA", lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDiskFreeSpaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceW$descriptor() {
        return GetDiskFreeSpaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceW$handle() {
        return GetDiskFreeSpaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static MemorySegment GetDiskFreeSpaceW$address() {
        return GetDiskFreeSpaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static int GetDiskFreeSpaceW(MemorySegment lpRootPathName, MemorySegment lpSectorsPerCluster, MemorySegment lpBytesPerSector, MemorySegment lpNumberOfFreeClusters, MemorySegment lpTotalNumberOfClusters) {
        var mh$ = GetDiskFreeSpaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceW", lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDiskFreeSpaceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceExA$descriptor() {
        return GetDiskFreeSpaceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceExA$handle() {
        return GetDiskFreeSpaceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MemorySegment GetDiskFreeSpaceExA$address() {
        return GetDiskFreeSpaceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static int GetDiskFreeSpaceExA(MemorySegment lpDirectoryName, MemorySegment lpFreeBytesAvailableToCaller, MemorySegment lpTotalNumberOfBytes, MemorySegment lpTotalNumberOfFreeBytes) {
        var mh$ = GetDiskFreeSpaceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceExA", lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
            }
            return (int)mh$.invokeExact(lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDiskFreeSpaceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceExW$descriptor() {
        return GetDiskFreeSpaceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceExW$handle() {
        return GetDiskFreeSpaceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MemorySegment GetDiskFreeSpaceExW$address() {
        return GetDiskFreeSpaceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static int GetDiskFreeSpaceExW(MemorySegment lpDirectoryName, MemorySegment lpFreeBytesAvailableToCaller, MemorySegment lpTotalNumberOfBytes, MemorySegment lpTotalNumberOfFreeBytes) {
        var mh$ = GetDiskFreeSpaceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceExW", lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
            }
            return (int)mh$.invokeExact(lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskSpaceInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDiskSpaceInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static FunctionDescriptor GetDiskSpaceInformationA$descriptor() {
        return GetDiskSpaceInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MethodHandle GetDiskSpaceInformationA$handle() {
        return GetDiskSpaceInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MemorySegment GetDiskSpaceInformationA$address() {
        return GetDiskSpaceInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static int GetDiskSpaceInformationA(MemorySegment rootPath, MemorySegment diskSpaceInfo) {
        var mh$ = GetDiskSpaceInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskSpaceInformationA", rootPath, diskSpaceInfo);
            }
            return (int)mh$.invokeExact(rootPath, diskSpaceInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskSpaceInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDiskSpaceInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static FunctionDescriptor GetDiskSpaceInformationW$descriptor() {
        return GetDiskSpaceInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MethodHandle GetDiskSpaceInformationW$handle() {
        return GetDiskSpaceInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MemorySegment GetDiskSpaceInformationW$address() {
        return GetDiskSpaceInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static int GetDiskSpaceInformationW(MemorySegment rootPath, MemorySegment diskSpaceInfo) {
        var mh$ = GetDiskSpaceInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskSpaceInformationW", rootPath, diskSpaceInfo);
            }
            return (int)mh$.invokeExact(rootPath, diskSpaceInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDriveTypeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDriveTypeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static FunctionDescriptor GetDriveTypeA$descriptor() {
        return GetDriveTypeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static MethodHandle GetDriveTypeA$handle() {
        return GetDriveTypeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static MemorySegment GetDriveTypeA$address() {
        return GetDriveTypeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static int GetDriveTypeA(MemorySegment lpRootPathName) {
        var mh$ = GetDriveTypeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDriveTypeA", lpRootPathName);
            }
            return (int)mh$.invokeExact(lpRootPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDriveTypeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetDriveTypeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static FunctionDescriptor GetDriveTypeW$descriptor() {
        return GetDriveTypeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static MethodHandle GetDriveTypeW$handle() {
        return GetDriveTypeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static MemorySegment GetDriveTypeW$address() {
        return GetDriveTypeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static int GetDriveTypeW(MemorySegment lpRootPathName) {
        var mh$ = GetDriveTypeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDriveTypeW", lpRootPathName);
            }
            return (int)mh$.invokeExact(lpRootPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     * } *LPWIN32_FILE_ATTRIBUTE_DATA
     * }
     */
    public static final AddressLayout LPWIN32_FILE_ATTRIBUTE_DATA = wgl_h.C_POINTER;

    private static class GetFileAttributesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileAttributesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetFileAttributesA$descriptor() {
        return GetFileAttributesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetFileAttributesA$handle() {
        return GetFileAttributesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment GetFileAttributesA$address() {
        return GetFileAttributesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static int GetFileAttributesA(MemorySegment lpFileName) {
        var mh$ = GetFileAttributesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileAttributesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetFileAttributesW$descriptor() {
        return GetFileAttributesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetFileAttributesW$handle() {
        return GetFileAttributesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment GetFileAttributesW$address() {
        return GetFileAttributesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static int GetFileAttributesW(MemorySegment lpFileName) {
        var mh$ = GetFileAttributesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileAttributesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExA$descriptor() {
        return GetFileAttributesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExA$handle() {
        return GetFileAttributesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MemorySegment GetFileAttributesExA$address() {
        return GetFileAttributesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExA", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileAttributesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExW$descriptor() {
        return GetFileAttributesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExW$handle() {
        return GetFileAttributesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MemorySegment GetFileAttributesExW$address() {
        return GetFileAttributesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExW", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _BY_HANDLE_FILE_INFORMATION {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD dwVolumeSerialNumber;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD nNumberOfLinks;
     *     DWORD nFileIndexHigh;
     *     DWORD nFileIndexLow;
     * } *PBY_HANDLE_FILE_INFORMATION
     * }
     */
    public static final AddressLayout PBY_HANDLE_FILE_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BY_HANDLE_FILE_INFORMATION {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD dwVolumeSerialNumber;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD nNumberOfLinks;
     *     DWORD nFileIndexHigh;
     *     DWORD nFileIndexLow;
     * } *LPBY_HANDLE_FILE_INFORMATION
     * }
     */
    public static final AddressLayout LPBY_HANDLE_FILE_INFORMATION = wgl_h.C_POINTER;

    private static class GetFileInformationByHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileInformationByHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileInformationByHandle$descriptor() {
        return GetFileInformationByHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static MethodHandle GetFileInformationByHandle$handle() {
        return GetFileInformationByHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static MemorySegment GetFileInformationByHandle$address() {
        return GetFileInformationByHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static int GetFileInformationByHandle(MemorySegment hFile, MemorySegment lpFileInformation) {
        var mh$ = GetFileInformationByHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileInformationByHandle", hFile, lpFileInformation);
            }
            return (int)mh$.invokeExact(hFile, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetFileSize$descriptor() {
        return GetFileSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetFileSize$handle() {
        return GetFileSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MemorySegment GetFileSize$address() {
        return GetFileSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetFileSize(MemorySegment hFile, MemorySegment lpFileSizeHigh) {
        var mh$ = GetFileSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSize", hFile, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(hFile, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileSizeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static FunctionDescriptor GetFileSizeEx$descriptor() {
        return GetFileSizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static MethodHandle GetFileSizeEx$handle() {
        return GetFileSizeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static MemorySegment GetFileSizeEx$address() {
        return GetFileSizeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static int GetFileSizeEx(MemorySegment hFile, MemorySegment lpFileSize) {
        var mh$ = GetFileSizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSizeEx", hFile, lpFileSize);
            }
            return (int)mh$.invokeExact(hFile, lpFileSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor GetFileType$descriptor() {
        return GetFileType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static MethodHandle GetFileType$handle() {
        return GetFileType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static MemorySegment GetFileType$address() {
        return GetFileType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static int GetFileType(MemorySegment hFile) {
        var mh$ = GetFileType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileType", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFinalPathNameByHandleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFinalPathNameByHandleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetFinalPathNameByHandleA$descriptor() {
        return GetFinalPathNameByHandleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetFinalPathNameByHandleA$handle() {
        return GetFinalPathNameByHandleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetFinalPathNameByHandleA$address() {
        return GetFinalPathNameByHandleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static int GetFinalPathNameByHandleA(MemorySegment hFile, MemorySegment lpszFilePath, int cchFilePath, int dwFlags) {
        var mh$ = GetFinalPathNameByHandleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFinalPathNameByHandleA", hFile, lpszFilePath, cchFilePath, dwFlags);
            }
            return (int)mh$.invokeExact(hFile, lpszFilePath, cchFilePath, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFinalPathNameByHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFinalPathNameByHandleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetFinalPathNameByHandleW$descriptor() {
        return GetFinalPathNameByHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetFinalPathNameByHandleW$handle() {
        return GetFinalPathNameByHandleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetFinalPathNameByHandleW$address() {
        return GetFinalPathNameByHandleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static int GetFinalPathNameByHandleW(MemorySegment hFile, MemorySegment lpszFilePath, int cchFilePath, int dwFlags) {
        var mh$ = GetFinalPathNameByHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFinalPathNameByHandleW", hFile, lpszFilePath, cchFilePath, dwFlags);
            }
            return (int)mh$.invokeExact(hFile, lpszFilePath, cchFilePath, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static FunctionDescriptor GetFileTime$descriptor() {
        return GetFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static MethodHandle GetFileTime$handle() {
        return GetFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static MemorySegment GetFileTime$address() {
        return GetFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static int GetFileTime(MemorySegment hFile, MemorySegment lpCreationTime, MemorySegment lpLastAccessTime, MemorySegment lpLastWriteTime) {
        var mh$ = GetFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileTime", hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
            }
            return (int)mh$.invokeExact(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFullPathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor GetFullPathNameW$descriptor() {
        return GetFullPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MethodHandle GetFullPathNameW$handle() {
        return GetFullPathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MemorySegment GetFullPathNameW$address() {
        return GetFullPathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static int GetFullPathNameW(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = GetFullPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameW", lpFileName, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFullPathNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor GetFullPathNameA$descriptor() {
        return GetFullPathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MethodHandle GetFullPathNameA$handle() {
        return GetFullPathNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MemorySegment GetFullPathNameA$address() {
        return GetFullPathNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static int GetFullPathNameA(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = GetFullPathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameA", lpFileName, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalDrives {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLogicalDrives");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static FunctionDescriptor GetLogicalDrives$descriptor() {
        return GetLogicalDrives.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static MethodHandle GetLogicalDrives$handle() {
        return GetLogicalDrives.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static MemorySegment GetLogicalDrives$address() {
        return GetLogicalDrives.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static int GetLogicalDrives() {
        var mh$ = GetLogicalDrives.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalDrives");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalDriveStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLogicalDriveStringsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetLogicalDriveStringsW$descriptor() {
        return GetLogicalDriveStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetLogicalDriveStringsW$handle() {
        return GetLogicalDriveStringsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MemorySegment GetLogicalDriveStringsW$address() {
        return GetLogicalDriveStringsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetLogicalDriveStringsW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetLogicalDriveStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalDriveStringsW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLongPathNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetLongPathNameA$descriptor() {
        return GetLongPathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetLongPathNameA$handle() {
        return GetLongPathNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MemorySegment GetLongPathNameA$address() {
        return GetLongPathNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static int GetLongPathNameA(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer) {
        var mh$ = GetLongPathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameA", lpszShortPath, lpszLongPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLongPathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetLongPathNameW$descriptor() {
        return GetLongPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetLongPathNameW$handle() {
        return GetLongPathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MemorySegment GetLongPathNameW$address() {
        return GetLongPathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static int GetLongPathNameW(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer) {
        var mh$ = GetLongPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameW", lpszShortPath, lpszLongPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShortPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetShortPathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetShortPathNameW$descriptor() {
        return GetShortPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetShortPathNameW$handle() {
        return GetShortPathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MemorySegment GetShortPathNameW$address() {
        return GetShortPathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static int GetShortPathNameW(MemorySegment lpszLongPath, MemorySegment lpszShortPath, int cchBuffer) {
        var mh$ = GetShortPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShortPathNameW", lpszLongPath, lpszShortPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszLongPath, lpszShortPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTempFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static FunctionDescriptor GetTempFileNameW$descriptor() {
        return GetTempFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static MethodHandle GetTempFileNameW$handle() {
        return GetTempFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static MemorySegment GetTempFileNameW$address() {
        return GetTempFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static int GetTempFileNameW(MemorySegment lpPathName, MemorySegment lpPrefixString, int uUnique, MemorySegment lpTempFileName) {
        var mh$ = GetTempFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempFileNameW", lpPathName, lpPrefixString, uUnique, lpTempFileName);
            }
            return (int)mh$.invokeExact(lpPathName, lpPrefixString, uUnique, lpTempFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationByHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVolumeInformationByHandleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationByHandleW$descriptor() {
        return GetVolumeInformationByHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationByHandleW$handle() {
        return GetVolumeInformationByHandleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MemorySegment GetVolumeInformationByHandleW$address() {
        return GetVolumeInformationByHandleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationByHandleW(MemorySegment hFile, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationByHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationByHandleW", hFile, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(hFile, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVolumeInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationW$descriptor() {
        return GetVolumeInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationW$handle() {
        return GetVolumeInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MemorySegment GetVolumeInformationW$address() {
        return GetVolumeInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationW(MemorySegment lpRootPathName, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationW", lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVolumePathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNameW$descriptor() {
        return GetVolumePathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumePathNameW$handle() {
        return GetVolumePathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumePathNameW$address() {
        return GetVolumePathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumePathNameW(MemorySegment lpszFileName, MemorySegment lpszVolumePathName, int cchBufferLength) {
        var mh$ = GetVolumePathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNameW", lpszFileName, lpszVolumePathName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszFileName, lpszVolumePathName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFileTimeToFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LocalFileTimeToFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static FunctionDescriptor LocalFileTimeToFileTime$descriptor() {
        return LocalFileTimeToFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static MethodHandle LocalFileTimeToFileTime$handle() {
        return LocalFileTimeToFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static MemorySegment LocalFileTimeToFileTime$address() {
        return LocalFileTimeToFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static int LocalFileTimeToFileTime(MemorySegment lpLocalFileTime, MemorySegment lpFileTime) {
        var mh$ = LocalFileTimeToFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFileTimeToFileTime", lpLocalFileTime, lpFileTime);
            }
            return (int)mh$.invokeExact(lpLocalFileTime, lpFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LockFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static FunctionDescriptor LockFile$descriptor() {
        return LockFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static MethodHandle LockFile$handle() {
        return LockFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static MemorySegment LockFile$address() {
        return LockFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static int LockFile(MemorySegment hFile, int dwFileOffsetLow, int dwFileOffsetHigh, int nNumberOfBytesToLockLow, int nNumberOfBytesToLockHigh) {
        var mh$ = LockFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockFile", hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh);
            }
            return (int)mh$.invokeExact(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LockFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor LockFileEx$descriptor() {
        return LockFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle LockFileEx$handle() {
        return LockFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment LockFileEx$address() {
        return LockFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int LockFileEx(MemorySegment hFile, int dwFlags, int dwReserved, int nNumberOfBytesToLockLow, int nNumberOfBytesToLockHigh, MemorySegment lpOverlapped) {
        var mh$ = LockFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockFileEx", hFile, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDosDeviceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryDosDeviceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static FunctionDescriptor QueryDosDeviceW$descriptor() {
        return QueryDosDeviceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MethodHandle QueryDosDeviceW$handle() {
        return QueryDosDeviceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MemorySegment QueryDosDeviceW$address() {
        return QueryDosDeviceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static int QueryDosDeviceW(MemorySegment lpDeviceName, MemorySegment lpTargetPath, int ucchMax) {
        var mh$ = QueryDosDeviceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDosDeviceW", lpDeviceName, lpTargetPath, ucchMax);
            }
            return (int)mh$.invokeExact(lpDeviceName, lpTargetPath, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReadFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ReadFile$descriptor() {
        return ReadFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ReadFile$handle() {
        return ReadFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment ReadFile$address() {
        return ReadFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ReadFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpNumberOfBytesRead, MemorySegment lpOverlapped) {
        var mh$ = ReadFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFile", hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReadFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor ReadFileEx$descriptor() {
        return ReadFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle ReadFileEx$handle() {
        return ReadFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MemorySegment ReadFileEx$address() {
        return ReadFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int ReadFileEx(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = ReadFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFileEx", hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFileScatter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReadFileScatter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ReadFileScatter$descriptor() {
        return ReadFileScatter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ReadFileScatter$handle() {
        return ReadFileScatter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment ReadFileScatter$address() {
        return ReadFileScatter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ReadFileScatter(MemorySegment hFile, MemorySegment aSegmentArray, int nNumberOfBytesToRead, MemorySegment lpReserved, MemorySegment lpOverlapped) {
        var mh$ = ReadFileScatter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFileScatter", hFile, aSegmentArray, nNumberOfBytesToRead, lpReserved, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, aSegmentArray, nNumberOfBytesToRead, lpReserved, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryA$descriptor() {
        return RemoveDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryA$handle() {
        return RemoveDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MemorySegment RemoveDirectoryA$address() {
        return RemoveDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryA(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryA", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryW$descriptor() {
        return RemoveDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryW$handle() {
        return RemoveDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MemorySegment RemoveDirectoryW$address() {
        return RemoveDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryW(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEndOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetEndOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor SetEndOfFile$descriptor() {
        return SetEndOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static MethodHandle SetEndOfFile$handle() {
        return SetEndOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static MemorySegment SetEndOfFile$address() {
        return SetEndOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static int SetEndOfFile(MemorySegment hFile) {
        var mh$ = SetEndOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEndOfFile", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileAttributesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesA$descriptor() {
        return SetFileAttributesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesA$handle() {
        return SetFileAttributesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MemorySegment SetFileAttributesA$address() {
        return SetFileAttributesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesA(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesA", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileAttributesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesW$descriptor() {
        return SetFileAttributesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesW$handle() {
        return SetFileAttributesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MemorySegment SetFileAttributesW$address() {
        return SetFileAttributesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesW(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesW", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileInformationByHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileInformationByHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static FunctionDescriptor SetFileInformationByHandle$descriptor() {
        return SetFileInformationByHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MethodHandle SetFileInformationByHandle$handle() {
        return SetFileInformationByHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MemorySegment SetFileInformationByHandle$address() {
        return SetFileInformationByHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static int SetFileInformationByHandle(MemorySegment hFile, int FileInformationClass, MemorySegment lpFileInformation, int dwBufferSize) {
        var mh$ = SetFileInformationByHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileInformationByHandle", hFile, FileInformationClass, lpFileInformation, dwBufferSize);
            }
            return (int)mh$.invokeExact(hFile, FileInformationClass, lpFileInformation, dwBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFilePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFilePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static FunctionDescriptor SetFilePointer$descriptor() {
        return SetFilePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static MethodHandle SetFilePointer$handle() {
        return SetFilePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static MemorySegment SetFilePointer$address() {
        return SetFilePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static int SetFilePointer(MemorySegment hFile, int lDistanceToMove, MemorySegment lpDistanceToMoveHigh, int dwMoveMethod) {
        var mh$ = SetFilePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFilePointer", hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
            }
            return (int)mh$.invokeExact(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFilePointerEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            _LARGE_INTEGER.layout(),
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFilePointerEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static FunctionDescriptor SetFilePointerEx$descriptor() {
        return SetFilePointerEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static MethodHandle SetFilePointerEx$handle() {
        return SetFilePointerEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static MemorySegment SetFilePointerEx$address() {
        return SetFilePointerEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static int SetFilePointerEx(MemorySegment hFile, MemorySegment liDistanceToMove, MemorySegment lpNewFilePointer, int dwMoveMethod) {
        var mh$ = SetFilePointerEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFilePointerEx", hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
            }
            return (int)mh$.invokeExact(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static FunctionDescriptor SetFileTime$descriptor() {
        return SetFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static MethodHandle SetFileTime$handle() {
        return SetFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static MemorySegment SetFileTime$address() {
        return SetFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static int SetFileTime(MemorySegment hFile, MemorySegment lpCreationTime, MemorySegment lpLastAccessTime, MemorySegment lpLastWriteTime) {
        var mh$ = SetFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileTime", hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
            }
            return (int)mh$.invokeExact(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileValidData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileValidData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static FunctionDescriptor SetFileValidData$descriptor() {
        return SetFileValidData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static MethodHandle SetFileValidData$handle() {
        return SetFileValidData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static MemorySegment SetFileValidData$address() {
        return SetFileValidData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static int SetFileValidData(MemorySegment hFile, long ValidDataLength) {
        var mh$ = SetFileValidData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileValidData", hFile, ValidDataLength);
            }
            return (int)mh$.invokeExact(hFile, ValidDataLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnlockFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnlockFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static FunctionDescriptor UnlockFile$descriptor() {
        return UnlockFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static MethodHandle UnlockFile$handle() {
        return UnlockFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static MemorySegment UnlockFile$address() {
        return UnlockFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static int UnlockFile(MemorySegment hFile, int dwFileOffsetLow, int dwFileOffsetHigh, int nNumberOfBytesToUnlockLow, int nNumberOfBytesToUnlockHigh) {
        var mh$ = UnlockFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnlockFile", hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh);
            }
            return (int)mh$.invokeExact(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnlockFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnlockFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor UnlockFileEx$descriptor() {
        return UnlockFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle UnlockFileEx$handle() {
        return UnlockFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment UnlockFileEx$address() {
        return UnlockFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int UnlockFileEx(MemorySegment hFile, int dwReserved, int nNumberOfBytesToUnlockLow, int nNumberOfBytesToUnlockHigh, MemorySegment lpOverlapped) {
        var mh$ = UnlockFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnlockFileEx", hFile, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WriteFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WriteFile$descriptor() {
        return WriteFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WriteFile$handle() {
        return WriteFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment WriteFile$address() {
        return WriteFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WriteFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpNumberOfBytesWritten, MemorySegment lpOverlapped) {
        var mh$ = WriteFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFile", hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WriteFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor WriteFileEx$descriptor() {
        return WriteFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle WriteFileEx$handle() {
        return WriteFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MemorySegment WriteFileEx$address() {
        return WriteFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int WriteFileEx(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = WriteFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFileEx", hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFileGather {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WriteFileGather");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WriteFileGather$descriptor() {
        return WriteFileGather.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WriteFileGather$handle() {
        return WriteFileGather.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment WriteFileGather$address() {
        return WriteFileGather.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WriteFileGather(MemorySegment hFile, MemorySegment aSegmentArray, int nNumberOfBytesToWrite, MemorySegment lpReserved, MemorySegment lpOverlapped) {
        var mh$ = WriteFileGather.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFileGather", hFile, aSegmentArray, nNumberOfBytesToWrite, lpReserved, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, aSegmentArray, nNumberOfBytesToWrite, lpReserved, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPathW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTempPathW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetTempPathW$descriptor() {
        return GetTempPathW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetTempPathW$handle() {
        return GetTempPathW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MemorySegment GetTempPathW$address() {
        return GetTempPathW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetTempPathW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetTempPathW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPathW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeNameForVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVolumeNameForVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumeNameForVolumeMountPointW$descriptor() {
        return GetVolumeNameForVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumeNameForVolumeMountPointW$handle() {
        return GetVolumeNameForVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumeNameForVolumeMountPointW$address() {
        return GetVolumeNameForVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumeNameForVolumeMountPointW(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = GetVolumeNameForVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeNameForVolumeMountPointW", lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNamesForVolumeNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVolumePathNamesForVolumeNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNamesForVolumeNameW$descriptor() {
        return GetVolumePathNamesForVolumeNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MethodHandle GetVolumePathNamesForVolumeNameW$handle() {
        return GetVolumePathNamesForVolumeNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MemorySegment GetVolumePathNamesForVolumeNameW$address() {
        return GetVolumePathNamesForVolumeNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static int GetVolumePathNamesForVolumeNameW(MemorySegment lpszVolumeName, MemorySegment lpszVolumePathNames, int cchBufferLength, MemorySegment lpcchReturnLength) {
        var mh$ = GetVolumePathNamesForVolumeNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNamesForVolumeNameW", lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
            }
            return (int)mh$.invokeExact(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
     *     DWORD dwSize;
     *     DWORD dwFileAttributes;
     *     DWORD dwFileFlags;
     *     DWORD dwSecurityQosFlags;
     *     LPSECURITY_ATTRIBUTES lpSecurityAttributes;
     *     HANDLE hTemplateFile;
     * } *PCREATEFILE2_EXTENDED_PARAMETERS
     * }
     */
    public static final AddressLayout PCREATEFILE2_EXTENDED_PARAMETERS = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
     *     DWORD dwSize;
     *     DWORD dwFileAttributes;
     *     DWORD dwFileFlags;
     *     DWORD dwSecurityQosFlags;
     *     LPSECURITY_ATTRIBUTES lpSecurityAttributes;
     *     HANDLE hTemplateFile;
     * } *LPCREATEFILE2_EXTENDED_PARAMETERS
     * }
     */
    public static final AddressLayout LPCREATEFILE2_EXTENDED_PARAMETERS = wgl_h.C_POINTER;

    private static class CreateFile2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFile2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static FunctionDescriptor CreateFile2$descriptor() {
        return CreateFile2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MethodHandle CreateFile2$handle() {
        return CreateFile2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2$address() {
        return CreateFile2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, int dwCreationDisposition, MemorySegment pCreateExParams) {
        var mh$ = CreateFile2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFile2", lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileIoOverlappedRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileIoOverlappedRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static FunctionDescriptor SetFileIoOverlappedRange$descriptor() {
        return SetFileIoOverlappedRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static MethodHandle SetFileIoOverlappedRange$handle() {
        return SetFileIoOverlappedRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static MemorySegment SetFileIoOverlappedRange$address() {
        return SetFileIoOverlappedRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static int SetFileIoOverlappedRange(MemorySegment FileHandle, MemorySegment OverlappedRangeStart, int Length) {
        var mh$ = SetFileIoOverlappedRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileIoOverlappedRange", FileHandle, OverlappedRangeStart, Length);
            }
            return (int)mh$.invokeExact(FileHandle, OverlappedRangeStart, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCompressedFileSizeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeA$descriptor() {
        return GetCompressedFileSizeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetCompressedFileSizeA$handle() {
        return GetCompressedFileSizeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MemorySegment GetCompressedFileSizeA$address() {
        return GetCompressedFileSizeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetCompressedFileSizeA(MemorySegment lpFileName, MemorySegment lpFileSizeHigh) {
        var mh$ = GetCompressedFileSizeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeA", lpFileName, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCompressedFileSizeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeW$descriptor() {
        return GetCompressedFileSizeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetCompressedFileSizeW$handle() {
        return GetCompressedFileSizeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MemorySegment GetCompressedFileSizeW$address() {
        return GetCompressedFileSizeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetCompressedFileSizeW(MemorySegment lpFileName, MemorySegment lpFileSizeHigh) {
        var mh$ = GetCompressedFileSizeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeW", lpFileName, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FindStreamInfoStandard = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _STREAM_INFO_LEVELS.FindStreamInfoStandard = 0
     * }
     */
    public static int FindStreamInfoStandard() {
        return FindStreamInfoStandard;
    }
    private static final int FindStreamInfoMaxInfoLevel = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _STREAM_INFO_LEVELS.FindStreamInfoMaxInfoLevel = 1
     * }
     */
    public static int FindStreamInfoMaxInfoLevel() {
        return FindStreamInfoMaxInfoLevel;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_STREAM_DATA {
     *     LARGE_INTEGER StreamSize;
     *     WCHAR cStreamName[296];
     * } *PWIN32_FIND_STREAM_DATA
     * }
     */
    public static final AddressLayout PWIN32_FIND_STREAM_DATA = wgl_h.C_POINTER;

    private static class FindFirstStreamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstStreamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor FindFirstStreamW$descriptor() {
        return FindFirstStreamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static MethodHandle FindFirstStreamW$handle() {
        return FindFirstStreamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static MemorySegment FindFirstStreamW$address() {
        return FindFirstStreamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static MemorySegment FindFirstStreamW(MemorySegment lpFileName, int InfoLevel, MemorySegment lpFindStreamData, int dwFlags) {
        var mh$ = FindFirstStreamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstStreamW", lpFileName, InfoLevel, lpFindStreamData, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, InfoLevel, lpFindStreamData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextStreamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindNextStreamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static FunctionDescriptor FindNextStreamW$descriptor() {
        return FindNextStreamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static MethodHandle FindNextStreamW$handle() {
        return FindNextStreamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static MemorySegment FindNextStreamW$address() {
        return FindNextStreamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static int FindNextStreamW(MemorySegment hFindStream, MemorySegment lpFindStreamData) {
        var mh$ = FindNextStreamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextStreamW", hFindStream, lpFindStreamData);
            }
            return (int)mh$.invokeExact(hFindStream, lpFindStreamData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreFileApisANSI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AreFileApisANSI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static FunctionDescriptor AreFileApisANSI$descriptor() {
        return AreFileApisANSI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static MethodHandle AreFileApisANSI$handle() {
        return AreFileApisANSI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static MemorySegment AreFileApisANSI$address() {
        return AreFileApisANSI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static int AreFileApisANSI() {
        var mh$ = AreFileApisANSI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreFileApisANSI");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPathA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTempPathA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetTempPathA$descriptor() {
        return GetTempPathA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetTempPathA$handle() {
        return GetTempPathA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MemorySegment GetTempPathA$address() {
        return GetTempPathA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetTempPathA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetTempPathA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPathA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static FunctionDescriptor FindFirstFileNameW$descriptor() {
        return FindFirstFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MethodHandle FindFirstFileNameW$handle() {
        return FindFirstFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MemorySegment FindFirstFileNameW$address() {
        return FindFirstFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MemorySegment FindFirstFileNameW(MemorySegment lpFileName, int dwFlags, MemorySegment StringLength, MemorySegment LinkName) {
        var mh$ = FindFirstFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileNameW", lpFileName, dwFlags, StringLength, LinkName);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwFlags, StringLength, LinkName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindNextFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static FunctionDescriptor FindNextFileNameW$descriptor() {
        return FindNextFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MethodHandle FindNextFileNameW$handle() {
        return FindNextFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MemorySegment FindNextFileNameW$address() {
        return FindNextFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static int FindNextFileNameW(MemorySegment hFindStream, MemorySegment StringLength, MemorySegment LinkName) {
        var mh$ = FindNextFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextFileNameW", hFindStream, StringLength, LinkName);
            }
            return (int)mh$.invokeExact(hFindStream, StringLength, LinkName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVolumeInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationA$descriptor() {
        return GetVolumeInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationA$handle() {
        return GetVolumeInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MemorySegment GetVolumeInformationA$address() {
        return GetVolumeInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationA(MemorySegment lpRootPathName, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationA", lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTempFileNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static FunctionDescriptor GetTempFileNameA$descriptor() {
        return GetTempFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static MethodHandle GetTempFileNameA$handle() {
        return GetTempFileNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static MemorySegment GetTempFileNameA$address() {
        return GetTempFileNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static int GetTempFileNameA(MemorySegment lpPathName, MemorySegment lpPrefixString, int uUnique, MemorySegment lpTempFileName) {
        var mh$ = GetTempFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempFileNameA", lpPathName, lpPrefixString, uUnique, lpTempFileName);
            }
            return (int)mh$.invokeExact(lpPathName, lpPrefixString, uUnique, lpTempFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileApisToOEM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileApisToOEM");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static FunctionDescriptor SetFileApisToOEM$descriptor() {
        return SetFileApisToOEM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static MethodHandle SetFileApisToOEM$handle() {
        return SetFileApisToOEM.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static MemorySegment SetFileApisToOEM$address() {
        return SetFileApisToOEM.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static void SetFileApisToOEM() {
        var mh$ = SetFileApisToOEM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileApisToOEM");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileApisToANSI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileApisToANSI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static FunctionDescriptor SetFileApisToANSI$descriptor() {
        return SetFileApisToANSI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static MethodHandle SetFileApisToANSI$handle() {
        return SetFileApisToANSI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static MemorySegment SetFileApisToANSI$address() {
        return SetFileApisToANSI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static void SetFileApisToANSI() {
        var mh$ = SetFileApisToANSI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileApisToANSI");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopyFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static FunctionDescriptor CopyFileFromAppW$descriptor() {
        return CopyFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MethodHandle CopyFileFromAppW$handle() {
        return CopyFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MemorySegment CopyFileFromAppW$address() {
        return CopyFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static int CopyFileFromAppW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int bFailIfExists) {
        var mh$ = CopyFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileFromAppW", lpExistingFileName, lpNewFileName, bFailIfExists);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, bFailIfExists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateDirectoryFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryFromAppW$descriptor() {
        return CreateDirectoryFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryFromAppW$handle() {
        return CreateDirectoryFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectoryFromAppW$address() {
        return CreateDirectoryFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryFromAppW(MemorySegment lpPathName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryFromAppW", lpPathName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpPathName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static FunctionDescriptor CreateFileFromAppW$descriptor() {
        return CreateFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MethodHandle CreateFileFromAppW$handle() {
        return CreateFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileFromAppW$address() {
        return CreateFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileFromAppW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileFromAppW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFile2FromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFile2FromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static FunctionDescriptor CreateFile2FromAppW$descriptor() {
        return CreateFile2FromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MethodHandle CreateFile2FromAppW$handle() {
        return CreateFile2FromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2FromAppW$address() {
        return CreateFile2FromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2FromAppW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, int dwCreationDisposition, MemorySegment pCreateExParams) {
        var mh$ = CreateFile2FromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFile2FromAppW", lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor DeleteFileFromAppW$descriptor() {
        return DeleteFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle DeleteFileFromAppW$handle() {
        return DeleteFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment DeleteFileFromAppW$address() {
        return DeleteFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static int DeleteFileFromAppW(MemorySegment lpFileName) {
        var mh$ = DeleteFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileFromAppW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileExFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstFileExFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static FunctionDescriptor FindFirstFileExFromAppW$descriptor() {
        return FindFirstFileExFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MethodHandle FindFirstFileExFromAppW$handle() {
        return FindFirstFileExFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExFromAppW$address() {
        return FindFirstFileExFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExFromAppW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
        var mh$ = FindFirstFileExFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileExFromAppW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileAttributesExFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExFromAppW$descriptor() {
        return GetFileAttributesExFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExFromAppW$handle() {
        return GetFileAttributesExFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MemorySegment GetFileAttributesExFromAppW$address() {
        return GetFileAttributesExFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExFromAppW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExFromAppW", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MoveFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static FunctionDescriptor MoveFileFromAppW$descriptor() {
        return MoveFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MethodHandle MoveFileFromAppW$handle() {
        return MoveFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MemorySegment MoveFileFromAppW$address() {
        return MoveFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static int MoveFileFromAppW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName) {
        var mh$ = MoveFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileFromAppW", lpExistingFileName, lpNewFileName);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveDirectoryFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryFromAppW$descriptor() {
        return RemoveDirectoryFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryFromAppW$handle() {
        return RemoveDirectoryFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static MemorySegment RemoveDirectoryFromAppW$address() {
        return RemoveDirectoryFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryFromAppW(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryFromAppW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReplaceFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor ReplaceFileFromAppW$descriptor() {
        return ReplaceFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MethodHandle ReplaceFileFromAppW$handle() {
        return ReplaceFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MemorySegment ReplaceFileFromAppW$address() {
        return ReplaceFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static int ReplaceFileFromAppW(MemorySegment lpReplacedFileName, MemorySegment lpReplacementFileName, MemorySegment lpBackupFileName, int dwReplaceFlags, MemorySegment lpExclude, MemorySegment lpReserved) {
        var mh$ = ReplaceFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceFileFromAppW", lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
            }
            return (int)mh$.invokeExact(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileAttributesFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesFromAppW$descriptor() {
        return SetFileAttributesFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesFromAppW$handle() {
        return SetFileAttributesFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MemorySegment SetFileAttributesFromAppW$address() {
        return SetFileAttributesFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesFromAppW(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesFromAppW", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDebuggerPresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsDebuggerPresent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static FunctionDescriptor IsDebuggerPresent$descriptor() {
        return IsDebuggerPresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static MethodHandle IsDebuggerPresent$handle() {
        return IsDebuggerPresent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static MemorySegment IsDebuggerPresent$address() {
        return IsDebuggerPresent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static int IsDebuggerPresent() {
        var mh$ = IsDebuggerPresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDebuggerPresent");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugBreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DebugBreak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static FunctionDescriptor DebugBreak$descriptor() {
        return DebugBreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static MethodHandle DebugBreak$handle() {
        return DebugBreak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static MemorySegment DebugBreak$address() {
        return DebugBreak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static void DebugBreak() {
        var mh$ = DebugBreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugBreak");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OutputDebugStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OutputDebugStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static FunctionDescriptor OutputDebugStringA$descriptor() {
        return OutputDebugStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static MethodHandle OutputDebugStringA$handle() {
        return OutputDebugStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static MemorySegment OutputDebugStringA$address() {
        return OutputDebugStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static void OutputDebugStringA(MemorySegment lpOutputString) {
        var mh$ = OutputDebugStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OutputDebugStringA", lpOutputString);
            }
            mh$.invokeExact(lpOutputString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OutputDebugStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OutputDebugStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static FunctionDescriptor OutputDebugStringW$descriptor() {
        return OutputDebugStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static MethodHandle OutputDebugStringW$handle() {
        return OutputDebugStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static MemorySegment OutputDebugStringW$address() {
        return OutputDebugStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static void OutputDebugStringW(MemorySegment lpOutputString) {
        var mh$ = OutputDebugStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OutputDebugStringW", lpOutputString);
            }
            mh$.invokeExact(lpOutputString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ContinueDebugEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ContinueDebugEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static FunctionDescriptor ContinueDebugEvent$descriptor() {
        return ContinueDebugEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static MethodHandle ContinueDebugEvent$handle() {
        return ContinueDebugEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static MemorySegment ContinueDebugEvent$address() {
        return ContinueDebugEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static int ContinueDebugEvent(int dwProcessId, int dwThreadId, int dwContinueStatus) {
        var mh$ = ContinueDebugEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ContinueDebugEvent", dwProcessId, dwThreadId, dwContinueStatus);
            }
            return (int)mh$.invokeExact(dwProcessId, dwThreadId, dwContinueStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForDebugEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitForDebugEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForDebugEvent$descriptor() {
        return WaitForDebugEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForDebugEvent$handle() {
        return WaitForDebugEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForDebugEvent$address() {
        return WaitForDebugEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForDebugEvent(MemorySegment lpDebugEvent, int dwMilliseconds) {
        var mh$ = WaitForDebugEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForDebugEvent", lpDebugEvent, dwMilliseconds);
            }
            return (int)mh$.invokeExact(lpDebugEvent, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugActiveProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DebugActiveProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor DebugActiveProcess$descriptor() {
        return DebugActiveProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static MethodHandle DebugActiveProcess$handle() {
        return DebugActiveProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static MemorySegment DebugActiveProcess$address() {
        return DebugActiveProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static int DebugActiveProcess(int dwProcessId) {
        var mh$ = DebugActiveProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugActiveProcess", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugActiveProcessStop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DebugActiveProcessStop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor DebugActiveProcessStop$descriptor() {
        return DebugActiveProcessStop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static MethodHandle DebugActiveProcessStop$handle() {
        return DebugActiveProcessStop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static MemorySegment DebugActiveProcessStop$address() {
        return DebugActiveProcessStop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static int DebugActiveProcessStop(int dwProcessId) {
        var mh$ = DebugActiveProcessStop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugActiveProcessStop", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckRemoteDebuggerPresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CheckRemoteDebuggerPresent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static FunctionDescriptor CheckRemoteDebuggerPresent$descriptor() {
        return CheckRemoteDebuggerPresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static MethodHandle CheckRemoteDebuggerPresent$handle() {
        return CheckRemoteDebuggerPresent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static MemorySegment CheckRemoteDebuggerPresent$address() {
        return CheckRemoteDebuggerPresent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static int CheckRemoteDebuggerPresent(MemorySegment hProcess, MemorySegment pbDebuggerPresent) {
        var mh$ = CheckRemoteDebuggerPresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckRemoteDebuggerPresent", hProcess, pbDebuggerPresent);
            }
            return (int)mh$.invokeExact(hProcess, pbDebuggerPresent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForDebugEventEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitForDebugEventEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForDebugEventEx$descriptor() {
        return WaitForDebugEventEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForDebugEventEx$handle() {
        return WaitForDebugEventEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForDebugEventEx$address() {
        return WaitForDebugEventEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForDebugEventEx(MemorySegment lpDebugEvent, int dwMilliseconds) {
        var mh$ = WaitForDebugEventEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForDebugEventEx", lpDebugEvent, dwMilliseconds);
            }
            return (int)mh$.invokeExact(lpDebugEvent, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EncodePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor EncodePointer$descriptor() {
        return EncodePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static MethodHandle EncodePointer$handle() {
        return EncodePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodePointer$address() {
        return EncodePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodePointer(MemorySegment Ptr) {
        var mh$ = EncodePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodePointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DecodePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor DecodePointer$descriptor() {
        return DecodePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static MethodHandle DecodePointer$handle() {
        return DecodePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodePointer$address() {
        return DecodePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodePointer(MemorySegment Ptr) {
        var mh$ = DecodePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodePointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodeSystemPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EncodeSystemPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor EncodeSystemPointer$descriptor() {
        return EncodeSystemPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MethodHandle EncodeSystemPointer$handle() {
        return EncodeSystemPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodeSystemPointer$address() {
        return EncodeSystemPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodeSystemPointer(MemorySegment Ptr) {
        var mh$ = EncodeSystemPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodeSystemPointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodeSystemPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DecodeSystemPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor DecodeSystemPointer$descriptor() {
        return DecodeSystemPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MethodHandle DecodeSystemPointer$handle() {
        return DecodeSystemPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodeSystemPointer$address() {
        return DecodeSystemPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodeSystemPointer(MemorySegment Ptr) {
        var mh$ = DecodeSystemPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodeSystemPointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodeRemotePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EncodeRemotePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static FunctionDescriptor EncodeRemotePointer$descriptor() {
        return EncodeRemotePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static MethodHandle EncodeRemotePointer$handle() {
        return EncodeRemotePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static MemorySegment EncodeRemotePointer$address() {
        return EncodeRemotePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static int EncodeRemotePointer(MemorySegment ProcessHandle, MemorySegment Ptr, MemorySegment EncodedPtr) {
        var mh$ = EncodeRemotePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodeRemotePointer", ProcessHandle, Ptr, EncodedPtr);
            }
            return (int)mh$.invokeExact(ProcessHandle, Ptr, EncodedPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodeRemotePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DecodeRemotePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static FunctionDescriptor DecodeRemotePointer$descriptor() {
        return DecodeRemotePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static MethodHandle DecodeRemotePointer$handle() {
        return DecodeRemotePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static MemorySegment DecodeRemotePointer$address() {
        return DecodeRemotePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static int DecodeRemotePointer(MemorySegment ProcessHandle, MemorySegment Ptr, MemorySegment DecodedPtr) {
        var mh$ = DecodeRemotePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodeRemotePointer", ProcessHandle, Ptr, DecodedPtr);
            }
            return (int)mh$.invokeExact(ProcessHandle, Ptr, DecodedPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Beep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Beep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static FunctionDescriptor Beep$descriptor() {
        return Beep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static MethodHandle Beep$handle() {
        return Beep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static MemorySegment Beep$address() {
        return Beep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static int Beep(int dwFreq, int dwDuration) {
        var mh$ = Beep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Beep", dwFreq, dwDuration);
            }
            return (int)mh$.invokeExact(dwFreq, dwDuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static FunctionDescriptor CloseHandle$descriptor() {
        return CloseHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static MethodHandle CloseHandle$handle() {
        return CloseHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static MemorySegment CloseHandle$address() {
        return CloseHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static int CloseHandle(MemorySegment hObject) {
        var mh$ = CloseHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseHandle", hObject);
            }
            return (int)mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DuplicateHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static FunctionDescriptor DuplicateHandle$descriptor() {
        return DuplicateHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static MethodHandle DuplicateHandle$handle() {
        return DuplicateHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static MemorySegment DuplicateHandle$address() {
        return DuplicateHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static int DuplicateHandle(MemorySegment hSourceProcessHandle, MemorySegment hSourceHandle, MemorySegment hTargetProcessHandle, MemorySegment lpTargetHandle, int dwDesiredAccess, int bInheritHandle, int dwOptions) {
        var mh$ = DuplicateHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateHandle", hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions);
            }
            return (int)mh$.invokeExact(hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareObjectHandles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CompareObjectHandles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static FunctionDescriptor CompareObjectHandles$descriptor() {
        return CompareObjectHandles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static MethodHandle CompareObjectHandles$handle() {
        return CompareObjectHandles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static MemorySegment CompareObjectHandles$address() {
        return CompareObjectHandles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static int CompareObjectHandles(MemorySegment hFirstObjectHandle, MemorySegment hSecondObjectHandle) {
        var mh$ = CompareObjectHandles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareObjectHandles", hFirstObjectHandle, hSecondObjectHandle);
            }
            return (int)mh$.invokeExact(hFirstObjectHandle, hSecondObjectHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetHandleInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetHandleInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static FunctionDescriptor GetHandleInformation$descriptor() {
        return GetHandleInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static MethodHandle GetHandleInformation$handle() {
        return GetHandleInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static MemorySegment GetHandleInformation$address() {
        return GetHandleInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static int GetHandleInformation(MemorySegment hObject, MemorySegment lpdwFlags) {
        var mh$ = GetHandleInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetHandleInformation", hObject, lpdwFlags);
            }
            return (int)mh$.invokeExact(hObject, lpdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetHandleInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetHandleInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetHandleInformation$descriptor() {
        return SetHandleInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetHandleInformation$handle() {
        return SetHandleInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetHandleInformation$address() {
        return SetHandleInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static int SetHandleInformation(MemorySegment hObject, int dwMask, int dwFlags) {
        var mh$ = SetHandleInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetHandleInformation", hObject, dwMask, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, dwMask, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RaiseException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static FunctionDescriptor RaiseException$descriptor() {
        return RaiseException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static MethodHandle RaiseException$handle() {
        return RaiseException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static MemorySegment RaiseException$address() {
        return RaiseException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static void RaiseException(int dwExceptionCode, int dwExceptionFlags, int nNumberOfArguments, MemorySegment lpArguments) {
        var mh$ = RaiseException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseException", dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
            }
            mh$.invokeExact(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnhandledExceptionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnhandledExceptionFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static FunctionDescriptor UnhandledExceptionFilter$descriptor() {
        return UnhandledExceptionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static MethodHandle UnhandledExceptionFilter$handle() {
        return UnhandledExceptionFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static MemorySegment UnhandledExceptionFilter$address() {
        return UnhandledExceptionFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static int UnhandledExceptionFilter(MemorySegment ExceptionInfo) {
        var mh$ = UnhandledExceptionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnhandledExceptionFilter", ExceptionInfo);
            }
            return (int)mh$.invokeExact(ExceptionInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUnhandledExceptionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetUnhandledExceptionFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static FunctionDescriptor SetUnhandledExceptionFilter$descriptor() {
        return SetUnhandledExceptionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static MethodHandle SetUnhandledExceptionFilter$handle() {
        return SetUnhandledExceptionFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static MemorySegment SetUnhandledExceptionFilter$address() {
        return SetUnhandledExceptionFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static MemorySegment SetUnhandledExceptionFilter(MemorySegment lpTopLevelExceptionFilter) {
        var mh$ = SetUnhandledExceptionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUnhandledExceptionFilter", lpTopLevelExceptionFilter);
            }
            return (MemorySegment)mh$.invokeExact(lpTopLevelExceptionFilter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static FunctionDescriptor GetLastError$descriptor() {
        return GetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static MethodHandle GetLastError$handle() {
        return GetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static MemorySegment GetLastError$address() {
        return GetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static int GetLastError() {
        var mh$ = GetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static FunctionDescriptor SetLastError$descriptor() {
        return SetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static MethodHandle SetLastError$handle() {
        return SetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static MemorySegment SetLastError$address() {
        return SetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static void SetLastError(int dwErrCode) {
        var mh$ = SetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLastError", dwErrCode);
            }
            mh$.invokeExact(dwErrCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static FunctionDescriptor GetErrorMode$descriptor() {
        return GetErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static MethodHandle GetErrorMode$handle() {
        return GetErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static MemorySegment GetErrorMode$address() {
        return GetErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static int GetErrorMode() {
        var mh$ = GetErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetErrorMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static FunctionDescriptor SetErrorMode$descriptor() {
        return SetErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static MethodHandle SetErrorMode$handle() {
        return SetErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static MemorySegment SetErrorMode$address() {
        return SetErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static int SetErrorMode(int uMode) {
        var mh$ = SetErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetErrorMode", uMode);
            }
            return (int)mh$.invokeExact(uMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddVectoredExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddVectoredExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static FunctionDescriptor AddVectoredExceptionHandler$descriptor() {
        return AddVectoredExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MethodHandle AddVectoredExceptionHandler$handle() {
        return AddVectoredExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredExceptionHandler$address() {
        return AddVectoredExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredExceptionHandler(int First, MemorySegment Handler) {
        var mh$ = AddVectoredExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddVectoredExceptionHandler", First, Handler);
            }
            return (MemorySegment)mh$.invokeExact(First, Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveVectoredExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveVectoredExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static FunctionDescriptor RemoveVectoredExceptionHandler$descriptor() {
        return RemoveVectoredExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static MethodHandle RemoveVectoredExceptionHandler$handle() {
        return RemoveVectoredExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static MemorySegment RemoveVectoredExceptionHandler$address() {
        return RemoveVectoredExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static int RemoveVectoredExceptionHandler(MemorySegment Handle) {
        var mh$ = RemoveVectoredExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveVectoredExceptionHandler", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddVectoredContinueHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddVectoredContinueHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static FunctionDescriptor AddVectoredContinueHandler$descriptor() {
        return AddVectoredContinueHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MethodHandle AddVectoredContinueHandler$handle() {
        return AddVectoredContinueHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredContinueHandler$address() {
        return AddVectoredContinueHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredContinueHandler(int First, MemorySegment Handler) {
        var mh$ = AddVectoredContinueHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddVectoredContinueHandler", First, Handler);
            }
            return (MemorySegment)mh$.invokeExact(First, Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveVectoredContinueHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveVectoredContinueHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static FunctionDescriptor RemoveVectoredContinueHandler$descriptor() {
        return RemoveVectoredContinueHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static MethodHandle RemoveVectoredContinueHandler$handle() {
        return RemoveVectoredContinueHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static MemorySegment RemoveVectoredContinueHandler$address() {
        return RemoveVectoredContinueHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static int RemoveVectoredContinueHandler(MemorySegment Handle) {
        var mh$ = RemoveVectoredContinueHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveVectoredContinueHandler", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseFailFastException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RaiseFailFastException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RaiseFailFastException$descriptor() {
        return RaiseFailFastException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static MethodHandle RaiseFailFastException$handle() {
        return RaiseFailFastException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static MemorySegment RaiseFailFastException$address() {
        return RaiseFailFastException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static void RaiseFailFastException(MemorySegment pExceptionRecord, MemorySegment pContextRecord, int dwFlags) {
        var mh$ = RaiseFailFastException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseFailFastException", pExceptionRecord, pContextRecord, dwFlags);
            }
            mh$.invokeExact(pExceptionRecord, pContextRecord, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FatalAppExitA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FatalAppExitA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static FunctionDescriptor FatalAppExitA$descriptor() {
        return FatalAppExitA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static MethodHandle FatalAppExitA$handle() {
        return FatalAppExitA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static MemorySegment FatalAppExitA$address() {
        return FatalAppExitA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static void FatalAppExitA(int uAction, MemorySegment lpMessageText) {
        var mh$ = FatalAppExitA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FatalAppExitA", uAction, lpMessageText);
            }
            mh$.invokeExact(uAction, lpMessageText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FatalAppExitW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FatalAppExitW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static FunctionDescriptor FatalAppExitW$descriptor() {
        return FatalAppExitW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static MethodHandle FatalAppExitW$handle() {
        return FatalAppExitW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static MemorySegment FatalAppExitW$address() {
        return FatalAppExitW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static void FatalAppExitW(int uAction, MemorySegment lpMessageText) {
        var mh$ = FatalAppExitW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FatalAppExitW", uAction, lpMessageText);
            }
            mh$.invokeExact(uAction, lpMessageText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static FunctionDescriptor GetThreadErrorMode$descriptor() {
        return GetThreadErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static MethodHandle GetThreadErrorMode$handle() {
        return GetThreadErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static MemorySegment GetThreadErrorMode$address() {
        return GetThreadErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static int GetThreadErrorMode() {
        var mh$ = GetThreadErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadErrorMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static FunctionDescriptor SetThreadErrorMode$descriptor() {
        return SetThreadErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static MethodHandle SetThreadErrorMode$handle() {
        return SetThreadErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static MemorySegment SetThreadErrorMode$address() {
        return SetThreadErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static int SetThreadErrorMode(int dwNewMode, MemorySegment lpOldMode) {
        var mh$ = SetThreadErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadErrorMode", dwNewMode, lpOldMode);
            }
            return (int)mh$.invokeExact(dwNewMode, lpOldMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateProcessOnMemoryExhaustion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TerminateProcessOnMemoryExhaustion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static FunctionDescriptor TerminateProcessOnMemoryExhaustion$descriptor() {
        return TerminateProcessOnMemoryExhaustion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static MethodHandle TerminateProcessOnMemoryExhaustion$handle() {
        return TerminateProcessOnMemoryExhaustion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static MemorySegment TerminateProcessOnMemoryExhaustion$address() {
        return TerminateProcessOnMemoryExhaustion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static void TerminateProcessOnMemoryExhaustion(long FailedAllocationSize) {
        var mh$ = TerminateProcessOnMemoryExhaustion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateProcessOnMemoryExhaustion", FailedAllocationSize);
            }
            mh$.invokeExact(FailedAllocationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FlsAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static FunctionDescriptor FlsAlloc$descriptor() {
        return FlsAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static MethodHandle FlsAlloc$handle() {
        return FlsAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static MemorySegment FlsAlloc$address() {
        return FlsAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static int FlsAlloc(MemorySegment lpCallback) {
        var mh$ = FlsAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsAlloc", lpCallback);
            }
            return (int)mh$.invokeExact(lpCallback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsGetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FlsGetValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static FunctionDescriptor FlsGetValue$descriptor() {
        return FlsGetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static MethodHandle FlsGetValue$handle() {
        return FlsGetValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static MemorySegment FlsGetValue$address() {
        return FlsGetValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static MemorySegment FlsGetValue(int dwFlsIndex) {
        var mh$ = FlsGetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsGetValue", dwFlsIndex);
            }
            return (MemorySegment)mh$.invokeExact(dwFlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsSetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FlsSetValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static FunctionDescriptor FlsSetValue$descriptor() {
        return FlsSetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static MethodHandle FlsSetValue$handle() {
        return FlsSetValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static MemorySegment FlsSetValue$address() {
        return FlsSetValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static int FlsSetValue(int dwFlsIndex, MemorySegment lpFlsData) {
        var mh$ = FlsSetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsSetValue", dwFlsIndex, lpFlsData);
            }
            return (int)mh$.invokeExact(dwFlsIndex, lpFlsData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FlsFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static FunctionDescriptor FlsFree$descriptor() {
        return FlsFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static MethodHandle FlsFree$handle() {
        return FlsFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static MemorySegment FlsFree$address() {
        return FlsFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static int FlsFree(int dwFlsIndex) {
        var mh$ = FlsFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsFree", dwFlsIndex);
            }
            return (int)mh$.invokeExact(dwFlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsThreadAFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsThreadAFiber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static FunctionDescriptor IsThreadAFiber$descriptor() {
        return IsThreadAFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static MethodHandle IsThreadAFiber$handle() {
        return IsThreadAFiber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static MemorySegment IsThreadAFiber$address() {
        return IsThreadAFiber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static int IsThreadAFiber() {
        var mh$ = IsThreadAFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsThreadAFiber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static FunctionDescriptor CreatePipe$descriptor() {
        return CreatePipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static MethodHandle CreatePipe$handle() {
        return CreatePipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static MemorySegment CreatePipe$address() {
        return CreatePipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static int CreatePipe(MemorySegment hReadPipe, MemorySegment hWritePipe, MemorySegment lpPipeAttributes, int nSize) {
        var mh$ = CreatePipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePipe", hReadPipe, hWritePipe, lpPipeAttributes, nSize);
            }
            return (int)mh$.invokeExact(hReadPipe, hWritePipe, lpPipeAttributes, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConnectNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ConnectNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ConnectNamedPipe$descriptor() {
        return ConnectNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ConnectNamedPipe$handle() {
        return ConnectNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment ConnectNamedPipe$address() {
        return ConnectNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ConnectNamedPipe(MemorySegment hNamedPipe, MemorySegment lpOverlapped) {
        var mh$ = ConnectNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConnectNamedPipe", hNamedPipe, lpOverlapped);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisconnectNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DisconnectNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static FunctionDescriptor DisconnectNamedPipe$descriptor() {
        return DisconnectNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static MethodHandle DisconnectNamedPipe$handle() {
        return DisconnectNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static MemorySegment DisconnectNamedPipe$address() {
        return DisconnectNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static int DisconnectNamedPipe(MemorySegment hNamedPipe) {
        var mh$ = DisconnectNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisconnectNamedPipe", hNamedPipe);
            }
            return (int)mh$.invokeExact(hNamedPipe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetNamedPipeHandleState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetNamedPipeHandleState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static FunctionDescriptor SetNamedPipeHandleState$descriptor() {
        return SetNamedPipeHandleState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static MethodHandle SetNamedPipeHandleState$handle() {
        return SetNamedPipeHandleState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static MemorySegment SetNamedPipeHandleState$address() {
        return SetNamedPipeHandleState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static int SetNamedPipeHandleState(MemorySegment hNamedPipe, MemorySegment lpMode, MemorySegment lpMaxCollectionCount, MemorySegment lpCollectDataTimeout) {
        var mh$ = SetNamedPipeHandleState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetNamedPipeHandleState", hNamedPipe, lpMode, lpMaxCollectionCount, lpCollectDataTimeout);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpMode, lpMaxCollectionCount, lpCollectDataTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PeekNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static FunctionDescriptor PeekNamedPipe$descriptor() {
        return PeekNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static MethodHandle PeekNamedPipe$handle() {
        return PeekNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static MemorySegment PeekNamedPipe$address() {
        return PeekNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static int PeekNamedPipe(MemorySegment hNamedPipe, MemorySegment lpBuffer, int nBufferSize, MemorySegment lpBytesRead, MemorySegment lpTotalBytesAvail, MemorySegment lpBytesLeftThisMessage) {
        var mh$ = PeekNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekNamedPipe", hNamedPipe, lpBuffer, nBufferSize, lpBytesRead, lpTotalBytesAvail, lpBytesLeftThisMessage);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpBuffer, nBufferSize, lpBytesRead, lpTotalBytesAvail, lpBytesLeftThisMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransactNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TransactNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor TransactNamedPipe$descriptor() {
        return TransactNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle TransactNamedPipe$handle() {
        return TransactNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment TransactNamedPipe$address() {
        return TransactNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int TransactNamedPipe(MemorySegment hNamedPipe, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesRead, MemorySegment lpOverlapped) {
        var mh$ = TransactNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransactNamedPipe", hNamedPipe, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, lpOverlapped);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateNamedPipeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateNamedPipeW$descriptor() {
        return CreateNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateNamedPipeW$handle() {
        return CreateNamedPipeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeW$address() {
        return CreateNamedPipeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeW(MemorySegment lpName, int dwOpenMode, int dwPipeMode, int nMaxInstances, int nOutBufferSize, int nInBufferSize, int nDefaultTimeOut, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateNamedPipeW", lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitNamedPipeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor WaitNamedPipeW$descriptor() {
        return WaitNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MethodHandle WaitNamedPipeW$handle() {
        return WaitNamedPipeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MemorySegment WaitNamedPipeW$address() {
        return WaitNamedPipeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static int WaitNamedPipeW(MemorySegment lpNamedPipeName, int nTimeOut) {
        var mh$ = WaitNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitNamedPipeW", lpNamedPipeName, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNamedPipeClientComputerNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientComputerNameW$descriptor() {
        return GetNamedPipeClientComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MethodHandle GetNamedPipeClientComputerNameW$handle() {
        return GetNamedPipeClientComputerNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MemorySegment GetNamedPipeClientComputerNameW$address() {
        return GetNamedPipeClientComputerNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static int GetNamedPipeClientComputerNameW(MemorySegment Pipe, MemorySegment ClientComputerName, int ClientComputerNameLength) {
        var mh$ = GetNamedPipeClientComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientComputerNameW", Pipe, ClientComputerName, ClientComputerNameLength);
            }
            return (int)mh$.invokeExact(Pipe, ClientComputerName, ClientComputerNameLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateNamedPipeClient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImpersonateNamedPipeClient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static FunctionDescriptor ImpersonateNamedPipeClient$descriptor() {
        return ImpersonateNamedPipeClient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static MethodHandle ImpersonateNamedPipeClient$handle() {
        return ImpersonateNamedPipeClient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static MemorySegment ImpersonateNamedPipeClient$address() {
        return ImpersonateNamedPipeClient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static int ImpersonateNamedPipeClient(MemorySegment hNamedPipe) {
        var mh$ = ImpersonateNamedPipeClient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateNamedPipeClient", hNamedPipe);
            }
            return (int)mh$.invokeExact(hNamedPipe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNamedPipeInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static FunctionDescriptor GetNamedPipeInfo$descriptor() {
        return GetNamedPipeInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static MethodHandle GetNamedPipeInfo$handle() {
        return GetNamedPipeInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static MemorySegment GetNamedPipeInfo$address() {
        return GetNamedPipeInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static int GetNamedPipeInfo(MemorySegment hNamedPipe, MemorySegment lpFlags, MemorySegment lpOutBufferSize, MemorySegment lpInBufferSize, MemorySegment lpMaxInstances) {
        var mh$ = GetNamedPipeInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeInfo", hNamedPipe, lpFlags, lpOutBufferSize, lpInBufferSize, lpMaxInstances);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpFlags, lpOutBufferSize, lpInBufferSize, lpMaxInstances);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeHandleStateW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNamedPipeHandleStateW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static FunctionDescriptor GetNamedPipeHandleStateW$descriptor() {
        return GetNamedPipeHandleStateW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MethodHandle GetNamedPipeHandleStateW$handle() {
        return GetNamedPipeHandleStateW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MemorySegment GetNamedPipeHandleStateW$address() {
        return GetNamedPipeHandleStateW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static int GetNamedPipeHandleStateW(MemorySegment hNamedPipe, MemorySegment lpState, MemorySegment lpCurInstances, MemorySegment lpMaxCollectionCount, MemorySegment lpCollectDataTimeout, MemorySegment lpUserName, int nMaxUserNameSize) {
        var mh$ = GetNamedPipeHandleStateW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeHandleStateW", hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CallNamedPipeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor CallNamedPipeW$descriptor() {
        return CallNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MethodHandle CallNamedPipeW$handle() {
        return CallNamedPipeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MemorySegment CallNamedPipeW$address() {
        return CallNamedPipeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static int CallNamedPipeW(MemorySegment lpNamedPipeName, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesRead, int nTimeOut) {
        var mh$ = CallNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallNamedPipeW", lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryPerformanceCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryPerformanceCounter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static FunctionDescriptor QueryPerformanceCounter$descriptor() {
        return QueryPerformanceCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static MethodHandle QueryPerformanceCounter$handle() {
        return QueryPerformanceCounter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static MemorySegment QueryPerformanceCounter$address() {
        return QueryPerformanceCounter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static int QueryPerformanceCounter(MemorySegment lpPerformanceCount) {
        var mh$ = QueryPerformanceCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryPerformanceCounter", lpPerformanceCount);
            }
            return (int)mh$.invokeExact(lpPerformanceCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryPerformanceFrequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryPerformanceFrequency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static FunctionDescriptor QueryPerformanceFrequency$descriptor() {
        return QueryPerformanceFrequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static MethodHandle QueryPerformanceFrequency$handle() {
        return QueryPerformanceFrequency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static MemorySegment QueryPerformanceFrequency$address() {
        return QueryPerformanceFrequency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static int QueryPerformanceFrequency(MemorySegment lpFrequency) {
        var mh$ = QueryPerformanceFrequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryPerformanceFrequency", lpFrequency);
            }
            return (int)mh$.invokeExact(lpFrequency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _HEAP_SUMMARY {
     *     DWORD cb;
     *     SIZE_T cbAllocated;
     *     SIZE_T cbCommitted;
     *     SIZE_T cbReserved;
     *     SIZE_T cbMaxReserve;
     * } *PHEAP_SUMMARY
     * }
     */
    public static final AddressLayout PHEAP_SUMMARY = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PHEAP_SUMMARY LPHEAP_SUMMARY
     * }
     */
    public static final AddressLayout LPHEAP_SUMMARY = wgl_h.C_POINTER;

    private static class HeapCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static FunctionDescriptor HeapCreate$descriptor() {
        return HeapCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static MethodHandle HeapCreate$handle() {
        return HeapCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static MemorySegment HeapCreate$address() {
        return HeapCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static MemorySegment HeapCreate(int flOptions, long dwInitialSize, long dwMaximumSize) {
        var mh$ = HeapCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapCreate", flOptions, dwInitialSize, dwMaximumSize);
            }
            return (MemorySegment)mh$.invokeExact(flOptions, dwInitialSize, dwMaximumSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapDestroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapDestroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapDestroy$descriptor() {
        return HeapDestroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapDestroy$handle() {
        return HeapDestroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static MemorySegment HeapDestroy$address() {
        return HeapDestroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static int HeapDestroy(MemorySegment hHeap) {
        var mh$ = HeapDestroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapDestroy", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static FunctionDescriptor HeapAlloc$descriptor() {
        return HeapAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static MethodHandle HeapAlloc$handle() {
        return HeapAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapAlloc$address() {
        return HeapAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapAlloc(MemorySegment hHeap, int dwFlags, long dwBytes) {
        var mh$ = HeapAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapAlloc", hHeap, dwFlags, dwBytes);
            }
            return (MemorySegment)mh$.invokeExact(hHeap, dwFlags, dwBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapReAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapReAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static FunctionDescriptor HeapReAlloc$descriptor() {
        return HeapReAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static MethodHandle HeapReAlloc$handle() {
        return HeapReAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapReAlloc$address() {
        return HeapReAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapReAlloc(MemorySegment hHeap, int dwFlags, MemorySegment lpMem, long dwBytes) {
        var mh$ = HeapReAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapReAlloc", hHeap, dwFlags, lpMem, dwBytes);
            }
            return (MemorySegment)mh$.invokeExact(hHeap, dwFlags, lpMem, dwBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapFree$descriptor() {
        return HeapFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static MethodHandle HeapFree$handle() {
        return HeapFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static MemorySegment HeapFree$address() {
        return HeapFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static int HeapFree(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapFree", hHeap, dwFlags, lpMem);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapSize$descriptor() {
        return HeapSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MethodHandle HeapSize$handle() {
        return HeapSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MemorySegment HeapSize$address() {
        return HeapSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static long HeapSize(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSize", hHeap, dwFlags, lpMem);
            }
            return (long)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessHeap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessHeap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static FunctionDescriptor GetProcessHeap$descriptor() {
        return GetProcessHeap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static MethodHandle GetProcessHeap$handle() {
        return GetProcessHeap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static MemorySegment GetProcessHeap$address() {
        return GetProcessHeap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static MemorySegment GetProcessHeap() {
        var mh$ = GetProcessHeap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessHeap");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapCompact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapCompact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor HeapCompact$descriptor() {
        return HeapCompact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static MethodHandle HeapCompact$handle() {
        return HeapCompact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static MemorySegment HeapCompact$address() {
        return HeapCompact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static long HeapCompact(MemorySegment hHeap, int dwFlags) {
        var mh$ = HeapCompact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapCompact", hHeap, dwFlags);
            }
            return (long)mh$.invokeExact(hHeap, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSetInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapSetInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static FunctionDescriptor HeapSetInformation$descriptor() {
        return HeapSetInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static MethodHandle HeapSetInformation$handle() {
        return HeapSetInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static MemorySegment HeapSetInformation$address() {
        return HeapSetInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static int HeapSetInformation(MemorySegment HeapHandle, int HeapInformationClass, MemorySegment HeapInformation, long HeapInformationLength) {
        var mh$ = HeapSetInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSetInformation", HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength);
            }
            return (int)mh$.invokeExact(HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapValidate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapValidate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapValidate$descriptor() {
        return HeapValidate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MethodHandle HeapValidate$handle() {
        return HeapValidate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MemorySegment HeapValidate$address() {
        return HeapValidate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static int HeapValidate(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapValidate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapValidate", hHeap, dwFlags, lpMem);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSummary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapSummary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static FunctionDescriptor HeapSummary$descriptor() {
        return HeapSummary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static MethodHandle HeapSummary$handle() {
        return HeapSummary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static MemorySegment HeapSummary$address() {
        return HeapSummary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static int HeapSummary(MemorySegment hHeap, int dwFlags, MemorySegment lpSummary) {
        var mh$ = HeapSummary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSummary", hHeap, dwFlags, lpSummary);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpSummary);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessHeaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessHeaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static FunctionDescriptor GetProcessHeaps$descriptor() {
        return GetProcessHeaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static MethodHandle GetProcessHeaps$handle() {
        return GetProcessHeaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static MemorySegment GetProcessHeaps$address() {
        return GetProcessHeaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static int GetProcessHeaps(int NumberOfHeaps, MemorySegment ProcessHeaps) {
        var mh$ = GetProcessHeaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessHeaps", NumberOfHeaps, ProcessHeaps);
            }
            return (int)mh$.invokeExact(NumberOfHeaps, ProcessHeaps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapLock$descriptor() {
        return HeapLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapLock$handle() {
        return HeapLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static MemorySegment HeapLock$address() {
        return HeapLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static int HeapLock(MemorySegment hHeap) {
        var mh$ = HeapLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapLock", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapUnlock$descriptor() {
        return HeapUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapUnlock$handle() {
        return HeapUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static MemorySegment HeapUnlock$address() {
        return HeapUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static int HeapUnlock(MemorySegment hHeap) {
        var mh$ = HeapUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapUnlock", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapWalk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapWalk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static FunctionDescriptor HeapWalk$descriptor() {
        return HeapWalk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static MethodHandle HeapWalk$handle() {
        return HeapWalk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static MemorySegment HeapWalk$address() {
        return HeapWalk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static int HeapWalk(MemorySegment hHeap, MemorySegment lpEntry) {
        var mh$ = HeapWalk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapWalk", hHeap, lpEntry);
            }
            return (int)mh$.invokeExact(hHeap, lpEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapQueryInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("HeapQueryInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static FunctionDescriptor HeapQueryInformation$descriptor() {
        return HeapQueryInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static MethodHandle HeapQueryInformation$handle() {
        return HeapQueryInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static MemorySegment HeapQueryInformation$address() {
        return HeapQueryInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static int HeapQueryInformation(MemorySegment HeapHandle, int HeapInformationClass, MemorySegment HeapInformation, long HeapInformationLength, MemorySegment ReturnLength) {
        var mh$ = HeapQueryInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapQueryInformation", HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength, ReturnLength);
            }
            return (int)mh$.invokeExact(HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIoCompletionPort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateIoCompletionPort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static FunctionDescriptor CreateIoCompletionPort$descriptor() {
        return CreateIoCompletionPort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MethodHandle CreateIoCompletionPort$handle() {
        return CreateIoCompletionPort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MemorySegment CreateIoCompletionPort$address() {
        return CreateIoCompletionPort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MemorySegment CreateIoCompletionPort(MemorySegment FileHandle, MemorySegment ExistingCompletionPort, long CompletionKey, int NumberOfConcurrentThreads) {
        var mh$ = CreateIoCompletionPort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIoCompletionPort", FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);
            }
            return (MemorySegment)mh$.invokeExact(FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueuedCompletionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetQueuedCompletionStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor GetQueuedCompletionStatus$descriptor() {
        return GetQueuedCompletionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle GetQueuedCompletionStatus$handle() {
        return GetQueuedCompletionStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment GetQueuedCompletionStatus$address() {
        return GetQueuedCompletionStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static int GetQueuedCompletionStatus(MemorySegment CompletionPort, MemorySegment lpNumberOfBytesTransferred, MemorySegment lpCompletionKey, MemorySegment lpOverlapped, int dwMilliseconds) {
        var mh$ = GetQueuedCompletionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueuedCompletionStatus", CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);
            }
            return (int)mh$.invokeExact(CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueuedCompletionStatusEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetQueuedCompletionStatusEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static FunctionDescriptor GetQueuedCompletionStatusEx$descriptor() {
        return GetQueuedCompletionStatusEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static MethodHandle GetQueuedCompletionStatusEx$handle() {
        return GetQueuedCompletionStatusEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static MemorySegment GetQueuedCompletionStatusEx$address() {
        return GetQueuedCompletionStatusEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static int GetQueuedCompletionStatusEx(MemorySegment CompletionPort, MemorySegment lpCompletionPortEntries, int ulCount, MemorySegment ulNumEntriesRemoved, int dwMilliseconds, int fAlertable) {
        var mh$ = GetQueuedCompletionStatusEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueuedCompletionStatusEx", CompletionPort, lpCompletionPortEntries, ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable);
            }
            return (int)mh$.invokeExact(CompletionPort, lpCompletionPortEntries, ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostQueuedCompletionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PostQueuedCompletionStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor PostQueuedCompletionStatus$descriptor() {
        return PostQueuedCompletionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle PostQueuedCompletionStatus$handle() {
        return PostQueuedCompletionStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment PostQueuedCompletionStatus$address() {
        return PostQueuedCompletionStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int PostQueuedCompletionStatus(MemorySegment CompletionPort, int dwNumberOfBytesTransferred, long dwCompletionKey, MemorySegment lpOverlapped) {
        var mh$ = PostQueuedCompletionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostQueuedCompletionStatus", CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);
            }
            return (int)mh$.invokeExact(CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceIoControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeviceIoControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor DeviceIoControl$descriptor() {
        return DeviceIoControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle DeviceIoControl$handle() {
        return DeviceIoControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment DeviceIoControl$address() {
        return DeviceIoControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int DeviceIoControl(MemorySegment hDevice, int dwIoControlCode, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesReturned, MemorySegment lpOverlapped) {
        var mh$ = DeviceIoControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceIoControl", hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
            }
            return (int)mh$.invokeExact(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOverlappedResult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetOverlappedResult");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static FunctionDescriptor GetOverlappedResult$descriptor() {
        return GetOverlappedResult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static MethodHandle GetOverlappedResult$handle() {
        return GetOverlappedResult.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static MemorySegment GetOverlappedResult$address() {
        return GetOverlappedResult.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static int GetOverlappedResult(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int bWait) {
        var mh$ = GetOverlappedResult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOverlappedResult", hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelIoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CancelIoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor CancelIoEx$descriptor() {
        return CancelIoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle CancelIoEx$handle() {
        return CancelIoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment CancelIoEx$address() {
        return CancelIoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int CancelIoEx(MemorySegment hFile, MemorySegment lpOverlapped) {
        var mh$ = CancelIoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelIoEx", hFile, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CancelIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor CancelIo$descriptor() {
        return CancelIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static MethodHandle CancelIo$handle() {
        return CancelIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static MemorySegment CancelIo$address() {
        return CancelIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static int CancelIo(MemorySegment hFile) {
        var mh$ = CancelIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelIo", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOverlappedResultEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetOverlappedResultEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor GetOverlappedResultEx$descriptor() {
        return GetOverlappedResultEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle GetOverlappedResultEx$handle() {
        return GetOverlappedResultEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment GetOverlappedResultEx$address() {
        return GetOverlappedResultEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int GetOverlappedResultEx(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int dwMilliseconds, int bAlertable) {
        var mh$ = GetOverlappedResultEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOverlappedResultEx", hFile, lpOverlapped, lpNumberOfBytesTransferred, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelSynchronousIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CancelSynchronousIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor CancelSynchronousIo$descriptor() {
        return CancelSynchronousIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static MethodHandle CancelSynchronousIo$handle() {
        return CancelSynchronousIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static MemorySegment CancelSynchronousIo$address() {
        return CancelSynchronousIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static int CancelSynchronousIo(MemorySegment hThread) {
        var mh$ = CancelSynchronousIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelSynchronousIo", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef RTL_SRWLOCK *PSRWLOCK
     * }
     */
    public static final AddressLayout PSRWLOCK = wgl_h.C_POINTER;

    private static class InitializeSRWLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeSRWLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor InitializeSRWLock$descriptor() {
        return InitializeSRWLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle InitializeSRWLock$handle() {
        return InitializeSRWLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment InitializeSRWLock$address() {
        return InitializeSRWLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static void InitializeSRWLock(MemorySegment SRWLock) {
        var mh$ = InitializeSRWLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSRWLock", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReleaseSRWLockExclusive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor ReleaseSRWLockExclusive$descriptor() {
        return ReleaseSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle ReleaseSRWLockExclusive$handle() {
        return ReleaseSRWLockExclusive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment ReleaseSRWLockExclusive$address() {
        return ReleaseSRWLockExclusive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static void ReleaseSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = ReleaseSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSRWLockExclusive", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReleaseSRWLockShared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor ReleaseSRWLockShared$descriptor() {
        return ReleaseSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle ReleaseSRWLockShared$handle() {
        return ReleaseSRWLockShared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment ReleaseSRWLockShared$address() {
        return ReleaseSRWLockShared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static void ReleaseSRWLockShared(MemorySegment SRWLock) {
        var mh$ = ReleaseSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSRWLockShared", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AcquireSRWLockExclusive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor AcquireSRWLockExclusive$descriptor() {
        return AcquireSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle AcquireSRWLockExclusive$handle() {
        return AcquireSRWLockExclusive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment AcquireSRWLockExclusive$address() {
        return AcquireSRWLockExclusive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static void AcquireSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = AcquireSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireSRWLockExclusive", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AcquireSRWLockShared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor AcquireSRWLockShared$descriptor() {
        return AcquireSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle AcquireSRWLockShared$handle() {
        return AcquireSRWLockShared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment AcquireSRWLockShared$address() {
        return AcquireSRWLockShared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static void AcquireSRWLockShared(MemorySegment SRWLock) {
        var mh$ = AcquireSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireSRWLockShared", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryAcquireSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TryAcquireSRWLockExclusive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor TryAcquireSRWLockExclusive$descriptor() {
        return TryAcquireSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle TryAcquireSRWLockExclusive$handle() {
        return TryAcquireSRWLockExclusive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment TryAcquireSRWLockExclusive$address() {
        return TryAcquireSRWLockExclusive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static byte TryAcquireSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = TryAcquireSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryAcquireSRWLockExclusive", SRWLock);
            }
            return (byte)mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryAcquireSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TryAcquireSRWLockShared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor TryAcquireSRWLockShared$descriptor() {
        return TryAcquireSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle TryAcquireSRWLockShared$handle() {
        return TryAcquireSRWLockShared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment TryAcquireSRWLockShared$address() {
        return TryAcquireSRWLockShared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static byte TryAcquireSRWLockShared(MemorySegment SRWLock) {
        var mh$ = TryAcquireSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryAcquireSRWLockShared", SRWLock);
            }
            return (byte)mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSection$descriptor() {
        return InitializeCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle InitializeCriticalSection$handle() {
        return InitializeCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment InitializeCriticalSection$address() {
        return InitializeCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void InitializeCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = InitializeCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnterCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnterCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor EnterCriticalSection$descriptor() {
        return EnterCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle EnterCriticalSection$handle() {
        return EnterCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment EnterCriticalSection$address() {
        return EnterCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void EnterCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = EnterCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnterCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LeaveCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LeaveCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor LeaveCriticalSection$descriptor() {
        return LeaveCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle LeaveCriticalSection$handle() {
        return LeaveCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment LeaveCriticalSection$address() {
        return LeaveCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void LeaveCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = LeaveCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LeaveCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSectionAndSpinCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeCriticalSectionAndSpinCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSectionAndSpinCount$descriptor() {
        return InitializeCriticalSectionAndSpinCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MethodHandle InitializeCriticalSectionAndSpinCount$handle() {
        return InitializeCriticalSectionAndSpinCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MemorySegment InitializeCriticalSectionAndSpinCount$address() {
        return InitializeCriticalSectionAndSpinCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static int InitializeCriticalSectionAndSpinCount(MemorySegment lpCriticalSection, int dwSpinCount) {
        var mh$ = InitializeCriticalSectionAndSpinCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSectionAndSpinCount", lpCriticalSection, dwSpinCount);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSectionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeCriticalSectionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSectionEx$descriptor() {
        return InitializeCriticalSectionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static MethodHandle InitializeCriticalSectionEx$handle() {
        return InitializeCriticalSectionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static MemorySegment InitializeCriticalSectionEx$address() {
        return InitializeCriticalSectionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static int InitializeCriticalSectionEx(MemorySegment lpCriticalSection, int dwSpinCount, int Flags) {
        var mh$ = InitializeCriticalSectionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSectionEx", lpCriticalSection, dwSpinCount, Flags);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCriticalSectionSpinCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetCriticalSectionSpinCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static FunctionDescriptor SetCriticalSectionSpinCount$descriptor() {
        return SetCriticalSectionSpinCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MethodHandle SetCriticalSectionSpinCount$handle() {
        return SetCriticalSectionSpinCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MemorySegment SetCriticalSectionSpinCount$address() {
        return SetCriticalSectionSpinCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static int SetCriticalSectionSpinCount(MemorySegment lpCriticalSection, int dwSpinCount) {
        var mh$ = SetCriticalSectionSpinCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCriticalSectionSpinCount", lpCriticalSection, dwSpinCount);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryEnterCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TryEnterCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor TryEnterCriticalSection$descriptor() {
        return TryEnterCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle TryEnterCriticalSection$handle() {
        return TryEnterCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment TryEnterCriticalSection$address() {
        return TryEnterCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static int TryEnterCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = TryEnterCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryEnterCriticalSection", lpCriticalSection);
            }
            return (int)mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor DeleteCriticalSection$descriptor() {
        return DeleteCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle DeleteCriticalSection$handle() {
        return DeleteCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment DeleteCriticalSection$address() {
        return DeleteCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void DeleteCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = DeleteCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PRTL_RUN_ONCE PINIT_ONCE
     * }
     */
    public static final AddressLayout PINIT_ONCE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_RUN_ONCE LPINIT_ONCE
     * }
     */
    public static final AddressLayout LPINIT_ONCE = wgl_h.C_POINTER;

    private static class InitOnceInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitOnceInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static FunctionDescriptor InitOnceInitialize$descriptor() {
        return InitOnceInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static MethodHandle InitOnceInitialize$handle() {
        return InitOnceInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static MemorySegment InitOnceInitialize$address() {
        return InitOnceInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static void InitOnceInitialize(MemorySegment InitOnce) {
        var mh$ = InitOnceInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceInitialize", InitOnce);
            }
            mh$.invokeExact(InitOnce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceExecuteOnce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitOnceExecuteOnce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static FunctionDescriptor InitOnceExecuteOnce$descriptor() {
        return InitOnceExecuteOnce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static MethodHandle InitOnceExecuteOnce$handle() {
        return InitOnceExecuteOnce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static MemorySegment InitOnceExecuteOnce$address() {
        return InitOnceExecuteOnce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static int InitOnceExecuteOnce(MemorySegment InitOnce, MemorySegment InitFn, MemorySegment Parameter, MemorySegment Context) {
        var mh$ = InitOnceExecuteOnce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceExecuteOnce", InitOnce, InitFn, Parameter, Context);
            }
            return (int)mh$.invokeExact(InitOnce, InitFn, Parameter, Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceBeginInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitOnceBeginInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor InitOnceBeginInitialize$descriptor() {
        return InitOnceBeginInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static MethodHandle InitOnceBeginInitialize$handle() {
        return InitOnceBeginInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static MemorySegment InitOnceBeginInitialize$address() {
        return InitOnceBeginInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static int InitOnceBeginInitialize(MemorySegment lpInitOnce, int dwFlags, MemorySegment fPending, MemorySegment lpContext) {
        var mh$ = InitOnceBeginInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceBeginInitialize", lpInitOnce, dwFlags, fPending, lpContext);
            }
            return (int)mh$.invokeExact(lpInitOnce, dwFlags, fPending, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceComplete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitOnceComplete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static FunctionDescriptor InitOnceComplete$descriptor() {
        return InitOnceComplete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static MethodHandle InitOnceComplete$handle() {
        return InitOnceComplete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static MemorySegment InitOnceComplete$address() {
        return InitOnceComplete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static int InitOnceComplete(MemorySegment lpInitOnce, int dwFlags, MemorySegment lpContext) {
        var mh$ = InitOnceComplete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceComplete", lpInitOnce, dwFlags, lpContext);
            }
            return (int)mh$.invokeExact(lpInitOnce, dwFlags, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef RTL_CONDITION_VARIABLE *PCONDITION_VARIABLE
     * }
     */
    public static final AddressLayout PCONDITION_VARIABLE = wgl_h.C_POINTER;

    private static class InitializeConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeConditionVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor InitializeConditionVariable$descriptor() {
        return InitializeConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle InitializeConditionVariable$handle() {
        return InitializeConditionVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MemorySegment InitializeConditionVariable$address() {
        return InitializeConditionVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void InitializeConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = InitializeConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WakeConditionVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor WakeConditionVariable$descriptor() {
        return WakeConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle WakeConditionVariable$handle() {
        return WakeConditionVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MemorySegment WakeConditionVariable$address() {
        return WakeConditionVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void WakeConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = WakeConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeAllConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WakeAllConditionVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor WakeAllConditionVariable$descriptor() {
        return WakeAllConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle WakeAllConditionVariable$handle() {
        return WakeAllConditionVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MemorySegment WakeAllConditionVariable$address() {
        return WakeAllConditionVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void WakeAllConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = WakeAllConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeAllConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepConditionVariableCS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SleepConditionVariableCS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor SleepConditionVariableCS$descriptor() {
        return SleepConditionVariableCS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle SleepConditionVariableCS$handle() {
        return SleepConditionVariableCS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment SleepConditionVariableCS$address() {
        return SleepConditionVariableCS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static int SleepConditionVariableCS(MemorySegment ConditionVariable, MemorySegment CriticalSection, int dwMilliseconds) {
        var mh$ = SleepConditionVariableCS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepConditionVariableCS", ConditionVariable, CriticalSection, dwMilliseconds);
            }
            return (int)mh$.invokeExact(ConditionVariable, CriticalSection, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepConditionVariableSRW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SleepConditionVariableSRW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static FunctionDescriptor SleepConditionVariableSRW$descriptor() {
        return SleepConditionVariableSRW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static MethodHandle SleepConditionVariableSRW$handle() {
        return SleepConditionVariableSRW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static MemorySegment SleepConditionVariableSRW$address() {
        return SleepConditionVariableSRW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static int SleepConditionVariableSRW(MemorySegment ConditionVariable, MemorySegment SRWLock, int dwMilliseconds, int Flags) {
        var mh$ = SleepConditionVariableSRW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepConditionVariableSRW", ConditionVariable, SRWLock, dwMilliseconds, Flags);
            }
            return (int)mh$.invokeExact(ConditionVariable, SRWLock, dwMilliseconds, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor SetEvent$descriptor() {
        return SetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static MethodHandle SetEvent$handle() {
        return SetEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static MemorySegment SetEvent$address() {
        return SetEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static int SetEvent(MemorySegment hEvent) {
        var mh$ = SetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEvent", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ResetEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor ResetEvent$descriptor() {
        return ResetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static MethodHandle ResetEvent$handle() {
        return ResetEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static MemorySegment ResetEvent$address() {
        return ResetEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static int ResetEvent(MemorySegment hEvent) {
        var mh$ = ResetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetEvent", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSemaphore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReleaseSemaphore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static FunctionDescriptor ReleaseSemaphore$descriptor() {
        return ReleaseSemaphore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static MethodHandle ReleaseSemaphore$handle() {
        return ReleaseSemaphore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static MemorySegment ReleaseSemaphore$address() {
        return ReleaseSemaphore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static int ReleaseSemaphore(MemorySegment hSemaphore, int lReleaseCount, MemorySegment lpPreviousCount) {
        var mh$ = ReleaseSemaphore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSemaphore", hSemaphore, lReleaseCount, lpPreviousCount);
            }
            return (int)mh$.invokeExact(hSemaphore, lReleaseCount, lpPreviousCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseMutex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReleaseMutex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static FunctionDescriptor ReleaseMutex$descriptor() {
        return ReleaseMutex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static MethodHandle ReleaseMutex$handle() {
        return ReleaseMutex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static MemorySegment ReleaseMutex$address() {
        return ReleaseMutex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static int ReleaseMutex(MemorySegment hMutex) {
        var mh$ = ReleaseMutex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseMutex", hMutex);
            }
            return (int)mh$.invokeExact(hMutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForSingleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitForSingleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForSingleObject$descriptor() {
        return WaitForSingleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForSingleObject$handle() {
        return WaitForSingleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForSingleObject$address() {
        return WaitForSingleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForSingleObject(MemorySegment hHandle, int dwMilliseconds) {
        var mh$ = WaitForSingleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForSingleObject", hHandle, dwMilliseconds);
            }
            return (int)mh$.invokeExact(hHandle, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SleepEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor SleepEx$descriptor() {
        return SleepEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle SleepEx$handle() {
        return SleepEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment SleepEx$address() {
        return SleepEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int SleepEx(int dwMilliseconds, int bAlertable) {
        var mh$ = SleepEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepEx", dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForSingleObjectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitForSingleObjectEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor WaitForSingleObjectEx$descriptor() {
        return WaitForSingleObjectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle WaitForSingleObjectEx$handle() {
        return WaitForSingleObjectEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment WaitForSingleObjectEx$address() {
        return WaitForSingleObjectEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int WaitForSingleObjectEx(MemorySegment hHandle, int dwMilliseconds, int bAlertable) {
        var mh$ = WaitForSingleObjectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForSingleObjectEx", hHandle, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hHandle, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForMultipleObjectsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitForMultipleObjectsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor WaitForMultipleObjectsEx$descriptor() {
        return WaitForMultipleObjectsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle WaitForMultipleObjectsEx$handle() {
        return WaitForMultipleObjectsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment WaitForMultipleObjectsEx$address() {
        return WaitForMultipleObjectsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int WaitForMultipleObjectsEx(int nCount, MemorySegment lpHandles, int bWaitAll, int dwMilliseconds, int bAlertable) {
        var mh$ = WaitForMultipleObjectsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForMultipleObjectsEx", nCount, lpHandles, bWaitAll, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(nCount, lpHandles, bWaitAll, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateMutexA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateMutexA$descriptor() {
        return CreateMutexA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateMutexA$handle() {
        return CreateMutexA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexA$address() {
        return CreateMutexA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexA(MemorySegment lpMutexAttributes, int bInitialOwner, MemorySegment lpName) {
        var mh$ = CreateMutexA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexA", lpMutexAttributes, bInitialOwner, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, bInitialOwner, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateMutexW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateMutexW$descriptor() {
        return CreateMutexW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateMutexW$handle() {
        return CreateMutexW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexW$address() {
        return CreateMutexW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexW(MemorySegment lpMutexAttributes, int bInitialOwner, MemorySegment lpName) {
        var mh$ = CreateMutexW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexW", lpMutexAttributes, bInitialOwner, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, bInitialOwner, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenMutexW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenMutexW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenMutexW$descriptor() {
        return OpenMutexW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenMutexW$handle() {
        return OpenMutexW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexW$address() {
        return OpenMutexW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenMutexW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenMutexW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateEventA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateEventA$descriptor() {
        return CreateEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateEventA$handle() {
        return CreateEventA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateEventA$address() {
        return CreateEventA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateEventA(MemorySegment lpEventAttributes, int bManualReset, int bInitialState, MemorySegment lpName) {
        var mh$ = CreateEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventA", lpEventAttributes, bManualReset, bInitialState, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, bManualReset, bInitialState, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateEventW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateEventW$descriptor() {
        return CreateEventW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateEventW$handle() {
        return CreateEventW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateEventW$address() {
        return CreateEventW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateEventW(MemorySegment lpEventAttributes, int bManualReset, int bInitialState, MemorySegment lpName) {
        var mh$ = CreateEventW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventW", lpEventAttributes, bManualReset, bInitialState, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, bManualReset, bInitialState, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenEventA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenEventA$descriptor() {
        return OpenEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenEventA$handle() {
        return OpenEventA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenEventA$address() {
        return OpenEventA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenEventA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenEventW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenEventW$descriptor() {
        return OpenEventW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenEventW$handle() {
        return OpenEventW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenEventW$address() {
        return OpenEventW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenEventW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenEventW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenSemaphoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenSemaphoreW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenSemaphoreW$descriptor() {
        return OpenSemaphoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenSemaphoreW$handle() {
        return OpenSemaphoreW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreW$address() {
        return OpenSemaphoreW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenSemaphoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenSemaphoreW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWaitableTimerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenWaitableTimerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor OpenWaitableTimerW$descriptor() {
        return OpenWaitableTimerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static MethodHandle OpenWaitableTimerW$handle() {
        return OpenWaitableTimerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerW$address() {
        return OpenWaitableTimerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpTimerName) {
        var mh$ = OpenWaitableTimerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWaitableTimerW", dwDesiredAccess, bInheritHandle, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWaitableTimerEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetWaitableTimerEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static FunctionDescriptor SetWaitableTimerEx$descriptor() {
        return SetWaitableTimerEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static MethodHandle SetWaitableTimerEx$handle() {
        return SetWaitableTimerEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static MemorySegment SetWaitableTimerEx$address() {
        return SetWaitableTimerEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static int SetWaitableTimerEx(MemorySegment hTimer, MemorySegment lpDueTime, int lPeriod, MemorySegment pfnCompletionRoutine, MemorySegment lpArgToCompletionRoutine, MemorySegment WakeContext, int TolerableDelay) {
        var mh$ = SetWaitableTimerEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWaitableTimerEx", hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, WakeContext, TolerableDelay);
            }
            return (int)mh$.invokeExact(hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, WakeContext, TolerableDelay);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWaitableTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetWaitableTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static FunctionDescriptor SetWaitableTimer$descriptor() {
        return SetWaitableTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static MethodHandle SetWaitableTimer$handle() {
        return SetWaitableTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static MemorySegment SetWaitableTimer$address() {
        return SetWaitableTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static int SetWaitableTimer(MemorySegment hTimer, MemorySegment lpDueTime, int lPeriod, MemorySegment pfnCompletionRoutine, MemorySegment lpArgToCompletionRoutine, int fResume) {
        var mh$ = SetWaitableTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWaitableTimer", hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, fResume);
            }
            return (int)mh$.invokeExact(hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, fResume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelWaitableTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CancelWaitableTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static FunctionDescriptor CancelWaitableTimer$descriptor() {
        return CancelWaitableTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static MethodHandle CancelWaitableTimer$handle() {
        return CancelWaitableTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static MemorySegment CancelWaitableTimer$address() {
        return CancelWaitableTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static int CancelWaitableTimer(MemorySegment hTimer) {
        var mh$ = CancelWaitableTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelWaitableTimer", hTimer);
            }
            return (int)mh$.invokeExact(hTimer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateMutexExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateMutexExA$descriptor() {
        return CreateMutexExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateMutexExA$handle() {
        return CreateMutexExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExA$address() {
        return CreateMutexExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExA(MemorySegment lpMutexAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateMutexExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexExA", lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateMutexExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateMutexExW$descriptor() {
        return CreateMutexExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateMutexExW$handle() {
        return CreateMutexExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExW$address() {
        return CreateMutexExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExW(MemorySegment lpMutexAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateMutexExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexExW", lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateEventExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateEventExA$descriptor() {
        return CreateEventExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateEventExA$handle() {
        return CreateEventExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExA$address() {
        return CreateEventExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExA(MemorySegment lpEventAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateEventExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventExA", lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateEventExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateEventExW$descriptor() {
        return CreateEventExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateEventExW$handle() {
        return CreateEventExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExW$address() {
        return CreateEventExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExW(MemorySegment lpEventAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateEventExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventExW", lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateSemaphoreExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreExW$descriptor() {
        return CreateSemaphoreExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateSemaphoreExW$handle() {
        return CreateSemaphoreExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExW$address() {
        return CreateSemaphoreExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExW(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateSemaphoreExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreExW", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateWaitableTimerExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerExW$descriptor() {
        return CreateWaitableTimerExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateWaitableTimerExW$handle() {
        return CreateWaitableTimerExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExW$address() {
        return CreateWaitableTimerExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExW(MemorySegment lpTimerAttributes, MemorySegment lpTimerName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateWaitableTimerExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerExW", lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER
     * }
     */
    public static final AddressLayout PSYNCHRONIZATION_BARRIER = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER
     * }
     */
    public static final AddressLayout LPSYNCHRONIZATION_BARRIER = wgl_h.C_POINTER;

    private static class EnterSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnterSynchronizationBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnterSynchronizationBarrier$descriptor() {
        return EnterSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnterSynchronizationBarrier$handle() {
        return EnterSynchronizationBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnterSynchronizationBarrier$address() {
        return EnterSynchronizationBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static int EnterSynchronizationBarrier(MemorySegment lpBarrier, int dwFlags) {
        var mh$ = EnterSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnterSynchronizationBarrier", lpBarrier, dwFlags);
            }
            return (int)mh$.invokeExact(lpBarrier, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeSynchronizationBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static FunctionDescriptor InitializeSynchronizationBarrier$descriptor() {
        return InitializeSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static MethodHandle InitializeSynchronizationBarrier$handle() {
        return InitializeSynchronizationBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static MemorySegment InitializeSynchronizationBarrier$address() {
        return InitializeSynchronizationBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static int InitializeSynchronizationBarrier(MemorySegment lpBarrier, int lTotalThreads, int lSpinCount) {
        var mh$ = InitializeSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSynchronizationBarrier", lpBarrier, lTotalThreads, lSpinCount);
            }
            return (int)mh$.invokeExact(lpBarrier, lTotalThreads, lSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteSynchronizationBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static FunctionDescriptor DeleteSynchronizationBarrier$descriptor() {
        return DeleteSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static MethodHandle DeleteSynchronizationBarrier$handle() {
        return DeleteSynchronizationBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static MemorySegment DeleteSynchronizationBarrier$address() {
        return DeleteSynchronizationBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static int DeleteSynchronizationBarrier(MemorySegment lpBarrier) {
        var mh$ = DeleteSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteSynchronizationBarrier", lpBarrier);
            }
            return (int)mh$.invokeExact(lpBarrier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor Sleep$descriptor() {
        return Sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle Sleep$handle() {
        return Sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment Sleep$address() {
        return Sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static void Sleep(int dwMilliseconds) {
        var mh$ = Sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Sleep", dwMilliseconds);
            }
            mh$.invokeExact(dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitOnAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitOnAddress$descriptor() {
        return WaitOnAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitOnAddress$handle() {
        return WaitOnAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitOnAddress$address() {
        return WaitOnAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static int WaitOnAddress(MemorySegment Address, MemorySegment CompareAddress, long AddressSize, int dwMilliseconds) {
        var mh$ = WaitOnAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnAddress", Address, CompareAddress, AddressSize, dwMilliseconds);
            }
            return (int)mh$.invokeExact(Address, CompareAddress, AddressSize, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeByAddressSingle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WakeByAddressSingle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static FunctionDescriptor WakeByAddressSingle$descriptor() {
        return WakeByAddressSingle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static MethodHandle WakeByAddressSingle$handle() {
        return WakeByAddressSingle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static MemorySegment WakeByAddressSingle$address() {
        return WakeByAddressSingle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static void WakeByAddressSingle(MemorySegment Address) {
        var mh$ = WakeByAddressSingle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeByAddressSingle", Address);
            }
            mh$.invokeExact(Address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeByAddressAll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WakeByAddressAll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static FunctionDescriptor WakeByAddressAll$descriptor() {
        return WakeByAddressAll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static MethodHandle WakeByAddressAll$handle() {
        return WakeByAddressAll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static MemorySegment WakeByAddressAll$address() {
        return WakeByAddressAll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static void WakeByAddressAll(MemorySegment Address) {
        var mh$ = WakeByAddressAll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeByAddressAll", Address);
            }
            mh$.invokeExact(Address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SignalObjectAndWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SignalObjectAndWait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor SignalObjectAndWait$descriptor() {
        return SignalObjectAndWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle SignalObjectAndWait$handle() {
        return SignalObjectAndWait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment SignalObjectAndWait$address() {
        return SignalObjectAndWait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int SignalObjectAndWait(MemorySegment hObjectToSignal, MemorySegment hObjectToWaitOn, int dwMilliseconds, int bAlertable) {
        var mh$ = SignalObjectAndWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SignalObjectAndWait", hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForMultipleObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitForMultipleObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForMultipleObjects$descriptor() {
        return WaitForMultipleObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForMultipleObjects$handle() {
        return WaitForMultipleObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForMultipleObjects$address() {
        return WaitForMultipleObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForMultipleObjects(int nCount, MemorySegment lpHandles, int bWaitAll, int dwMilliseconds) {
        var mh$ = WaitForMultipleObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForMultipleObjects", nCount, lpHandles, bWaitAll, dwMilliseconds);
            }
            return (int)mh$.invokeExact(nCount, lpHandles, bWaitAll, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateSemaphoreW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreW$descriptor() {
        return CreateSemaphoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateSemaphoreW$handle() {
        return CreateSemaphoreW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreW$address() {
        return CreateSemaphoreW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreW(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName) {
        var mh$ = CreateSemaphoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreW", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateWaitableTimerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerW$descriptor() {
        return CreateWaitableTimerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static MethodHandle CreateWaitableTimerW$handle() {
        return CreateWaitableTimerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerW$address() {
        return CreateWaitableTimerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerW(MemorySegment lpTimerAttributes, int bManualReset, MemorySegment lpTimerName) {
        var mh$ = CreateWaitableTimerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerW", lpTimerAttributes, bManualReset, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, bManualReset, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSListHead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeSListHead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InitializeSListHead$descriptor() {
        return InitializeSListHead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InitializeSListHead$handle() {
        return InitializeSListHead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InitializeSListHead$address() {
        return InitializeSListHead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static void InitializeSListHead(MemorySegment ListHead) {
        var mh$ = InitializeSListHead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSListHead", ListHead);
            }
            mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPopEntrySList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InterlockedPopEntrySList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InterlockedPopEntrySList$descriptor() {
        return InterlockedPopEntrySList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InterlockedPopEntrySList$handle() {
        return InterlockedPopEntrySList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedPopEntrySList$address() {
        return InterlockedPopEntrySList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedPopEntrySList(MemorySegment ListHead) {
        var mh$ = InterlockedPopEntrySList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPopEntrySList", ListHead);
            }
            return (MemorySegment)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPushEntrySList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InterlockedPushEntrySList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static FunctionDescriptor InterlockedPushEntrySList$descriptor() {
        return InterlockedPushEntrySList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MethodHandle InterlockedPushEntrySList$handle() {
        return InterlockedPushEntrySList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MemorySegment InterlockedPushEntrySList$address() {
        return InterlockedPushEntrySList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MemorySegment InterlockedPushEntrySList(MemorySegment ListHead, MemorySegment ListEntry) {
        var mh$ = InterlockedPushEntrySList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPushEntrySList", ListHead, ListEntry);
            }
            return (MemorySegment)mh$.invokeExact(ListHead, ListEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPushListSListEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InterlockedPushListSListEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static FunctionDescriptor InterlockedPushListSListEx$descriptor() {
        return InterlockedPushListSListEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static MethodHandle InterlockedPushListSListEx$handle() {
        return InterlockedPushListSListEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static MemorySegment InterlockedPushListSListEx$address() {
        return InterlockedPushListSListEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static MemorySegment InterlockedPushListSListEx(MemorySegment ListHead, MemorySegment List, MemorySegment ListEnd, int Count) {
        var mh$ = InterlockedPushListSListEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPushListSListEx", ListHead, List, ListEnd, Count);
            }
            return (MemorySegment)mh$.invokeExact(ListHead, List, ListEnd, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedFlushSList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InterlockedFlushSList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InterlockedFlushSList$descriptor() {
        return InterlockedFlushSList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InterlockedFlushSList$handle() {
        return InterlockedFlushSList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedFlushSList$address() {
        return InterlockedFlushSList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedFlushSList(MemorySegment ListHead) {
        var mh$ = InterlockedFlushSList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedFlushSList", ListHead);
            }
            return (MemorySegment)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDepthSList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryDepthSList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor QueryDepthSList$descriptor() {
        return QueryDepthSList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle QueryDepthSList$handle() {
        return QueryDepthSList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment QueryDepthSList$address() {
        return QueryDepthSList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static short QueryDepthSList(MemorySegment ListHead) {
        var mh$ = QueryDepthSList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDepthSList", ListHead);
            }
            return (short)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_INFORMATION {
     *     HANDLE hProcess;
     *     HANDLE hThread;
     *     DWORD dwProcessId;
     *     DWORD dwThreadId;
     * } *PPROCESS_INFORMATION
     * }
     */
    public static final AddressLayout PPROCESS_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_INFORMATION {
     *     HANDLE hProcess;
     *     HANDLE hThread;
     *     DWORD dwProcessId;
     *     DWORD dwThreadId;
     * } *LPPROCESS_INFORMATION
     * }
     */
    public static final AddressLayout LPPROCESS_INFORMATION = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOA {
     *     DWORD cb;
     *     LPSTR lpReserved;
     *     LPSTR lpDesktop;
     *     LPSTR lpTitle;
     *     DWORD dwX;
     *     DWORD dwY;
     *     DWORD dwXSize;
     *     DWORD dwYSize;
     *     DWORD dwXCountChars;
     *     DWORD dwYCountChars;
     *     DWORD dwFillAttribute;
     *     DWORD dwFlags;
     *     WORD wShowWindow;
     *     WORD cbReserved2;
     *     LPBYTE lpReserved2;
     *     HANDLE hStdInput;
     *     HANDLE hStdOutput;
     *     HANDLE hStdError;
     * } *LPSTARTUPINFOA
     * }
     */
    public static final AddressLayout LPSTARTUPINFOA = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOW {
     *     DWORD cb;
     *     LPWSTR lpReserved;
     *     LPWSTR lpDesktop;
     *     LPWSTR lpTitle;
     *     DWORD dwX;
     *     DWORD dwY;
     *     DWORD dwXSize;
     *     DWORD dwYSize;
     *     DWORD dwXCountChars;
     *     DWORD dwYCountChars;
     *     DWORD dwFillAttribute;
     *     DWORD dwFlags;
     *     WORD wShowWindow;
     *     WORD cbReserved2;
     *     LPBYTE lpReserved2;
     *     HANDLE hStdInput;
     *     HANDLE hStdOutput;
     *     HANDLE hStdError;
     * } *LPSTARTUPINFOW
     * }
     */
    public static final AddressLayout LPSTARTUPINFOW = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTARTUPINFOA LPSTARTUPINFO
     * }
     */
    public static final AddressLayout LPSTARTUPINFO = wgl_h.C_POINTER;

    private static class QueueUserAPC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueueUserAPC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor QueueUserAPC$descriptor() {
        return QueueUserAPC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle QueueUserAPC$handle() {
        return QueueUserAPC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static MemorySegment QueueUserAPC$address() {
        return QueueUserAPC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static int QueueUserAPC(MemorySegment pfnAPC, MemorySegment hThread, long dwData) {
        var mh$ = QueueUserAPC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueueUserAPC", pfnAPC, hThread, dwData);
            }
            return (int)mh$.invokeExact(pfnAPC, hThread, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessTimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessTimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static FunctionDescriptor GetProcessTimes$descriptor() {
        return GetProcessTimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MethodHandle GetProcessTimes$handle() {
        return GetProcessTimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MemorySegment GetProcessTimes$address() {
        return GetProcessTimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static int GetProcessTimes(MemorySegment hProcess, MemorySegment lpCreationTime, MemorySegment lpExitTime, MemorySegment lpKernelTime, MemorySegment lpUserTime) {
        var mh$ = GetProcessTimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessTimes", hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
            }
            return (int)mh$.invokeExact(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static FunctionDescriptor GetCurrentProcess$descriptor() {
        return GetCurrentProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static MethodHandle GetCurrentProcess$handle() {
        return GetCurrentProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static MemorySegment GetCurrentProcess$address() {
        return GetCurrentProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static MemorySegment GetCurrentProcess() {
        var mh$ = GetCurrentProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcess");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentProcessId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static FunctionDescriptor GetCurrentProcessId$descriptor() {
        return GetCurrentProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static MethodHandle GetCurrentProcessId$handle() {
        return GetCurrentProcessId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static MemorySegment GetCurrentProcessId$address() {
        return GetCurrentProcessId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static int GetCurrentProcessId() {
        var mh$ = GetCurrentProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcessId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExitProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExitProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static FunctionDescriptor ExitProcess$descriptor() {
        return ExitProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static MethodHandle ExitProcess$handle() {
        return ExitProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static MemorySegment ExitProcess$address() {
        return ExitProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static void ExitProcess(int uExitCode) {
        var mh$ = ExitProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExitProcess", uExitCode);
            }
            mh$.invokeExact(uExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TerminateProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static FunctionDescriptor TerminateProcess$descriptor() {
        return TerminateProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static MethodHandle TerminateProcess$handle() {
        return TerminateProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static MemorySegment TerminateProcess$address() {
        return TerminateProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static int TerminateProcess(MemorySegment hProcess, int uExitCode) {
        var mh$ = TerminateProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateProcess", hProcess, uExitCode);
            }
            return (int)mh$.invokeExact(hProcess, uExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExitCodeProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetExitCodeProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static FunctionDescriptor GetExitCodeProcess$descriptor() {
        return GetExitCodeProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static MethodHandle GetExitCodeProcess$handle() {
        return GetExitCodeProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static MemorySegment GetExitCodeProcess$address() {
        return GetExitCodeProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static int GetExitCodeProcess(MemorySegment hProcess, MemorySegment lpExitCode) {
        var mh$ = GetExitCodeProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExitCodeProcess", hProcess, lpExitCode);
            }
            return (int)mh$.invokeExact(hProcess, lpExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchToThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SwitchToThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static FunctionDescriptor SwitchToThread$descriptor() {
        return SwitchToThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static MethodHandle SwitchToThread$handle() {
        return SwitchToThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static MemorySegment SwitchToThread$address() {
        return SwitchToThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static int SwitchToThread() {
        var mh$ = SwitchToThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchToThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static FunctionDescriptor CreateThread$descriptor() {
        return CreateThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MethodHandle CreateThread$handle() {
        return CreateThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateThread$address() {
        return CreateThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateThread(MemorySegment lpThreadAttributes, long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter, int dwCreationFlags, MemorySegment lpThreadId) {
        var mh$ = CreateThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThread", lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
            }
            return (MemorySegment)mh$.invokeExact(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRemoteThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateRemoteThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static FunctionDescriptor CreateRemoteThread$descriptor() {
        return CreateRemoteThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MethodHandle CreateRemoteThread$handle() {
        return CreateRemoteThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateRemoteThread$address() {
        return CreateRemoteThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateRemoteThread(MemorySegment hProcess, MemorySegment lpThreadAttributes, long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter, int dwCreationFlags, MemorySegment lpThreadId) {
        var mh$ = CreateRemoteThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRemoteThread", hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetCurrentThread()
     * }
     */
    public static FunctionDescriptor GetCurrentThread$descriptor() {
        return GetCurrentThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetCurrentThread()
     * }
     */
    public static MethodHandle GetCurrentThread$handle() {
        return GetCurrentThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetCurrentThread()
     * }
     */
    public static MemorySegment GetCurrentThread$address() {
        return GetCurrentThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetCurrentThread()
     * }
     */
    public static MemorySegment GetCurrentThread() {
        var mh$ = GetCurrentThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentThread");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentThreadId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentThreadId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentThreadId()
     * }
     */
    public static FunctionDescriptor GetCurrentThreadId$descriptor() {
        return GetCurrentThreadId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentThreadId()
     * }
     */
    public static MethodHandle GetCurrentThreadId$handle() {
        return GetCurrentThreadId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCurrentThreadId()
     * }
     */
    public static MemorySegment GetCurrentThreadId$address() {
        return GetCurrentThreadId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCurrentThreadId()
     * }
     */
    public static int GetCurrentThreadId() {
        var mh$ = GetCurrentThreadId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentThreadId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
     * }
     */
    public static FunctionDescriptor OpenThread$descriptor() {
        return OpenThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
     * }
     */
    public static MethodHandle OpenThread$handle() {
        return OpenThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
     * }
     */
    public static MemorySegment OpenThread$address() {
        return OpenThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
     * }
     */
    public static MemorySegment OpenThread(int dwDesiredAccess, int bInheritHandle, int dwThreadId) {
        var mh$ = OpenThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenThread", dwDesiredAccess, bInheritHandle, dwThreadId);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, dwThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPriority(HANDLE hThread, int nPriority)
     * }
     */
    public static FunctionDescriptor SetThreadPriority$descriptor() {
        return SetThreadPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPriority(HANDLE hThread, int nPriority)
     * }
     */
    public static MethodHandle SetThreadPriority$handle() {
        return SetThreadPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadPriority(HANDLE hThread, int nPriority)
     * }
     */
    public static MemorySegment SetThreadPriority$address() {
        return SetThreadPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadPriority(HANDLE hThread, int nPriority)
     * }
     */
    public static int SetThreadPriority(MemorySegment hThread, int nPriority) {
        var mh$ = SetThreadPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPriority", hThread, nPriority);
            }
            return (int)mh$.invokeExact(hThread, nPriority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadPriorityBoost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor SetThreadPriorityBoost$descriptor() {
        return SetThreadPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost)
     * }
     */
    public static MethodHandle SetThreadPriorityBoost$handle() {
        return SetThreadPriorityBoost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost)
     * }
     */
    public static MemorySegment SetThreadPriorityBoost$address() {
        return SetThreadPriorityBoost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost)
     * }
     */
    public static int SetThreadPriorityBoost(MemorySegment hThread, int bDisablePriorityBoost) {
        var mh$ = SetThreadPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPriorityBoost", hThread, bDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hThread, bDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadPriorityBoost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor GetThreadPriorityBoost$descriptor() {
        return GetThreadPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost)
     * }
     */
    public static MethodHandle GetThreadPriorityBoost$handle() {
        return GetThreadPriorityBoost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost)
     * }
     */
    public static MemorySegment GetThreadPriorityBoost$address() {
        return GetThreadPriorityBoost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost)
     * }
     */
    public static int GetThreadPriorityBoost(MemorySegment hThread, MemorySegment pDisablePriorityBoost) {
        var mh$ = GetThreadPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadPriorityBoost", hThread, pDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hThread, pDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetThreadPriority(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor GetThreadPriority$descriptor() {
        return GetThreadPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetThreadPriority(HANDLE hThread)
     * }
     */
    public static MethodHandle GetThreadPriority$handle() {
        return GetThreadPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetThreadPriority(HANDLE hThread)
     * }
     */
    public static MemorySegment GetThreadPriority$address() {
        return GetThreadPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetThreadPriority(HANDLE hThread)
     * }
     */
    public static int GetThreadPriority(MemorySegment hThread) {
        var mh$ = GetThreadPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadPriority", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExitThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ExitThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExitThread(DWORD dwExitCode)
     * }
     */
    public static FunctionDescriptor ExitThread$descriptor() {
        return ExitThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExitThread(DWORD dwExitCode)
     * }
     */
    public static MethodHandle ExitThread$handle() {
        return ExitThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ExitThread(DWORD dwExitCode)
     * }
     */
    public static MemorySegment ExitThread$address() {
        return ExitThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ExitThread(DWORD dwExitCode)
     * }
     */
    public static void ExitThread(int dwExitCode) {
        var mh$ = ExitThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExitThread", dwExitCode);
            }
            mh$.invokeExact(dwExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TerminateThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
     * }
     */
    public static FunctionDescriptor TerminateThread$descriptor() {
        return TerminateThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
     * }
     */
    public static MethodHandle TerminateThread$handle() {
        return TerminateThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
     * }
     */
    public static MemorySegment TerminateThread$address() {
        return TerminateThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
     * }
     */
    public static int TerminateThread(MemorySegment hThread, int dwExitCode) {
        var mh$ = TerminateThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateThread", hThread, dwExitCode);
            }
            return (int)mh$.invokeExact(hThread, dwExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExitCodeThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetExitCodeThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)
     * }
     */
    public static FunctionDescriptor GetExitCodeThread$descriptor() {
        return GetExitCodeThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)
     * }
     */
    public static MethodHandle GetExitCodeThread$handle() {
        return GetExitCodeThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)
     * }
     */
    public static MemorySegment GetExitCodeThread$address() {
        return GetExitCodeThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)
     * }
     */
    public static int GetExitCodeThread(MemorySegment hThread, MemorySegment lpExitCode) {
        var mh$ = GetExitCodeThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExitCodeThread", hThread, lpExitCode);
            }
            return (int)mh$.invokeExact(hThread, lpExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SuspendThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SuspendThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SuspendThread(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor SuspendThread$descriptor() {
        return SuspendThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SuspendThread(HANDLE hThread)
     * }
     */
    public static MethodHandle SuspendThread$handle() {
        return SuspendThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SuspendThread(HANDLE hThread)
     * }
     */
    public static MemorySegment SuspendThread$address() {
        return SuspendThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SuspendThread(HANDLE hThread)
     * }
     */
    public static int SuspendThread(MemorySegment hThread) {
        var mh$ = SuspendThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SuspendThread", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResumeThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ResumeThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ResumeThread(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor ResumeThread$descriptor() {
        return ResumeThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ResumeThread(HANDLE hThread)
     * }
     */
    public static MethodHandle ResumeThread$handle() {
        return ResumeThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ResumeThread(HANDLE hThread)
     * }
     */
    public static MemorySegment ResumeThread$address() {
        return ResumeThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ResumeThread(HANDLE hThread)
     * }
     */
    public static int ResumeThread(MemorySegment hThread) {
        var mh$ = ResumeThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResumeThread", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TlsAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD TlsAlloc()
     * }
     */
    public static FunctionDescriptor TlsAlloc$descriptor() {
        return TlsAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD TlsAlloc()
     * }
     */
    public static MethodHandle TlsAlloc$handle() {
        return TlsAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD TlsAlloc()
     * }
     */
    public static MemorySegment TlsAlloc$address() {
        return TlsAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD TlsAlloc()
     * }
     */
    public static int TlsAlloc() {
        var mh$ = TlsAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsAlloc");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsGetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TlsGetValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID TlsGetValue(DWORD dwTlsIndex)
     * }
     */
    public static FunctionDescriptor TlsGetValue$descriptor() {
        return TlsGetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID TlsGetValue(DWORD dwTlsIndex)
     * }
     */
    public static MethodHandle TlsGetValue$handle() {
        return TlsGetValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID TlsGetValue(DWORD dwTlsIndex)
     * }
     */
    public static MemorySegment TlsGetValue$address() {
        return TlsGetValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID TlsGetValue(DWORD dwTlsIndex)
     * }
     */
    public static MemorySegment TlsGetValue(int dwTlsIndex) {
        var mh$ = TlsGetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsGetValue", dwTlsIndex);
            }
            return (MemorySegment)mh$.invokeExact(dwTlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsSetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TlsSetValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
     * }
     */
    public static FunctionDescriptor TlsSetValue$descriptor() {
        return TlsSetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
     * }
     */
    public static MethodHandle TlsSetValue$handle() {
        return TlsSetValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
     * }
     */
    public static MemorySegment TlsSetValue$address() {
        return TlsSetValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
     * }
     */
    public static int TlsSetValue(int dwTlsIndex, MemorySegment lpTlsValue) {
        var mh$ = TlsSetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsSetValue", dwTlsIndex, lpTlsValue);
            }
            return (int)mh$.invokeExact(dwTlsIndex, lpTlsValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TlsFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TlsFree(DWORD dwTlsIndex)
     * }
     */
    public static FunctionDescriptor TlsFree$descriptor() {
        return TlsFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TlsFree(DWORD dwTlsIndex)
     * }
     */
    public static MethodHandle TlsFree$handle() {
        return TlsFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TlsFree(DWORD dwTlsIndex)
     * }
     */
    public static MemorySegment TlsFree$address() {
        return TlsFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TlsFree(DWORD dwTlsIndex)
     * }
     */
    public static int TlsFree(int dwTlsIndex) {
        var mh$ = TlsFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsFree", dwTlsIndex);
            }
            return (int)mh$.invokeExact(dwTlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateProcessA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessA$descriptor() {
        return CreateProcessA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessA$handle() {
        return CreateProcessA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessA$address() {
        return CreateProcessA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessA(MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessA", lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateProcessW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessW$descriptor() {
        return CreateProcessW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessW$handle() {
        return CreateProcessW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessW$address() {
        return CreateProcessW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessW(MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessW", lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessShutdownParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessShutdownParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetProcessShutdownParameters$descriptor() {
        return SetProcessShutdownParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetProcessShutdownParameters$handle() {
        return SetProcessShutdownParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetProcessShutdownParameters$address() {
        return SetProcessShutdownParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags)
     * }
     */
    public static int SetProcessShutdownParameters(int dwLevel, int dwFlags) {
        var mh$ = SetProcessShutdownParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessShutdownParameters", dwLevel, dwFlags);
            }
            return (int)mh$.invokeExact(dwLevel, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessVersion(DWORD ProcessId)
     * }
     */
    public static FunctionDescriptor GetProcessVersion$descriptor() {
        return GetProcessVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessVersion(DWORD ProcessId)
     * }
     */
    public static MethodHandle GetProcessVersion$handle() {
        return GetProcessVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProcessVersion(DWORD ProcessId)
     * }
     */
    public static MemorySegment GetProcessVersion$address() {
        return GetProcessVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProcessVersion(DWORD ProcessId)
     * }
     */
    public static int GetProcessVersion(int ProcessId) {
        var mh$ = GetProcessVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessVersion", ProcessId);
            }
            return (int)mh$.invokeExact(ProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStartupInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetStartupInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
     * }
     */
    public static FunctionDescriptor GetStartupInfoW$descriptor() {
        return GetStartupInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
     * }
     */
    public static MethodHandle GetStartupInfoW$handle() {
        return GetStartupInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
     * }
     */
    public static MemorySegment GetStartupInfoW$address() {
        return GetStartupInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
     * }
     */
    public static void GetStartupInfoW(MemorySegment lpStartupInfo) {
        var mh$ = GetStartupInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStartupInfoW", lpStartupInfo);
            }
            mh$.invokeExact(lpStartupInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessAsUserW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateProcessAsUserW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessAsUserW$descriptor() {
        return CreateProcessAsUserW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessAsUserW$handle() {
        return CreateProcessAsUserW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessAsUserW$address() {
        return CreateProcessAsUserW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessAsUserW(MemorySegment hToken, MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessAsUserW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessAsUserW", hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadToken(PHANDLE Thread, HANDLE Token)
     * }
     */
    public static FunctionDescriptor SetThreadToken$descriptor() {
        return SetThreadToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadToken(PHANDLE Thread, HANDLE Token)
     * }
     */
    public static MethodHandle SetThreadToken$handle() {
        return SetThreadToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadToken(PHANDLE Thread, HANDLE Token)
     * }
     */
    public static MemorySegment SetThreadToken$address() {
        return SetThreadToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadToken(PHANDLE Thread, HANDLE Token)
     * }
     */
    public static int SetThreadToken(MemorySegment Thread, MemorySegment Token) {
        var mh$ = SetThreadToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadToken", Thread, Token);
            }
            return (int)mh$.invokeExact(Thread, Token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenProcessToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenProcessToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor OpenProcessToken$descriptor() {
        return OpenProcessToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
     * }
     */
    public static MethodHandle OpenProcessToken$handle() {
        return OpenProcessToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
     * }
     */
    public static MemorySegment OpenProcessToken$address() {
        return OpenProcessToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
     * }
     */
    public static int OpenProcessToken(MemorySegment ProcessHandle, int DesiredAccess, MemorySegment TokenHandle) {
        var mh$ = OpenProcessToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenProcessToken", ProcessHandle, DesiredAccess, TokenHandle);
            }
            return (int)mh$.invokeExact(ProcessHandle, DesiredAccess, TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenThreadToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenThreadToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor OpenThreadToken$descriptor() {
        return OpenThreadToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle)
     * }
     */
    public static MethodHandle OpenThreadToken$handle() {
        return OpenThreadToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle)
     * }
     */
    public static MemorySegment OpenThreadToken$address() {
        return OpenThreadToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle)
     * }
     */
    public static int OpenThreadToken(MemorySegment ThreadHandle, int DesiredAccess, int OpenAsSelf, MemorySegment TokenHandle) {
        var mh$ = OpenThreadToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenThreadToken", ThreadHandle, DesiredAccess, OpenAsSelf, TokenHandle);
            }
            return (int)mh$.invokeExact(ThreadHandle, DesiredAccess, OpenAsSelf, TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPriorityClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetPriorityClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
     * }
     */
    public static FunctionDescriptor SetPriorityClass$descriptor() {
        return SetPriorityClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
     * }
     */
    public static MethodHandle SetPriorityClass$handle() {
        return SetPriorityClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
     * }
     */
    public static MemorySegment SetPriorityClass$address() {
        return SetPriorityClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
     * }
     */
    public static int SetPriorityClass(MemorySegment hProcess, int dwPriorityClass) {
        var mh$ = SetPriorityClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPriorityClass", hProcess, dwPriorityClass);
            }
            return (int)mh$.invokeExact(hProcess, dwPriorityClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPriorityClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPriorityClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPriorityClass(HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor GetPriorityClass$descriptor() {
        return GetPriorityClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPriorityClass(HANDLE hProcess)
     * }
     */
    public static MethodHandle GetPriorityClass$handle() {
        return GetPriorityClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPriorityClass(HANDLE hProcess)
     * }
     */
    public static MemorySegment GetPriorityClass$address() {
        return GetPriorityClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPriorityClass(HANDLE hProcess)
     * }
     */
    public static int GetPriorityClass(MemorySegment hProcess) {
        var mh$ = GetPriorityClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPriorityClass", hProcess);
            }
            return (int)mh$.invokeExact(hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadStackGuarantee {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadStackGuarantee");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadStackGuarantee(PULONG StackSizeInBytes)
     * }
     */
    public static FunctionDescriptor SetThreadStackGuarantee$descriptor() {
        return SetThreadStackGuarantee.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadStackGuarantee(PULONG StackSizeInBytes)
     * }
     */
    public static MethodHandle SetThreadStackGuarantee$handle() {
        return SetThreadStackGuarantee.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadStackGuarantee(PULONG StackSizeInBytes)
     * }
     */
    public static MemorySegment SetThreadStackGuarantee$address() {
        return SetThreadStackGuarantee.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadStackGuarantee(PULONG StackSizeInBytes)
     * }
     */
    public static int SetThreadStackGuarantee(MemorySegment StackSizeInBytes) {
        var mh$ = SetThreadStackGuarantee.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadStackGuarantee", StackSizeInBytes);
            }
            return (int)mh$.invokeExact(StackSizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProcessIdToSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ProcessIdToSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId)
     * }
     */
    public static FunctionDescriptor ProcessIdToSessionId$descriptor() {
        return ProcessIdToSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId)
     * }
     */
    public static MethodHandle ProcessIdToSessionId$handle() {
        return ProcessIdToSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId)
     * }
     */
    public static MemorySegment ProcessIdToSessionId$address() {
        return ProcessIdToSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId)
     * }
     */
    public static int ProcessIdToSessionId(int dwProcessId, MemorySegment pSessionId) {
        var mh$ = ProcessIdToSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProcessIdToSessionId", dwProcessId, pSessionId);
            }
            return (int)mh$.invokeExact(dwProcessId, pSessionId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST
     * }
     */
    public static final AddressLayout PPROC_THREAD_ATTRIBUTE_LIST = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROC_THREAD_ATTRIBUTE_LIST *LPPROC_THREAD_ATTRIBUTE_LIST
     * }
     */
    public static final AddressLayout LPPROC_THREAD_ATTRIBUTE_LIST = wgl_h.C_POINTER;

    private static class GetProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessId(HANDLE Process)
     * }
     */
    public static FunctionDescriptor GetProcessId$descriptor() {
        return GetProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessId(HANDLE Process)
     * }
     */
    public static MethodHandle GetProcessId$handle() {
        return GetProcessId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProcessId(HANDLE Process)
     * }
     */
    public static MemorySegment GetProcessId$address() {
        return GetProcessId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProcessId(HANDLE Process)
     * }
     */
    public static int GetProcessId(MemorySegment Process) {
        var mh$ = GetProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessId", Process);
            }
            return (int)mh$.invokeExact(Process);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetThreadId(HANDLE Thread)
     * }
     */
    public static FunctionDescriptor GetThreadId$descriptor() {
        return GetThreadId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetThreadId(HANDLE Thread)
     * }
     */
    public static MethodHandle GetThreadId$handle() {
        return GetThreadId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetThreadId(HANDLE Thread)
     * }
     */
    public static MemorySegment GetThreadId$address() {
        return GetThreadId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetThreadId(HANDLE Thread)
     * }
     */
    public static int GetThreadId(MemorySegment Thread) {
        var mh$ = GetThreadId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadId", Thread);
            }
            return (int)mh$.invokeExact(Thread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushProcessWriteBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FlushProcessWriteBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlushProcessWriteBuffers()
     * }
     */
    public static FunctionDescriptor FlushProcessWriteBuffers$descriptor() {
        return FlushProcessWriteBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlushProcessWriteBuffers()
     * }
     */
    public static MethodHandle FlushProcessWriteBuffers$handle() {
        return FlushProcessWriteBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlushProcessWriteBuffers()
     * }
     */
    public static MemorySegment FlushProcessWriteBuffers$address() {
        return FlushProcessWriteBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlushProcessWriteBuffers()
     * }
     */
    public static void FlushProcessWriteBuffers() {
        var mh$ = FlushProcessWriteBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushProcessWriteBuffers");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessIdOfThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessIdOfThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessIdOfThread(HANDLE Thread)
     * }
     */
    public static FunctionDescriptor GetProcessIdOfThread$descriptor() {
        return GetProcessIdOfThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessIdOfThread(HANDLE Thread)
     * }
     */
    public static MethodHandle GetProcessIdOfThread$handle() {
        return GetProcessIdOfThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProcessIdOfThread(HANDLE Thread)
     * }
     */
    public static MemorySegment GetProcessIdOfThread$address() {
        return GetProcessIdOfThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProcessIdOfThread(HANDLE Thread)
     * }
     */
    public static int GetProcessIdOfThread(MemorySegment Thread) {
        var mh$ = GetProcessIdOfThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessIdOfThread", Thread);
            }
            return (int)mh$.invokeExact(Thread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeProcThreadAttributeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeProcThreadAttributeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize)
     * }
     */
    public static FunctionDescriptor InitializeProcThreadAttributeList$descriptor() {
        return InitializeProcThreadAttributeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize)
     * }
     */
    public static MethodHandle InitializeProcThreadAttributeList$handle() {
        return InitializeProcThreadAttributeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize)
     * }
     */
    public static MemorySegment InitializeProcThreadAttributeList$address() {
        return InitializeProcThreadAttributeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize)
     * }
     */
    public static int InitializeProcThreadAttributeList(MemorySegment lpAttributeList, int dwAttributeCount, int dwFlags, MemorySegment lpSize) {
        var mh$ = InitializeProcThreadAttributeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeProcThreadAttributeList", lpAttributeList, dwAttributeCount, dwFlags, lpSize);
            }
            return (int)mh$.invokeExact(lpAttributeList, dwAttributeCount, dwFlags, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteProcThreadAttributeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteProcThreadAttributeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList)
     * }
     */
    public static FunctionDescriptor DeleteProcThreadAttributeList$descriptor() {
        return DeleteProcThreadAttributeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList)
     * }
     */
    public static MethodHandle DeleteProcThreadAttributeList$handle() {
        return DeleteProcThreadAttributeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList)
     * }
     */
    public static MemorySegment DeleteProcThreadAttributeList$address() {
        return DeleteProcThreadAttributeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList)
     * }
     */
    public static void DeleteProcThreadAttributeList(MemorySegment lpAttributeList) {
        var mh$ = DeleteProcThreadAttributeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteProcThreadAttributeList", lpAttributeList);
            }
            mh$.invokeExact(lpAttributeList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateProcThreadAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UpdateProcThreadAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize)
     * }
     */
    public static FunctionDescriptor UpdateProcThreadAttribute$descriptor() {
        return UpdateProcThreadAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize)
     * }
     */
    public static MethodHandle UpdateProcThreadAttribute$handle() {
        return UpdateProcThreadAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize)
     * }
     */
    public static MemorySegment UpdateProcThreadAttribute$address() {
        return UpdateProcThreadAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize)
     * }
     */
    public static int UpdateProcThreadAttribute(MemorySegment lpAttributeList, int dwFlags, long Attribute, MemorySegment lpValue, long cbSize, MemorySegment lpPreviousValue, MemorySegment lpReturnSize) {
        var mh$ = UpdateProcThreadAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateProcThreadAttribute", lpAttributeList, dwFlags, Attribute, lpValue, cbSize, lpPreviousValue, lpReturnSize);
            }
            return (int)mh$.invokeExact(lpAttributeList, dwFlags, Attribute, lpValue, cbSize, lpPreviousValue, lpReturnSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDynamicEHContinuationTargets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessDynamicEHContinuationTargets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEHContinuationTargets(HANDLE Process, USHORT NumberOfTargets, PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets)
     * }
     */
    public static FunctionDescriptor SetProcessDynamicEHContinuationTargets$descriptor() {
        return SetProcessDynamicEHContinuationTargets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEHContinuationTargets(HANDLE Process, USHORT NumberOfTargets, PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets)
     * }
     */
    public static MethodHandle SetProcessDynamicEHContinuationTargets$handle() {
        return SetProcessDynamicEHContinuationTargets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEHContinuationTargets(HANDLE Process, USHORT NumberOfTargets, PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets)
     * }
     */
    public static MemorySegment SetProcessDynamicEHContinuationTargets$address() {
        return SetProcessDynamicEHContinuationTargets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEHContinuationTargets(HANDLE Process, USHORT NumberOfTargets, PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets)
     * }
     */
    public static int SetProcessDynamicEHContinuationTargets(MemorySegment Process, short NumberOfTargets, MemorySegment Targets) {
        var mh$ = SetProcessDynamicEHContinuationTargets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDynamicEHContinuationTargets", Process, NumberOfTargets, Targets);
            }
            return (int)mh$.invokeExact(Process, NumberOfTargets, Targets);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDynamicEnforcedCetCompatibleRanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessDynamicEnforcedCetCompatibleRanges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEnforcedCetCompatibleRanges(HANDLE Process, USHORT NumberOfRanges, PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges)
     * }
     */
    public static FunctionDescriptor SetProcessDynamicEnforcedCetCompatibleRanges$descriptor() {
        return SetProcessDynamicEnforcedCetCompatibleRanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEnforcedCetCompatibleRanges(HANDLE Process, USHORT NumberOfRanges, PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges)
     * }
     */
    public static MethodHandle SetProcessDynamicEnforcedCetCompatibleRanges$handle() {
        return SetProcessDynamicEnforcedCetCompatibleRanges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEnforcedCetCompatibleRanges(HANDLE Process, USHORT NumberOfRanges, PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges)
     * }
     */
    public static MemorySegment SetProcessDynamicEnforcedCetCompatibleRanges$address() {
        return SetProcessDynamicEnforcedCetCompatibleRanges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEnforcedCetCompatibleRanges(HANDLE Process, USHORT NumberOfRanges, PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges)
     * }
     */
    public static int SetProcessDynamicEnforcedCetCompatibleRanges(MemorySegment Process, short NumberOfRanges, MemorySegment Ranges) {
        var mh$ = SetProcessDynamicEnforcedCetCompatibleRanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDynamicEnforcedCetCompatibleRanges", Process, NumberOfRanges, Ranges);
            }
            return (int)mh$.invokeExact(Process, NumberOfRanges, Ranges);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessAffinityUpdateMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessAffinityUpdateMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetProcessAffinityUpdateMode$descriptor() {
        return SetProcessAffinityUpdateMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetProcessAffinityUpdateMode$handle() {
        return SetProcessAffinityUpdateMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetProcessAffinityUpdateMode$address() {
        return SetProcessAffinityUpdateMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags)
     * }
     */
    public static int SetProcessAffinityUpdateMode(MemorySegment hProcess, int dwFlags) {
        var mh$ = SetProcessAffinityUpdateMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessAffinityUpdateMode", hProcess, dwFlags);
            }
            return (int)mh$.invokeExact(hProcess, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryProcessAffinityUpdateMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryProcessAffinityUpdateMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags)
     * }
     */
    public static FunctionDescriptor QueryProcessAffinityUpdateMode$descriptor() {
        return QueryProcessAffinityUpdateMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags)
     * }
     */
    public static MethodHandle QueryProcessAffinityUpdateMode$handle() {
        return QueryProcessAffinityUpdateMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags)
     * }
     */
    public static MemorySegment QueryProcessAffinityUpdateMode$address() {
        return QueryProcessAffinityUpdateMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags)
     * }
     */
    public static int QueryProcessAffinityUpdateMode(MemorySegment hProcess, MemorySegment lpdwFlags) {
        var mh$ = QueryProcessAffinityUpdateMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryProcessAffinityUpdateMode", hProcess, lpdwFlags);
            }
            return (int)mh$.invokeExact(hProcess, lpdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRemoteThreadEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateRemoteThreadEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId)
     * }
     */
    public static FunctionDescriptor CreateRemoteThreadEx$descriptor() {
        return CreateRemoteThreadEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId)
     * }
     */
    public static MethodHandle CreateRemoteThreadEx$handle() {
        return CreateRemoteThreadEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateRemoteThreadEx$address() {
        return CreateRemoteThreadEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateRemoteThreadEx(MemorySegment hProcess, MemorySegment lpThreadAttributes, long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter, int dwCreationFlags, MemorySegment lpAttributeList, MemorySegment lpThreadId) {
        var mh$ = CreateRemoteThreadEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRemoteThreadEx", hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpAttributeList, lpThreadId);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpAttributeList, lpThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentThreadStackLimits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentThreadStackLimits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit)
     * }
     */
    public static FunctionDescriptor GetCurrentThreadStackLimits$descriptor() {
        return GetCurrentThreadStackLimits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit)
     * }
     */
    public static MethodHandle GetCurrentThreadStackLimits$handle() {
        return GetCurrentThreadStackLimits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit)
     * }
     */
    public static MemorySegment GetCurrentThreadStackLimits$address() {
        return GetCurrentThreadStackLimits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit)
     * }
     */
    public static void GetCurrentThreadStackLimits(MemorySegment LowLimit, MemorySegment HighLimit) {
        var mh$ = GetCurrentThreadStackLimits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentThreadStackLimits", LowLimit, HighLimit);
            }
            mh$.invokeExact(LowLimit, HighLimit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
     * }
     */
    public static FunctionDescriptor GetThreadContext$descriptor() {
        return GetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
     * }
     */
    public static MethodHandle GetThreadContext$handle() {
        return GetThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
     * }
     */
    public static MemorySegment GetThreadContext$address() {
        return GetThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
     * }
     */
    public static int GetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = GetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessMitigationPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessMitigationPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor GetProcessMitigationPolicy$descriptor() {
        return GetProcessMitigationPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle GetProcessMitigationPolicy$handle() {
        return GetProcessMitigationPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MemorySegment GetProcessMitigationPolicy$address() {
        return GetProcessMitigationPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static int GetProcessMitigationPolicy(MemorySegment hProcess, int MitigationPolicy, MemorySegment lpBuffer, long dwLength) {
        var mh$ = GetProcessMitigationPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessMitigationPolicy", hProcess, MitigationPolicy, lpBuffer, dwLength);
            }
            return (int)mh$.invokeExact(hProcess, MitigationPolicy, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
     * }
     */
    public static FunctionDescriptor SetThreadContext$descriptor() {
        return SetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
     * }
     */
    public static MethodHandle SetThreadContext$handle() {
        return SetThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
     * }
     */
    public static MemorySegment SetThreadContext$address() {
        return SetThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
     * }
     */
    public static int SetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = SetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessMitigationPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessMitigationPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor SetProcessMitigationPolicy$descriptor() {
        return SetProcessMitigationPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle SetProcessMitigationPolicy$handle() {
        return SetProcessMitigationPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MemorySegment SetProcessMitigationPolicy$address() {
        return SetProcessMitigationPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static int SetProcessMitigationPolicy(int MitigationPolicy, MemorySegment lpBuffer, long dwLength) {
        var mh$ = SetProcessMitigationPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessMitigationPolicy", MitigationPolicy, lpBuffer, dwLength);
            }
            return (int)mh$.invokeExact(MitigationPolicy, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushInstructionCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FlushInstructionCache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
     * }
     */
    public static FunctionDescriptor FlushInstructionCache$descriptor() {
        return FlushInstructionCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
     * }
     */
    public static MethodHandle FlushInstructionCache$handle() {
        return FlushInstructionCache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
     * }
     */
    public static MemorySegment FlushInstructionCache$address() {
        return FlushInstructionCache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
     * }
     */
    public static int FlushInstructionCache(MemorySegment hProcess, MemorySegment lpBaseAddress, long dwSize) {
        var mh$ = FlushInstructionCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushInstructionCache", hProcess, lpBaseAddress, dwSize);
            }
            return (int)mh$.invokeExact(hProcess, lpBaseAddress, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadTimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadTimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static FunctionDescriptor GetThreadTimes$descriptor() {
        return GetThreadTimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MethodHandle GetThreadTimes$handle() {
        return GetThreadTimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MemorySegment GetThreadTimes$address() {
        return GetThreadTimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static int GetThreadTimes(MemorySegment hThread, MemorySegment lpCreationTime, MemorySegment lpExitTime, MemorySegment lpKernelTime, MemorySegment lpUserTime) {
        var mh$ = GetThreadTimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadTimes", hThread, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
            }
            return (int)mh$.invokeExact(hThread, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor OpenProcess$descriptor() {
        return OpenProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
     * }
     */
    public static MethodHandle OpenProcess$handle() {
        return OpenProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
     * }
     */
    public static MemorySegment OpenProcess$address() {
        return OpenProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
     * }
     */
    public static MemorySegment OpenProcess(int dwDesiredAccess, int bInheritHandle, int dwProcessId) {
        var mh$ = OpenProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenProcess", dwDesiredAccess, bInheritHandle, dwProcessId);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsProcessorFeaturePresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsProcessorFeaturePresent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
     * }
     */
    public static FunctionDescriptor IsProcessorFeaturePresent$descriptor() {
        return IsProcessorFeaturePresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
     * }
     */
    public static MethodHandle IsProcessorFeaturePresent$handle() {
        return IsProcessorFeaturePresent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
     * }
     */
    public static MemorySegment IsProcessorFeaturePresent$address() {
        return IsProcessorFeaturePresent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
     * }
     */
    public static int IsProcessorFeaturePresent(int ProcessorFeature) {
        var mh$ = IsProcessorFeaturePresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsProcessorFeaturePresent", ProcessorFeature);
            }
            return (int)mh$.invokeExact(ProcessorFeature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessHandleCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessHandleCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
     * }
     */
    public static FunctionDescriptor GetProcessHandleCount$descriptor() {
        return GetProcessHandleCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
     * }
     */
    public static MethodHandle GetProcessHandleCount$handle() {
        return GetProcessHandleCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
     * }
     */
    public static MemorySegment GetProcessHandleCount$address() {
        return GetProcessHandleCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
     * }
     */
    public static int GetProcessHandleCount(MemorySegment hProcess, MemorySegment pdwHandleCount) {
        var mh$ = GetProcessHandleCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessHandleCount", hProcess, pdwHandleCount);
            }
            return (int)mh$.invokeExact(hProcess, pdwHandleCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcessorNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentProcessorNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessorNumber()
     * }
     */
    public static FunctionDescriptor GetCurrentProcessorNumber$descriptor() {
        return GetCurrentProcessorNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessorNumber()
     * }
     */
    public static MethodHandle GetCurrentProcessorNumber$handle() {
        return GetCurrentProcessorNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessorNumber()
     * }
     */
    public static MemorySegment GetCurrentProcessorNumber$address() {
        return GetCurrentProcessorNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCurrentProcessorNumber()
     * }
     */
    public static int GetCurrentProcessorNumber() {
        var mh$ = GetCurrentProcessorNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcessorNumber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadIdealProcessorEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadIdealProcessorEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor)
     * }
     */
    public static FunctionDescriptor SetThreadIdealProcessorEx$descriptor() {
        return SetThreadIdealProcessorEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor)
     * }
     */
    public static MethodHandle SetThreadIdealProcessorEx$handle() {
        return SetThreadIdealProcessorEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor)
     * }
     */
    public static MemorySegment SetThreadIdealProcessorEx$address() {
        return SetThreadIdealProcessorEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor)
     * }
     */
    public static int SetThreadIdealProcessorEx(MemorySegment hThread, MemorySegment lpIdealProcessor, MemorySegment lpPreviousIdealProcessor) {
        var mh$ = SetThreadIdealProcessorEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadIdealProcessorEx", hThread, lpIdealProcessor, lpPreviousIdealProcessor);
            }
            return (int)mh$.invokeExact(hThread, lpIdealProcessor, lpPreviousIdealProcessor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadIdealProcessorEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadIdealProcessorEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor)
     * }
     */
    public static FunctionDescriptor GetThreadIdealProcessorEx$descriptor() {
        return GetThreadIdealProcessorEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor)
     * }
     */
    public static MethodHandle GetThreadIdealProcessorEx$handle() {
        return GetThreadIdealProcessorEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor)
     * }
     */
    public static MemorySegment GetThreadIdealProcessorEx$address() {
        return GetThreadIdealProcessorEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor)
     * }
     */
    public static int GetThreadIdealProcessorEx(MemorySegment hThread, MemorySegment lpIdealProcessor) {
        var mh$ = GetThreadIdealProcessorEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadIdealProcessorEx", hThread, lpIdealProcessor);
            }
            return (int)mh$.invokeExact(hThread, lpIdealProcessor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcessorNumberEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCurrentProcessorNumberEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
     * }
     */
    public static FunctionDescriptor GetCurrentProcessorNumberEx$descriptor() {
        return GetCurrentProcessorNumberEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
     * }
     */
    public static MethodHandle GetCurrentProcessorNumberEx$handle() {
        return GetCurrentProcessorNumberEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
     * }
     */
    public static MemorySegment GetCurrentProcessorNumberEx$address() {
        return GetCurrentProcessorNumberEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
     * }
     */
    public static void GetCurrentProcessorNumberEx(MemorySegment ProcNumber) {
        var mh$ = GetCurrentProcessorNumberEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcessorNumberEx", ProcNumber);
            }
            mh$.invokeExact(ProcNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessPriorityBoost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor GetProcessPriorityBoost$descriptor() {
        return GetProcessPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
     * }
     */
    public static MethodHandle GetProcessPriorityBoost$handle() {
        return GetProcessPriorityBoost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
     * }
     */
    public static MemorySegment GetProcessPriorityBoost$address() {
        return GetProcessPriorityBoost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
     * }
     */
    public static int GetProcessPriorityBoost(MemorySegment hProcess, MemorySegment pDisablePriorityBoost) {
        var mh$ = GetProcessPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessPriorityBoost", hProcess, pDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hProcess, pDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessPriorityBoost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor SetProcessPriorityBoost$descriptor() {
        return SetProcessPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
     * }
     */
    public static MethodHandle SetProcessPriorityBoost$handle() {
        return SetProcessPriorityBoost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
     * }
     */
    public static MemorySegment SetProcessPriorityBoost$address() {
        return SetProcessPriorityBoost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
     * }
     */
    public static int SetProcessPriorityBoost(MemorySegment hProcess, int bDisablePriorityBoost) {
        var mh$ = SetProcessPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessPriorityBoost", hProcess, bDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hProcess, bDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadIOPendingFlag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadIOPendingFlag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
     * }
     */
    public static FunctionDescriptor GetThreadIOPendingFlag$descriptor() {
        return GetThreadIOPendingFlag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
     * }
     */
    public static MethodHandle GetThreadIOPendingFlag$handle() {
        return GetThreadIOPendingFlag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
     * }
     */
    public static MemorySegment GetThreadIOPendingFlag$address() {
        return GetThreadIOPendingFlag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
     * }
     */
    public static int GetThreadIOPendingFlag(MemorySegment hThread, MemorySegment lpIOIsPending) {
        var mh$ = GetThreadIOPendingFlag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadIOPendingFlag", hThread, lpIOIsPending);
            }
            return (int)mh$.invokeExact(hThread, lpIOIsPending);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemTimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime)
     * }
     */
    public static FunctionDescriptor GetSystemTimes$descriptor() {
        return GetSystemTimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime)
     * }
     */
    public static MethodHandle GetSystemTimes$handle() {
        return GetSystemTimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime)
     * }
     */
    public static MemorySegment GetSystemTimes$address() {
        return GetSystemTimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime)
     * }
     */
    public static int GetSystemTimes(MemorySegment lpIdleTime, MemorySegment lpKernelTime, MemorySegment lpUserTime) {
        var mh$ = GetSystemTimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimes", lpIdleTime, lpKernelTime, lpUserTime);
            }
            return (int)mh$.invokeExact(lpIdleTime, lpKernelTime, lpUserTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ThreadMemoryPriority = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadMemoryPriority = 0
     * }
     */
    public static int ThreadMemoryPriority() {
        return ThreadMemoryPriority;
    }
    private static final int ThreadAbsoluteCpuPriority = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadAbsoluteCpuPriority = 1
     * }
     */
    public static int ThreadAbsoluteCpuPriority() {
        return ThreadAbsoluteCpuPriority;
    }
    private static final int ThreadDynamicCodePolicy = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadDynamicCodePolicy = 2
     * }
     */
    public static int ThreadDynamicCodePolicy() {
        return ThreadDynamicCodePolicy;
    }
    private static final int ThreadPowerThrottling = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadPowerThrottling = 3
     * }
     */
    public static int ThreadPowerThrottling() {
        return ThreadPowerThrottling;
    }
    private static final int ThreadInformationClassMax = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadInformationClassMax = 4
     * }
     */
    public static int ThreadInformationClassMax() {
        return ThreadInformationClassMax;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORY_PRIORITY_INFORMATION {
     *     ULONG MemoryPriority;
     * } *PMEMORY_PRIORITY_INFORMATION
     * }
     */
    public static final AddressLayout PMEMORY_PRIORITY_INFORMATION = wgl_h.C_POINTER;

    private static class GetThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static FunctionDescriptor GetThreadInformation$descriptor() {
        return GetThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static MethodHandle GetThreadInformation$handle() {
        return GetThreadInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static MemorySegment GetThreadInformation$address() {
        return GetThreadInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static int GetThreadInformation(MemorySegment hThread, int ThreadInformationClass, MemorySegment ThreadInformation, int ThreadInformationSize) {
        var mh$ = GetThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadInformation", hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
            }
            return (int)mh$.invokeExact(hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static FunctionDescriptor SetThreadInformation$descriptor() {
        return SetThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static MethodHandle SetThreadInformation$handle() {
        return SetThreadInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static MemorySegment SetThreadInformation$address() {
        return SetThreadInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static int SetThreadInformation(MemorySegment hThread, int ThreadInformationClass, MemorySegment ThreadInformation, int ThreadInformationSize) {
        var mh$ = SetThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadInformation", hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
            }
            return (int)mh$.invokeExact(hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsProcessCritical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsProcessCritical");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsProcessCritical(HANDLE hProcess, PBOOL Critical)
     * }
     */
    public static FunctionDescriptor IsProcessCritical$descriptor() {
        return IsProcessCritical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsProcessCritical(HANDLE hProcess, PBOOL Critical)
     * }
     */
    public static MethodHandle IsProcessCritical$handle() {
        return IsProcessCritical.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsProcessCritical(HANDLE hProcess, PBOOL Critical)
     * }
     */
    public static MemorySegment IsProcessCritical$address() {
        return IsProcessCritical.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsProcessCritical(HANDLE hProcess, PBOOL Critical)
     * }
     */
    public static int IsProcessCritical(MemorySegment hProcess, MemorySegment Critical) {
        var mh$ = IsProcessCritical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsProcessCritical", hProcess, Critical);
            }
            return (int)mh$.invokeExact(hProcess, Critical);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProtectedPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProtectedPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue)
     * }
     */
    public static FunctionDescriptor SetProtectedPolicy$descriptor() {
        return SetProtectedPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue)
     * }
     */
    public static MethodHandle SetProtectedPolicy$handle() {
        return SetProtectedPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue)
     * }
     */
    public static MemorySegment SetProtectedPolicy$address() {
        return SetProtectedPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue)
     * }
     */
    public static int SetProtectedPolicy(MemorySegment PolicyGuid, long PolicyValue, MemorySegment OldPolicyValue) {
        var mh$ = SetProtectedPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProtectedPolicy", PolicyGuid, PolicyValue, OldPolicyValue);
            }
            return (int)mh$.invokeExact(PolicyGuid, PolicyValue, OldPolicyValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryProtectedPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryProtectedPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue)
     * }
     */
    public static FunctionDescriptor QueryProtectedPolicy$descriptor() {
        return QueryProtectedPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue)
     * }
     */
    public static MethodHandle QueryProtectedPolicy$handle() {
        return QueryProtectedPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue)
     * }
     */
    public static MemorySegment QueryProtectedPolicy$address() {
        return QueryProtectedPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue)
     * }
     */
    public static int QueryProtectedPolicy(MemorySegment PolicyGuid, MemorySegment PolicyValue) {
        var mh$ = QueryProtectedPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryProtectedPolicy", PolicyGuid, PolicyValue);
            }
            return (int)mh$.invokeExact(PolicyGuid, PolicyValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadIdealProcessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadIdealProcessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
     * }
     */
    public static FunctionDescriptor SetThreadIdealProcessor$descriptor() {
        return SetThreadIdealProcessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
     * }
     */
    public static MethodHandle SetThreadIdealProcessor$handle() {
        return SetThreadIdealProcessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
     * }
     */
    public static MemorySegment SetThreadIdealProcessor$address() {
        return SetThreadIdealProcessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
     * }
     */
    public static int SetThreadIdealProcessor(MemorySegment hThread, int dwIdealProcessor) {
        var mh$ = SetThreadIdealProcessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadIdealProcessor", hThread, dwIdealProcessor);
            }
            return (int)mh$.invokeExact(hThread, dwIdealProcessor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ProcessMemoryPriority = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessMemoryPriority = 0
     * }
     */
    public static int ProcessMemoryPriority() {
        return ProcessMemoryPriority;
    }
    private static final int ProcessMemoryExhaustionInfo = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessMemoryExhaustionInfo = 1
     * }
     */
    public static int ProcessMemoryExhaustionInfo() {
        return ProcessMemoryExhaustionInfo;
    }
    private static final int ProcessAppMemoryInfo = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessAppMemoryInfo = 2
     * }
     */
    public static int ProcessAppMemoryInfo() {
        return ProcessAppMemoryInfo;
    }
    private static final int ProcessInPrivateInfo = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessInPrivateInfo = 3
     * }
     */
    public static int ProcessInPrivateInfo() {
        return ProcessInPrivateInfo;
    }
    private static final int ProcessPowerThrottling = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessPowerThrottling = 4
     * }
     */
    public static int ProcessPowerThrottling() {
        return ProcessPowerThrottling;
    }
    private static final int ProcessReservedValue1 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessReservedValue1 = 5
     * }
     */
    public static int ProcessReservedValue1() {
        return ProcessReservedValue1;
    }
    private static final int ProcessTelemetryCoverageInfo = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessTelemetryCoverageInfo = 6
     * }
     */
    public static int ProcessTelemetryCoverageInfo() {
        return ProcessTelemetryCoverageInfo;
    }
    private static final int ProcessProtectionLevelInfo = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessProtectionLevelInfo = 7
     * }
     */
    public static int ProcessProtectionLevelInfo() {
        return ProcessProtectionLevelInfo;
    }
    private static final int ProcessLeapSecondInfo = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessLeapSecondInfo = 8
     * }
     */
    public static int ProcessLeapSecondInfo() {
        return ProcessLeapSecondInfo;
    }
    private static final int ProcessInformationClassMax = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessInformationClassMax = 9
     * }
     */
    public static int ProcessInformationClassMax() {
        return ProcessInformationClassMax;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _APP_MEMORY_INFORMATION {
     *     ULONG64 AvailableCommit;
     *     ULONG64 PrivateCommitUsage;
     *     ULONG64 PeakPrivateCommitUsage;
     *     ULONG64 TotalCommitUsage;
     * } *PAPP_MEMORY_INFORMATION
     * }
     */
    public static final AddressLayout PAPP_MEMORY_INFORMATION = wgl_h.C_POINTER;
    private static final int PMETypeFailFastOnCommitFailure = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeFailFastOnCommitFailure = 0
     * }
     */
    public static int PMETypeFailFastOnCommitFailure() {
        return PMETypeFailFastOnCommitFailure;
    }
    private static final int PMETypeMax = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeMax = 1
     * }
     */
    public static int PMETypeMax() {
        return PMETypeMax;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _PROCESS_MEMORY_EXHAUSTION_TYPE {
     *     PMETypeFailFastOnCommitFailure,
     *     PMETypeMax
     * } *PPROCESS_MEMORY_EXHAUSTION_TYPE
     * }
     */
    public static final AddressLayout PPROCESS_MEMORY_EXHAUSTION_TYPE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MEMORY_EXHAUSTION_INFO {
     *     USHORT Version;
     *     USHORT Reserved;
     *     PROCESS_MEMORY_EXHAUSTION_TYPE Type;
     *     ULONG_PTR Value;
     * } *PPROCESS_MEMORY_EXHAUSTION_INFO
     * }
     */
    public static final AddressLayout PPROCESS_MEMORY_EXHAUSTION_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_POWER_THROTTLING_STATE {
     *     ULONG Version;
     *     ULONG ControlMask;
     *     ULONG StateMask;
     * } *PPROCESS_POWER_THROTTLING_STATE
     * }
     */
    public static final AddressLayout PPROCESS_POWER_THROTTLING_STATE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_LEAP_SECOND_INFO {
     *     ULONG Flags;
     *     ULONG Reserved;
     * } *PPROCESS_LEAP_SECOND_INFO
     * }
     */
    public static final AddressLayout PPROCESS_LEAP_SECOND_INFO = wgl_h.C_POINTER;

    private static class SetProcessInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static FunctionDescriptor SetProcessInformation$descriptor() {
        return SetProcessInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static MethodHandle SetProcessInformation$handle() {
        return SetProcessInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static MemorySegment SetProcessInformation$address() {
        return SetProcessInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static int SetProcessInformation(MemorySegment hProcess, int ProcessInformationClass, MemorySegment ProcessInformation, int ProcessInformationSize) {
        var mh$ = SetProcessInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessInformation", hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
            }
            return (int)mh$.invokeExact(hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static FunctionDescriptor GetProcessInformation$descriptor() {
        return GetProcessInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static MethodHandle GetProcessInformation$handle() {
        return GetProcessInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static MemorySegment GetProcessInformation$address() {
        return GetProcessInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static int GetProcessInformation(MemorySegment hProcess, int ProcessInformationClass, MemorySegment ProcessInformation, int ProcessInformationSize) {
        var mh$ = GetProcessInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessInformation", hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
            }
            return (int)mh$.invokeExact(hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemCpuSetInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemCpuSetInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemCpuSetInformation(PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags)
     * }
     */
    public static FunctionDescriptor GetSystemCpuSetInformation$descriptor() {
        return GetSystemCpuSetInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemCpuSetInformation(PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags)
     * }
     */
    public static MethodHandle GetSystemCpuSetInformation$handle() {
        return GetSystemCpuSetInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemCpuSetInformation(PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags)
     * }
     */
    public static MemorySegment GetSystemCpuSetInformation$address() {
        return GetSystemCpuSetInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemCpuSetInformation(PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags)
     * }
     */
    public static int GetSystemCpuSetInformation(MemorySegment Information, int BufferLength, MemorySegment ReturnedLength, MemorySegment Process, int Flags) {
        var mh$ = GetSystemCpuSetInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemCpuSetInformation", Information, BufferLength, ReturnedLength, Process, Flags);
            }
            return (int)mh$.invokeExact(Information, BufferLength, ReturnedLength, Process, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessDefaultCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessDefaultCpuSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static FunctionDescriptor GetProcessDefaultCpuSets$descriptor() {
        return GetProcessDefaultCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static MethodHandle GetProcessDefaultCpuSets$handle() {
        return GetProcessDefaultCpuSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static MemorySegment GetProcessDefaultCpuSets$address() {
        return GetProcessDefaultCpuSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static int GetProcessDefaultCpuSets(MemorySegment Process, MemorySegment CpuSetIds, int CpuSetIdCount, MemorySegment RequiredIdCount) {
        var mh$ = GetProcessDefaultCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessDefaultCpuSets", Process, CpuSetIds, CpuSetIdCount, RequiredIdCount);
            }
            return (int)mh$.invokeExact(Process, CpuSetIds, CpuSetIdCount, RequiredIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDefaultCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessDefaultCpuSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSets(HANDLE Process, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static FunctionDescriptor SetProcessDefaultCpuSets$descriptor() {
        return SetProcessDefaultCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSets(HANDLE Process, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static MethodHandle SetProcessDefaultCpuSets$handle() {
        return SetProcessDefaultCpuSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSets(HANDLE Process, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static MemorySegment SetProcessDefaultCpuSets$address() {
        return SetProcessDefaultCpuSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSets(HANDLE Process, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static int SetProcessDefaultCpuSets(MemorySegment Process, MemorySegment CpuSetIds, int CpuSetIdCount) {
        var mh$ = SetProcessDefaultCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDefaultCpuSets", Process, CpuSetIds, CpuSetIdCount);
            }
            return (int)mh$.invokeExact(Process, CpuSetIds, CpuSetIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadSelectedCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadSelectedCpuSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static FunctionDescriptor GetThreadSelectedCpuSets$descriptor() {
        return GetThreadSelectedCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static MethodHandle GetThreadSelectedCpuSets$handle() {
        return GetThreadSelectedCpuSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static MemorySegment GetThreadSelectedCpuSets$address() {
        return GetThreadSelectedCpuSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static int GetThreadSelectedCpuSets(MemorySegment Thread, MemorySegment CpuSetIds, int CpuSetIdCount, MemorySegment RequiredIdCount) {
        var mh$ = GetThreadSelectedCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadSelectedCpuSets", Thread, CpuSetIds, CpuSetIdCount, RequiredIdCount);
            }
            return (int)mh$.invokeExact(Thread, CpuSetIds, CpuSetIdCount, RequiredIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadSelectedCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadSelectedCpuSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSets(HANDLE Thread, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static FunctionDescriptor SetThreadSelectedCpuSets$descriptor() {
        return SetThreadSelectedCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSets(HANDLE Thread, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static MethodHandle SetThreadSelectedCpuSets$handle() {
        return SetThreadSelectedCpuSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSets(HANDLE Thread, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static MemorySegment SetThreadSelectedCpuSets$address() {
        return SetThreadSelectedCpuSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSets(HANDLE Thread, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static int SetThreadSelectedCpuSets(MemorySegment Thread, MemorySegment CpuSetIds, int CpuSetIdCount) {
        var mh$ = SetThreadSelectedCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadSelectedCpuSets", Thread, CpuSetIds, CpuSetIdCount);
            }
            return (int)mh$.invokeExact(Thread, CpuSetIds, CpuSetIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessAsUserA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateProcessAsUserA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessAsUserA$descriptor() {
        return CreateProcessAsUserA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessAsUserA$handle() {
        return CreateProcessAsUserA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessAsUserA$address() {
        return CreateProcessAsUserA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessAsUserA(MemorySegment hToken, MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessAsUserA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessAsUserA", hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessShutdownParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessShutdownParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
     * }
     */
    public static FunctionDescriptor GetProcessShutdownParameters$descriptor() {
        return GetProcessShutdownParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
     * }
     */
    public static MethodHandle GetProcessShutdownParameters$handle() {
        return GetProcessShutdownParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
     * }
     */
    public static MemorySegment GetProcessShutdownParameters$address() {
        return GetProcessShutdownParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
     * }
     */
    public static int GetProcessShutdownParameters(MemorySegment lpdwLevel, MemorySegment lpdwFlags) {
        var mh$ = GetProcessShutdownParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessShutdownParameters", lpdwLevel, lpdwFlags);
            }
            return (int)mh$.invokeExact(lpdwLevel, lpdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription)
     * }
     */
    public static FunctionDescriptor SetThreadDescription$descriptor() {
        return SetThreadDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription)
     * }
     */
    public static MethodHandle SetThreadDescription$handle() {
        return SetThreadDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription)
     * }
     */
    public static MemorySegment SetThreadDescription$address() {
        return SetThreadDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription)
     * }
     */
    public static int SetThreadDescription(MemorySegment hThread, MemorySegment lpThreadDescription) {
        var mh$ = SetThreadDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadDescription", hThread, lpThreadDescription);
            }
            return (int)mh$.invokeExact(hThread, lpThreadDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetThreadDescription(HANDLE hThread, PWSTR *ppszThreadDescription)
     * }
     */
    public static FunctionDescriptor GetThreadDescription$descriptor() {
        return GetThreadDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetThreadDescription(HANDLE hThread, PWSTR *ppszThreadDescription)
     * }
     */
    public static MethodHandle GetThreadDescription$handle() {
        return GetThreadDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetThreadDescription(HANDLE hThread, PWSTR *ppszThreadDescription)
     * }
     */
    public static MemorySegment GetThreadDescription$address() {
        return GetThreadDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetThreadDescription(HANDLE hThread, PWSTR *ppszThreadDescription)
     * }
     */
    public static int GetThreadDescription(MemorySegment hThread, MemorySegment ppszThreadDescription) {
        var mh$ = GetThreadDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadDescription", hThread, ppszThreadDescription);
            }
            return (int)mh$.invokeExact(hThread, ppszThreadDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_INFO {
     *     union {
     *         DWORD dwOemId;
     *         struct {
     *             WORD wProcessorArchitecture;
     *             WORD wReserved;
     *         };
     *     };
     *     DWORD dwPageSize;
     *     LPVOID lpMinimumApplicationAddress;
     *     LPVOID lpMaximumApplicationAddress;
     *     DWORD_PTR dwActiveProcessorMask;
     *     DWORD dwNumberOfProcessors;
     *     DWORD dwProcessorType;
     *     DWORD dwAllocationGranularity;
     *     WORD wProcessorLevel;
     *     WORD wProcessorRevision;
     * } *LPSYSTEM_INFO
     * }
     */
    public static final AddressLayout LPSYSTEM_INFO = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORYSTATUSEX {
     *     DWORD dwLength;
     *     DWORD dwMemoryLoad;
     *     DWORDLONG ullTotalPhys;
     *     DWORDLONG ullAvailPhys;
     *     DWORDLONG ullTotalPageFile;
     *     DWORDLONG ullAvailPageFile;
     *     DWORDLONG ullTotalVirtual;
     *     DWORDLONG ullAvailVirtual;
     *     DWORDLONG ullAvailExtendedVirtual;
     * } *LPMEMORYSTATUSEX
     * }
     */
    public static final AddressLayout LPMEMORYSTATUSEX = wgl_h.C_POINTER;

    private static class GlobalMemoryStatusEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GlobalMemoryStatusEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer)
     * }
     */
    public static FunctionDescriptor GlobalMemoryStatusEx$descriptor() {
        return GlobalMemoryStatusEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer)
     * }
     */
    public static MethodHandle GlobalMemoryStatusEx$handle() {
        return GlobalMemoryStatusEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer)
     * }
     */
    public static MemorySegment GlobalMemoryStatusEx$address() {
        return GlobalMemoryStatusEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer)
     * }
     */
    public static int GlobalMemoryStatusEx(MemorySegment lpBuffer) {
        var mh$ = GlobalMemoryStatusEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalMemoryStatusEx", lpBuffer);
            }
            return (int)mh$.invokeExact(lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static FunctionDescriptor GetSystemInfo$descriptor() {
        return GetSystemInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static MethodHandle GetSystemInfo$handle() {
        return GetSystemInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static MemorySegment GetSystemInfo$address() {
        return GetSystemInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static void GetSystemInfo(MemorySegment lpSystemInfo) {
        var mh$ = GetSystemInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemInfo", lpSystemInfo);
            }
            mh$.invokeExact(lpSystemInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static FunctionDescriptor GetSystemTime$descriptor() {
        return GetSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MethodHandle GetSystemTime$handle() {
        return GetSystemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetSystemTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MemorySegment GetSystemTime$address() {
        return GetSystemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetSystemTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static void GetSystemTime(MemorySegment lpSystemTime) {
        var mh$ = GetSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTime", lpSystemTime);
            }
            mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimeAsFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemTimeAsFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static FunctionDescriptor GetSystemTimeAsFileTime$descriptor() {
        return GetSystemTimeAsFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static MethodHandle GetSystemTimeAsFileTime$handle() {
        return GetSystemTimeAsFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static MemorySegment GetSystemTimeAsFileTime$address() {
        return GetSystemTimeAsFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static void GetSystemTimeAsFileTime(MemorySegment lpSystemTimeAsFileTime) {
        var mh$ = GetSystemTimeAsFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimeAsFileTime", lpSystemTimeAsFileTime);
            }
            mh$.invokeExact(lpSystemTimeAsFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLocalTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetLocalTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static FunctionDescriptor GetLocalTime$descriptor() {
        return GetLocalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetLocalTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MethodHandle GetLocalTime$handle() {
        return GetLocalTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetLocalTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MemorySegment GetLocalTime$address() {
        return GetLocalTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetLocalTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static void GetLocalTime(MemorySegment lpSystemTime) {
        var mh$ = GetLocalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocalTime", lpSystemTime);
            }
            mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsUserCetAvailableInEnvironment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsUserCetAvailableInEnvironment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsUserCetAvailableInEnvironment(DWORD UserCetEnvironment)
     * }
     */
    public static FunctionDescriptor IsUserCetAvailableInEnvironment$descriptor() {
        return IsUserCetAvailableInEnvironment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsUserCetAvailableInEnvironment(DWORD UserCetEnvironment)
     * }
     */
    public static MethodHandle IsUserCetAvailableInEnvironment$handle() {
        return IsUserCetAvailableInEnvironment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsUserCetAvailableInEnvironment(DWORD UserCetEnvironment)
     * }
     */
    public static MemorySegment IsUserCetAvailableInEnvironment$address() {
        return IsUserCetAvailableInEnvironment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsUserCetAvailableInEnvironment(DWORD UserCetEnvironment)
     * }
     */
    public static int IsUserCetAvailableInEnvironment(int UserCetEnvironment) {
        var mh$ = IsUserCetAvailableInEnvironment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsUserCetAvailableInEnvironment", UserCetEnvironment);
            }
            return (int)mh$.invokeExact(UserCetEnvironment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemLeapSecondInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemLeapSecondInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemLeapSecondInformation(PBOOL Enabled, PDWORD Flags)
     * }
     */
    public static FunctionDescriptor GetSystemLeapSecondInformation$descriptor() {
        return GetSystemLeapSecondInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemLeapSecondInformation(PBOOL Enabled, PDWORD Flags)
     * }
     */
    public static MethodHandle GetSystemLeapSecondInformation$handle() {
        return GetSystemLeapSecondInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemLeapSecondInformation(PBOOL Enabled, PDWORD Flags)
     * }
     */
    public static MemorySegment GetSystemLeapSecondInformation$address() {
        return GetSystemLeapSecondInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemLeapSecondInformation(PBOOL Enabled, PDWORD Flags)
     * }
     */
    public static int GetSystemLeapSecondInformation(MemorySegment Enabled, MemorySegment Flags) {
        var mh$ = GetSystemLeapSecondInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemLeapSecondInformation", Enabled, Flags);
            }
            return (int)mh$.invokeExact(Enabled, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetVersion()
     * }
     */
    public static FunctionDescriptor GetVersion$descriptor() {
        return GetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetVersion()
     * }
     */
    public static MethodHandle GetVersion$handle() {
        return GetVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetVersion()
     * }
     */
    public static MemorySegment GetVersion$address() {
        return GetVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetVersion()
     * }
     */
    public static int GetVersion() {
        var mh$ = GetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVersion");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLocalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetLocalTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLocalTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static FunctionDescriptor SetLocalTime$descriptor() {
        return SetLocalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLocalTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static MethodHandle SetLocalTime$handle() {
        return SetLocalTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetLocalTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static MemorySegment SetLocalTime$address() {
        return SetLocalTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetLocalTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static int SetLocalTime(MemorySegment lpSystemTime) {
        var mh$ = SetLocalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLocalTime", lpSystemTime);
            }
            return (int)mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTickCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTickCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTickCount()
     * }
     */
    public static FunctionDescriptor GetTickCount$descriptor() {
        return GetTickCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTickCount()
     * }
     */
    public static MethodHandle GetTickCount$handle() {
        return GetTickCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTickCount()
     * }
     */
    public static MemorySegment GetTickCount$address() {
        return GetTickCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTickCount()
     * }
     */
    public static int GetTickCount() {
        var mh$ = GetTickCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTickCount");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTickCount64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTickCount64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONGLONG GetTickCount64()
     * }
     */
    public static FunctionDescriptor GetTickCount64$descriptor() {
        return GetTickCount64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONGLONG GetTickCount64()
     * }
     */
    public static MethodHandle GetTickCount64$handle() {
        return GetTickCount64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONGLONG GetTickCount64()
     * }
     */
    public static MemorySegment GetTickCount64$address() {
        return GetTickCount64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONGLONG GetTickCount64()
     * }
     */
    public static long GetTickCount64() {
        var mh$ = GetTickCount64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTickCount64");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimeAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemTimeAdjustment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor GetSystemTimeAdjustment$descriptor() {
        return GetSystemTimeAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle GetSystemTimeAdjustment$handle() {
        return GetSystemTimeAdjustment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static MemorySegment GetSystemTimeAdjustment$address() {
        return GetSystemTimeAdjustment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static int GetSystemTimeAdjustment(MemorySegment lpTimeAdjustment, MemorySegment lpTimeIncrement, MemorySegment lpTimeAdjustmentDisabled) {
        var mh$ = GetSystemTimeAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimeAdjustment", lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimeAdjustmentPrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemTimeAdjustmentPrecise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor GetSystemTimeAdjustmentPrecise$descriptor() {
        return GetSystemTimeAdjustmentPrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle GetSystemTimeAdjustmentPrecise$handle() {
        return GetSystemTimeAdjustmentPrecise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static MemorySegment GetSystemTimeAdjustmentPrecise$address() {
        return GetSystemTimeAdjustmentPrecise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static int GetSystemTimeAdjustmentPrecise(MemorySegment lpTimeAdjustment, MemorySegment lpTimeIncrement, MemorySegment lpTimeAdjustmentDisabled) {
        var mh$ = GetSystemTimeAdjustmentPrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimeAdjustmentPrecise", lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemDirectoryA$descriptor() {
        return GetSystemDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemDirectoryA$handle() {
        return GetSystemDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemDirectoryA$address() {
        return GetSystemDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemDirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemDirectoryW$descriptor() {
        return GetSystemDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemDirectoryW$handle() {
        return GetSystemDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemDirectoryW$address() {
        return GetSystemDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemDirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowsDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWindowsDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetWindowsDirectoryA$descriptor() {
        return GetWindowsDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetWindowsDirectoryA$handle() {
        return GetWindowsDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetWindowsDirectoryA$address() {
        return GetWindowsDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetWindowsDirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetWindowsDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowsDirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowsDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWindowsDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetWindowsDirectoryW$descriptor() {
        return GetWindowsDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetWindowsDirectoryW$handle() {
        return GetWindowsDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetWindowsDirectoryW$address() {
        return GetWindowsDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetWindowsDirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetWindowsDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowsDirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWindowsDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemWindowsDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWindowsDirectoryA$descriptor() {
        return GetSystemWindowsDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWindowsDirectoryA$handle() {
        return GetSystemWindowsDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemWindowsDirectoryA$address() {
        return GetSystemWindowsDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWindowsDirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWindowsDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWindowsDirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWindowsDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemWindowsDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWindowsDirectoryW$descriptor() {
        return GetSystemWindowsDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWindowsDirectoryW$handle() {
        return GetSystemWindowsDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemWindowsDirectoryW$address() {
        return GetSystemWindowsDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWindowsDirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWindowsDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWindowsDirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ComputerNameNetBIOS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameNetBIOS = 0
     * }
     */
    public static int ComputerNameNetBIOS() {
        return ComputerNameNetBIOS;
    }
    private static final int ComputerNameDnsHostname = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameDnsHostname = 1
     * }
     */
    public static int ComputerNameDnsHostname() {
        return ComputerNameDnsHostname;
    }
    private static final int ComputerNameDnsDomain = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameDnsDomain = 2
     * }
     */
    public static int ComputerNameDnsDomain() {
        return ComputerNameDnsDomain;
    }
    private static final int ComputerNameDnsFullyQualified = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameDnsFullyQualified = 3
     * }
     */
    public static int ComputerNameDnsFullyQualified() {
        return ComputerNameDnsFullyQualified;
    }
    private static final int ComputerNamePhysicalNetBIOS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalNetBIOS = 4
     * }
     */
    public static int ComputerNamePhysicalNetBIOS() {
        return ComputerNamePhysicalNetBIOS;
    }
    private static final int ComputerNamePhysicalDnsHostname = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsHostname = 5
     * }
     */
    public static int ComputerNamePhysicalDnsHostname() {
        return ComputerNamePhysicalDnsHostname;
    }
    private static final int ComputerNamePhysicalDnsDomain = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsDomain = 6
     * }
     */
    public static int ComputerNamePhysicalDnsDomain() {
        return ComputerNamePhysicalDnsDomain;
    }
    private static final int ComputerNamePhysicalDnsFullyQualified = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsFullyQualified = 7
     * }
     */
    public static int ComputerNamePhysicalDnsFullyQualified() {
        return ComputerNamePhysicalDnsFullyQualified;
    }
    private static final int ComputerNameMax = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameMax = 8
     * }
     */
    public static int ComputerNameMax() {
        return ComputerNameMax;
    }

    private static class GetComputerNameExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetComputerNameExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameExA$descriptor() {
        return GetComputerNameExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameExA$handle() {
        return GetComputerNameExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MemorySegment GetComputerNameExA$address() {
        return GetComputerNameExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameExA(int NameType, MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameExA", NameType, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetComputerNameExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetComputerNameExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameExW$descriptor() {
        return GetComputerNameExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameExW$handle() {
        return GetComputerNameExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MemorySegment GetComputerNameExW$address() {
        return GetComputerNameExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameExW(int NameType, MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameExW", NameType, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetComputerNameExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor SetComputerNameExW$descriptor() {
        return SetComputerNameExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
     * }
     */
    public static MethodHandle SetComputerNameExW$handle() {
        return SetComputerNameExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
     * }
     */
    public static MemorySegment SetComputerNameExW$address() {
        return SetComputerNameExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
     * }
     */
    public static int SetComputerNameExW(int NameType, MemorySegment lpBuffer) {
        var mh$ = SetComputerNameExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameExW", NameType, lpBuffer);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSystemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static FunctionDescriptor SetSystemTime$descriptor() {
        return SetSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static MethodHandle SetSystemTime$handle() {
        return SetSystemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static MemorySegment SetSystemTime$address() {
        return SetSystemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static int SetSystemTime(MemorySegment lpSystemTime) {
        var mh$ = SetSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemTime", lpSystemTime);
            }
            return (int)mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVersionExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVersionExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetVersionExA$descriptor() {
        return GetVersionExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
     * }
     */
    public static MethodHandle GetVersionExA$handle() {
        return GetVersionExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
     * }
     */
    public static MemorySegment GetVersionExA$address() {
        return GetVersionExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
     * }
     */
    public static int GetVersionExA(MemorySegment lpVersionInformation) {
        var mh$ = GetVersionExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVersionExA", lpVersionInformation);
            }
            return (int)mh$.invokeExact(lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVersionExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetVersionExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVersionExW(LPOSVERSIONINFOW lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetVersionExW$descriptor() {
        return GetVersionExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVersionExW(LPOSVERSIONINFOW lpVersionInformation)
     * }
     */
    public static MethodHandle GetVersionExW$handle() {
        return GetVersionExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVersionExW(LPOSVERSIONINFOW lpVersionInformation)
     * }
     */
    public static MemorySegment GetVersionExW$address() {
        return GetVersionExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVersionExW(LPOSVERSIONINFOW lpVersionInformation)
     * }
     */
    public static int GetVersionExW(MemorySegment lpVersionInformation) {
        var mh$ = GetVersionExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVersionExW", lpVersionInformation);
            }
            return (int)mh$.invokeExact(lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalProcessorInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLogicalProcessorInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static FunctionDescriptor GetLogicalProcessorInformation$descriptor() {
        return GetLogicalProcessorInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MethodHandle GetLogicalProcessorInformation$handle() {
        return GetLogicalProcessorInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MemorySegment GetLogicalProcessorInformation$address() {
        return GetLogicalProcessorInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static int GetLogicalProcessorInformation(MemorySegment Buffer, MemorySegment ReturnedLength) {
        var mh$ = GetLogicalProcessorInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalProcessorInformation", Buffer, ReturnedLength);
            }
            return (int)mh$.invokeExact(Buffer, ReturnedLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalProcessorInformationEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLogicalProcessorInformationEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength)
     * }
     */
    public static FunctionDescriptor GetLogicalProcessorInformationEx$descriptor() {
        return GetLogicalProcessorInformationEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MethodHandle GetLogicalProcessorInformationEx$handle() {
        return GetLogicalProcessorInformationEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MemorySegment GetLogicalProcessorInformationEx$address() {
        return GetLogicalProcessorInformationEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength)
     * }
     */
    public static int GetLogicalProcessorInformationEx(int RelationshipType, MemorySegment Buffer, MemorySegment ReturnedLength) {
        var mh$ = GetLogicalProcessorInformationEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalProcessorInformationEx", RelationshipType, Buffer, ReturnedLength);
            }
            return (int)mh$.invokeExact(RelationshipType, Buffer, ReturnedLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNativeSystemInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNativeSystemInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static FunctionDescriptor GetNativeSystemInfo$descriptor() {
        return GetNativeSystemInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static MethodHandle GetNativeSystemInfo$handle() {
        return GetNativeSystemInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static MemorySegment GetNativeSystemInfo$address() {
        return GetNativeSystemInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static void GetNativeSystemInfo(MemorySegment lpSystemInfo) {
        var mh$ = GetNativeSystemInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNativeSystemInfo", lpSystemInfo);
            }
            mh$.invokeExact(lpSystemInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimePreciseAsFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemTimePreciseAsFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static FunctionDescriptor GetSystemTimePreciseAsFileTime$descriptor() {
        return GetSystemTimePreciseAsFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static MethodHandle GetSystemTimePreciseAsFileTime$handle() {
        return GetSystemTimePreciseAsFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static MemorySegment GetSystemTimePreciseAsFileTime$address() {
        return GetSystemTimePreciseAsFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static void GetSystemTimePreciseAsFileTime(MemorySegment lpSystemTimeAsFileTime) {
        var mh$ = GetSystemTimePreciseAsFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimePreciseAsFileTime", lpSystemTimeAsFileTime);
            }
            mh$.invokeExact(lpSystemTimeAsFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProductInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProductInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
     * }
     */
    public static FunctionDescriptor GetProductInfo$descriptor() {
        return GetProductInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
     * }
     */
    public static MethodHandle GetProductInfo$handle() {
        return GetProductInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
     * }
     */
    public static MemorySegment GetProductInfo$address() {
        return GetProductInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
     * }
     */
    public static int GetProductInfo(int dwOSMajorVersion, int dwOSMinorVersion, int dwSpMajorVersion, int dwSpMinorVersion, MemorySegment pdwReturnedProductType) {
        var mh$ = GetProductInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProductInfo", dwOSMajorVersion, dwOSMinorVersion, dwSpMajorVersion, dwSpMinorVersion, pdwReturnedProductType);
            }
            return (int)mh$.invokeExact(dwOSMajorVersion, dwOSMinorVersion, dwSpMajorVersion, dwSpMinorVersion, pdwReturnedProductType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOsSafeBootMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetOsSafeBootMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOsSafeBootMode(PDWORD Flags)
     * }
     */
    public static FunctionDescriptor GetOsSafeBootMode$descriptor() {
        return GetOsSafeBootMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOsSafeBootMode(PDWORD Flags)
     * }
     */
    public static MethodHandle GetOsSafeBootMode$handle() {
        return GetOsSafeBootMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOsSafeBootMode(PDWORD Flags)
     * }
     */
    public static MemorySegment GetOsSafeBootMode$address() {
        return GetOsSafeBootMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOsSafeBootMode(PDWORD Flags)
     * }
     */
    public static int GetOsSafeBootMode(MemorySegment Flags) {
        var mh$ = GetOsSafeBootMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOsSafeBootMode", Flags);
            }
            return (int)mh$.invokeExact(Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemFirmwareTables {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumSystemFirmwareTables");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
     * }
     */
    public static FunctionDescriptor EnumSystemFirmwareTables$descriptor() {
        return EnumSystemFirmwareTables.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
     * }
     */
    public static MethodHandle EnumSystemFirmwareTables$handle() {
        return EnumSystemFirmwareTables.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
     * }
     */
    public static MemorySegment EnumSystemFirmwareTables$address() {
        return EnumSystemFirmwareTables.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
     * }
     */
    public static int EnumSystemFirmwareTables(int FirmwareTableProviderSignature, MemorySegment pFirmwareTableEnumBuffer, int BufferSize) {
        var mh$ = EnumSystemFirmwareTables.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemFirmwareTables", FirmwareTableProviderSignature, pFirmwareTableEnumBuffer, BufferSize);
            }
            return (int)mh$.invokeExact(FirmwareTableProviderSignature, pFirmwareTableEnumBuffer, BufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemFirmwareTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemFirmwareTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
     * }
     */
    public static FunctionDescriptor GetSystemFirmwareTable$descriptor() {
        return GetSystemFirmwareTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
     * }
     */
    public static MethodHandle GetSystemFirmwareTable$handle() {
        return GetSystemFirmwareTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
     * }
     */
    public static MemorySegment GetSystemFirmwareTable$address() {
        return GetSystemFirmwareTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
     * }
     */
    public static int GetSystemFirmwareTable(int FirmwareTableProviderSignature, int FirmwareTableID, MemorySegment pFirmwareTableBuffer, int BufferSize) {
        var mh$ = GetSystemFirmwareTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemFirmwareTable", FirmwareTableProviderSignature, FirmwareTableID, pFirmwareTableBuffer, BufferSize);
            }
            return (int)mh$.invokeExact(FirmwareTableProviderSignature, FirmwareTableID, pFirmwareTableBuffer, BufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DnsHostnameToComputerNameExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DnsHostnameToComputerNameExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor DnsHostnameToComputerNameExW$descriptor() {
        return DnsHostnameToComputerNameExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MethodHandle DnsHostnameToComputerNameExW$handle() {
        return DnsHostnameToComputerNameExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MemorySegment DnsHostnameToComputerNameExW$address() {
        return DnsHostnameToComputerNameExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static int DnsHostnameToComputerNameExW(MemorySegment Hostname, MemorySegment ComputerName, MemorySegment nSize) {
        var mh$ = DnsHostnameToComputerNameExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DnsHostnameToComputerNameExW", Hostname, ComputerName, nSize);
            }
            return (int)mh$.invokeExact(Hostname, ComputerName, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPhysicallyInstalledSystemMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPhysicallyInstalledSystemMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
     * }
     */
    public static FunctionDescriptor GetPhysicallyInstalledSystemMemory$descriptor() {
        return GetPhysicallyInstalledSystemMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
     * }
     */
    public static MethodHandle GetPhysicallyInstalledSystemMemory$handle() {
        return GetPhysicallyInstalledSystemMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
     * }
     */
    public static MemorySegment GetPhysicallyInstalledSystemMemory$address() {
        return GetPhysicallyInstalledSystemMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
     * }
     */
    public static int GetPhysicallyInstalledSystemMemory(MemorySegment TotalMemoryInKilobytes) {
        var mh$ = GetPhysicallyInstalledSystemMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPhysicallyInstalledSystemMemory", TotalMemoryInKilobytes);
            }
            return (int)mh$.invokeExact(TotalMemoryInKilobytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameEx2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetComputerNameEx2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor SetComputerNameEx2W$descriptor() {
        return SetComputerNameEx2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer)
     * }
     */
    public static MethodHandle SetComputerNameEx2W$handle() {
        return SetComputerNameEx2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer)
     * }
     */
    public static MemorySegment SetComputerNameEx2W$address() {
        return SetComputerNameEx2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer)
     * }
     */
    public static int SetComputerNameEx2W(int NameType, int Flags, MemorySegment lpBuffer) {
        var mh$ = SetComputerNameEx2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameEx2W", NameType, Flags, lpBuffer);
            }
            return (int)mh$.invokeExact(NameType, Flags, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemTimeAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSystemTimeAdjustment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor SetSystemTimeAdjustment$descriptor() {
        return SetSystemTimeAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle SetSystemTimeAdjustment$handle() {
        return SetSystemTimeAdjustment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static MemorySegment SetSystemTimeAdjustment$address() {
        return SetSystemTimeAdjustment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static int SetSystemTimeAdjustment(int dwTimeAdjustment, int bTimeAdjustmentDisabled) {
        var mh$ = SetSystemTimeAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemTimeAdjustment", dwTimeAdjustment, bTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(dwTimeAdjustment, bTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemTimeAdjustmentPrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSystemTimeAdjustmentPrecise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor SetSystemTimeAdjustmentPrecise$descriptor() {
        return SetSystemTimeAdjustmentPrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle SetSystemTimeAdjustmentPrecise$handle() {
        return SetSystemTimeAdjustmentPrecise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static MemorySegment SetSystemTimeAdjustmentPrecise$address() {
        return SetSystemTimeAdjustmentPrecise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static int SetSystemTimeAdjustmentPrecise(long dwTimeAdjustment, int bTimeAdjustmentDisabled) {
        var mh$ = SetSystemTimeAdjustmentPrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemTimeAdjustmentPrecise", dwTimeAdjustment, bTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(dwTimeAdjustment, bTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InstallELAMCertificateInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InstallELAMCertificateInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InstallELAMCertificateInfo(HANDLE ELAMFile)
     * }
     */
    public static FunctionDescriptor InstallELAMCertificateInfo$descriptor() {
        return InstallELAMCertificateInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InstallELAMCertificateInfo(HANDLE ELAMFile)
     * }
     */
    public static MethodHandle InstallELAMCertificateInfo$handle() {
        return InstallELAMCertificateInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InstallELAMCertificateInfo(HANDLE ELAMFile)
     * }
     */
    public static MemorySegment InstallELAMCertificateInfo$address() {
        return InstallELAMCertificateInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InstallELAMCertificateInfo(HANDLE ELAMFile)
     * }
     */
    public static int InstallELAMCertificateInfo(MemorySegment ELAMFile) {
        var mh$ = InstallELAMCertificateInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InstallELAMCertificateInfo", ELAMFile);
            }
            return (int)mh$.invokeExact(ELAMFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessorSystemCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessorSystemCycleTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static FunctionDescriptor GetProcessorSystemCycleTime$descriptor() {
        return GetProcessorSystemCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MethodHandle GetProcessorSystemCycleTime$handle() {
        return GetProcessorSystemCycleTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MemorySegment GetProcessorSystemCycleTime$address() {
        return GetProcessorSystemCycleTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static int GetProcessorSystemCycleTime(short Group, MemorySegment Buffer, MemorySegment ReturnedLength) {
        var mh$ = GetProcessorSystemCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessorSystemCycleTime", Group, Buffer, ReturnedLength);
            }
            return (int)mh$.invokeExact(Group, Buffer, ReturnedLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOsManufacturingMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetOsManufacturingMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOsManufacturingMode(PBOOL pbEnabled)
     * }
     */
    public static FunctionDescriptor GetOsManufacturingMode$descriptor() {
        return GetOsManufacturingMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOsManufacturingMode(PBOOL pbEnabled)
     * }
     */
    public static MethodHandle GetOsManufacturingMode$handle() {
        return GetOsManufacturingMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOsManufacturingMode(PBOOL pbEnabled)
     * }
     */
    public static MemorySegment GetOsManufacturingMode$address() {
        return GetOsManufacturingMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOsManufacturingMode(PBOOL pbEnabled)
     * }
     */
    public static int GetOsManufacturingMode(MemorySegment pbEnabled) {
        var mh$ = GetOsManufacturingMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOsManufacturingMode", pbEnabled);
            }
            return (int)mh$.invokeExact(pbEnabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetIntegratedDisplaySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetIntegratedDisplaySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetIntegratedDisplaySize(double *sizeInInches)
     * }
     */
    public static FunctionDescriptor GetIntegratedDisplaySize$descriptor() {
        return GetIntegratedDisplaySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetIntegratedDisplaySize(double *sizeInInches)
     * }
     */
    public static MethodHandle GetIntegratedDisplaySize$handle() {
        return GetIntegratedDisplaySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetIntegratedDisplaySize(double *sizeInInches)
     * }
     */
    public static MemorySegment GetIntegratedDisplaySize$address() {
        return GetIntegratedDisplaySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetIntegratedDisplaySize(double *sizeInInches)
     * }
     */
    public static int GetIntegratedDisplaySize(MemorySegment sizeInInches) {
        var mh$ = GetIntegratedDisplaySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetIntegratedDisplaySize", sizeInInches);
            }
            return (int)mh$.invokeExact(sizeInInches);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetComputerNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameA(LPCSTR lpComputerName)
     * }
     */
    public static FunctionDescriptor SetComputerNameA$descriptor() {
        return SetComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameA(LPCSTR lpComputerName)
     * }
     */
    public static MethodHandle SetComputerNameA$handle() {
        return SetComputerNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetComputerNameA(LPCSTR lpComputerName)
     * }
     */
    public static MemorySegment SetComputerNameA$address() {
        return SetComputerNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameA(LPCSTR lpComputerName)
     * }
     */
    public static int SetComputerNameA(MemorySegment lpComputerName) {
        var mh$ = SetComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameA", lpComputerName);
            }
            return (int)mh$.invokeExact(lpComputerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetComputerNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameW(LPCWSTR lpComputerName)
     * }
     */
    public static FunctionDescriptor SetComputerNameW$descriptor() {
        return SetComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameW(LPCWSTR lpComputerName)
     * }
     */
    public static MethodHandle SetComputerNameW$handle() {
        return SetComputerNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetComputerNameW(LPCWSTR lpComputerName)
     * }
     */
    public static MemorySegment SetComputerNameW$address() {
        return SetComputerNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameW(LPCWSTR lpComputerName)
     * }
     */
    public static int SetComputerNameW(MemorySegment lpComputerName) {
        var mh$ = SetComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameW", lpComputerName);
            }
            return (int)mh$.invokeExact(lpComputerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetComputerNameExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor SetComputerNameExA$descriptor() {
        return SetComputerNameExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
     * }
     */
    public static MethodHandle SetComputerNameExA$handle() {
        return SetComputerNameExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
     * }
     */
    public static MemorySegment SetComputerNameExA$address() {
        return SetComputerNameExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
     * }
     */
    public static int SetComputerNameExA(int NameType, MemorySegment lpBuffer) {
        var mh$ = SetComputerNameExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameExA", NameType, lpBuffer);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static FunctionDescriptor VirtualAlloc$descriptor() {
        return VirtualAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MethodHandle VirtualAlloc$handle() {
        return VirtualAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MemorySegment VirtualAlloc$address() {
        return VirtualAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MemorySegment VirtualAlloc(MemorySegment lpAddress, long dwSize, int flAllocationType, int flProtect) {
        var mh$ = VirtualAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAlloc", lpAddress, dwSize, flAllocationType, flProtect);
            }
            return (MemorySegment)mh$.invokeExact(lpAddress, dwSize, flAllocationType, flProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualProtect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualProtect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static FunctionDescriptor VirtualProtect$descriptor() {
        return VirtualProtect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static MethodHandle VirtualProtect$handle() {
        return VirtualProtect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static MemorySegment VirtualProtect$address() {
        return VirtualProtect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static int VirtualProtect(MemorySegment lpAddress, long dwSize, int flNewProtect, MemorySegment lpflOldProtect) {
        var mh$ = VirtualProtect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualProtect", lpAddress, dwSize, flNewProtect, lpflOldProtect);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize, flNewProtect, lpflOldProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static FunctionDescriptor VirtualFree$descriptor() {
        return VirtualFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static MethodHandle VirtualFree$handle() {
        return VirtualFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static MemorySegment VirtualFree$address() {
        return VirtualFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static int VirtualFree(MemorySegment lpAddress, long dwSize, int dwFreeType) {
        var mh$ = VirtualFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualFree", lpAddress, dwSize, dwFreeType);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize, dwFreeType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualQuery {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualQuery");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor VirtualQuery$descriptor() {
        return VirtualQuery.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle VirtualQuery$handle() {
        return VirtualQuery.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MemorySegment VirtualQuery$address() {
        return VirtualQuery.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static long VirtualQuery(MemorySegment lpAddress, MemorySegment lpBuffer, long dwLength) {
        var mh$ = VirtualQuery.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualQuery", lpAddress, lpBuffer, dwLength);
            }
            return (long)mh$.invokeExact(lpAddress, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAllocEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualAllocEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static FunctionDescriptor VirtualAllocEx$descriptor() {
        return VirtualAllocEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MethodHandle VirtualAllocEx$handle() {
        return VirtualAllocEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MemorySegment VirtualAllocEx$address() {
        return VirtualAllocEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MemorySegment VirtualAllocEx(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int flAllocationType, int flProtect) {
        var mh$ = VirtualAllocEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAllocEx", hProcess, lpAddress, dwSize, flAllocationType, flProtect);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpAddress, dwSize, flAllocationType, flProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualProtectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualProtectEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static FunctionDescriptor VirtualProtectEx$descriptor() {
        return VirtualProtectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static MethodHandle VirtualProtectEx$handle() {
        return VirtualProtectEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static MemorySegment VirtualProtectEx$address() {
        return VirtualProtectEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static int VirtualProtectEx(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int flNewProtect, MemorySegment lpflOldProtect) {
        var mh$ = VirtualProtectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualProtectEx", hProcess, lpAddress, dwSize, flNewProtect, lpflOldProtect);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, dwSize, flNewProtect, lpflOldProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualQueryEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualQueryEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor VirtualQueryEx$descriptor() {
        return VirtualQueryEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle VirtualQueryEx$handle() {
        return VirtualQueryEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MemorySegment VirtualQueryEx$address() {
        return VirtualQueryEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static long VirtualQueryEx(MemorySegment hProcess, MemorySegment lpAddress, MemorySegment lpBuffer, long dwLength) {
        var mh$ = VirtualQueryEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualQueryEx", hProcess, lpAddress, lpBuffer, dwLength);
            }
            return (long)mh$.invokeExact(hProcess, lpAddress, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadProcessMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReadProcessMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
     * }
     */
    public static FunctionDescriptor ReadProcessMemory$descriptor() {
        return ReadProcessMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
     * }
     */
    public static MethodHandle ReadProcessMemory$handle() {
        return ReadProcessMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
     * }
     */
    public static MemorySegment ReadProcessMemory$address() {
        return ReadProcessMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
     * }
     */
    public static int ReadProcessMemory(MemorySegment hProcess, MemorySegment lpBaseAddress, MemorySegment lpBuffer, long nSize, MemorySegment lpNumberOfBytesRead) {
        var mh$ = ReadProcessMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadProcessMemory", hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
            }
            return (int)mh$.invokeExact(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProcessMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WriteProcessMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
     * }
     */
    public static FunctionDescriptor WriteProcessMemory$descriptor() {
        return WriteProcessMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
     * }
     */
    public static MethodHandle WriteProcessMemory$handle() {
        return WriteProcessMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
     * }
     */
    public static MemorySegment WriteProcessMemory$address() {
        return WriteProcessMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
     * }
     */
    public static int WriteProcessMemory(MemorySegment hProcess, MemorySegment lpBaseAddress, MemorySegment lpBuffer, long nSize, MemorySegment lpNumberOfBytesWritten) {
        var mh$ = WriteProcessMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProcessMemory", hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
            }
            return (int)mh$.invokeExact(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFileMappingW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateFileMappingW$descriptor() {
        return CreateFileMappingW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateFileMappingW$handle() {
        return CreateFileMappingW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateFileMappingW$address() {
        return CreateFileMappingW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateFileMappingW(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName) {
        var mh$ = CreateFileMappingW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingW", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFileMappingW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenFileMappingW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenFileMappingW$descriptor() {
        return OpenFileMappingW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenFileMappingW$handle() {
        return OpenFileMappingW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenFileMappingW$address() {
        return OpenFileMappingW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenFileMappingW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenFileMappingW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileMappingW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapViewOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
     * }
     */
    public static FunctionDescriptor MapViewOfFile$descriptor() {
        return MapViewOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
     * }
     */
    public static MethodHandle MapViewOfFile$handle() {
        return MapViewOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
     * }
     */
    public static MemorySegment MapViewOfFile$address() {
        return MapViewOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
     * }
     */
    public static MemorySegment MapViewOfFile(MemorySegment hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, long dwNumberOfBytesToMap) {
        var mh$ = MapViewOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFile", hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapViewOfFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
     * }
     */
    public static FunctionDescriptor MapViewOfFileEx$descriptor() {
        return MapViewOfFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
     * }
     */
    public static MethodHandle MapViewOfFileEx$handle() {
        return MapViewOfFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
     * }
     */
    public static MemorySegment MapViewOfFileEx$address() {
        return MapViewOfFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
     * }
     */
    public static MemorySegment MapViewOfFileEx(MemorySegment hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, long dwNumberOfBytesToMap, MemorySegment lpBaseAddress) {
        var mh$ = MapViewOfFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileEx", hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualFreeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualFreeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static FunctionDescriptor VirtualFreeEx$descriptor() {
        return VirtualFreeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static MethodHandle VirtualFreeEx$handle() {
        return VirtualFreeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static MemorySegment VirtualFreeEx$address() {
        return VirtualFreeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static int VirtualFreeEx(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int dwFreeType) {
        var mh$ = VirtualFreeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualFreeEx", hProcess, lpAddress, dwSize, dwFreeType);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, dwSize, dwFreeType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushViewOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FlushViewOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
     * }
     */
    public static FunctionDescriptor FlushViewOfFile$descriptor() {
        return FlushViewOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
     * }
     */
    public static MethodHandle FlushViewOfFile$handle() {
        return FlushViewOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
     * }
     */
    public static MemorySegment FlushViewOfFile$address() {
        return FlushViewOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
     * }
     */
    public static int FlushViewOfFile(MemorySegment lpBaseAddress, long dwNumberOfBytesToFlush) {
        var mh$ = FlushViewOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushViewOfFile", lpBaseAddress, dwNumberOfBytesToFlush);
            }
            return (int)mh$.invokeExact(lpBaseAddress, dwNumberOfBytesToFlush);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnmapViewOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnmapViewOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile(LPCVOID lpBaseAddress)
     * }
     */
    public static FunctionDescriptor UnmapViewOfFile$descriptor() {
        return UnmapViewOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile(LPCVOID lpBaseAddress)
     * }
     */
    public static MethodHandle UnmapViewOfFile$handle() {
        return UnmapViewOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile(LPCVOID lpBaseAddress)
     * }
     */
    public static MemorySegment UnmapViewOfFile$address() {
        return UnmapViewOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile(LPCVOID lpBaseAddress)
     * }
     */
    public static int UnmapViewOfFile(MemorySegment lpBaseAddress) {
        var mh$ = UnmapViewOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnmapViewOfFile", lpBaseAddress);
            }
            return (int)mh$.invokeExact(lpBaseAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLargePageMinimum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLargePageMinimum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T GetLargePageMinimum()
     * }
     */
    public static FunctionDescriptor GetLargePageMinimum$descriptor() {
        return GetLargePageMinimum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T GetLargePageMinimum()
     * }
     */
    public static MethodHandle GetLargePageMinimum$handle() {
        return GetLargePageMinimum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T GetLargePageMinimum()
     * }
     */
    public static MemorySegment GetLargePageMinimum$address() {
        return GetLargePageMinimum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T GetLargePageMinimum()
     * }
     */
    public static long GetLargePageMinimum() {
        var mh$ = GetLargePageMinimum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLargePageMinimum");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessWorkingSetSizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessWorkingSetSizeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
     * }
     */
    public static FunctionDescriptor GetProcessWorkingSetSizeEx$descriptor() {
        return GetProcessWorkingSetSizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
     * }
     */
    public static MethodHandle GetProcessWorkingSetSizeEx$handle() {
        return GetProcessWorkingSetSizeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
     * }
     */
    public static MemorySegment GetProcessWorkingSetSizeEx$address() {
        return GetProcessWorkingSetSizeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
     * }
     */
    public static int GetProcessWorkingSetSizeEx(MemorySegment hProcess, MemorySegment lpMinimumWorkingSetSize, MemorySegment lpMaximumWorkingSetSize, MemorySegment Flags) {
        var mh$ = GetProcessWorkingSetSizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessWorkingSetSizeEx", hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize, Flags);
            }
            return (int)mh$.invokeExact(hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessWorkingSetSizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessWorkingSetSizeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
     * }
     */
    public static FunctionDescriptor SetProcessWorkingSetSizeEx$descriptor() {
        return SetProcessWorkingSetSizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
     * }
     */
    public static MethodHandle SetProcessWorkingSetSizeEx$handle() {
        return SetProcessWorkingSetSizeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
     * }
     */
    public static MemorySegment SetProcessWorkingSetSizeEx$address() {
        return SetProcessWorkingSetSizeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
     * }
     */
    public static int SetProcessWorkingSetSizeEx(MemorySegment hProcess, long dwMinimumWorkingSetSize, long dwMaximumWorkingSetSize, int Flags) {
        var mh$ = SetProcessWorkingSetSizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessWorkingSetSizeEx", hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize, Flags);
            }
            return (int)mh$.invokeExact(hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static FunctionDescriptor VirtualLock$descriptor() {
        return VirtualLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static MethodHandle VirtualLock$handle() {
        return VirtualLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static MemorySegment VirtualLock$address() {
        return VirtualLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static int VirtualLock(MemorySegment lpAddress, long dwSize) {
        var mh$ = VirtualLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualLock", lpAddress, dwSize);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static FunctionDescriptor VirtualUnlock$descriptor() {
        return VirtualUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static MethodHandle VirtualUnlock$handle() {
        return VirtualUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static MemorySegment VirtualUnlock$address() {
        return VirtualUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static int VirtualUnlock(MemorySegment lpAddress, long dwSize) {
        var mh$ = VirtualUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualUnlock", lpAddress, dwSize);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWriteWatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWriteWatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, LPDWORD lpdwGranularity)
     * }
     */
    public static FunctionDescriptor GetWriteWatch$descriptor() {
        return GetWriteWatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, LPDWORD lpdwGranularity)
     * }
     */
    public static MethodHandle GetWriteWatch$handle() {
        return GetWriteWatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, LPDWORD lpdwGranularity)
     * }
     */
    public static MemorySegment GetWriteWatch$address() {
        return GetWriteWatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, LPDWORD lpdwGranularity)
     * }
     */
    public static int GetWriteWatch(int dwFlags, MemorySegment lpBaseAddress, long dwRegionSize, MemorySegment lpAddresses, MemorySegment lpdwCount, MemorySegment lpdwGranularity) {
        var mh$ = GetWriteWatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWriteWatch", dwFlags, lpBaseAddress, dwRegionSize, lpAddresses, lpdwCount, lpdwGranularity);
            }
            return (int)mh$.invokeExact(dwFlags, lpBaseAddress, dwRegionSize, lpAddresses, lpdwCount, lpdwGranularity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetWriteWatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ResetWriteWatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
     * }
     */
    public static FunctionDescriptor ResetWriteWatch$descriptor() {
        return ResetWriteWatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
     * }
     */
    public static MethodHandle ResetWriteWatch$handle() {
        return ResetWriteWatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
     * }
     */
    public static MemorySegment ResetWriteWatch$address() {
        return ResetWriteWatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
     * }
     */
    public static int ResetWriteWatch(MemorySegment lpBaseAddress, long dwRegionSize) {
        var mh$ = ResetWriteWatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetWriteWatch", lpBaseAddress, dwRegionSize);
            }
            return (int)mh$.invokeExact(lpBaseAddress, dwRegionSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int LowMemoryResourceNotification = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _MEMORY_RESOURCE_NOTIFICATION_TYPE.LowMemoryResourceNotification = 0
     * }
     */
    public static int LowMemoryResourceNotification() {
        return LowMemoryResourceNotification;
    }
    private static final int HighMemoryResourceNotification = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _MEMORY_RESOURCE_NOTIFICATION_TYPE.HighMemoryResourceNotification = 1
     * }
     */
    public static int HighMemoryResourceNotification() {
        return HighMemoryResourceNotification;
    }

    private static class CreateMemoryResourceNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateMemoryResourceNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
     * }
     */
    public static FunctionDescriptor CreateMemoryResourceNotification$descriptor() {
        return CreateMemoryResourceNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
     * }
     */
    public static MethodHandle CreateMemoryResourceNotification$handle() {
        return CreateMemoryResourceNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
     * }
     */
    public static MemorySegment CreateMemoryResourceNotification$address() {
        return CreateMemoryResourceNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
     * }
     */
    public static MemorySegment CreateMemoryResourceNotification(int NotificationType) {
        var mh$ = CreateMemoryResourceNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMemoryResourceNotification", NotificationType);
            }
            return (MemorySegment)mh$.invokeExact(NotificationType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryMemoryResourceNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryMemoryResourceNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
     * }
     */
    public static FunctionDescriptor QueryMemoryResourceNotification$descriptor() {
        return QueryMemoryResourceNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
     * }
     */
    public static MethodHandle QueryMemoryResourceNotification$handle() {
        return QueryMemoryResourceNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
     * }
     */
    public static MemorySegment QueryMemoryResourceNotification$address() {
        return QueryMemoryResourceNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
     * }
     */
    public static int QueryMemoryResourceNotification(MemorySegment ResourceNotificationHandle, MemorySegment ResourceState) {
        var mh$ = QueryMemoryResourceNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryMemoryResourceNotification", ResourceNotificationHandle, ResourceState);
            }
            return (int)mh$.invokeExact(ResourceNotificationHandle, ResourceState);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemFileCacheSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemFileCacheSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
     * }
     */
    public static FunctionDescriptor GetSystemFileCacheSize$descriptor() {
        return GetSystemFileCacheSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
     * }
     */
    public static MethodHandle GetSystemFileCacheSize$handle() {
        return GetSystemFileCacheSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
     * }
     */
    public static MemorySegment GetSystemFileCacheSize$address() {
        return GetSystemFileCacheSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
     * }
     */
    public static int GetSystemFileCacheSize(MemorySegment lpMinimumFileCacheSize, MemorySegment lpMaximumFileCacheSize, MemorySegment lpFlags) {
        var mh$ = GetSystemFileCacheSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemFileCacheSize", lpMinimumFileCacheSize, lpMaximumFileCacheSize, lpFlags);
            }
            return (int)mh$.invokeExact(lpMinimumFileCacheSize, lpMaximumFileCacheSize, lpFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemFileCacheSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSystemFileCacheSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
     * }
     */
    public static FunctionDescriptor SetSystemFileCacheSize$descriptor() {
        return SetSystemFileCacheSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
     * }
     */
    public static MethodHandle SetSystemFileCacheSize$handle() {
        return SetSystemFileCacheSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
     * }
     */
    public static MemorySegment SetSystemFileCacheSize$address() {
        return SetSystemFileCacheSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
     * }
     */
    public static int SetSystemFileCacheSize(long MinimumFileCacheSize, long MaximumFileCacheSize, int Flags) {
        var mh$ = SetSystemFileCacheSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemFileCacheSize", MinimumFileCacheSize, MaximumFileCacheSize, Flags);
            }
            return (int)mh$.invokeExact(MinimumFileCacheSize, MaximumFileCacheSize, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingNumaW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFileMappingNumaW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor CreateFileMappingNumaW$descriptor() {
        return CreateFileMappingNumaW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MethodHandle CreateFileMappingNumaW$handle() {
        return CreateFileMappingNumaW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MemorySegment CreateFileMappingNumaW$address() {
        return CreateFileMappingNumaW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MemorySegment CreateFileMappingNumaW(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName, int nndPreferred) {
        var mh$ = CreateFileMappingNumaW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingNumaW", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_MEMORY_RANGE_ENTRY {
     *     PVOID VirtualAddress;
     *     SIZE_T NumberOfBytes;
     * } *PWIN32_MEMORY_RANGE_ENTRY
     * }
     */
    public static final AddressLayout PWIN32_MEMORY_RANGE_ENTRY = wgl_h.C_POINTER;

    private static class PrefetchVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PrefetchVirtualMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags)
     * }
     */
    public static FunctionDescriptor PrefetchVirtualMemory$descriptor() {
        return PrefetchVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags)
     * }
     */
    public static MethodHandle PrefetchVirtualMemory$handle() {
        return PrefetchVirtualMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags)
     * }
     */
    public static MemorySegment PrefetchVirtualMemory$address() {
        return PrefetchVirtualMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags)
     * }
     */
    public static int PrefetchVirtualMemory(MemorySegment hProcess, long NumberOfEntries, MemorySegment VirtualAddresses, int Flags) {
        var mh$ = PrefetchVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrefetchVirtualMemory", hProcess, NumberOfEntries, VirtualAddresses, Flags);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfEntries, VirtualAddresses, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFileMappingFromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingFromApp(HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name)
     * }
     */
    public static FunctionDescriptor CreateFileMappingFromApp$descriptor() {
        return CreateFileMappingFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingFromApp(HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name)
     * }
     */
    public static MethodHandle CreateFileMappingFromApp$handle() {
        return CreateFileMappingFromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingFromApp(HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name)
     * }
     */
    public static MemorySegment CreateFileMappingFromApp$address() {
        return CreateFileMappingFromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingFromApp(HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name)
     * }
     */
    public static MemorySegment CreateFileMappingFromApp(MemorySegment hFile, MemorySegment SecurityAttributes, int PageProtection, long MaximumSize, MemorySegment Name) {
        var mh$ = CreateFileMappingFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingFromApp", hFile, SecurityAttributes, PageProtection, MaximumSize, Name);
            }
            return (MemorySegment)mh$.invokeExact(hFile, SecurityAttributes, PageProtection, MaximumSize, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapViewOfFileFromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap)
     * }
     */
    public static FunctionDescriptor MapViewOfFileFromApp$descriptor() {
        return MapViewOfFileFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap)
     * }
     */
    public static MethodHandle MapViewOfFileFromApp$handle() {
        return MapViewOfFileFromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap)
     * }
     */
    public static MemorySegment MapViewOfFileFromApp$address() {
        return MapViewOfFileFromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap)
     * }
     */
    public static MemorySegment MapViewOfFileFromApp(MemorySegment hFileMappingObject, int DesiredAccess, long FileOffset, long NumberOfBytesToMap) {
        var mh$ = MapViewOfFileFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileFromApp", hFileMappingObject, DesiredAccess, FileOffset, NumberOfBytesToMap);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, DesiredAccess, FileOffset, NumberOfBytesToMap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnmapViewOfFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnmapViewOfFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static FunctionDescriptor UnmapViewOfFileEx$descriptor() {
        return UnmapViewOfFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static MethodHandle UnmapViewOfFileEx$handle() {
        return UnmapViewOfFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static MemorySegment UnmapViewOfFileEx$address() {
        return UnmapViewOfFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static int UnmapViewOfFileEx(MemorySegment BaseAddress, int UnmapFlags) {
        var mh$ = UnmapViewOfFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnmapViewOfFileEx", BaseAddress, UnmapFlags);
            }
            return (int)mh$.invokeExact(BaseAddress, UnmapFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateUserPhysicalPages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AllocateUserPhysicalPages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor AllocateUserPhysicalPages$descriptor() {
        return AllocateUserPhysicalPages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle AllocateUserPhysicalPages$handle() {
        return AllocateUserPhysicalPages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MemorySegment AllocateUserPhysicalPages$address() {
        return AllocateUserPhysicalPages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int AllocateUserPhysicalPages(MemorySegment hProcess, MemorySegment NumberOfPages, MemorySegment PageArray) {
        var mh$ = AllocateUserPhysicalPages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateUserPhysicalPages", hProcess, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeUserPhysicalPages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FreeUserPhysicalPages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor FreeUserPhysicalPages$descriptor() {
        return FreeUserPhysicalPages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle FreeUserPhysicalPages$handle() {
        return FreeUserPhysicalPages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MemorySegment FreeUserPhysicalPages$address() {
        return FreeUserPhysicalPages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int FreeUserPhysicalPages(MemorySegment hProcess, MemorySegment NumberOfPages, MemorySegment PageArray) {
        var mh$ = FreeUserPhysicalPages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeUserPhysicalPages", hProcess, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapUserPhysicalPages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapUserPhysicalPages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor MapUserPhysicalPages$descriptor() {
        return MapUserPhysicalPages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle MapUserPhysicalPages$handle() {
        return MapUserPhysicalPages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MemorySegment MapUserPhysicalPages$address() {
        return MapUserPhysicalPages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int MapUserPhysicalPages(MemorySegment VirtualAddress, long NumberOfPages, MemorySegment PageArray) {
        var mh$ = MapUserPhysicalPages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapUserPhysicalPages", VirtualAddress, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(VirtualAddress, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateUserPhysicalPagesNuma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AllocateUserPhysicalPagesNuma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor AllocateUserPhysicalPagesNuma$descriptor() {
        return AllocateUserPhysicalPagesNuma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred)
     * }
     */
    public static MethodHandle AllocateUserPhysicalPagesNuma$handle() {
        return AllocateUserPhysicalPagesNuma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred)
     * }
     */
    public static MemorySegment AllocateUserPhysicalPagesNuma$address() {
        return AllocateUserPhysicalPagesNuma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred)
     * }
     */
    public static int AllocateUserPhysicalPagesNuma(MemorySegment hProcess, MemorySegment NumberOfPages, MemorySegment PageArray, int nndPreferred) {
        var mh$ = AllocateUserPhysicalPagesNuma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateUserPhysicalPagesNuma", hProcess, NumberOfPages, PageArray, nndPreferred);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfPages, PageArray, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAllocExNuma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualAllocExNuma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor VirtualAllocExNuma$descriptor() {
        return VirtualAllocExNuma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
     * }
     */
    public static MethodHandle VirtualAllocExNuma$handle() {
        return VirtualAllocExNuma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
     * }
     */
    public static MemorySegment VirtualAllocExNuma$address() {
        return VirtualAllocExNuma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
     * }
     */
    public static MemorySegment VirtualAllocExNuma(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int flAllocationType, int flProtect, int nndPreferred) {
        var mh$ = VirtualAllocExNuma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAllocExNuma", hProcess, lpAddress, dwSize, flAllocationType, flProtect, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpAddress, dwSize, flAllocationType, flProtect, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMemoryErrorHandlingCapabilities {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetMemoryErrorHandlingCapabilities");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMemoryErrorHandlingCapabilities(PULONG Capabilities)
     * }
     */
    public static FunctionDescriptor GetMemoryErrorHandlingCapabilities$descriptor() {
        return GetMemoryErrorHandlingCapabilities.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMemoryErrorHandlingCapabilities(PULONG Capabilities)
     * }
     */
    public static MethodHandle GetMemoryErrorHandlingCapabilities$handle() {
        return GetMemoryErrorHandlingCapabilities.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMemoryErrorHandlingCapabilities(PULONG Capabilities)
     * }
     */
    public static MemorySegment GetMemoryErrorHandlingCapabilities$address() {
        return GetMemoryErrorHandlingCapabilities.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMemoryErrorHandlingCapabilities(PULONG Capabilities)
     * }
     */
    public static int GetMemoryErrorHandlingCapabilities(MemorySegment Capabilities) {
        var mh$ = GetMemoryErrorHandlingCapabilities.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMemoryErrorHandlingCapabilities", Capabilities);
            }
            return (int)mh$.invokeExact(Capabilities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterBadMemoryNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RegisterBadMemoryNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback)
     * }
     */
    public static FunctionDescriptor RegisterBadMemoryNotification$descriptor() {
        return RegisterBadMemoryNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback)
     * }
     */
    public static MethodHandle RegisterBadMemoryNotification$handle() {
        return RegisterBadMemoryNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback)
     * }
     */
    public static MemorySegment RegisterBadMemoryNotification$address() {
        return RegisterBadMemoryNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback)
     * }
     */
    public static MemorySegment RegisterBadMemoryNotification(MemorySegment Callback) {
        var mh$ = RegisterBadMemoryNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterBadMemoryNotification", Callback);
            }
            return (MemorySegment)mh$.invokeExact(Callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterBadMemoryNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterBadMemoryNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterBadMemoryNotification(PVOID RegistrationHandle)
     * }
     */
    public static FunctionDescriptor UnregisterBadMemoryNotification$descriptor() {
        return UnregisterBadMemoryNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterBadMemoryNotification(PVOID RegistrationHandle)
     * }
     */
    public static MethodHandle UnregisterBadMemoryNotification$handle() {
        return UnregisterBadMemoryNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterBadMemoryNotification(PVOID RegistrationHandle)
     * }
     */
    public static MemorySegment UnregisterBadMemoryNotification$address() {
        return UnregisterBadMemoryNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterBadMemoryNotification(PVOID RegistrationHandle)
     * }
     */
    public static int UnregisterBadMemoryNotification(MemorySegment RegistrationHandle) {
        var mh$ = UnregisterBadMemoryNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterBadMemoryNotification", RegistrationHandle);
            }
            return (int)mh$.invokeExact(RegistrationHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VmOfferPriorityVeryLow = (int)1L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityVeryLow = 1
     * }
     */
    public static int VmOfferPriorityVeryLow() {
        return VmOfferPriorityVeryLow;
    }
    private static final int VmOfferPriorityLow = (int)2L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityLow = 2
     * }
     */
    public static int VmOfferPriorityLow() {
        return VmOfferPriorityLow;
    }
    private static final int VmOfferPriorityBelowNormal = (int)3L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityBelowNormal = 3
     * }
     */
    public static int VmOfferPriorityBelowNormal() {
        return VmOfferPriorityBelowNormal;
    }
    private static final int VmOfferPriorityNormal = (int)4L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityNormal = 4
     * }
     */
    public static int VmOfferPriorityNormal() {
        return VmOfferPriorityNormal;
    }

    private static class OfferVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OfferVirtualMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority)
     * }
     */
    public static FunctionDescriptor OfferVirtualMemory$descriptor() {
        return OfferVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority)
     * }
     */
    public static MethodHandle OfferVirtualMemory$handle() {
        return OfferVirtualMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority)
     * }
     */
    public static MemorySegment OfferVirtualMemory$address() {
        return OfferVirtualMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority)
     * }
     */
    public static int OfferVirtualMemory(MemorySegment VirtualAddress, long Size, int Priority) {
        var mh$ = OfferVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OfferVirtualMemory", VirtualAddress, Size, Priority);
            }
            return (int)mh$.invokeExact(VirtualAddress, Size, Priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReclaimVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReclaimVirtualMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ReclaimVirtualMemory(const void *VirtualAddress, SIZE_T Size)
     * }
     */
    public static FunctionDescriptor ReclaimVirtualMemory$descriptor() {
        return ReclaimVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ReclaimVirtualMemory(const void *VirtualAddress, SIZE_T Size)
     * }
     */
    public static MethodHandle ReclaimVirtualMemory$handle() {
        return ReclaimVirtualMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ReclaimVirtualMemory(const void *VirtualAddress, SIZE_T Size)
     * }
     */
    public static MemorySegment ReclaimVirtualMemory$address() {
        return ReclaimVirtualMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ReclaimVirtualMemory(const void *VirtualAddress, SIZE_T Size)
     * }
     */
    public static int ReclaimVirtualMemory(MemorySegment VirtualAddress, long Size) {
        var mh$ = ReclaimVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReclaimVirtualMemory", VirtualAddress, Size);
            }
            return (int)mh$.invokeExact(VirtualAddress, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DiscardVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DiscardVirtualMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size)
     * }
     */
    public static FunctionDescriptor DiscardVirtualMemory$descriptor() {
        return DiscardVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size)
     * }
     */
    public static MethodHandle DiscardVirtualMemory$handle() {
        return DiscardVirtualMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size)
     * }
     */
    public static MemorySegment DiscardVirtualMemory$address() {
        return DiscardVirtualMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size)
     * }
     */
    public static int DiscardVirtualMemory(MemorySegment VirtualAddress, long Size) {
        var mh$ = DiscardVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DiscardVirtualMemory", VirtualAddress, Size);
            }
            return (int)mh$.invokeExact(VirtualAddress, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessValidCallTargets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessValidCallTargets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargets(HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation)
     * }
     */
    public static FunctionDescriptor SetProcessValidCallTargets$descriptor() {
        return SetProcessValidCallTargets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargets(HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation)
     * }
     */
    public static MethodHandle SetProcessValidCallTargets$handle() {
        return SetProcessValidCallTargets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargets(HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation)
     * }
     */
    public static MemorySegment SetProcessValidCallTargets$address() {
        return SetProcessValidCallTargets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargets(HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation)
     * }
     */
    public static int SetProcessValidCallTargets(MemorySegment hProcess, MemorySegment VirtualAddress, long RegionSize, int NumberOfOffsets, MemorySegment OffsetInformation) {
        var mh$ = SetProcessValidCallTargets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessValidCallTargets", hProcess, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation);
            }
            return (int)mh$.invokeExact(hProcess, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessValidCallTargetsForMappedView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetProcessValidCallTargetsForMappedView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation, HANDLE Section, ULONG64 ExpectedFileOffset)
     * }
     */
    public static FunctionDescriptor SetProcessValidCallTargetsForMappedView$descriptor() {
        return SetProcessValidCallTargetsForMappedView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation, HANDLE Section, ULONG64 ExpectedFileOffset)
     * }
     */
    public static MethodHandle SetProcessValidCallTargetsForMappedView$handle() {
        return SetProcessValidCallTargetsForMappedView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation, HANDLE Section, ULONG64 ExpectedFileOffset)
     * }
     */
    public static MemorySegment SetProcessValidCallTargetsForMappedView$address() {
        return SetProcessValidCallTargetsForMappedView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation, HANDLE Section, ULONG64 ExpectedFileOffset)
     * }
     */
    public static int SetProcessValidCallTargetsForMappedView(MemorySegment Process, MemorySegment VirtualAddress, long RegionSize, int NumberOfOffsets, MemorySegment OffsetInformation, MemorySegment Section, long ExpectedFileOffset) {
        var mh$ = SetProcessValidCallTargetsForMappedView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessValidCallTargetsForMappedView", Process, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation, Section, ExpectedFileOffset);
            }
            return (int)mh$.invokeExact(Process, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation, Section, ExpectedFileOffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAllocFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualAllocFromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection)
     * }
     */
    public static FunctionDescriptor VirtualAllocFromApp$descriptor() {
        return VirtualAllocFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection)
     * }
     */
    public static MethodHandle VirtualAllocFromApp$handle() {
        return VirtualAllocFromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection)
     * }
     */
    public static MemorySegment VirtualAllocFromApp$address() {
        return VirtualAllocFromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection)
     * }
     */
    public static MemorySegment VirtualAllocFromApp(MemorySegment BaseAddress, long Size, int AllocationType, int Protection) {
        var mh$ = VirtualAllocFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAllocFromApp", BaseAddress, Size, AllocationType, Protection);
            }
            return (MemorySegment)mh$.invokeExact(BaseAddress, Size, AllocationType, Protection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualProtectFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualProtectFromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection)
     * }
     */
    public static FunctionDescriptor VirtualProtectFromApp$descriptor() {
        return VirtualProtectFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection)
     * }
     */
    public static MethodHandle VirtualProtectFromApp$handle() {
        return VirtualProtectFromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection)
     * }
     */
    public static MemorySegment VirtualProtectFromApp$address() {
        return VirtualProtectFromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection)
     * }
     */
    public static int VirtualProtectFromApp(MemorySegment Address, long Size, int NewProtection, MemorySegment OldProtection) {
        var mh$ = VirtualProtectFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualProtectFromApp", Address, Size, NewProtection, OldProtection);
            }
            return (int)mh$.invokeExact(Address, Size, NewProtection, OldProtection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFileMappingFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenFileMappingFromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name)
     * }
     */
    public static FunctionDescriptor OpenFileMappingFromApp$descriptor() {
        return OpenFileMappingFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name)
     * }
     */
    public static MethodHandle OpenFileMappingFromApp$handle() {
        return OpenFileMappingFromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name)
     * }
     */
    public static MemorySegment OpenFileMappingFromApp$address() {
        return OpenFileMappingFromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name)
     * }
     */
    public static MemorySegment OpenFileMappingFromApp(int DesiredAccess, int InheritHandle, MemorySegment Name) {
        var mh$ = OpenFileMappingFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileMappingFromApp", DesiredAccess, InheritHandle, Name);
            }
            return (MemorySegment)mh$.invokeExact(DesiredAccess, InheritHandle, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int MemoryRegionInfo = (int)0L;
    /**
     * {@snippet lang=c :
     * enum WIN32_MEMORY_INFORMATION_CLASS.MemoryRegionInfo = 0
     * }
     */
    public static int MemoryRegionInfo() {
        return MemoryRegionInfo;
    }

    private static class QueryVirtualMemoryInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryVirtualMemoryInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryVirtualMemoryInformation(HANDLE Process, const void *VirtualAddress, WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationSize, PSIZE_T ReturnSize)
     * }
     */
    public static FunctionDescriptor QueryVirtualMemoryInformation$descriptor() {
        return QueryVirtualMemoryInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryVirtualMemoryInformation(HANDLE Process, const void *VirtualAddress, WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationSize, PSIZE_T ReturnSize)
     * }
     */
    public static MethodHandle QueryVirtualMemoryInformation$handle() {
        return QueryVirtualMemoryInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryVirtualMemoryInformation(HANDLE Process, const void *VirtualAddress, WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationSize, PSIZE_T ReturnSize)
     * }
     */
    public static MemorySegment QueryVirtualMemoryInformation$address() {
        return QueryVirtualMemoryInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryVirtualMemoryInformation(HANDLE Process, const void *VirtualAddress, WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationSize, PSIZE_T ReturnSize)
     * }
     */
    public static int QueryVirtualMemoryInformation(MemorySegment Process, MemorySegment VirtualAddress, int MemoryInformationClass, MemorySegment MemoryInformation, long MemoryInformationSize, MemorySegment ReturnSize) {
        var mh$ = QueryVirtualMemoryInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryVirtualMemoryInformation", Process, VirtualAddress, MemoryInformationClass, MemoryInformation, MemoryInformationSize, ReturnSize);
            }
            return (int)mh$.invokeExact(Process, VirtualAddress, MemoryInformationClass, MemoryInformation, MemoryInformationSize, ReturnSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileNuma2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapViewOfFileNuma2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)
     * }
     */
    public static FunctionDescriptor MapViewOfFileNuma2$descriptor() {
        return MapViewOfFileNuma2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)
     * }
     */
    public static MethodHandle MapViewOfFileNuma2$handle() {
        return MapViewOfFileNuma2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)
     * }
     */
    public static MemorySegment MapViewOfFileNuma2$address() {
        return MapViewOfFileNuma2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)
     * }
     */
    public static MemorySegment MapViewOfFileNuma2(MemorySegment FileMappingHandle, MemorySegment ProcessHandle, long Offset, MemorySegment BaseAddress, long ViewSize, int AllocationType, int PageProtection, int PreferredNode) {
        var mh$ = MapViewOfFileNuma2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileNuma2", FileMappingHandle, ProcessHandle, Offset, BaseAddress, ViewSize, AllocationType, PageProtection, PreferredNode);
            }
            return (MemorySegment)mh$.invokeExact(FileMappingHandle, ProcessHandle, Offset, BaseAddress, ViewSize, AllocationType, PageProtection, PreferredNode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnmapViewOfFile2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnmapViewOfFile2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static FunctionDescriptor UnmapViewOfFile2$descriptor() {
        return UnmapViewOfFile2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static MethodHandle UnmapViewOfFile2$handle() {
        return UnmapViewOfFile2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static MemorySegment UnmapViewOfFile2$address() {
        return UnmapViewOfFile2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static int UnmapViewOfFile2(MemorySegment Process, MemorySegment BaseAddress, int UnmapFlags) {
        var mh$ = UnmapViewOfFile2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnmapViewOfFile2", Process, BaseAddress, UnmapFlags);
            }
            return (int)mh$.invokeExact(Process, BaseAddress, UnmapFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualUnlockEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualUnlockEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size)
     * }
     */
    public static FunctionDescriptor VirtualUnlockEx$descriptor() {
        return VirtualUnlockEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size)
     * }
     */
    public static MethodHandle VirtualUnlockEx$handle() {
        return VirtualUnlockEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size)
     * }
     */
    public static MemorySegment VirtualUnlockEx$address() {
        return VirtualUnlockEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size)
     * }
     */
    public static int VirtualUnlockEx(MemorySegment Process, MemorySegment Address, long Size) {
        var mh$ = VirtualUnlockEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualUnlockEx", Process, Address, Size);
            }
            return (int)mh$.invokeExact(Process, Address, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAlloc2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualAlloc2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor VirtualAlloc2$descriptor() {
        return VirtualAlloc2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle VirtualAlloc2$handle() {
        return VirtualAlloc2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment VirtualAlloc2$address() {
        return VirtualAlloc2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID VirtualAlloc2(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment VirtualAlloc2(MemorySegment Process, MemorySegment BaseAddress, long Size, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = VirtualAlloc2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAlloc2", Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFile3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapViewOfFile3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor MapViewOfFile3$descriptor() {
        return MapViewOfFile3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle MapViewOfFile3$handle() {
        return MapViewOfFile3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment MapViewOfFile3$address() {
        return MapViewOfFile3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFile3(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment MapViewOfFile3(MemorySegment FileMapping, MemorySegment Process, MemorySegment BaseAddress, long Offset, long ViewSize, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = MapViewOfFile3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFile3", FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAlloc2FromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("VirtualAlloc2FromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2FromApp(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor VirtualAlloc2FromApp$descriptor() {
        return VirtualAlloc2FromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2FromApp(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle VirtualAlloc2FromApp$handle() {
        return VirtualAlloc2FromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2FromApp(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment VirtualAlloc2FromApp$address() {
        return VirtualAlloc2FromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID VirtualAlloc2FromApp(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment VirtualAlloc2FromApp(MemorySegment Process, MemorySegment BaseAddress, long Size, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = VirtualAlloc2FromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAlloc2FromApp", Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFile3FromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapViewOfFile3FromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor MapViewOfFile3FromApp$descriptor() {
        return MapViewOfFile3FromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle MapViewOfFile3FromApp$handle() {
        return MapViewOfFile3FromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment MapViewOfFile3FromApp$address() {
        return MapViewOfFile3FromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment MapViewOfFile3FromApp(MemorySegment FileMapping, MemorySegment Process, MemorySegment BaseAddress, long Offset, long ViewSize, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = MapViewOfFile3FromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFile3FromApp", FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMapping2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateFileMapping2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES *SecurityAttributes, ULONG DesiredAccess, ULONG PageProtection, ULONG AllocationAttributes, ULONG64 MaximumSize, PCWSTR Name, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor CreateFileMapping2$descriptor() {
        return CreateFileMapping2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES *SecurityAttributes, ULONG DesiredAccess, ULONG PageProtection, ULONG AllocationAttributes, ULONG64 MaximumSize, PCWSTR Name, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle CreateFileMapping2$handle() {
        return CreateFileMapping2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES *SecurityAttributes, ULONG DesiredAccess, ULONG PageProtection, ULONG AllocationAttributes, ULONG64 MaximumSize, PCWSTR Name, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment CreateFileMapping2$address() {
        return CreateFileMapping2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES *SecurityAttributes, ULONG DesiredAccess, ULONG PageProtection, ULONG AllocationAttributes, ULONG64 MaximumSize, PCWSTR Name, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment CreateFileMapping2(MemorySegment File, MemorySegment SecurityAttributes, int DesiredAccess, int PageProtection, int AllocationAttributes, long MaximumSize, MemorySegment Name, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = CreateFileMapping2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMapping2", File, SecurityAttributes, DesiredAccess, PageProtection, AllocationAttributes, MaximumSize, Name, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(File, SecurityAttributes, DesiredAccess, PageProtection, AllocationAttributes, MaximumSize, Name, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsEnclaveTypeSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsEnclaveTypeSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsEnclaveTypeSupported(DWORD flEnclaveType)
     * }
     */
    public static FunctionDescriptor IsEnclaveTypeSupported$descriptor() {
        return IsEnclaveTypeSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsEnclaveTypeSupported(DWORD flEnclaveType)
     * }
     */
    public static MethodHandle IsEnclaveTypeSupported$handle() {
        return IsEnclaveTypeSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsEnclaveTypeSupported(DWORD flEnclaveType)
     * }
     */
    public static MemorySegment IsEnclaveTypeSupported$address() {
        return IsEnclaveTypeSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsEnclaveTypeSupported(DWORD flEnclaveType)
     * }
     */
    public static int IsEnclaveTypeSupported(int flEnclaveType) {
        var mh$ = IsEnclaveTypeSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsEnclaveTypeSupported", flEnclaveType);
            }
            return (int)mh$.invokeExact(flEnclaveType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateEnclave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CreateEnclave(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, SIZE_T dwInitialCommitment, DWORD flEnclaveType, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static FunctionDescriptor CreateEnclave$descriptor() {
        return CreateEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CreateEnclave(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, SIZE_T dwInitialCommitment, DWORD flEnclaveType, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MethodHandle CreateEnclave$handle() {
        return CreateEnclave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID CreateEnclave(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, SIZE_T dwInitialCommitment, DWORD flEnclaveType, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MemorySegment CreateEnclave$address() {
        return CreateEnclave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID CreateEnclave(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, SIZE_T dwInitialCommitment, DWORD flEnclaveType, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MemorySegment CreateEnclave(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, long dwInitialCommitment, int flEnclaveType, MemorySegment lpEnclaveInformation, int dwInfoLength, MemorySegment lpEnclaveError) {
        var mh$ = CreateEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEnclave", hProcess, lpAddress, dwSize, dwInitialCommitment, flEnclaveType, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpAddress, dwSize, dwInitialCommitment, flEnclaveType, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadEnclaveData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadEnclaveData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveData(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpBuffer, SIZE_T nSize, DWORD flProtect, LPCVOID lpPageInformation, DWORD dwInfoLength, PSIZE_T lpNumberOfBytesWritten, LPDWORD lpEnclaveError)
     * }
     */
    public static FunctionDescriptor LoadEnclaveData$descriptor() {
        return LoadEnclaveData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveData(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpBuffer, SIZE_T nSize, DWORD flProtect, LPCVOID lpPageInformation, DWORD dwInfoLength, PSIZE_T lpNumberOfBytesWritten, LPDWORD lpEnclaveError)
     * }
     */
    public static MethodHandle LoadEnclaveData$handle() {
        return LoadEnclaveData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveData(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpBuffer, SIZE_T nSize, DWORD flProtect, LPCVOID lpPageInformation, DWORD dwInfoLength, PSIZE_T lpNumberOfBytesWritten, LPDWORD lpEnclaveError)
     * }
     */
    public static MemorySegment LoadEnclaveData$address() {
        return LoadEnclaveData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LoadEnclaveData(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpBuffer, SIZE_T nSize, DWORD flProtect, LPCVOID lpPageInformation, DWORD dwInfoLength, PSIZE_T lpNumberOfBytesWritten, LPDWORD lpEnclaveError)
     * }
     */
    public static int LoadEnclaveData(MemorySegment hProcess, MemorySegment lpAddress, MemorySegment lpBuffer, long nSize, int flProtect, MemorySegment lpPageInformation, int dwInfoLength, MemorySegment lpNumberOfBytesWritten, MemorySegment lpEnclaveError) {
        var mh$ = LoadEnclaveData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadEnclaveData", hProcess, lpAddress, lpBuffer, nSize, flProtect, lpPageInformation, dwInfoLength, lpNumberOfBytesWritten, lpEnclaveError);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, lpBuffer, nSize, flProtect, lpPageInformation, dwInfoLength, lpNumberOfBytesWritten, lpEnclaveError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeEnclave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static FunctionDescriptor InitializeEnclave$descriptor() {
        return InitializeEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MethodHandle InitializeEnclave$handle() {
        return InitializeEnclave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MemorySegment InitializeEnclave$address() {
        return InitializeEnclave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static int InitializeEnclave(MemorySegment hProcess, MemorySegment lpAddress, MemorySegment lpEnclaveInformation, int dwInfoLength, MemorySegment lpEnclaveError) {
        var mh$ = InitializeEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeEnclave", hProcess, lpAddress, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadEnclaveImageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadEnclaveImageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName)
     * }
     */
    public static FunctionDescriptor LoadEnclaveImageA$descriptor() {
        return LoadEnclaveImageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName)
     * }
     */
    public static MethodHandle LoadEnclaveImageA$handle() {
        return LoadEnclaveImageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName)
     * }
     */
    public static MemorySegment LoadEnclaveImageA$address() {
        return LoadEnclaveImageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName)
     * }
     */
    public static int LoadEnclaveImageA(MemorySegment lpEnclaveAddress, MemorySegment lpImageName) {
        var mh$ = LoadEnclaveImageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadEnclaveImageA", lpEnclaveAddress, lpImageName);
            }
            return (int)mh$.invokeExact(lpEnclaveAddress, lpImageName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadEnclaveImageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadEnclaveImageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName)
     * }
     */
    public static FunctionDescriptor LoadEnclaveImageW$descriptor() {
        return LoadEnclaveImageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName)
     * }
     */
    public static MethodHandle LoadEnclaveImageW$handle() {
        return LoadEnclaveImageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName)
     * }
     */
    public static MemorySegment LoadEnclaveImageW$address() {
        return LoadEnclaveImageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName)
     * }
     */
    public static int LoadEnclaveImageW(MemorySegment lpEnclaveAddress, MemorySegment lpImageName) {
        var mh$ = LoadEnclaveImageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadEnclaveImageW", lpEnclaveAddress, lpImageName);
            }
            return (int)mh$.invokeExact(lpEnclaveAddress, lpImageName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CallEnclave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID *lpReturnValue)
     * }
     */
    public static FunctionDescriptor CallEnclave$descriptor() {
        return CallEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID *lpReturnValue)
     * }
     */
    public static MethodHandle CallEnclave$handle() {
        return CallEnclave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID *lpReturnValue)
     * }
     */
    public static MemorySegment CallEnclave$address() {
        return CallEnclave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID *lpReturnValue)
     * }
     */
    public static int CallEnclave(MemorySegment lpRoutine, MemorySegment lpParameter, int fWaitForThread, MemorySegment lpReturnValue) {
        var mh$ = CallEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallEnclave", lpRoutine, lpParameter, fWaitForThread, lpReturnValue);
            }
            return (int)mh$.invokeExact(lpRoutine, lpParameter, fWaitForThread, lpReturnValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TerminateEnclave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateEnclave(LPVOID lpAddress, BOOL fWait)
     * }
     */
    public static FunctionDescriptor TerminateEnclave$descriptor() {
        return TerminateEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateEnclave(LPVOID lpAddress, BOOL fWait)
     * }
     */
    public static MethodHandle TerminateEnclave$handle() {
        return TerminateEnclave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TerminateEnclave(LPVOID lpAddress, BOOL fWait)
     * }
     */
    public static MemorySegment TerminateEnclave$address() {
        return TerminateEnclave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TerminateEnclave(LPVOID lpAddress, BOOL fWait)
     * }
     */
    public static int TerminateEnclave(MemorySegment lpAddress, int fWait) {
        var mh$ = TerminateEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateEnclave", lpAddress, fWait);
            }
            return (int)mh$.invokeExact(lpAddress, fWait);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteEnclave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteEnclave(LPVOID lpAddress)
     * }
     */
    public static FunctionDescriptor DeleteEnclave$descriptor() {
        return DeleteEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteEnclave(LPVOID lpAddress)
     * }
     */
    public static MethodHandle DeleteEnclave$handle() {
        return DeleteEnclave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteEnclave(LPVOID lpAddress)
     * }
     */
    public static MemorySegment DeleteEnclave$address() {
        return DeleteEnclave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteEnclave(LPVOID lpAddress)
     * }
     */
    public static int DeleteEnclave(MemorySegment lpAddress) {
        var mh$ = DeleteEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteEnclave", lpAddress);
            }
            return (int)mh$.invokeExact(lpAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueueUserWorkItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueueUserWorkItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
     * }
     */
    public static FunctionDescriptor QueueUserWorkItem$descriptor() {
        return QueueUserWorkItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
     * }
     */
    public static MethodHandle QueueUserWorkItem$handle() {
        return QueueUserWorkItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
     * }
     */
    public static MemorySegment QueueUserWorkItem$address() {
        return QueueUserWorkItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
     * }
     */
    public static int QueueUserWorkItem(MemorySegment Function, MemorySegment Context, int Flags) {
        var mh$ = QueueUserWorkItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueueUserWorkItem", Function, Context, Flags);
            }
            return (int)mh$.invokeExact(Function, Context, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterWaitEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("UnregisterWaitEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
     * }
     */
    public static FunctionDescriptor UnregisterWaitEx$descriptor() {
        return UnregisterWaitEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
     * }
     */
    public static MethodHandle UnregisterWaitEx$handle() {
        return UnregisterWaitEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
     * }
     */
    public static MemorySegment UnregisterWaitEx$address() {
        return UnregisterWaitEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
     * }
     */
    public static int UnregisterWaitEx(MemorySegment WaitHandle, MemorySegment CompletionEvent) {
        var mh$ = UnregisterWaitEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterWaitEx", WaitHandle, CompletionEvent);
            }
            return (int)mh$.invokeExact(WaitHandle, CompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateTimerQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateTimerQueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateTimerQueue()
     * }
     */
    public static FunctionDescriptor CreateTimerQueue$descriptor() {
        return CreateTimerQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateTimerQueue()
     * }
     */
    public static MethodHandle CreateTimerQueue$handle() {
        return CreateTimerQueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateTimerQueue()
     * }
     */
    public static MemorySegment CreateTimerQueue$address() {
        return CreateTimerQueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateTimerQueue()
     * }
     */
    public static MemorySegment CreateTimerQueue() {
        var mh$ = CreateTimerQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateTimerQueue");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateTimerQueueTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateTimerQueueTimer$descriptor() {
        return CreateTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
     * }
     */
    public static MethodHandle CreateTimerQueueTimer$handle() {
        return CreateTimerQueueTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
     * }
     */
    public static MemorySegment CreateTimerQueueTimer$address() {
        return CreateTimerQueueTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
     * }
     */
    public static int CreateTimerQueueTimer(MemorySegment phNewTimer, MemorySegment TimerQueue, MemorySegment Callback, MemorySegment Parameter, int DueTime, int Period, int Flags) {
        var mh$ = CreateTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateTimerQueueTimer", phNewTimer, TimerQueue, Callback, Parameter, DueTime, Period, Flags);
            }
            return (int)mh$.invokeExact(phNewTimer, TimerQueue, Callback, Parameter, DueTime, Period, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ChangeTimerQueueTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
     * }
     */
    public static FunctionDescriptor ChangeTimerQueueTimer$descriptor() {
        return ChangeTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
     * }
     */
    public static MethodHandle ChangeTimerQueueTimer$handle() {
        return ChangeTimerQueueTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
     * }
     */
    public static MemorySegment ChangeTimerQueueTimer$address() {
        return ChangeTimerQueueTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
     * }
     */
    public static int ChangeTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Timer, int DueTime, int Period) {
        var mh$ = ChangeTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeTimerQueueTimer", TimerQueue, Timer, DueTime, Period);
            }
            return (int)mh$.invokeExact(TimerQueue, Timer, DueTime, Period);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteTimerQueueTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
     * }
     */
    public static FunctionDescriptor DeleteTimerQueueTimer$descriptor() {
        return DeleteTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
     * }
     */
    public static MethodHandle DeleteTimerQueueTimer$handle() {
        return DeleteTimerQueueTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
     * }
     */
    public static MemorySegment DeleteTimerQueueTimer$address() {
        return DeleteTimerQueueTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
     * }
     */
    public static int DeleteTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Timer, MemorySegment CompletionEvent) {
        var mh$ = DeleteTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteTimerQueueTimer", TimerQueue, Timer, CompletionEvent);
            }
            return (int)mh$.invokeExact(TimerQueue, Timer, CompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteTimerQueueEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteTimerQueueEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent)
     * }
     */
    public static FunctionDescriptor DeleteTimerQueueEx$descriptor() {
        return DeleteTimerQueueEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent)
     * }
     */
    public static MethodHandle DeleteTimerQueueEx$handle() {
        return DeleteTimerQueueEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent)
     * }
     */
    public static MemorySegment DeleteTimerQueueEx$address() {
        return DeleteTimerQueueEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent)
     * }
     */
    public static int DeleteTimerQueueEx(MemorySegment TimerQueue, MemorySegment CompletionEvent) {
        var mh$ = DeleteTimerQueueEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteTimerQueueEx", TimerQueue, CompletionEvent);
            }
            return (int)mh$.invokeExact(TimerQueue, CompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateThreadpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_POOL CreateThreadpool(PVOID reserved)
     * }
     */
    public static FunctionDescriptor CreateThreadpool$descriptor() {
        return CreateThreadpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_POOL CreateThreadpool(PVOID reserved)
     * }
     */
    public static MethodHandle CreateThreadpool$handle() {
        return CreateThreadpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_POOL CreateThreadpool(PVOID reserved)
     * }
     */
    public static MemorySegment CreateThreadpool$address() {
        return CreateThreadpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_POOL CreateThreadpool(PVOID reserved)
     * }
     */
    public static MemorySegment CreateThreadpool(MemorySegment reserved) {
        var mh$ = CreateThreadpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpool", reserved);
            }
            return (MemorySegment)mh$.invokeExact(reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolThreadMaximum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadpoolThreadMaximum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost)
     * }
     */
    public static FunctionDescriptor SetThreadpoolThreadMaximum$descriptor() {
        return SetThreadpoolThreadMaximum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost)
     * }
     */
    public static MethodHandle SetThreadpoolThreadMaximum$handle() {
        return SetThreadpoolThreadMaximum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost)
     * }
     */
    public static MemorySegment SetThreadpoolThreadMaximum$address() {
        return SetThreadpoolThreadMaximum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost)
     * }
     */
    public static void SetThreadpoolThreadMaximum(MemorySegment ptpp, int cthrdMost) {
        var mh$ = SetThreadpoolThreadMaximum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolThreadMaximum", ptpp, cthrdMost);
            }
            mh$.invokeExact(ptpp, cthrdMost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolThreadMinimum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadpoolThreadMinimum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
     * }
     */
    public static FunctionDescriptor SetThreadpoolThreadMinimum$descriptor() {
        return SetThreadpoolThreadMinimum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
     * }
     */
    public static MethodHandle SetThreadpoolThreadMinimum$handle() {
        return SetThreadpoolThreadMinimum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
     * }
     */
    public static MemorySegment SetThreadpoolThreadMinimum$address() {
        return SetThreadpoolThreadMinimum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
     * }
     */
    public static int SetThreadpoolThreadMinimum(MemorySegment ptpp, int cthrdMic) {
        var mh$ = SetThreadpoolThreadMinimum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolThreadMinimum", ptpp, cthrdMic);
            }
            return (int)mh$.invokeExact(ptpp, cthrdMic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolStackInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadpoolStackInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static FunctionDescriptor SetThreadpoolStackInformation$descriptor() {
        return SetThreadpoolStackInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static MethodHandle SetThreadpoolStackInformation$handle() {
        return SetThreadpoolStackInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static MemorySegment SetThreadpoolStackInformation$address() {
        return SetThreadpoolStackInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static int SetThreadpoolStackInformation(MemorySegment ptpp, MemorySegment ptpsi) {
        var mh$ = SetThreadpoolStackInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolStackInformation", ptpp, ptpsi);
            }
            return (int)mh$.invokeExact(ptpp, ptpsi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryThreadpoolStackInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryThreadpoolStackInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static FunctionDescriptor QueryThreadpoolStackInformation$descriptor() {
        return QueryThreadpoolStackInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static MethodHandle QueryThreadpoolStackInformation$handle() {
        return QueryThreadpoolStackInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static MemorySegment QueryThreadpoolStackInformation$address() {
        return QueryThreadpoolStackInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static int QueryThreadpoolStackInformation(MemorySegment ptpp, MemorySegment ptpsi) {
        var mh$ = QueryThreadpoolStackInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryThreadpoolStackInformation", ptpp, ptpsi);
            }
            return (int)mh$.invokeExact(ptpp, ptpsi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseThreadpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpool(PTP_POOL ptpp)
     * }
     */
    public static FunctionDescriptor CloseThreadpool$descriptor() {
        return CloseThreadpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpool(PTP_POOL ptpp)
     * }
     */
    public static MethodHandle CloseThreadpool$handle() {
        return CloseThreadpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpool(PTP_POOL ptpp)
     * }
     */
    public static MemorySegment CloseThreadpool$address() {
        return CloseThreadpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpool(PTP_POOL ptpp)
     * }
     */
    public static void CloseThreadpool(MemorySegment ptpp) {
        var mh$ = CloseThreadpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpool", ptpp);
            }
            mh$.invokeExact(ptpp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolCleanupGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateThreadpoolCleanupGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup()
     * }
     */
    public static FunctionDescriptor CreateThreadpoolCleanupGroup$descriptor() {
        return CreateThreadpoolCleanupGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup()
     * }
     */
    public static MethodHandle CreateThreadpoolCleanupGroup$handle() {
        return CreateThreadpoolCleanupGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup()
     * }
     */
    public static MemorySegment CreateThreadpoolCleanupGroup$address() {
        return CreateThreadpoolCleanupGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup()
     * }
     */
    public static MemorySegment CreateThreadpoolCleanupGroup() {
        var mh$ = CreateThreadpoolCleanupGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolCleanupGroup");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolCleanupGroupMembers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseThreadpoolCleanupGroupMembers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolCleanupGroupMembers$descriptor() {
        return CloseThreadpoolCleanupGroupMembers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext)
     * }
     */
    public static MethodHandle CloseThreadpoolCleanupGroupMembers$handle() {
        return CloseThreadpoolCleanupGroupMembers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext)
     * }
     */
    public static MemorySegment CloseThreadpoolCleanupGroupMembers$address() {
        return CloseThreadpoolCleanupGroupMembers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext)
     * }
     */
    public static void CloseThreadpoolCleanupGroupMembers(MemorySegment ptpcg, int fCancelPendingCallbacks, MemorySegment pvCleanupContext) {
        var mh$ = CloseThreadpoolCleanupGroupMembers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolCleanupGroupMembers", ptpcg, fCancelPendingCallbacks, pvCleanupContext);
            }
            mh$.invokeExact(ptpcg, fCancelPendingCallbacks, pvCleanupContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolCleanupGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseThreadpoolCleanupGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolCleanupGroup$descriptor() {
        return CloseThreadpoolCleanupGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)
     * }
     */
    public static MethodHandle CloseThreadpoolCleanupGroup$handle() {
        return CloseThreadpoolCleanupGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)
     * }
     */
    public static MemorySegment CloseThreadpoolCleanupGroup$address() {
        return CloseThreadpoolCleanupGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)
     * }
     */
    public static void CloseThreadpoolCleanupGroup(MemorySegment ptpcg) {
        var mh$ = CloseThreadpoolCleanupGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolCleanupGroup", ptpcg);
            }
            mh$.invokeExact(ptpcg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEventWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetEventWhenCallbackReturns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt)
     * }
     */
    public static FunctionDescriptor SetEventWhenCallbackReturns$descriptor() {
        return SetEventWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt)
     * }
     */
    public static MethodHandle SetEventWhenCallbackReturns$handle() {
        return SetEventWhenCallbackReturns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt)
     * }
     */
    public static MemorySegment SetEventWhenCallbackReturns$address() {
        return SetEventWhenCallbackReturns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt)
     * }
     */
    public static void SetEventWhenCallbackReturns(MemorySegment pci, MemorySegment evt) {
        var mh$ = SetEventWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEventWhenCallbackReturns", pci, evt);
            }
            mh$.invokeExact(pci, evt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSemaphoreWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReleaseSemaphoreWhenCallbackReturns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)
     * }
     */
    public static FunctionDescriptor ReleaseSemaphoreWhenCallbackReturns$descriptor() {
        return ReleaseSemaphoreWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)
     * }
     */
    public static MethodHandle ReleaseSemaphoreWhenCallbackReturns$handle() {
        return ReleaseSemaphoreWhenCallbackReturns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)
     * }
     */
    public static MemorySegment ReleaseSemaphoreWhenCallbackReturns$address() {
        return ReleaseSemaphoreWhenCallbackReturns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)
     * }
     */
    public static void ReleaseSemaphoreWhenCallbackReturns(MemorySegment pci, MemorySegment sem, int crel) {
        var mh$ = ReleaseSemaphoreWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSemaphoreWhenCallbackReturns", pci, sem, crel);
            }
            mh$.invokeExact(pci, sem, crel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseMutexWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ReleaseMutexWhenCallbackReturns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut)
     * }
     */
    public static FunctionDescriptor ReleaseMutexWhenCallbackReturns$descriptor() {
        return ReleaseMutexWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut)
     * }
     */
    public static MethodHandle ReleaseMutexWhenCallbackReturns$handle() {
        return ReleaseMutexWhenCallbackReturns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut)
     * }
     */
    public static MemorySegment ReleaseMutexWhenCallbackReturns$address() {
        return ReleaseMutexWhenCallbackReturns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut)
     * }
     */
    public static void ReleaseMutexWhenCallbackReturns(MemorySegment pci, MemorySegment mut) {
        var mh$ = ReleaseMutexWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseMutexWhenCallbackReturns", pci, mut);
            }
            mh$.invokeExact(pci, mut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LeaveCriticalSectionWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LeaveCriticalSectionWhenCallbackReturns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)
     * }
     */
    public static FunctionDescriptor LeaveCriticalSectionWhenCallbackReturns$descriptor() {
        return LeaveCriticalSectionWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)
     * }
     */
    public static MethodHandle LeaveCriticalSectionWhenCallbackReturns$handle() {
        return LeaveCriticalSectionWhenCallbackReturns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)
     * }
     */
    public static MemorySegment LeaveCriticalSectionWhenCallbackReturns$address() {
        return LeaveCriticalSectionWhenCallbackReturns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)
     * }
     */
    public static void LeaveCriticalSectionWhenCallbackReturns(MemorySegment pci, MemorySegment pcs) {
        var mh$ = LeaveCriticalSectionWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LeaveCriticalSectionWhenCallbackReturns", pci, pcs);
            }
            mh$.invokeExact(pci, pcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeLibraryWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FreeLibraryWhenCallbackReturns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod)
     * }
     */
    public static FunctionDescriptor FreeLibraryWhenCallbackReturns$descriptor() {
        return FreeLibraryWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod)
     * }
     */
    public static MethodHandle FreeLibraryWhenCallbackReturns$handle() {
        return FreeLibraryWhenCallbackReturns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod)
     * }
     */
    public static MemorySegment FreeLibraryWhenCallbackReturns$address() {
        return FreeLibraryWhenCallbackReturns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod)
     * }
     */
    public static void FreeLibraryWhenCallbackReturns(MemorySegment pci, MemorySegment mod) {
        var mh$ = FreeLibraryWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeLibraryWhenCallbackReturns", pci, mod);
            }
            mh$.invokeExact(pci, mod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallbackMayRunLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CallbackMayRunLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static FunctionDescriptor CallbackMayRunLong$descriptor() {
        return CallbackMayRunLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static MethodHandle CallbackMayRunLong$handle() {
        return CallbackMayRunLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static MemorySegment CallbackMayRunLong$address() {
        return CallbackMayRunLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static int CallbackMayRunLong(MemorySegment pci) {
        var mh$ = CallbackMayRunLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallbackMayRunLong", pci);
            }
            return (int)mh$.invokeExact(pci);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisassociateCurrentThreadFromCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DisassociateCurrentThreadFromCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static FunctionDescriptor DisassociateCurrentThreadFromCallback$descriptor() {
        return DisassociateCurrentThreadFromCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static MethodHandle DisassociateCurrentThreadFromCallback$handle() {
        return DisassociateCurrentThreadFromCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static MemorySegment DisassociateCurrentThreadFromCallback$address() {
        return DisassociateCurrentThreadFromCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static void DisassociateCurrentThreadFromCallback(MemorySegment pci) {
        var mh$ = DisassociateCurrentThreadFromCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisassociateCurrentThreadFromCallback", pci);
            }
            mh$.invokeExact(pci);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TrySubmitThreadpoolCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TrySubmitThreadpoolCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor TrySubmitThreadpoolCallback$descriptor() {
        return TrySubmitThreadpoolCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle TrySubmitThreadpoolCallback$handle() {
        return TrySubmitThreadpoolCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment TrySubmitThreadpoolCallback$address() {
        return TrySubmitThreadpoolCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static int TrySubmitThreadpoolCallback(MemorySegment pfns, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = TrySubmitThreadpoolCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrySubmitThreadpoolCallback", pfns, pv, pcbe);
            }
            return (int)mh$.invokeExact(pfns, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolWork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateThreadpoolWork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_WORK CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolWork$descriptor() {
        return CreateThreadpoolWork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_WORK CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolWork$handle() {
        return CreateThreadpoolWork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_WORK CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolWork$address() {
        return CreateThreadpoolWork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_WORK CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolWork(MemorySegment pfnwk, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolWork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolWork", pfnwk, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(pfnwk, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SubmitThreadpoolWork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SubmitThreadpoolWork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SubmitThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static FunctionDescriptor SubmitThreadpoolWork$descriptor() {
        return SubmitThreadpoolWork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SubmitThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static MethodHandle SubmitThreadpoolWork$handle() {
        return SubmitThreadpoolWork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SubmitThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static MemorySegment SubmitThreadpoolWork$address() {
        return SubmitThreadpoolWork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SubmitThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static void SubmitThreadpoolWork(MemorySegment pwk) {
        var mh$ = SubmitThreadpoolWork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SubmitThreadpoolWork", pwk);
            }
            mh$.invokeExact(pwk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolWorkCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitForThreadpoolWorkCallbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolWorkCallbacks$descriptor() {
        return WaitForThreadpoolWorkCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolWorkCallbacks$handle() {
        return WaitForThreadpoolWorkCallbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MemorySegment WaitForThreadpoolWorkCallbacks$address() {
        return WaitForThreadpoolWorkCallbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolWorkCallbacks(MemorySegment pwk, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolWorkCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolWorkCallbacks", pwk, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pwk, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolWork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseThreadpoolWork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolWork$descriptor() {
        return CloseThreadpoolWork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static MethodHandle CloseThreadpoolWork$handle() {
        return CloseThreadpoolWork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static MemorySegment CloseThreadpoolWork$address() {
        return CloseThreadpoolWork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static void CloseThreadpoolWork(MemorySegment pwk) {
        var mh$ = CloseThreadpoolWork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolWork", pwk);
            }
            mh$.invokeExact(pwk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateThreadpoolTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolTimer$descriptor() {
        return CreateThreadpoolTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolTimer$handle() {
        return CreateThreadpoolTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolTimer$address() {
        return CreateThreadpoolTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolTimer(MemorySegment pfnti, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolTimer", pfnti, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(pfnti, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadpoolTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static FunctionDescriptor SetThreadpoolTimer$descriptor() {
        return SetThreadpoolTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static MethodHandle SetThreadpoolTimer$handle() {
        return SetThreadpoolTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static MemorySegment SetThreadpoolTimer$address() {
        return SetThreadpoolTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static void SetThreadpoolTimer(MemorySegment pti, MemorySegment pftDueTime, int msPeriod, int msWindowLength) {
        var mh$ = SetThreadpoolTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolTimer", pti, pftDueTime, msPeriod, msWindowLength);
            }
            mh$.invokeExact(pti, pftDueTime, msPeriod, msWindowLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsThreadpoolTimerSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsThreadpoolTimerSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsThreadpoolTimerSet(PTP_TIMER pti)
     * }
     */
    public static FunctionDescriptor IsThreadpoolTimerSet$descriptor() {
        return IsThreadpoolTimerSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsThreadpoolTimerSet(PTP_TIMER pti)
     * }
     */
    public static MethodHandle IsThreadpoolTimerSet$handle() {
        return IsThreadpoolTimerSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsThreadpoolTimerSet(PTP_TIMER pti)
     * }
     */
    public static MemorySegment IsThreadpoolTimerSet$address() {
        return IsThreadpoolTimerSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsThreadpoolTimerSet(PTP_TIMER pti)
     * }
     */
    public static int IsThreadpoolTimerSet(MemorySegment pti) {
        var mh$ = IsThreadpoolTimerSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsThreadpoolTimerSet", pti);
            }
            return (int)mh$.invokeExact(pti);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolTimerCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitForThreadpoolTimerCallbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolTimerCallbacks$descriptor() {
        return WaitForThreadpoolTimerCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolTimerCallbacks$handle() {
        return WaitForThreadpoolTimerCallbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MemorySegment WaitForThreadpoolTimerCallbacks$address() {
        return WaitForThreadpoolTimerCallbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolTimerCallbacks(MemorySegment pti, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolTimerCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolTimerCallbacks", pti, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pti, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseThreadpoolTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolTimer(PTP_TIMER pti)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolTimer$descriptor() {
        return CloseThreadpoolTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolTimer(PTP_TIMER pti)
     * }
     */
    public static MethodHandle CloseThreadpoolTimer$handle() {
        return CloseThreadpoolTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolTimer(PTP_TIMER pti)
     * }
     */
    public static MemorySegment CloseThreadpoolTimer$address() {
        return CloseThreadpoolTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolTimer(PTP_TIMER pti)
     * }
     */
    public static void CloseThreadpoolTimer(MemorySegment pti) {
        var mh$ = CloseThreadpoolTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolTimer", pti);
            }
            mh$.invokeExact(pti);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateThreadpoolWait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_WAIT CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolWait$descriptor() {
        return CreateThreadpoolWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_WAIT CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolWait$handle() {
        return CreateThreadpoolWait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_WAIT CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolWait$address() {
        return CreateThreadpoolWait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_WAIT CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolWait(MemorySegment pfnwa, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolWait", pfnwa, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(pfnwa, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadpoolWait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout)
     * }
     */
    public static FunctionDescriptor SetThreadpoolWait$descriptor() {
        return SetThreadpoolWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout)
     * }
     */
    public static MethodHandle SetThreadpoolWait$handle() {
        return SetThreadpoolWait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout)
     * }
     */
    public static MemorySegment SetThreadpoolWait$address() {
        return SetThreadpoolWait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout)
     * }
     */
    public static void SetThreadpoolWait(MemorySegment pwa, MemorySegment h, MemorySegment pftTimeout) {
        var mh$ = SetThreadpoolWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolWait", pwa, h, pftTimeout);
            }
            mh$.invokeExact(pwa, h, pftTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolWaitCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitForThreadpoolWaitCallbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolWaitCallbacks$descriptor() {
        return WaitForThreadpoolWaitCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolWaitCallbacks$handle() {
        return WaitForThreadpoolWaitCallbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MemorySegment WaitForThreadpoolWaitCallbacks$address() {
        return WaitForThreadpoolWaitCallbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolWaitCallbacks(MemorySegment pwa, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolWaitCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolWaitCallbacks", pwa, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pwa, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseThreadpoolWait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolWait(PTP_WAIT pwa)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolWait$descriptor() {
        return CloseThreadpoolWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolWait(PTP_WAIT pwa)
     * }
     */
    public static MethodHandle CloseThreadpoolWait$handle() {
        return CloseThreadpoolWait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolWait(PTP_WAIT pwa)
     * }
     */
    public static MemorySegment CloseThreadpoolWait$address() {
        return CloseThreadpoolWait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolWait(PTP_WAIT pwa)
     * }
     */
    public static void CloseThreadpoolWait(MemorySegment pwa) {
        var mh$ = CloseThreadpoolWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolWait", pwa);
            }
            mh$.invokeExact(pwa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateThreadpoolIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_IO CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolIo$descriptor() {
        return CreateThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_IO CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolIo$handle() {
        return CreateThreadpoolIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_IO CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolIo$address() {
        return CreateThreadpoolIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_IO CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolIo(MemorySegment fl, MemorySegment pfnio, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolIo", fl, pfnio, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(fl, pfnio, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("StartThreadpoolIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StartThreadpoolIo(PTP_IO pio)
     * }
     */
    public static FunctionDescriptor StartThreadpoolIo$descriptor() {
        return StartThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StartThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MethodHandle StartThreadpoolIo$handle() {
        return StartThreadpoolIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void StartThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MemorySegment StartThreadpoolIo$address() {
        return StartThreadpoolIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void StartThreadpoolIo(PTP_IO pio)
     * }
     */
    public static void StartThreadpoolIo(MemorySegment pio) {
        var mh$ = StartThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartThreadpoolIo", pio);
            }
            mh$.invokeExact(pio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CancelThreadpoolIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CancelThreadpoolIo(PTP_IO pio)
     * }
     */
    public static FunctionDescriptor CancelThreadpoolIo$descriptor() {
        return CancelThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CancelThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MethodHandle CancelThreadpoolIo$handle() {
        return CancelThreadpoolIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CancelThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MemorySegment CancelThreadpoolIo$address() {
        return CancelThreadpoolIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CancelThreadpoolIo(PTP_IO pio)
     * }
     */
    public static void CancelThreadpoolIo(MemorySegment pio) {
        var mh$ = CancelThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelThreadpoolIo", pio);
            }
            mh$.invokeExact(pio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolIoCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("WaitForThreadpoolIoCallbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolIoCallbacks$descriptor() {
        return WaitForThreadpoolIoCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolIoCallbacks$handle() {
        return WaitForThreadpoolIoCallbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MemorySegment WaitForThreadpoolIoCallbacks$address() {
        return WaitForThreadpoolIoCallbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolIoCallbacks(MemorySegment pio, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolIoCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolIoCallbacks", pio, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pio, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CloseThreadpoolIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolIo(PTP_IO pio)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolIo$descriptor() {
        return CloseThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MethodHandle CloseThreadpoolIo$handle() {
        return CloseThreadpoolIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MemorySegment CloseThreadpoolIo$address() {
        return CloseThreadpoolIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolIo(PTP_IO pio)
     * }
     */
    public static void CloseThreadpoolIo(MemorySegment pio) {
        var mh$ = CloseThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolIo", pio);
            }
            mh$.invokeExact(pio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolTimerEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadpoolTimerEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static FunctionDescriptor SetThreadpoolTimerEx$descriptor() {
        return SetThreadpoolTimerEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static MethodHandle SetThreadpoolTimerEx$handle() {
        return SetThreadpoolTimerEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static MemorySegment SetThreadpoolTimerEx$address() {
        return SetThreadpoolTimerEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static int SetThreadpoolTimerEx(MemorySegment pti, MemorySegment pftDueTime, int msPeriod, int msWindowLength) {
        var mh$ = SetThreadpoolTimerEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolTimerEx", pti, pftDueTime, msPeriod, msWindowLength);
            }
            return (int)mh$.invokeExact(pti, pftDueTime, msPeriod, msWindowLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolWaitEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadpoolWaitEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved)
     * }
     */
    public static FunctionDescriptor SetThreadpoolWaitEx$descriptor() {
        return SetThreadpoolWaitEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved)
     * }
     */
    public static MethodHandle SetThreadpoolWaitEx$handle() {
        return SetThreadpoolWaitEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved)
     * }
     */
    public static MemorySegment SetThreadpoolWaitEx$address() {
        return SetThreadpoolWaitEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved)
     * }
     */
    public static int SetThreadpoolWaitEx(MemorySegment pwa, MemorySegment h, MemorySegment pftTimeout, MemorySegment Reserved) {
        var mh$ = SetThreadpoolWaitEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolWaitEx", pwa, h, pftTimeout, Reserved);
            }
            return (int)mh$.invokeExact(pwa, h, pftTimeout, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsProcessInJob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsProcessInJob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
     * }
     */
    public static FunctionDescriptor IsProcessInJob$descriptor() {
        return IsProcessInJob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
     * }
     */
    public static MethodHandle IsProcessInJob$handle() {
        return IsProcessInJob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
     * }
     */
    public static MemorySegment IsProcessInJob$address() {
        return IsProcessInJob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
     * }
     */
    public static int IsProcessInJob(MemorySegment ProcessHandle, MemorySegment JobHandle, MemorySegment Result) {
        var mh$ = IsProcessInJob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsProcessInJob", ProcessHandle, JobHandle, Result);
            }
            return (int)mh$.invokeExact(ProcessHandle, JobHandle, Result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateJobObjectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateJobObjectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateJobObjectW$descriptor() {
        return CreateJobObjectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateJobObjectW$handle() {
        return CreateJobObjectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectW$address() {
        return CreateJobObjectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectW(MemorySegment lpJobAttributes, MemorySegment lpName) {
        var mh$ = CreateJobObjectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateJobObjectW", lpJobAttributes, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpJobAttributes, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeMemoryJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FreeMemoryJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeMemoryJobObject(void *Buffer)
     * }
     */
    public static FunctionDescriptor FreeMemoryJobObject$descriptor() {
        return FreeMemoryJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeMemoryJobObject(void *Buffer)
     * }
     */
    public static MethodHandle FreeMemoryJobObject$handle() {
        return FreeMemoryJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FreeMemoryJobObject(void *Buffer)
     * }
     */
    public static MemorySegment FreeMemoryJobObject$address() {
        return FreeMemoryJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FreeMemoryJobObject(void *Buffer)
     * }
     */
    public static void FreeMemoryJobObject(MemorySegment Buffer) {
        var mh$ = FreeMemoryJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeMemoryJobObject", Buffer);
            }
            mh$.invokeExact(Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenJobObjectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenJobObjectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenJobObjectW$descriptor() {
        return OpenJobObjectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenJobObjectW$handle() {
        return OpenJobObjectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectW$address() {
        return OpenJobObjectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenJobObjectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenJobObjectW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AssignProcessToJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AssignProcessToJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor AssignProcessToJobObject$descriptor() {
        return AssignProcessToJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
     * }
     */
    public static MethodHandle AssignProcessToJobObject$handle() {
        return AssignProcessToJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
     * }
     */
    public static MemorySegment AssignProcessToJobObject$address() {
        return AssignProcessToJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
     * }
     */
    public static int AssignProcessToJobObject(MemorySegment hJob, MemorySegment hProcess) {
        var mh$ = AssignProcessToJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AssignProcessToJobObject", hJob, hProcess);
            }
            return (int)mh$.invokeExact(hJob, hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("TerminateJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateJobObject(HANDLE hJob, UINT uExitCode)
     * }
     */
    public static FunctionDescriptor TerminateJobObject$descriptor() {
        return TerminateJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateJobObject(HANDLE hJob, UINT uExitCode)
     * }
     */
    public static MethodHandle TerminateJobObject$handle() {
        return TerminateJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TerminateJobObject(HANDLE hJob, UINT uExitCode)
     * }
     */
    public static MemorySegment TerminateJobObject$address() {
        return TerminateJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TerminateJobObject(HANDLE hJob, UINT uExitCode)
     * }
     */
    public static int TerminateJobObject(MemorySegment hJob, int uExitCode) {
        var mh$ = TerminateJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateJobObject", hJob, uExitCode);
            }
            return (int)mh$.invokeExact(hJob, uExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetInformationJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
     * }
     */
    public static FunctionDescriptor SetInformationJobObject$descriptor() {
        return SetInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
     * }
     */
    public static MethodHandle SetInformationJobObject$handle() {
        return SetInformationJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
     * }
     */
    public static MemorySegment SetInformationJobObject$address() {
        return SetInformationJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
     * }
     */
    public static int SetInformationJobObject(MemorySegment hJob, int JobObjectInformationClass, MemorySegment lpJobObjectInformation, int cbJobObjectInformationLength) {
        var mh$ = SetInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetInformationJobObject", hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength);
            }
            return (int)mh$.invokeExact(hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetIoRateControlInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetIoRateControlInformationJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION *IoRateControlInfo)
     * }
     */
    public static FunctionDescriptor SetIoRateControlInformationJobObject$descriptor() {
        return SetIoRateControlInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION *IoRateControlInfo)
     * }
     */
    public static MethodHandle SetIoRateControlInformationJobObject$handle() {
        return SetIoRateControlInformationJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION *IoRateControlInfo)
     * }
     */
    public static MemorySegment SetIoRateControlInformationJobObject$address() {
        return SetIoRateControlInformationJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION *IoRateControlInfo)
     * }
     */
    public static int SetIoRateControlInformationJobObject(MemorySegment hJob, MemorySegment IoRateControlInfo) {
        var mh$ = SetIoRateControlInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetIoRateControlInformationJobObject", hJob, IoRateControlInfo);
            }
            return (int)mh$.invokeExact(hJob, IoRateControlInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryInformationJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
     * }
     */
    public static FunctionDescriptor QueryInformationJobObject$descriptor() {
        return QueryInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
     * }
     */
    public static MethodHandle QueryInformationJobObject$handle() {
        return QueryInformationJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
     * }
     */
    public static MemorySegment QueryInformationJobObject$address() {
        return QueryInformationJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
     * }
     */
    public static int QueryInformationJobObject(MemorySegment hJob, int JobObjectInformationClass, MemorySegment lpJobObjectInformation, int cbJobObjectInformationLength, MemorySegment lpReturnLength) {
        var mh$ = QueryInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryInformationJobObject", hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength, lpReturnLength);
            }
            return (int)mh$.invokeExact(hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength, lpReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryIoRateControlInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryIoRateControlInformationJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryIoRateControlInformationJobObject(HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION **InfoBlocks, ULONG *InfoBlockCount)
     * }
     */
    public static FunctionDescriptor QueryIoRateControlInformationJobObject$descriptor() {
        return QueryIoRateControlInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryIoRateControlInformationJobObject(HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION **InfoBlocks, ULONG *InfoBlockCount)
     * }
     */
    public static MethodHandle QueryIoRateControlInformationJobObject$handle() {
        return QueryIoRateControlInformationJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryIoRateControlInformationJobObject(HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION **InfoBlocks, ULONG *InfoBlockCount)
     * }
     */
    public static MemorySegment QueryIoRateControlInformationJobObject$address() {
        return QueryIoRateControlInformationJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryIoRateControlInformationJobObject(HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION **InfoBlocks, ULONG *InfoBlockCount)
     * }
     */
    public static int QueryIoRateControlInformationJobObject(MemorySegment hJob, MemorySegment VolumeName, MemorySegment InfoBlocks, MemorySegment InfoBlockCount) {
        var mh$ = QueryIoRateControlInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryIoRateControlInformationJobObject", hJob, VolumeName, InfoBlocks, InfoBlockCount);
            }
            return (int)mh$.invokeExact(hJob, VolumeName, InfoBlocks, InfoBlockCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64DisableWow64FsRedirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Wow64DisableWow64FsRedirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64DisableWow64FsRedirection(PVOID *OldValue)
     * }
     */
    public static FunctionDescriptor Wow64DisableWow64FsRedirection$descriptor() {
        return Wow64DisableWow64FsRedirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64DisableWow64FsRedirection(PVOID *OldValue)
     * }
     */
    public static MethodHandle Wow64DisableWow64FsRedirection$handle() {
        return Wow64DisableWow64FsRedirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Wow64DisableWow64FsRedirection(PVOID *OldValue)
     * }
     */
    public static MemorySegment Wow64DisableWow64FsRedirection$address() {
        return Wow64DisableWow64FsRedirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Wow64DisableWow64FsRedirection(PVOID *OldValue)
     * }
     */
    public static int Wow64DisableWow64FsRedirection(MemorySegment OldValue) {
        var mh$ = Wow64DisableWow64FsRedirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64DisableWow64FsRedirection", OldValue);
            }
            return (int)mh$.invokeExact(OldValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64RevertWow64FsRedirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Wow64RevertWow64FsRedirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64RevertWow64FsRedirection(PVOID OlValue)
     * }
     */
    public static FunctionDescriptor Wow64RevertWow64FsRedirection$descriptor() {
        return Wow64RevertWow64FsRedirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64RevertWow64FsRedirection(PVOID OlValue)
     * }
     */
    public static MethodHandle Wow64RevertWow64FsRedirection$handle() {
        return Wow64RevertWow64FsRedirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Wow64RevertWow64FsRedirection(PVOID OlValue)
     * }
     */
    public static MemorySegment Wow64RevertWow64FsRedirection$address() {
        return Wow64RevertWow64FsRedirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Wow64RevertWow64FsRedirection(PVOID OlValue)
     * }
     */
    public static int Wow64RevertWow64FsRedirection(MemorySegment OlValue) {
        var mh$ = Wow64RevertWow64FsRedirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64RevertWow64FsRedirection", OlValue);
            }
            return (int)mh$.invokeExact(OlValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64Process {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsWow64Process");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
     * }
     */
    public static FunctionDescriptor IsWow64Process$descriptor() {
        return IsWow64Process.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
     * }
     */
    public static MethodHandle IsWow64Process$handle() {
        return IsWow64Process.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
     * }
     */
    public static MemorySegment IsWow64Process$address() {
        return IsWow64Process.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
     * }
     */
    public static int IsWow64Process(MemorySegment hProcess, MemorySegment Wow64Process) {
        var mh$ = IsWow64Process.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64Process", hProcess, Wow64Process);
            }
            return (int)mh$.invokeExact(hProcess, Wow64Process);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64DirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemWow64DirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWow64DirectoryA$descriptor() {
        return GetSystemWow64DirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWow64DirectoryA$handle() {
        return GetSystemWow64DirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemWow64DirectoryA$address() {
        return GetSystemWow64DirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWow64DirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWow64DirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64DirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64DirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemWow64DirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWow64DirectoryW$descriptor() {
        return GetSystemWow64DirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWow64DirectoryW$handle() {
        return GetSystemWow64DirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemWow64DirectoryW$address() {
        return GetSystemWow64DirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWow64DirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWow64DirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64DirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64SetThreadDefaultGuestMachine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Wow64SetThreadDefaultGuestMachine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * USHORT Wow64SetThreadDefaultGuestMachine(USHORT Machine)
     * }
     */
    public static FunctionDescriptor Wow64SetThreadDefaultGuestMachine$descriptor() {
        return Wow64SetThreadDefaultGuestMachine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * USHORT Wow64SetThreadDefaultGuestMachine(USHORT Machine)
     * }
     */
    public static MethodHandle Wow64SetThreadDefaultGuestMachine$handle() {
        return Wow64SetThreadDefaultGuestMachine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * USHORT Wow64SetThreadDefaultGuestMachine(USHORT Machine)
     * }
     */
    public static MemorySegment Wow64SetThreadDefaultGuestMachine$address() {
        return Wow64SetThreadDefaultGuestMachine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * USHORT Wow64SetThreadDefaultGuestMachine(USHORT Machine)
     * }
     */
    public static short Wow64SetThreadDefaultGuestMachine(short Machine) {
        var mh$ = Wow64SetThreadDefaultGuestMachine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64SetThreadDefaultGuestMachine", Machine);
            }
            return (short)mh$.invokeExact(Machine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64Process2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsWow64Process2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine)
     * }
     */
    public static FunctionDescriptor IsWow64Process2$descriptor() {
        return IsWow64Process2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine)
     * }
     */
    public static MethodHandle IsWow64Process2$handle() {
        return IsWow64Process2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine)
     * }
     */
    public static MemorySegment IsWow64Process2$address() {
        return IsWow64Process2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine)
     * }
     */
    public static int IsWow64Process2(MemorySegment hProcess, MemorySegment pProcessMachine, MemorySegment pNativeMachine) {
        var mh$ = IsWow64Process2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64Process2", hProcess, pProcessMachine, pNativeMachine);
            }
            return (int)mh$.invokeExact(hProcess, pProcessMachine, pNativeMachine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64Directory2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemWow64Directory2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static FunctionDescriptor GetSystemWow64Directory2A$descriptor() {
        return GetSystemWow64Directory2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static MethodHandle GetSystemWow64Directory2A$handle() {
        return GetSystemWow64Directory2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static MemorySegment GetSystemWow64Directory2A$address() {
        return GetSystemWow64Directory2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static int GetSystemWow64Directory2A(MemorySegment lpBuffer, int uSize, short ImageFileMachineType) {
        var mh$ = GetSystemWow64Directory2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64Directory2A", lpBuffer, uSize, ImageFileMachineType);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize, ImageFileMachineType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64Directory2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSystemWow64Directory2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static FunctionDescriptor GetSystemWow64Directory2W$descriptor() {
        return GetSystemWow64Directory2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static MethodHandle GetSystemWow64Directory2W$handle() {
        return GetSystemWow64Directory2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static MemorySegment GetSystemWow64Directory2W$address() {
        return GetSystemWow64Directory2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static int GetSystemWow64Directory2W(MemorySegment lpBuffer, int uSize, short ImageFileMachineType) {
        var mh$ = GetSystemWow64Directory2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64Directory2W", lpBuffer, uSize, ImageFileMachineType);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize, ImageFileMachineType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64GuestMachineSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsWow64GuestMachineSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL *MachineIsSupported)
     * }
     */
    public static FunctionDescriptor IsWow64GuestMachineSupported$descriptor() {
        return IsWow64GuestMachineSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL *MachineIsSupported)
     * }
     */
    public static MethodHandle IsWow64GuestMachineSupported$handle() {
        return IsWow64GuestMachineSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL *MachineIsSupported)
     * }
     */
    public static MemorySegment IsWow64GuestMachineSupported$address() {
        return IsWow64GuestMachineSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL *MachineIsSupported)
     * }
     */
    public static int IsWow64GuestMachineSupported(short WowGuestMachine, MemorySegment MachineIsSupported) {
        var mh$ = IsWow64GuestMachineSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64GuestMachineSupported", WowGuestMachine, MachineIsSupported);
            }
            return (int)mh$.invokeExact(WowGuestMachine, MachineIsSupported);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64GetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Wow64GetThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext)
     * }
     */
    public static FunctionDescriptor Wow64GetThreadContext$descriptor() {
        return Wow64GetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext)
     * }
     */
    public static MethodHandle Wow64GetThreadContext$handle() {
        return Wow64GetThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext)
     * }
     */
    public static MemorySegment Wow64GetThreadContext$address() {
        return Wow64GetThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext)
     * }
     */
    public static int Wow64GetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = Wow64GetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64GetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64SetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Wow64SetThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
     * }
     */
    public static FunctionDescriptor Wow64SetThreadContext$descriptor() {
        return Wow64SetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
     * }
     */
    public static MethodHandle Wow64SetThreadContext$handle() {
        return Wow64SetThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
     * }
     */
    public static MemorySegment Wow64SetThreadContext$address() {
        return Wow64SetThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
     * }
     */
    public static int Wow64SetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = Wow64SetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64SetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64SuspendThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("Wow64SuspendThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD Wow64SuspendThread(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor Wow64SuspendThread$descriptor() {
        return Wow64SuspendThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD Wow64SuspendThread(HANDLE hThread)
     * }
     */
    public static MethodHandle Wow64SuspendThread$handle() {
        return Wow64SuspendThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD Wow64SuspendThread(HANDLE hThread)
     * }
     */
    public static MemorySegment Wow64SuspendThread$address() {
        return Wow64SuspendThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD Wow64SuspendThread(HANDLE hThread)
     * }
     */
    public static int Wow64SuspendThread(MemorySegment hThread) {
        var mh$ = Wow64SuspendThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64SuspendThread", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMUILANG {
     *     ULONG NumOfEnumUILang;
     *     ULONG SizeOfEnumUIBuffer;
     *     LANGID *pEnumUIBuffer;
     * } *PENUMUILANG
     * }
     */
    public static final AddressLayout PENUMUILANG = wgl_h.C_POINTER;

    private static class DisableThreadLibraryCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DisableThreadLibraryCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DisableThreadLibraryCalls(HMODULE hLibModule)
     * }
     */
    public static FunctionDescriptor DisableThreadLibraryCalls$descriptor() {
        return DisableThreadLibraryCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DisableThreadLibraryCalls(HMODULE hLibModule)
     * }
     */
    public static MethodHandle DisableThreadLibraryCalls$handle() {
        return DisableThreadLibraryCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DisableThreadLibraryCalls(HMODULE hLibModule)
     * }
     */
    public static MemorySegment DisableThreadLibraryCalls$address() {
        return DisableThreadLibraryCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DisableThreadLibraryCalls(HMODULE hLibModule)
     * }
     */
    public static int DisableThreadLibraryCalls(MemorySegment hLibModule) {
        var mh$ = DisableThreadLibraryCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableThreadLibraryCalls", hLibModule);
            }
            return (int)mh$.invokeExact(hLibModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindResourceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
     * }
     */
    public static FunctionDescriptor FindResourceExW$descriptor() {
        return FindResourceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
     * }
     */
    public static MethodHandle FindResourceExW$handle() {
        return FindResourceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRSRC FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
     * }
     */
    public static MemorySegment FindResourceExW$address() {
        return FindResourceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRSRC FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
     * }
     */
    public static MemorySegment FindResourceExW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, short wLanguage) {
        var mh$ = FindResourceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceExW", hModule, lpType, lpName, wLanguage);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpType, lpName, wLanguage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindStringOrdinal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindStringOrdinal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
     * }
     */
    public static FunctionDescriptor FindStringOrdinal$descriptor() {
        return FindStringOrdinal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
     * }
     */
    public static MethodHandle FindStringOrdinal$handle() {
        return FindStringOrdinal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
     * }
     */
    public static MemorySegment FindStringOrdinal$address() {
        return FindStringOrdinal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
     * }
     */
    public static int FindStringOrdinal(int dwFindStringOrdinalFlags, MemorySegment lpStringSource, int cchSource, MemorySegment lpStringValue, int cchValue, int bIgnoreCase) {
        var mh$ = FindStringOrdinal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindStringOrdinal", dwFindStringOrdinalFlags, lpStringSource, cchSource, lpStringValue, cchValue, bIgnoreCase);
            }
            return (int)mh$.invokeExact(dwFindStringOrdinalFlags, lpStringSource, cchSource, lpStringValue, cchValue, bIgnoreCase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeLibrary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FreeLibrary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeLibrary(HMODULE hLibModule)
     * }
     */
    public static FunctionDescriptor FreeLibrary$descriptor() {
        return FreeLibrary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeLibrary(HMODULE hLibModule)
     * }
     */
    public static MethodHandle FreeLibrary$handle() {
        return FreeLibrary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeLibrary(HMODULE hLibModule)
     * }
     */
    public static MemorySegment FreeLibrary$address() {
        return FreeLibrary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeLibrary(HMODULE hLibModule)
     * }
     */
    public static int FreeLibrary(MemorySegment hLibModule) {
        var mh$ = FreeLibrary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeLibrary", hLibModule);
            }
            return (int)mh$.invokeExact(hLibModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeLibraryAndExitThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FreeLibraryAndExitThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)
     * }
     */
    public static FunctionDescriptor FreeLibraryAndExitThread$descriptor() {
        return FreeLibraryAndExitThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)
     * }
     */
    public static MethodHandle FreeLibraryAndExitThread$handle() {
        return FreeLibraryAndExitThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)
     * }
     */
    public static MemorySegment FreeLibraryAndExitThread$address() {
        return FreeLibraryAndExitThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)
     * }
     */
    public static void FreeLibraryAndExitThread(MemorySegment hLibModule, int dwExitCode) {
        var mh$ = FreeLibraryAndExitThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeLibraryAndExitThread", hLibModule, dwExitCode);
            }
            mh$.invokeExact(hLibModule, dwExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FreeResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeResource(HGLOBAL hResData)
     * }
     */
    public static FunctionDescriptor FreeResource$descriptor() {
        return FreeResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeResource(HGLOBAL hResData)
     * }
     */
    public static MethodHandle FreeResource$handle() {
        return FreeResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeResource(HGLOBAL hResData)
     * }
     */
    public static MemorySegment FreeResource$address() {
        return FreeResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeResource(HGLOBAL hResData)
     * }
     */
    public static int FreeResource(MemorySegment hResData) {
        var mh$ = FreeResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeResource", hResData);
            }
            return (int)mh$.invokeExact(hResData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetModuleFileNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetModuleFileNameA$descriptor() {
        return GetModuleFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
     * }
     */
    public static MethodHandle GetModuleFileNameA$handle() {
        return GetModuleFileNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
     * }
     */
    public static MemorySegment GetModuleFileNameA$address() {
        return GetModuleFileNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
     * }
     */
    public static int GetModuleFileNameA(MemorySegment hModule, MemorySegment lpFilename, int nSize) {
        var mh$ = GetModuleFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleFileNameA", hModule, lpFilename, nSize);
            }
            return (int)mh$.invokeExact(hModule, lpFilename, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetModuleFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetModuleFileNameW$descriptor() {
        return GetModuleFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
     * }
     */
    public static MethodHandle GetModuleFileNameW$handle() {
        return GetModuleFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
     * }
     */
    public static MemorySegment GetModuleFileNameW$address() {
        return GetModuleFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
     * }
     */
    public static int GetModuleFileNameW(MemorySegment hModule, MemorySegment lpFilename, int nSize) {
        var mh$ = GetModuleFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleFileNameW", hModule, lpFilename, nSize);
            }
            return (int)mh$.invokeExact(hModule, lpFilename, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetModuleHandleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
     * }
     */
    public static FunctionDescriptor GetModuleHandleA$descriptor() {
        return GetModuleHandleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
     * }
     */
    public static MethodHandle GetModuleHandleA$handle() {
        return GetModuleHandleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
     * }
     */
    public static MemorySegment GetModuleHandleA$address() {
        return GetModuleHandleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
     * }
     */
    public static MemorySegment GetModuleHandleA(MemorySegment lpModuleName) {
        var mh$ = GetModuleHandleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleA", lpModuleName);
            }
            return (MemorySegment)mh$.invokeExact(lpModuleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetModuleHandleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
     * }
     */
    public static FunctionDescriptor GetModuleHandleW$descriptor() {
        return GetModuleHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
     * }
     */
    public static MethodHandle GetModuleHandleW$handle() {
        return GetModuleHandleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
     * }
     */
    public static MemorySegment GetModuleHandleW$address() {
        return GetModuleHandleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
     * }
     */
    public static MemorySegment GetModuleHandleW(MemorySegment lpModuleName) {
        var mh$ = GetModuleHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleW", lpModuleName);
            }
            return (MemorySegment)mh$.invokeExact(lpModuleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetModuleHandleExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static FunctionDescriptor GetModuleHandleExA$descriptor() {
        return GetModuleHandleExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static MethodHandle GetModuleHandleExA$handle() {
        return GetModuleHandleExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static MemorySegment GetModuleHandleExA$address() {
        return GetModuleHandleExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static int GetModuleHandleExA(int dwFlags, MemorySegment lpModuleName, MemorySegment phModule) {
        var mh$ = GetModuleHandleExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleExA", dwFlags, lpModuleName, phModule);
            }
            return (int)mh$.invokeExact(dwFlags, lpModuleName, phModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetModuleHandleExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static FunctionDescriptor GetModuleHandleExW$descriptor() {
        return GetModuleHandleExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static MethodHandle GetModuleHandleExW$handle() {
        return GetModuleHandleExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static MemorySegment GetModuleHandleExW$address() {
        return GetModuleHandleExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static int GetModuleHandleExW(int dwFlags, MemorySegment lpModuleName, MemorySegment phModule) {
        var mh$ = GetModuleHandleExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleExW", dwFlags, lpModuleName, phModule);
            }
            return (int)mh$.invokeExact(dwFlags, lpModuleName, phModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
     * }
     */
    public static FunctionDescriptor GetProcAddress$descriptor() {
        return GetProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
     * }
     */
    public static MethodHandle GetProcAddress$handle() {
        return GetProcAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
     * }
     */
    public static MemorySegment GetProcAddress$address() {
        return GetProcAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
     * }
     */
    public static MemorySegment GetProcAddress(MemorySegment hModule, MemorySegment lpProcName) {
        var mh$ = GetProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcAddress", hModule, lpProcName);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpProcName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _REDIRECTION_FUNCTION_DESCRIPTOR {
     *     PCSTR DllName;
     *     PCSTR FunctionName;
     *     PVOID RedirectionTarget;
     * } *PREDIRECTION_FUNCTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PREDIRECTION_FUNCTION_DESCRIPTOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const REDIRECTION_FUNCTION_DESCRIPTOR *PCREDIRECTION_FUNCTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PCREDIRECTION_FUNCTION_DESCRIPTOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REDIRECTION_DESCRIPTOR {
     *     ULONG Version;
     *     ULONG FunctionCount;
     *     PCREDIRECTION_FUNCTION_DESCRIPTOR Redirections;
     * } *PREDIRECTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PREDIRECTION_DESCRIPTOR = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const REDIRECTION_DESCRIPTOR *PCREDIRECTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PCREDIRECTION_DESCRIPTOR = wgl_h.C_POINTER;

    private static class LoadLibraryExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadLibraryExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LoadLibraryExA$descriptor() {
        return LoadLibraryExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle LoadLibraryExA$handle() {
        return LoadLibraryExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment LoadLibraryExA$address() {
        return LoadLibraryExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment LoadLibraryExA(MemorySegment lpLibFileName, MemorySegment hFile, int dwFlags) {
        var mh$ = LoadLibraryExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryExA", lpLibFileName, hFile, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName, hFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadLibraryExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadLibraryExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LoadLibraryExW$descriptor() {
        return LoadLibraryExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle LoadLibraryExW$handle() {
        return LoadLibraryExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment LoadLibraryExW$address() {
        return LoadLibraryExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment LoadLibraryExW(MemorySegment lpLibFileName, MemorySegment hFile, int dwFlags) {
        var mh$ = LoadLibraryExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryExW", lpLibFileName, hFile, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName, hFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL LoadResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static FunctionDescriptor LoadResource$descriptor() {
        return LoadResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL LoadResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MethodHandle LoadResource$handle() {
        return LoadResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLOBAL LoadResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MemorySegment LoadResource$address() {
        return LoadResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLOBAL LoadResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MemorySegment LoadResource(MemorySegment hModule, MemorySegment hResInfo) {
        var mh$ = LoadResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadResource", hModule, hResInfo);
            }
            return (MemorySegment)mh$.invokeExact(hModule, hResInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static FunctionDescriptor LoadStringA$descriptor() {
        return LoadStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static MethodHandle LoadStringA$handle() {
        return LoadStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static MemorySegment LoadStringA$address() {
        return LoadStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static int LoadStringA(MemorySegment hInstance, int uID, MemorySegment lpBuffer, int cchBufferMax) {
        var mh$ = LoadStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadStringA", hInstance, uID, lpBuffer, cchBufferMax);
            }
            return (int)mh$.invokeExact(hInstance, uID, lpBuffer, cchBufferMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static FunctionDescriptor LoadStringW$descriptor() {
        return LoadStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static MethodHandle LoadStringW$handle() {
        return LoadStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static MemorySegment LoadStringW$address() {
        return LoadStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static int LoadStringW(MemorySegment hInstance, int uID, MemorySegment lpBuffer, int cchBufferMax) {
        var mh$ = LoadStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadStringW", hInstance, uID, lpBuffer, cchBufferMax);
            }
            return (int)mh$.invokeExact(hInstance, uID, lpBuffer, cchBufferMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LockResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID LockResource(HGLOBAL hResData)
     * }
     */
    public static FunctionDescriptor LockResource$descriptor() {
        return LockResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID LockResource(HGLOBAL hResData)
     * }
     */
    public static MethodHandle LockResource$handle() {
        return LockResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID LockResource(HGLOBAL hResData)
     * }
     */
    public static MemorySegment LockResource$address() {
        return LockResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID LockResource(HGLOBAL hResData)
     * }
     */
    public static MemorySegment LockResource(MemorySegment hResData) {
        var mh$ = LockResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockResource", hResData);
            }
            return (MemorySegment)mh$.invokeExact(hResData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SizeofResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SizeofResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SizeofResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static FunctionDescriptor SizeofResource$descriptor() {
        return SizeofResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SizeofResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MethodHandle SizeofResource$handle() {
        return SizeofResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SizeofResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MemorySegment SizeofResource$address() {
        return SizeofResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SizeofResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static int SizeofResource(MemorySegment hModule, MemorySegment hResInfo) {
        var mh$ = SizeofResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SizeofResource", hModule, hResInfo);
            }
            return (int)mh$.invokeExact(hModule, hResInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PVOID DLL_DIRECTORY_COOKIE
     * }
     */
    public static final AddressLayout DLL_DIRECTORY_COOKIE = wgl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID *PDLL_DIRECTORY_COOKIE
     * }
     */
    public static final AddressLayout PDLL_DIRECTORY_COOKIE = wgl_h.C_POINTER;

    private static class AddDllDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddDllDirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
     * }
     */
    public static FunctionDescriptor AddDllDirectory$descriptor() {
        return AddDllDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
     * }
     */
    public static MethodHandle AddDllDirectory$handle() {
        return AddDllDirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
     * }
     */
    public static MemorySegment AddDllDirectory$address() {
        return AddDllDirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
     * }
     */
    public static MemorySegment AddDllDirectory(MemorySegment NewDirectory) {
        var mh$ = AddDllDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddDllDirectory", NewDirectory);
            }
            return (MemorySegment)mh$.invokeExact(NewDirectory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDllDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RemoveDllDirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
     * }
     */
    public static FunctionDescriptor RemoveDllDirectory$descriptor() {
        return RemoveDllDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
     * }
     */
    public static MethodHandle RemoveDllDirectory$handle() {
        return RemoveDllDirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
     * }
     */
    public static MemorySegment RemoveDllDirectory$address() {
        return RemoveDllDirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
     * }
     */
    public static int RemoveDllDirectory(MemorySegment Cookie) {
        var mh$ = RemoveDllDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDllDirectory", Cookie);
            }
            return (int)mh$.invokeExact(Cookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDefaultDllDirectories {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetDefaultDllDirectories");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
     * }
     */
    public static FunctionDescriptor SetDefaultDllDirectories$descriptor() {
        return SetDefaultDllDirectories.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
     * }
     */
    public static MethodHandle SetDefaultDllDirectories$handle() {
        return SetDefaultDllDirectories.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
     * }
     */
    public static MemorySegment SetDefaultDllDirectories$address() {
        return SetDefaultDllDirectories.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
     * }
     */
    public static int SetDefaultDllDirectories(int DirectoryFlags) {
        var mh$ = SetDefaultDllDirectories.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDefaultDllDirectories", DirectoryFlags);
            }
            return (int)mh$.invokeExact(DirectoryFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceLanguagesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesExA$descriptor() {
        return EnumResourceLanguagesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceLanguagesExA$handle() {
        return EnumResourceLanguagesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceLanguagesExA$address() {
        return EnumResourceLanguagesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceLanguagesExA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceLanguagesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesExA", hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceLanguagesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesExW$descriptor() {
        return EnumResourceLanguagesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceLanguagesExW$handle() {
        return EnumResourceLanguagesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceLanguagesExW$address() {
        return EnumResourceLanguagesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceLanguagesExW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceLanguagesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesExW", hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceNamesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesExA$descriptor() {
        return EnumResourceNamesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceNamesExA$handle() {
        return EnumResourceNamesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceNamesExA$address() {
        return EnumResourceNamesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceNamesExA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceNamesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesExA", hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceNamesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesExW$descriptor() {
        return EnumResourceNamesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceNamesExW$handle() {
        return EnumResourceNamesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceNamesExW$address() {
        return EnumResourceNamesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceNamesExW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceNamesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesExW", hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceTypesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesExA$descriptor() {
        return EnumResourceTypesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceTypesExA$handle() {
        return EnumResourceTypesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceTypesExA$address() {
        return EnumResourceTypesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceTypesExA(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceTypesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesExA", hModule, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG,
            wgl_h.C_LONG,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceTypesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesExW$descriptor() {
        return EnumResourceTypesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceTypesExW$handle() {
        return EnumResourceTypesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceTypesExW$address() {
        return EnumResourceTypesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceTypesExW(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceTypesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesExW", hModule, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
     * }
     */
    public static FunctionDescriptor FindResourceW$descriptor() {
        return FindResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
     * }
     */
    public static MethodHandle FindResourceW$handle() {
        return FindResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
     * }
     */
    public static MemorySegment FindResourceW$address() {
        return FindResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
     * }
     */
    public static MemorySegment FindResourceW(MemorySegment hModule, MemorySegment lpName, MemorySegment lpType) {
        var mh$ = FindResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceW", hModule, lpName, lpType);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpName, lpType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadLibraryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadLibraryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryA(LPCSTR lpLibFileName)
     * }
     */
    public static FunctionDescriptor LoadLibraryA$descriptor() {
        return LoadLibraryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryA(LPCSTR lpLibFileName)
     * }
     */
    public static MethodHandle LoadLibraryA$handle() {
        return LoadLibraryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryA(LPCSTR lpLibFileName)
     * }
     */
    public static MemorySegment LoadLibraryA$address() {
        return LoadLibraryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryA(LPCSTR lpLibFileName)
     * }
     */
    public static MemorySegment LoadLibraryA(MemorySegment lpLibFileName) {
        var mh$ = LoadLibraryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryA", lpLibFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadLibraryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("LoadLibraryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryW(LPCWSTR lpLibFileName)
     * }
     */
    public static FunctionDescriptor LoadLibraryW$descriptor() {
        return LoadLibraryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryW(LPCWSTR lpLibFileName)
     * }
     */
    public static MethodHandle LoadLibraryW$handle() {
        return LoadLibraryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryW(LPCWSTR lpLibFileName)
     * }
     */
    public static MemorySegment LoadLibraryW$address() {
        return LoadLibraryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryW(LPCWSTR lpLibFileName)
     * }
     */
    public static MemorySegment LoadLibraryW(MemorySegment lpLibFileName) {
        var mh$ = LoadLibraryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryW", lpLibFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EnumResourceNamesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesW$descriptor() {
        return EnumResourceNamesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceNamesW$handle() {
        return EnumResourceNamesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceNamesW$address() {
        return EnumResourceNamesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceNamesW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceNamesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesW", hModule, lpType, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AccessCheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static FunctionDescriptor AccessCheck$descriptor() {
        return AccessCheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static MethodHandle AccessCheck$handle() {
        return AccessCheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static MemorySegment AccessCheck$address() {
        return AccessCheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static int AccessCheck(MemorySegment pSecurityDescriptor, MemorySegment ClientToken, int DesiredAccess, MemorySegment GenericMapping, MemorySegment PrivilegeSet, MemorySegment PrivilegeSetLength, MemorySegment GrantedAccess, MemorySegment AccessStatus) {
        var mh$ = AccessCheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheck", pSecurityDescriptor, ClientToken, DesiredAccess, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, ClientToken, DesiredAccess, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckAndAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AccessCheckAndAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckAndAuditAlarmW$descriptor() {
        return AccessCheckAndAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckAndAuditAlarmW$handle() {
        return AccessCheckAndAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckAndAuditAlarmW$address() {
        return AccessCheckAndAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckAndAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, int DesiredAccess, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckAndAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckAndAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AccessCheckByType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static FunctionDescriptor AccessCheckByType$descriptor() {
        return AccessCheckByType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static MethodHandle AccessCheckByType$handle() {
        return AccessCheckByType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static MemorySegment AccessCheckByType$address() {
        return AccessCheckByType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static int AccessCheckByType(MemorySegment pSecurityDescriptor, MemorySegment PrincipalSelfSid, MemorySegment ClientToken, int DesiredAccess, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, MemorySegment PrivilegeSet, MemorySegment PrivilegeSetLength, MemorySegment GrantedAccess, MemorySegment AccessStatus) {
        var mh$ = AccessCheckByType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByType", pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AccessCheckByTypeResultList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultList$descriptor() {
        return AccessCheckByTypeResultList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultList$handle() {
        return AccessCheckByTypeResultList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList)
     * }
     */
    public static MemorySegment AccessCheckByTypeResultList$address() {
        return AccessCheckByTypeResultList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList)
     * }
     */
    public static int AccessCheckByTypeResultList(MemorySegment pSecurityDescriptor, MemorySegment PrincipalSelfSid, MemorySegment ClientToken, int DesiredAccess, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, MemorySegment PrivilegeSet, MemorySegment PrivilegeSetLength, MemorySegment GrantedAccessList, MemorySegment AccessStatusList) {
        var mh$ = AccessCheckByTypeResultList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultList", pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccessList, AccessStatusList);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccessList, AccessStatusList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeAndAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AccessCheckByTypeAndAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeAndAuditAlarmW$descriptor() {
        return AccessCheckByTypeAndAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeAndAuditAlarmW$handle() {
        return AccessCheckByTypeAndAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeAndAuditAlarmW$address() {
        return AccessCheckByTypeAndAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeAndAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeAndAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeAndAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AccessCheckByTypeResultListAndAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmW$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmW$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeResultListAndAuditAlarmW$address() {
        return AccessCheckByTypeResultListAndAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccessList, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmByHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AccessCheckByTypeResultListAndAuditAlarmByHandleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmByHandleW$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmByHandleW$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeResultListAndAuditAlarmByHandleW$address() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmByHandleW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccessList, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmByHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmByHandleW", SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessAllowedAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAccessAllowedAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessAllowedAce$descriptor() {
        return AddAccessAllowedAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessAllowedAce$handle() {
        return AddAccessAllowedAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessAllowedAce$address() {
        return AddAccessAllowedAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessAllowedAce(MemorySegment pAcl, int dwAceRevision, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessAllowedAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessAllowedAce", pAcl, dwAceRevision, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessAllowedAceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAccessAllowedAceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessAllowedAceEx$descriptor() {
        return AddAccessAllowedAceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessAllowedAceEx$handle() {
        return AddAccessAllowedAceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessAllowedAceEx$address() {
        return AddAccessAllowedAceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessAllowedAceEx(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessAllowedAceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessAllowedAceEx", pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessAllowedObjectAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAccessAllowedObjectAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessAllowedObjectAce$descriptor() {
        return AddAccessAllowedObjectAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessAllowedObjectAce$handle() {
        return AddAccessAllowedObjectAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessAllowedObjectAce$address() {
        return AddAccessAllowedObjectAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static int AddAccessAllowedObjectAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment ObjectTypeGuid, MemorySegment InheritedObjectTypeGuid, MemorySegment pSid) {
        var mh$ = AddAccessAllowedObjectAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessAllowedObjectAce", pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessDeniedAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAccessDeniedAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessDeniedAce$descriptor() {
        return AddAccessDeniedAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessDeniedAce$handle() {
        return AddAccessDeniedAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessDeniedAce$address() {
        return AddAccessDeniedAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessDeniedAce(MemorySegment pAcl, int dwAceRevision, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessDeniedAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessDeniedAce", pAcl, dwAceRevision, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessDeniedAceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAccessDeniedAceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessDeniedAceEx$descriptor() {
        return AddAccessDeniedAceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessDeniedAceEx$handle() {
        return AddAccessDeniedAceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessDeniedAceEx$address() {
        return AddAccessDeniedAceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessDeniedAceEx(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessDeniedAceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessDeniedAceEx", pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessDeniedObjectAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAccessDeniedObjectAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessDeniedObjectAce$descriptor() {
        return AddAccessDeniedObjectAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessDeniedObjectAce$handle() {
        return AddAccessDeniedObjectAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessDeniedObjectAce$address() {
        return AddAccessDeniedObjectAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static int AddAccessDeniedObjectAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment ObjectTypeGuid, MemorySegment InheritedObjectTypeGuid, MemorySegment pSid) {
        var mh$ = AddAccessDeniedObjectAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessDeniedObjectAce", pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength)
     * }
     */
    public static FunctionDescriptor AddAce$descriptor() {
        return AddAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength)
     * }
     */
    public static MethodHandle AddAce$handle() {
        return AddAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength)
     * }
     */
    public static MemorySegment AddAce$address() {
        return AddAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength)
     * }
     */
    public static int AddAce(MemorySegment pAcl, int dwAceRevision, int dwStartingAceIndex, MemorySegment pAceList, int nAceListLength) {
        var mh$ = AddAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAce", pAcl, dwAceRevision, dwStartingAceIndex, pAceList, nAceListLength);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, dwStartingAceIndex, pAceList, nAceListLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAuditAccessAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAuditAccessAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static FunctionDescriptor AddAuditAccessAce$descriptor() {
        return AddAuditAccessAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MethodHandle AddAuditAccessAce$handle() {
        return AddAuditAccessAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MemorySegment AddAuditAccessAce$address() {
        return AddAuditAccessAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static int AddAuditAccessAce(MemorySegment pAcl, int dwAceRevision, int dwAccessMask, MemorySegment pSid, int bAuditSuccess, int bAuditFailure) {
        var mh$ = AddAuditAccessAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAuditAccessAce", pAcl, dwAceRevision, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAuditAccessAceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAuditAccessAceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static FunctionDescriptor AddAuditAccessAceEx$descriptor() {
        return AddAuditAccessAceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MethodHandle AddAuditAccessAceEx$handle() {
        return AddAuditAccessAceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MemorySegment AddAuditAccessAceEx$address() {
        return AddAuditAccessAceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static int AddAuditAccessAceEx(MemorySegment pAcl, int dwAceRevision, int AceFlags, int dwAccessMask, MemorySegment pSid, int bAuditSuccess, int bAuditFailure) {
        var mh$ = AddAuditAccessAceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAuditAccessAceEx", pAcl, dwAceRevision, AceFlags, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAuditAccessObjectAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddAuditAccessObjectAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static FunctionDescriptor AddAuditAccessObjectAce$descriptor() {
        return AddAuditAccessObjectAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MethodHandle AddAuditAccessObjectAce$handle() {
        return AddAuditAccessObjectAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MemorySegment AddAuditAccessObjectAce$address() {
        return AddAuditAccessObjectAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static int AddAuditAccessObjectAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment ObjectTypeGuid, MemorySegment InheritedObjectTypeGuid, MemorySegment pSid, int bAuditSuccess, int bAuditFailure) {
        var mh$ = AddAuditAccessObjectAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAuditAccessObjectAce", pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid, bAuditSuccess, bAuditFailure);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid, bAuditSuccess, bAuditFailure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddMandatoryAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddMandatoryAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid)
     * }
     */
    public static FunctionDescriptor AddMandatoryAce$descriptor() {
        return AddMandatoryAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid)
     * }
     */
    public static MethodHandle AddMandatoryAce$handle() {
        return AddMandatoryAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid)
     * }
     */
    public static MemorySegment AddMandatoryAce$address() {
        return AddMandatoryAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid)
     * }
     */
    public static int AddMandatoryAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int MandatoryPolicy, MemorySegment pLabelSid) {
        var mh$ = AddMandatoryAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddMandatoryAce", pAcl, dwAceRevision, AceFlags, MandatoryPolicy, pLabelSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, MandatoryPolicy, pLabelSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddResourceAttributeAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddResourceAttributeAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddResourceAttributeAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid, PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, PDWORD pReturnLength)
     * }
     */
    public static FunctionDescriptor AddResourceAttributeAce$descriptor() {
        return AddResourceAttributeAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddResourceAttributeAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid, PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, PDWORD pReturnLength)
     * }
     */
    public static MethodHandle AddResourceAttributeAce$handle() {
        return AddResourceAttributeAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddResourceAttributeAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid, PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, PDWORD pReturnLength)
     * }
     */
    public static MemorySegment AddResourceAttributeAce$address() {
        return AddResourceAttributeAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddResourceAttributeAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid, PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, PDWORD pReturnLength)
     * }
     */
    public static int AddResourceAttributeAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid, MemorySegment pAttributeInfo, MemorySegment pReturnLength) {
        var mh$ = AddResourceAttributeAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddResourceAttributeAce", pAcl, dwAceRevision, AceFlags, AccessMask, pSid, pAttributeInfo, pReturnLength);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid, pAttributeInfo, pReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddScopedPolicyIDAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddScopedPolicyIDAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddScopedPolicyIDAce$descriptor() {
        return AddScopedPolicyIDAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddScopedPolicyIDAce$handle() {
        return AddScopedPolicyIDAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MemorySegment AddScopedPolicyIDAce$address() {
        return AddScopedPolicyIDAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddScopedPolicyIDAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid) {
        var mh$ = AddScopedPolicyIDAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddScopedPolicyIDAce", pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustTokenGroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AdjustTokenGroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor AdjustTokenGroups$descriptor() {
        return AdjustTokenGroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle AdjustTokenGroups$handle() {
        return AdjustTokenGroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength)
     * }
     */
    public static MemorySegment AdjustTokenGroups$address() {
        return AdjustTokenGroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength)
     * }
     */
    public static int AdjustTokenGroups(MemorySegment TokenHandle, int ResetToDefault, MemorySegment NewState, int BufferLength, MemorySegment PreviousState, MemorySegment ReturnLength) {
        var mh$ = AdjustTokenGroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustTokenGroups", TokenHandle, ResetToDefault, NewState, BufferLength, PreviousState, ReturnLength);
            }
            return (int)mh$.invokeExact(TokenHandle, ResetToDefault, NewState, BufferLength, PreviousState, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustTokenPrivileges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AdjustTokenPrivileges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor AdjustTokenPrivileges$descriptor() {
        return AdjustTokenPrivileges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle AdjustTokenPrivileges$handle() {
        return AdjustTokenPrivileges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
     * }
     */
    public static MemorySegment AdjustTokenPrivileges$address() {
        return AdjustTokenPrivileges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
     * }
     */
    public static int AdjustTokenPrivileges(MemorySegment TokenHandle, int DisableAllPrivileges, MemorySegment NewState, int BufferLength, MemorySegment PreviousState, MemorySegment ReturnLength) {
        var mh$ = AdjustTokenPrivileges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustTokenPrivileges", TokenHandle, DisableAllPrivileges, NewState, BufferLength, PreviousState, ReturnLength);
            }
            return (int)mh$.invokeExact(TokenHandle, DisableAllPrivileges, NewState, BufferLength, PreviousState, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateAndInitializeSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_CHAR,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AllocateAndInitializeSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid)
     * }
     */
    public static FunctionDescriptor AllocateAndInitializeSid$descriptor() {
        return AllocateAndInitializeSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid)
     * }
     */
    public static MethodHandle AllocateAndInitializeSid$handle() {
        return AllocateAndInitializeSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid)
     * }
     */
    public static MemorySegment AllocateAndInitializeSid$address() {
        return AllocateAndInitializeSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid)
     * }
     */
    public static int AllocateAndInitializeSid(MemorySegment pIdentifierAuthority, byte nSubAuthorityCount, int nSubAuthority0, int nSubAuthority1, int nSubAuthority2, int nSubAuthority3, int nSubAuthority4, int nSubAuthority5, int nSubAuthority6, int nSubAuthority7, MemorySegment pSid) {
        var mh$ = AllocateAndInitializeSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateAndInitializeSid", pIdentifierAuthority, nSubAuthorityCount, nSubAuthority0, nSubAuthority1, nSubAuthority2, nSubAuthority3, nSubAuthority4, nSubAuthority5, nSubAuthority6, nSubAuthority7, pSid);
            }
            return (int)mh$.invokeExact(pIdentifierAuthority, nSubAuthorityCount, nSubAuthority0, nSubAuthority1, nSubAuthority2, nSubAuthority3, nSubAuthority4, nSubAuthority5, nSubAuthority6, nSubAuthority7, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateLocallyUniqueId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AllocateLocallyUniqueId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateLocallyUniqueId(PLUID Luid)
     * }
     */
    public static FunctionDescriptor AllocateLocallyUniqueId$descriptor() {
        return AllocateLocallyUniqueId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateLocallyUniqueId(PLUID Luid)
     * }
     */
    public static MethodHandle AllocateLocallyUniqueId$handle() {
        return AllocateLocallyUniqueId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllocateLocallyUniqueId(PLUID Luid)
     * }
     */
    public static MemorySegment AllocateLocallyUniqueId$address() {
        return AllocateLocallyUniqueId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllocateLocallyUniqueId(PLUID Luid)
     * }
     */
    public static int AllocateLocallyUniqueId(MemorySegment Luid) {
        var mh$ = AllocateLocallyUniqueId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateLocallyUniqueId", Luid);
            }
            return (int)mh$.invokeExact(Luid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreAllAccessesGranted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AreAllAccessesGranted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor AreAllAccessesGranted$descriptor() {
        return AreAllAccessesGranted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static MethodHandle AreAllAccessesGranted$handle() {
        return AreAllAccessesGranted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static MemorySegment AreAllAccessesGranted$address() {
        return AreAllAccessesGranted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static int AreAllAccessesGranted(int GrantedAccess, int DesiredAccess) {
        var mh$ = AreAllAccessesGranted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreAllAccessesGranted", GrantedAccess, DesiredAccess);
            }
            return (int)mh$.invokeExact(GrantedAccess, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreAnyAccessesGranted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AreAnyAccessesGranted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor AreAnyAccessesGranted$descriptor() {
        return AreAnyAccessesGranted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static MethodHandle AreAnyAccessesGranted$handle() {
        return AreAnyAccessesGranted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static MemorySegment AreAnyAccessesGranted$address() {
        return AreAnyAccessesGranted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static int AreAnyAccessesGranted(int GrantedAccess, int DesiredAccess) {
        var mh$ = AreAnyAccessesGranted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreAnyAccessesGranted", GrantedAccess, DesiredAccess);
            }
            return (int)mh$.invokeExact(GrantedAccess, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckTokenMembership {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CheckTokenMembership");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember)
     * }
     */
    public static FunctionDescriptor CheckTokenMembership$descriptor() {
        return CheckTokenMembership.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember)
     * }
     */
    public static MethodHandle CheckTokenMembership$handle() {
        return CheckTokenMembership.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember)
     * }
     */
    public static MemorySegment CheckTokenMembership$address() {
        return CheckTokenMembership.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember)
     * }
     */
    public static int CheckTokenMembership(MemorySegment TokenHandle, MemorySegment SidToCheck, MemorySegment IsMember) {
        var mh$ = CheckTokenMembership.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckTokenMembership", TokenHandle, SidToCheck, IsMember);
            }
            return (int)mh$.invokeExact(TokenHandle, SidToCheck, IsMember);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckTokenCapability {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CheckTokenCapability");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability)
     * }
     */
    public static FunctionDescriptor CheckTokenCapability$descriptor() {
        return CheckTokenCapability.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability)
     * }
     */
    public static MethodHandle CheckTokenCapability$handle() {
        return CheckTokenCapability.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability)
     * }
     */
    public static MemorySegment CheckTokenCapability$address() {
        return CheckTokenCapability.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability)
     * }
     */
    public static int CheckTokenCapability(MemorySegment TokenHandle, MemorySegment CapabilitySidToCheck, MemorySegment HasCapability) {
        var mh$ = CheckTokenCapability.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckTokenCapability", TokenHandle, CapabilitySidToCheck, HasCapability);
            }
            return (int)mh$.invokeExact(TokenHandle, CapabilitySidToCheck, HasCapability);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAppContainerAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetAppContainerAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID *AppContainerAce, DWORD *AppContainerAceIndex)
     * }
     */
    public static FunctionDescriptor GetAppContainerAce$descriptor() {
        return GetAppContainerAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID *AppContainerAce, DWORD *AppContainerAceIndex)
     * }
     */
    public static MethodHandle GetAppContainerAce$handle() {
        return GetAppContainerAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID *AppContainerAce, DWORD *AppContainerAceIndex)
     * }
     */
    public static MemorySegment GetAppContainerAce$address() {
        return GetAppContainerAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID *AppContainerAce, DWORD *AppContainerAceIndex)
     * }
     */
    public static int GetAppContainerAce(MemorySegment Acl, int StartingAceIndex, MemorySegment AppContainerAce, MemorySegment AppContainerAceIndex) {
        var mh$ = GetAppContainerAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAppContainerAce", Acl, StartingAceIndex, AppContainerAce, AppContainerAceIndex);
            }
            return (int)mh$.invokeExact(Acl, StartingAceIndex, AppContainerAce, AppContainerAceIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckTokenMembershipEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CheckTokenMembershipEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember)
     * }
     */
    public static FunctionDescriptor CheckTokenMembershipEx$descriptor() {
        return CheckTokenMembershipEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember)
     * }
     */
    public static MethodHandle CheckTokenMembershipEx$handle() {
        return CheckTokenMembershipEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember)
     * }
     */
    public static MemorySegment CheckTokenMembershipEx$address() {
        return CheckTokenMembershipEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember)
     * }
     */
    public static int CheckTokenMembershipEx(MemorySegment TokenHandle, MemorySegment SidToCheck, int Flags, MemorySegment IsMember) {
        var mh$ = CheckTokenMembershipEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckTokenMembershipEx", TokenHandle, SidToCheck, Flags, IsMember);
            }
            return (int)mh$.invokeExact(TokenHandle, SidToCheck, Flags, IsMember);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertToAutoInheritPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_CHAR,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ConvertToAutoInheritPrivateObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor ConvertToAutoInheritPrivateObjectSecurity$descriptor() {
        return ConvertToAutoInheritPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle ConvertToAutoInheritPrivateObjectSecurity$handle() {
        return ConvertToAutoInheritPrivateObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MemorySegment ConvertToAutoInheritPrivateObjectSecurity$address() {
        return ConvertToAutoInheritPrivateObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int ConvertToAutoInheritPrivateObjectSecurity(MemorySegment ParentDescriptor, MemorySegment CurrentSecurityDescriptor, MemorySegment NewSecurityDescriptor, MemorySegment ObjectType, byte IsDirectoryObject, MemorySegment GenericMapping) {
        var mh$ = ConvertToAutoInheritPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertToAutoInheritPrivateObjectSecurity", ParentDescriptor, CurrentSecurityDescriptor, NewSecurityDescriptor, ObjectType, IsDirectoryObject, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CurrentSecurityDescriptor, NewSecurityDescriptor, ObjectType, IsDirectoryObject, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopySid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CopySid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid)
     * }
     */
    public static FunctionDescriptor CopySid$descriptor() {
        return CopySid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid)
     * }
     */
    public static MethodHandle CopySid$handle() {
        return CopySid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid)
     * }
     */
    public static MemorySegment CopySid$address() {
        return CopySid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid)
     * }
     */
    public static int CopySid(int nDestinationSidLength, MemorySegment pDestinationSid, MemorySegment pSourceSid) {
        var mh$ = CopySid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopySid", nDestinationSidLength, pDestinationSid, pSourceSid);
            }
            return (int)mh$.invokeExact(nDestinationSidLength, pDestinationSid, pSourceSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePrivateObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor CreatePrivateObjectSecurity$descriptor() {
        return CreatePrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle CreatePrivateObjectSecurity$handle() {
        return CreatePrivateObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MemorySegment CreatePrivateObjectSecurity$address() {
        return CreatePrivateObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int CreatePrivateObjectSecurity(MemorySegment ParentDescriptor, MemorySegment CreatorDescriptor, MemorySegment NewDescriptor, int IsDirectoryObject, MemorySegment Token, MemorySegment GenericMapping) {
        var mh$ = CreatePrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateObjectSecurity", ParentDescriptor, CreatorDescriptor, NewDescriptor, IsDirectoryObject, Token, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CreatorDescriptor, NewDescriptor, IsDirectoryObject, Token, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateObjectSecurityEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePrivateObjectSecurityEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor CreatePrivateObjectSecurityEx$descriptor() {
        return CreatePrivateObjectSecurityEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle CreatePrivateObjectSecurityEx$handle() {
        return CreatePrivateObjectSecurityEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MemorySegment CreatePrivateObjectSecurityEx$address() {
        return CreatePrivateObjectSecurityEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int CreatePrivateObjectSecurityEx(MemorySegment ParentDescriptor, MemorySegment CreatorDescriptor, MemorySegment NewDescriptor, MemorySegment ObjectType, int IsContainerObject, int AutoInheritFlags, MemorySegment Token, MemorySegment GenericMapping) {
        var mh$ = CreatePrivateObjectSecurityEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateObjectSecurityEx", ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectType, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectType, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateObjectSecurityWithMultipleInheritance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePrivateObjectSecurityWithMultipleInheritance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor CreatePrivateObjectSecurityWithMultipleInheritance$descriptor() {
        return CreatePrivateObjectSecurityWithMultipleInheritance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle CreatePrivateObjectSecurityWithMultipleInheritance$handle() {
        return CreatePrivateObjectSecurityWithMultipleInheritance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MemorySegment CreatePrivateObjectSecurityWithMultipleInheritance$address() {
        return CreatePrivateObjectSecurityWithMultipleInheritance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int CreatePrivateObjectSecurityWithMultipleInheritance(MemorySegment ParentDescriptor, MemorySegment CreatorDescriptor, MemorySegment NewDescriptor, MemorySegment ObjectTypes, int GuidCount, int IsContainerObject, int AutoInheritFlags, MemorySegment Token, MemorySegment GenericMapping) {
        var mh$ = CreatePrivateObjectSecurityWithMultipleInheritance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateObjectSecurityWithMultipleInheritance", ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectTypes, GuidCount, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectTypes, GuidCount, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRestrictedToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateRestrictedToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle)
     * }
     */
    public static FunctionDescriptor CreateRestrictedToken$descriptor() {
        return CreateRestrictedToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle)
     * }
     */
    public static MethodHandle CreateRestrictedToken$handle() {
        return CreateRestrictedToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle)
     * }
     */
    public static MemorySegment CreateRestrictedToken$address() {
        return CreateRestrictedToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle)
     * }
     */
    public static int CreateRestrictedToken(MemorySegment ExistingTokenHandle, int Flags, int DisableSidCount, MemorySegment SidsToDisable, int DeletePrivilegeCount, MemorySegment PrivilegesToDelete, int RestrictedSidCount, MemorySegment SidsToRestrict, MemorySegment NewTokenHandle) {
        var mh$ = CreateRestrictedToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRestrictedToken", ExistingTokenHandle, Flags, DisableSidCount, SidsToDisable, DeletePrivilegeCount, PrivilegesToDelete, RestrictedSidCount, SidsToRestrict, NewTokenHandle);
            }
            return (int)mh$.invokeExact(ExistingTokenHandle, Flags, DisableSidCount, SidsToDisable, DeletePrivilegeCount, PrivilegesToDelete, RestrictedSidCount, SidsToRestrict, NewTokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWellKnownSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateWellKnownSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid)
     * }
     */
    public static FunctionDescriptor CreateWellKnownSid$descriptor() {
        return CreateWellKnownSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid)
     * }
     */
    public static MethodHandle CreateWellKnownSid$handle() {
        return CreateWellKnownSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid)
     * }
     */
    public static MemorySegment CreateWellKnownSid$address() {
        return CreateWellKnownSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid)
     * }
     */
    public static int CreateWellKnownSid(int WellKnownSidType, MemorySegment DomainSid, MemorySegment pSid, MemorySegment cbSid) {
        var mh$ = CreateWellKnownSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWellKnownSid", WellKnownSidType, DomainSid, pSid, cbSid);
            }
            return (int)mh$.invokeExact(WellKnownSidType, DomainSid, pSid, cbSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualDomainSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EqualDomainSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual)
     * }
     */
    public static FunctionDescriptor EqualDomainSid$descriptor() {
        return EqualDomainSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual)
     * }
     */
    public static MethodHandle EqualDomainSid$handle() {
        return EqualDomainSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual)
     * }
     */
    public static MemorySegment EqualDomainSid$address() {
        return EqualDomainSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual)
     * }
     */
    public static int EqualDomainSid(MemorySegment pSid1, MemorySegment pSid2, MemorySegment pfEqual) {
        var mh$ = EqualDomainSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualDomainSid", pSid1, pSid2, pfEqual);
            }
            return (int)mh$.invokeExact(pSid1, pSid2, pfEqual);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteAce(PACL pAcl, DWORD dwAceIndex)
     * }
     */
    public static FunctionDescriptor DeleteAce$descriptor() {
        return DeleteAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteAce(PACL pAcl, DWORD dwAceIndex)
     * }
     */
    public static MethodHandle DeleteAce$handle() {
        return DeleteAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteAce(PACL pAcl, DWORD dwAceIndex)
     * }
     */
    public static MemorySegment DeleteAce$address() {
        return DeleteAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteAce(PACL pAcl, DWORD dwAceIndex)
     * }
     */
    public static int DeleteAce(MemorySegment pAcl, int dwAceIndex) {
        var mh$ = DeleteAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteAce", pAcl, dwAceIndex);
            }
            return (int)mh$.invokeExact(pAcl, dwAceIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DestroyPrivateObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor)
     * }
     */
    public static FunctionDescriptor DestroyPrivateObjectSecurity$descriptor() {
        return DestroyPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor)
     * }
     */
    public static MethodHandle DestroyPrivateObjectSecurity$handle() {
        return DestroyPrivateObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor)
     * }
     */
    public static MemorySegment DestroyPrivateObjectSecurity$address() {
        return DestroyPrivateObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor)
     * }
     */
    public static int DestroyPrivateObjectSecurity(MemorySegment ObjectDescriptor) {
        var mh$ = DestroyPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyPrivateObjectSecurity", ObjectDescriptor);
            }
            return (int)mh$.invokeExact(ObjectDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DuplicateToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle)
     * }
     */
    public static FunctionDescriptor DuplicateToken$descriptor() {
        return DuplicateToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle)
     * }
     */
    public static MethodHandle DuplicateToken$handle() {
        return DuplicateToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle)
     * }
     */
    public static MemorySegment DuplicateToken$address() {
        return DuplicateToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle)
     * }
     */
    public static int DuplicateToken(MemorySegment ExistingTokenHandle, int ImpersonationLevel, MemorySegment DuplicateTokenHandle) {
        var mh$ = DuplicateToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateToken", ExistingTokenHandle, ImpersonationLevel, DuplicateTokenHandle);
            }
            return (int)mh$.invokeExact(ExistingTokenHandle, ImpersonationLevel, DuplicateTokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateTokenEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DuplicateTokenEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken)
     * }
     */
    public static FunctionDescriptor DuplicateTokenEx$descriptor() {
        return DuplicateTokenEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken)
     * }
     */
    public static MethodHandle DuplicateTokenEx$handle() {
        return DuplicateTokenEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken)
     * }
     */
    public static MemorySegment DuplicateTokenEx$address() {
        return DuplicateTokenEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken)
     * }
     */
    public static int DuplicateTokenEx(MemorySegment hExistingToken, int dwDesiredAccess, MemorySegment lpTokenAttributes, int ImpersonationLevel, int TokenType, MemorySegment phNewToken) {
        var mh$ = DuplicateTokenEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateTokenEx", hExistingToken, dwDesiredAccess, lpTokenAttributes, ImpersonationLevel, TokenType, phNewToken);
            }
            return (int)mh$.invokeExact(hExistingToken, dwDesiredAccess, lpTokenAttributes, ImpersonationLevel, TokenType, phNewToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualPrefixSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EqualPrefixSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualPrefixSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static FunctionDescriptor EqualPrefixSid$descriptor() {
        return EqualPrefixSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualPrefixSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static MethodHandle EqualPrefixSid$handle() {
        return EqualPrefixSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EqualPrefixSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static MemorySegment EqualPrefixSid$address() {
        return EqualPrefixSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EqualPrefixSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static int EqualPrefixSid(MemorySegment pSid1, MemorySegment pSid2) {
        var mh$ = EqualPrefixSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualPrefixSid", pSid1, pSid2);
            }
            return (int)mh$.invokeExact(pSid1, pSid2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("EqualSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static FunctionDescriptor EqualSid$descriptor() {
        return EqualSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static MethodHandle EqualSid$handle() {
        return EqualSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EqualSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static MemorySegment EqualSid$address() {
        return EqualSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EqualSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static int EqualSid(MemorySegment pSid1, MemorySegment pSid2) {
        var mh$ = EqualSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualSid", pSid1, pSid2);
            }
            return (int)mh$.invokeExact(pSid1, pSid2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFreeAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FindFirstFreeAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindFirstFreeAce(PACL pAcl, LPVOID *pAce)
     * }
     */
    public static FunctionDescriptor FindFirstFreeAce$descriptor() {
        return FindFirstFreeAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindFirstFreeAce(PACL pAcl, LPVOID *pAce)
     * }
     */
    public static MethodHandle FindFirstFreeAce$handle() {
        return FindFirstFreeAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindFirstFreeAce(PACL pAcl, LPVOID *pAce)
     * }
     */
    public static MemorySegment FindFirstFreeAce$address() {
        return FindFirstFreeAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindFirstFreeAce(PACL pAcl, LPVOID *pAce)
     * }
     */
    public static int FindFirstFreeAce(MemorySegment pAcl, MemorySegment pAce) {
        var mh$ = FindFirstFreeAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFreeAce", pAcl, pAce);
            }
            return (int)mh$.invokeExact(pAcl, pAce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("FreeSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID FreeSid(PSID pSid)
     * }
     */
    public static FunctionDescriptor FreeSid$descriptor() {
        return FreeSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID FreeSid(PSID pSid)
     * }
     */
    public static MethodHandle FreeSid$handle() {
        return FreeSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID FreeSid(PSID pSid)
     * }
     */
    public static MemorySegment FreeSid$address() {
        return FreeSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID FreeSid(PSID pSid)
     * }
     */
    public static MemorySegment FreeSid(MemorySegment pSid) {
        var mh$ = FreeSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeSid", pSid);
            }
            return (MemorySegment)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)
     * }
     */
    public static FunctionDescriptor GetAce$descriptor() {
        return GetAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)
     * }
     */
    public static MethodHandle GetAce$handle() {
        return GetAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)
     * }
     */
    public static MemorySegment GetAce$address() {
        return GetAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)
     * }
     */
    public static int GetAce(MemorySegment pAcl, int dwAceIndex, MemorySegment pAce) {
        var mh$ = GetAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAce", pAcl, dwAceIndex, pAce);
            }
            return (int)mh$.invokeExact(pAcl, dwAceIndex, pAce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAclInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetAclInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static FunctionDescriptor GetAclInformation$descriptor() {
        return GetAclInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static MethodHandle GetAclInformation$handle() {
        return GetAclInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static MemorySegment GetAclInformation$address() {
        return GetAclInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static int GetAclInformation(MemorySegment pAcl, MemorySegment pAclInformation, int nAclInformationLength, int dwAclInformationClass) {
        var mh$ = GetAclInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAclInformation", pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
            }
            return (int)mh$.invokeExact(pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSecurityW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetFileSecurityW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetFileSecurityW$descriptor() {
        return GetFileSecurityW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetFileSecurityW$handle() {
        return GetFileSecurityW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetFileSecurityW$address() {
        return GetFileSecurityW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetFileSecurityW(MemorySegment lpFileName, int RequestedInformation, MemorySegment pSecurityDescriptor, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetFileSecurityW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSecurityW", lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKernelObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetKernelObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetKernelObjectSecurity$descriptor() {
        return GetKernelObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetKernelObjectSecurity$handle() {
        return GetKernelObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetKernelObjectSecurity$address() {
        return GetKernelObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetKernelObjectSecurity(MemorySegment Handle, int RequestedInformation, MemorySegment pSecurityDescriptor, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetKernelObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKernelObjectSecurity", Handle, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(Handle, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLengthSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetLengthSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLengthSid(PSID pSid)
     * }
     */
    public static FunctionDescriptor GetLengthSid$descriptor() {
        return GetLengthSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLengthSid(PSID pSid)
     * }
     */
    public static MethodHandle GetLengthSid$handle() {
        return GetLengthSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLengthSid(PSID pSid)
     * }
     */
    public static MemorySegment GetLengthSid$address() {
        return GetLengthSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLengthSid(PSID pSid)
     * }
     */
    public static int GetLengthSid(MemorySegment pSid) {
        var mh$ = GetLengthSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLengthSid", pSid);
            }
            return (int)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetPrivateObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor GetPrivateObjectSecurity$descriptor() {
        return GetPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle GetPrivateObjectSecurity$handle() {
        return GetPrivateObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength)
     * }
     */
    public static MemorySegment GetPrivateObjectSecurity$address() {
        return GetPrivateObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength)
     * }
     */
    public static int GetPrivateObjectSecurity(MemorySegment ObjectDescriptor, int SecurityInformation, MemorySegment ResultantDescriptor, int DescriptorLength, MemorySegment ReturnLength) {
        var mh$ = GetPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateObjectSecurity", ObjectDescriptor, SecurityInformation, ResultantDescriptor, DescriptorLength, ReturnLength);
            }
            return (int)mh$.invokeExact(ObjectDescriptor, SecurityInformation, ResultantDescriptor, DescriptorLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSecurityDescriptorControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorControl$descriptor() {
        return GetSecurityDescriptorControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision)
     * }
     */
    public static MethodHandle GetSecurityDescriptorControl$handle() {
        return GetSecurityDescriptorControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision)
     * }
     */
    public static MemorySegment GetSecurityDescriptorControl$address() {
        return GetSecurityDescriptorControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision)
     * }
     */
    public static int GetSecurityDescriptorControl(MemorySegment pSecurityDescriptor, MemorySegment pControl, MemorySegment lpdwRevision) {
        var mh$ = GetSecurityDescriptorControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorControl", pSecurityDescriptor, pControl, lpdwRevision);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pControl, lpdwRevision);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorDacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSecurityDescriptorDacl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorDacl$descriptor() {
        return GetSecurityDescriptorDacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorDacl$handle() {
        return GetSecurityDescriptorDacl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted)
     * }
     */
    public static MemorySegment GetSecurityDescriptorDacl$address() {
        return GetSecurityDescriptorDacl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted)
     * }
     */
    public static int GetSecurityDescriptorDacl(MemorySegment pSecurityDescriptor, MemorySegment lpbDaclPresent, MemorySegment pDacl, MemorySegment lpbDaclDefaulted) {
        var mh$ = GetSecurityDescriptorDacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorDacl", pSecurityDescriptor, lpbDaclPresent, pDacl, lpbDaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, lpbDaclPresent, pDacl, lpbDaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSecurityDescriptorGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorGroup$descriptor() {
        return GetSecurityDescriptorGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorGroup$handle() {
        return GetSecurityDescriptorGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted)
     * }
     */
    public static MemorySegment GetSecurityDescriptorGroup$address() {
        return GetSecurityDescriptorGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted)
     * }
     */
    public static int GetSecurityDescriptorGroup(MemorySegment pSecurityDescriptor, MemorySegment pGroup, MemorySegment lpbGroupDefaulted) {
        var mh$ = GetSecurityDescriptorGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorGroup", pSecurityDescriptor, pGroup, lpbGroupDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pGroup, lpbGroupDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSecurityDescriptorLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorLength$descriptor() {
        return GetSecurityDescriptorLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle GetSecurityDescriptorLength$handle() {
        return GetSecurityDescriptorLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MemorySegment GetSecurityDescriptorLength$address() {
        return GetSecurityDescriptorLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int GetSecurityDescriptorLength(MemorySegment pSecurityDescriptor) {
        var mh$ = GetSecurityDescriptorLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorLength", pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorOwner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSecurityDescriptorOwner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorOwner$descriptor() {
        return GetSecurityDescriptorOwner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorOwner$handle() {
        return GetSecurityDescriptorOwner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted)
     * }
     */
    public static MemorySegment GetSecurityDescriptorOwner$address() {
        return GetSecurityDescriptorOwner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted)
     * }
     */
    public static int GetSecurityDescriptorOwner(MemorySegment pSecurityDescriptor, MemorySegment pOwner, MemorySegment lpbOwnerDefaulted) {
        var mh$ = GetSecurityDescriptorOwner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorOwner", pSecurityDescriptor, pOwner, lpbOwnerDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pOwner, lpbOwnerDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorRMControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSecurityDescriptorRMControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorRMControl$descriptor() {
        return GetSecurityDescriptorRMControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static MethodHandle GetSecurityDescriptorRMControl$handle() {
        return GetSecurityDescriptorRMControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static MemorySegment GetSecurityDescriptorRMControl$address() {
        return GetSecurityDescriptorRMControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static int GetSecurityDescriptorRMControl(MemorySegment SecurityDescriptor, MemorySegment RMControl) {
        var mh$ = GetSecurityDescriptorRMControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorRMControl", SecurityDescriptor, RMControl);
            }
            return (int)mh$.invokeExact(SecurityDescriptor, RMControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorSacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSecurityDescriptorSacl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorSacl$descriptor() {
        return GetSecurityDescriptorSacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorSacl$handle() {
        return GetSecurityDescriptorSacl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted)
     * }
     */
    public static MemorySegment GetSecurityDescriptorSacl$address() {
        return GetSecurityDescriptorSacl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted)
     * }
     */
    public static int GetSecurityDescriptorSacl(MemorySegment pSecurityDescriptor, MemorySegment lpbSaclPresent, MemorySegment pSacl, MemorySegment lpbSaclDefaulted) {
        var mh$ = GetSecurityDescriptorSacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorSacl", pSecurityDescriptor, lpbSaclPresent, pSacl, lpbSaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, lpbSaclPresent, pSacl, lpbSaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidIdentifierAuthority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSidIdentifierAuthority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid)
     * }
     */
    public static FunctionDescriptor GetSidIdentifierAuthority$descriptor() {
        return GetSidIdentifierAuthority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid)
     * }
     */
    public static MethodHandle GetSidIdentifierAuthority$handle() {
        return GetSidIdentifierAuthority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid)
     * }
     */
    public static MemorySegment GetSidIdentifierAuthority$address() {
        return GetSidIdentifierAuthority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid)
     * }
     */
    public static MemorySegment GetSidIdentifierAuthority(MemorySegment pSid) {
        var mh$ = GetSidIdentifierAuthority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidIdentifierAuthority", pSid);
            }
            return (MemorySegment)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidLengthRequired {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSidLengthRequired");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetSidLengthRequired(UCHAR nSubAuthorityCount)
     * }
     */
    public static FunctionDescriptor GetSidLengthRequired$descriptor() {
        return GetSidLengthRequired.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetSidLengthRequired(UCHAR nSubAuthorityCount)
     * }
     */
    public static MethodHandle GetSidLengthRequired$handle() {
        return GetSidLengthRequired.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetSidLengthRequired(UCHAR nSubAuthorityCount)
     * }
     */
    public static MemorySegment GetSidLengthRequired$address() {
        return GetSidLengthRequired.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetSidLengthRequired(UCHAR nSubAuthorityCount)
     * }
     */
    public static int GetSidLengthRequired(byte nSubAuthorityCount) {
        var mh$ = GetSidLengthRequired.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidLengthRequired", nSubAuthorityCount);
            }
            return (int)mh$.invokeExact(nSubAuthorityCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidSubAuthority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSidSubAuthority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PDWORD GetSidSubAuthority(PSID pSid, DWORD nSubAuthority)
     * }
     */
    public static FunctionDescriptor GetSidSubAuthority$descriptor() {
        return GetSidSubAuthority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PDWORD GetSidSubAuthority(PSID pSid, DWORD nSubAuthority)
     * }
     */
    public static MethodHandle GetSidSubAuthority$handle() {
        return GetSidSubAuthority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PDWORD GetSidSubAuthority(PSID pSid, DWORD nSubAuthority)
     * }
     */
    public static MemorySegment GetSidSubAuthority$address() {
        return GetSidSubAuthority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PDWORD GetSidSubAuthority(PSID pSid, DWORD nSubAuthority)
     * }
     */
    public static MemorySegment GetSidSubAuthority(MemorySegment pSid, int nSubAuthority) {
        var mh$ = GetSidSubAuthority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidSubAuthority", pSid, nSubAuthority);
            }
            return (MemorySegment)mh$.invokeExact(pSid, nSubAuthority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidSubAuthorityCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetSidSubAuthorityCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUCHAR GetSidSubAuthorityCount(PSID pSid)
     * }
     */
    public static FunctionDescriptor GetSidSubAuthorityCount$descriptor() {
        return GetSidSubAuthorityCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUCHAR GetSidSubAuthorityCount(PSID pSid)
     * }
     */
    public static MethodHandle GetSidSubAuthorityCount$handle() {
        return GetSidSubAuthorityCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUCHAR GetSidSubAuthorityCount(PSID pSid)
     * }
     */
    public static MemorySegment GetSidSubAuthorityCount$address() {
        return GetSidSubAuthorityCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUCHAR GetSidSubAuthorityCount(PSID pSid)
     * }
     */
    public static MemorySegment GetSidSubAuthorityCount(MemorySegment pSid) {
        var mh$ = GetSidSubAuthorityCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidSubAuthorityCount", pSid);
            }
            return (MemorySegment)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTokenInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetTokenInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor GetTokenInformation$descriptor() {
        return GetTokenInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle GetTokenInformation$handle() {
        return GetTokenInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength)
     * }
     */
    public static MemorySegment GetTokenInformation$address() {
        return GetTokenInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength)
     * }
     */
    public static int GetTokenInformation(MemorySegment TokenHandle, int TokenInformationClass, MemorySegment TokenInformation, int TokenInformationLength, MemorySegment ReturnLength) {
        var mh$ = GetTokenInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTokenInformation", TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, ReturnLength);
            }
            return (int)mh$.invokeExact(TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowsAccountDomainSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetWindowsAccountDomainSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD *cbDomainSid)
     * }
     */
    public static FunctionDescriptor GetWindowsAccountDomainSid$descriptor() {
        return GetWindowsAccountDomainSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD *cbDomainSid)
     * }
     */
    public static MethodHandle GetWindowsAccountDomainSid$handle() {
        return GetWindowsAccountDomainSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD *cbDomainSid)
     * }
     */
    public static MemorySegment GetWindowsAccountDomainSid$address() {
        return GetWindowsAccountDomainSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD *cbDomainSid)
     * }
     */
    public static int GetWindowsAccountDomainSid(MemorySegment pSid, MemorySegment pDomainSid, MemorySegment cbDomainSid) {
        var mh$ = GetWindowsAccountDomainSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowsAccountDomainSid", pSid, pDomainSid, cbDomainSid);
            }
            return (int)mh$.invokeExact(pSid, pDomainSid, cbDomainSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateAnonymousToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImpersonateAnonymousToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateAnonymousToken(HANDLE ThreadHandle)
     * }
     */
    public static FunctionDescriptor ImpersonateAnonymousToken$descriptor() {
        return ImpersonateAnonymousToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateAnonymousToken(HANDLE ThreadHandle)
     * }
     */
    public static MethodHandle ImpersonateAnonymousToken$handle() {
        return ImpersonateAnonymousToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImpersonateAnonymousToken(HANDLE ThreadHandle)
     * }
     */
    public static MemorySegment ImpersonateAnonymousToken$address() {
        return ImpersonateAnonymousToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImpersonateAnonymousToken(HANDLE ThreadHandle)
     * }
     */
    public static int ImpersonateAnonymousToken(MemorySegment ThreadHandle) {
        var mh$ = ImpersonateAnonymousToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateAnonymousToken", ThreadHandle);
            }
            return (int)mh$.invokeExact(ThreadHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateLoggedOnUser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImpersonateLoggedOnUser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateLoggedOnUser(HANDLE hToken)
     * }
     */
    public static FunctionDescriptor ImpersonateLoggedOnUser$descriptor() {
        return ImpersonateLoggedOnUser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateLoggedOnUser(HANDLE hToken)
     * }
     */
    public static MethodHandle ImpersonateLoggedOnUser$handle() {
        return ImpersonateLoggedOnUser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImpersonateLoggedOnUser(HANDLE hToken)
     * }
     */
    public static MemorySegment ImpersonateLoggedOnUser$address() {
        return ImpersonateLoggedOnUser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImpersonateLoggedOnUser(HANDLE hToken)
     * }
     */
    public static int ImpersonateLoggedOnUser(MemorySegment hToken) {
        var mh$ = ImpersonateLoggedOnUser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateLoggedOnUser", hToken);
            }
            return (int)mh$.invokeExact(hToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateSelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ImpersonateSelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     * }
     */
    public static FunctionDescriptor ImpersonateSelf$descriptor() {
        return ImpersonateSelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     * }
     */
    public static MethodHandle ImpersonateSelf$handle() {
        return ImpersonateSelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     * }
     */
    public static MemorySegment ImpersonateSelf$address() {
        return ImpersonateSelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     * }
     */
    public static int ImpersonateSelf(int ImpersonationLevel) {
        var mh$ = ImpersonateSelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateSelf", ImpersonationLevel);
            }
            return (int)mh$.invokeExact(ImpersonationLevel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeAcl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeAcl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision)
     * }
     */
    public static FunctionDescriptor InitializeAcl$descriptor() {
        return InitializeAcl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision)
     * }
     */
    public static MethodHandle InitializeAcl$handle() {
        return InitializeAcl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision)
     * }
     */
    public static MemorySegment InitializeAcl$address() {
        return InitializeAcl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision)
     * }
     */
    public static int InitializeAcl(MemorySegment pAcl, int nAclLength, int dwAclRevision) {
        var mh$ = InitializeAcl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeAcl", pAcl, nAclLength, dwAclRevision);
            }
            return (int)mh$.invokeExact(pAcl, nAclLength, dwAclRevision);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSecurityDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeSecurityDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)
     * }
     */
    public static FunctionDescriptor InitializeSecurityDescriptor$descriptor() {
        return InitializeSecurityDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)
     * }
     */
    public static MethodHandle InitializeSecurityDescriptor$handle() {
        return InitializeSecurityDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)
     * }
     */
    public static MemorySegment InitializeSecurityDescriptor$address() {
        return InitializeSecurityDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)
     * }
     */
    public static int InitializeSecurityDescriptor(MemorySegment pSecurityDescriptor, int dwRevision) {
        var mh$ = InitializeSecurityDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSecurityDescriptor", pSecurityDescriptor, dwRevision);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, dwRevision);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_CHAR
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("InitializeSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount)
     * }
     */
    public static FunctionDescriptor InitializeSid$descriptor() {
        return InitializeSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount)
     * }
     */
    public static MethodHandle InitializeSid$handle() {
        return InitializeSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount)
     * }
     */
    public static MemorySegment InitializeSid$address() {
        return InitializeSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount)
     * }
     */
    public static int InitializeSid(MemorySegment Sid, MemorySegment pIdentifierAuthority, byte nSubAuthorityCount) {
        var mh$ = InitializeSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSid", Sid, pIdentifierAuthority, nSubAuthorityCount);
            }
            return (int)mh$.invokeExact(Sid, pIdentifierAuthority, nSubAuthorityCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTokenRestricted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsTokenRestricted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTokenRestricted(HANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor IsTokenRestricted$descriptor() {
        return IsTokenRestricted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTokenRestricted(HANDLE TokenHandle)
     * }
     */
    public static MethodHandle IsTokenRestricted$handle() {
        return IsTokenRestricted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsTokenRestricted(HANDLE TokenHandle)
     * }
     */
    public static MemorySegment IsTokenRestricted$address() {
        return IsTokenRestricted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsTokenRestricted(HANDLE TokenHandle)
     * }
     */
    public static int IsTokenRestricted(MemorySegment TokenHandle) {
        var mh$ = IsTokenRestricted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTokenRestricted", TokenHandle);
            }
            return (int)mh$.invokeExact(TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidAcl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsValidAcl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidAcl(PACL pAcl)
     * }
     */
    public static FunctionDescriptor IsValidAcl$descriptor() {
        return IsValidAcl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidAcl(PACL pAcl)
     * }
     */
    public static MethodHandle IsValidAcl$handle() {
        return IsValidAcl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidAcl(PACL pAcl)
     * }
     */
    public static MemorySegment IsValidAcl$address() {
        return IsValidAcl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidAcl(PACL pAcl)
     * }
     */
    public static int IsValidAcl(MemorySegment pAcl) {
        var mh$ = IsValidAcl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidAcl", pAcl);
            }
            return (int)mh$.invokeExact(pAcl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidSecurityDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsValidSecurityDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor IsValidSecurityDescriptor$descriptor() {
        return IsValidSecurityDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle IsValidSecurityDescriptor$handle() {
        return IsValidSecurityDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MemorySegment IsValidSecurityDescriptor$address() {
        return IsValidSecurityDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int IsValidSecurityDescriptor(MemorySegment pSecurityDescriptor) {
        var mh$ = IsValidSecurityDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidSecurityDescriptor", pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsValidSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidSid(PSID pSid)
     * }
     */
    public static FunctionDescriptor IsValidSid$descriptor() {
        return IsValidSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidSid(PSID pSid)
     * }
     */
    public static MethodHandle IsValidSid$handle() {
        return IsValidSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidSid(PSID pSid)
     * }
     */
    public static MemorySegment IsValidSid$address() {
        return IsValidSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidSid(PSID pSid)
     * }
     */
    public static int IsValidSid(MemorySegment pSid) {
        var mh$ = IsValidSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidSid", pSid);
            }
            return (int)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWellKnownSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("IsWellKnownSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType)
     * }
     */
    public static FunctionDescriptor IsWellKnownSid$descriptor() {
        return IsWellKnownSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType)
     * }
     */
    public static MethodHandle IsWellKnownSid$handle() {
        return IsWellKnownSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType)
     * }
     */
    public static MemorySegment IsWellKnownSid$address() {
        return IsWellKnownSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType)
     * }
     */
    public static int IsWellKnownSid(MemorySegment pSid, int WellKnownSidType) {
        var mh$ = IsWellKnownSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWellKnownSid", pSid, WellKnownSidType);
            }
            return (int)mh$.invokeExact(pSid, WellKnownSidType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MakeAbsoluteSD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MakeAbsoluteSD");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize)
     * }
     */
    public static FunctionDescriptor MakeAbsoluteSD$descriptor() {
        return MakeAbsoluteSD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize)
     * }
     */
    public static MethodHandle MakeAbsoluteSD$handle() {
        return MakeAbsoluteSD.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize)
     * }
     */
    public static MemorySegment MakeAbsoluteSD$address() {
        return MakeAbsoluteSD.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize)
     * }
     */
    public static int MakeAbsoluteSD(MemorySegment pSelfRelativeSecurityDescriptor, MemorySegment pAbsoluteSecurityDescriptor, MemorySegment lpdwAbsoluteSecurityDescriptorSize, MemorySegment pDacl, MemorySegment lpdwDaclSize, MemorySegment pSacl, MemorySegment lpdwSaclSize, MemorySegment pOwner, MemorySegment lpdwOwnerSize, MemorySegment pPrimaryGroup, MemorySegment lpdwPrimaryGroupSize) {
        var mh$ = MakeAbsoluteSD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MakeAbsoluteSD", pSelfRelativeSecurityDescriptor, pAbsoluteSecurityDescriptor, lpdwAbsoluteSecurityDescriptorSize, pDacl, lpdwDaclSize, pSacl, lpdwSaclSize, pOwner, lpdwOwnerSize, pPrimaryGroup, lpdwPrimaryGroupSize);
            }
            return (int)mh$.invokeExact(pSelfRelativeSecurityDescriptor, pAbsoluteSecurityDescriptor, lpdwAbsoluteSecurityDescriptorSize, pDacl, lpdwDaclSize, pSacl, lpdwSaclSize, pOwner, lpdwOwnerSize, pPrimaryGroup, lpdwPrimaryGroupSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MakeSelfRelativeSD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MakeSelfRelativeSD");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength)
     * }
     */
    public static FunctionDescriptor MakeSelfRelativeSD$descriptor() {
        return MakeSelfRelativeSD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength)
     * }
     */
    public static MethodHandle MakeSelfRelativeSD$handle() {
        return MakeSelfRelativeSD.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength)
     * }
     */
    public static MemorySegment MakeSelfRelativeSD$address() {
        return MakeSelfRelativeSD.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength)
     * }
     */
    public static int MakeSelfRelativeSD(MemorySegment pAbsoluteSecurityDescriptor, MemorySegment pSelfRelativeSecurityDescriptor, MemorySegment lpdwBufferLength) {
        var mh$ = MakeSelfRelativeSD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MakeSelfRelativeSD", pAbsoluteSecurityDescriptor, pSelfRelativeSecurityDescriptor, lpdwBufferLength);
            }
            return (int)mh$.invokeExact(pAbsoluteSecurityDescriptor, pSelfRelativeSecurityDescriptor, lpdwBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapGenericMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("MapGenericMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor MapGenericMask$descriptor() {
        return MapGenericMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle MapGenericMask$handle() {
        return MapGenericMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MemorySegment MapGenericMask$address() {
        return MapGenericMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static void MapGenericMask(MemorySegment AccessMask, MemorySegment GenericMapping) {
        var mh$ = MapGenericMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapGenericMask", AccessMask, GenericMapping);
            }
            mh$.invokeExact(AccessMask, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCloseAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ObjectCloseAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectCloseAuditAlarmW$descriptor() {
        return ObjectCloseAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectCloseAuditAlarmW$handle() {
        return ObjectCloseAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectCloseAuditAlarmW$address() {
        return ObjectCloseAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectCloseAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectCloseAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCloseAuditAlarmW", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectDeleteAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ObjectDeleteAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectDeleteAuditAlarmW$descriptor() {
        return ObjectDeleteAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectDeleteAuditAlarmW$handle() {
        return ObjectDeleteAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectDeleteAuditAlarmW$address() {
        return ObjectDeleteAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectDeleteAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectDeleteAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectDeleteAuditAlarmW", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectOpenAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ObjectOpenAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectOpenAuditAlarmW$descriptor() {
        return ObjectOpenAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectOpenAuditAlarmW$handle() {
        return ObjectOpenAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectOpenAuditAlarmW$address() {
        return ObjectOpenAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static int ObjectOpenAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment pSecurityDescriptor, MemorySegment ClientToken, int DesiredAccess, int GrantedAccess, MemorySegment Privileges, int ObjectCreation, int AccessGranted, MemorySegment GenerateOnClose) {
        var mh$ = ObjectOpenAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectOpenAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectPrivilegeAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ObjectPrivilegeAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor ObjectPrivilegeAuditAlarmW$descriptor() {
        return ObjectPrivilegeAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle ObjectPrivilegeAuditAlarmW$handle() {
        return ObjectPrivilegeAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MemorySegment ObjectPrivilegeAuditAlarmW$address() {
        return ObjectPrivilegeAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int ObjectPrivilegeAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, int DesiredAccess, MemorySegment Privileges, int AccessGranted) {
        var mh$ = ObjectPrivilegeAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectPrivilegeAuditAlarmW", SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivilegeCheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PrivilegeCheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult)
     * }
     */
    public static FunctionDescriptor PrivilegeCheck$descriptor() {
        return PrivilegeCheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult)
     * }
     */
    public static MethodHandle PrivilegeCheck$handle() {
        return PrivilegeCheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult)
     * }
     */
    public static MemorySegment PrivilegeCheck$address() {
        return PrivilegeCheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult)
     * }
     */
    public static int PrivilegeCheck(MemorySegment ClientToken, MemorySegment RequiredPrivileges, MemorySegment pfResult) {
        var mh$ = PrivilegeCheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivilegeCheck", ClientToken, RequiredPrivileges, pfResult);
            }
            return (int)mh$.invokeExact(ClientToken, RequiredPrivileges, pfResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivilegedServiceAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("PrivilegedServiceAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor PrivilegedServiceAuditAlarmW$descriptor() {
        return PrivilegedServiceAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle PrivilegedServiceAuditAlarmW$handle() {
        return PrivilegedServiceAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MemorySegment PrivilegedServiceAuditAlarmW$address() {
        return PrivilegedServiceAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int PrivilegedServiceAuditAlarmW(MemorySegment SubsystemName, MemorySegment ServiceName, MemorySegment ClientToken, MemorySegment Privileges, int AccessGranted) {
        var mh$ = PrivilegedServiceAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivilegedServiceAuditAlarmW", SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuerySecurityAccessMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QuerySecurityAccessMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor QuerySecurityAccessMask$descriptor() {
        return QuerySecurityAccessMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static MethodHandle QuerySecurityAccessMask$handle() {
        return QuerySecurityAccessMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static MemorySegment QuerySecurityAccessMask$address() {
        return QuerySecurityAccessMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static void QuerySecurityAccessMask(int SecurityInformation, MemorySegment DesiredAccess) {
        var mh$ = QuerySecurityAccessMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuerySecurityAccessMask", SecurityInformation, DesiredAccess);
            }
            mh$.invokeExact(SecurityInformation, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RevertToSelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT    );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("RevertToSelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RevertToSelf()
     * }
     */
    public static FunctionDescriptor RevertToSelf$descriptor() {
        return RevertToSelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RevertToSelf()
     * }
     */
    public static MethodHandle RevertToSelf$handle() {
        return RevertToSelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RevertToSelf()
     * }
     */
    public static MemorySegment RevertToSelf$address() {
        return RevertToSelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RevertToSelf()
     * }
     */
    public static int RevertToSelf() {
        var mh$ = RevertToSelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RevertToSelf");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAclInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetAclInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static FunctionDescriptor SetAclInformation$descriptor() {
        return SetAclInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static MethodHandle SetAclInformation$handle() {
        return SetAclInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static MemorySegment SetAclInformation$address() {
        return SetAclInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static int SetAclInformation(MemorySegment pAcl, MemorySegment pAclInformation, int nAclInformationLength, int dwAclInformationClass) {
        var mh$ = SetAclInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAclInformation", pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
            }
            return (int)mh$.invokeExact(pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileSecurityW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetFileSecurityW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor SetFileSecurityW$descriptor() {
        return SetFileSecurityW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle SetFileSecurityW$handle() {
        return SetFileSecurityW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MemorySegment SetFileSecurityW$address() {
        return SetFileSecurityW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int SetFileSecurityW(MemorySegment lpFileName, int SecurityInformation, MemorySegment pSecurityDescriptor) {
        var mh$ = SetFileSecurityW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileSecurityW", lpFileName, SecurityInformation, pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(lpFileName, SecurityInformation, pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetKernelObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetKernelObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor)
     * }
     */
    public static FunctionDescriptor SetKernelObjectSecurity$descriptor() {
        return SetKernelObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor)
     * }
     */
    public static MethodHandle SetKernelObjectSecurity$handle() {
        return SetKernelObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor)
     * }
     */
    public static MemorySegment SetKernelObjectSecurity$address() {
        return SetKernelObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor)
     * }
     */
    public static int SetKernelObjectSecurity(MemorySegment Handle, int SecurityInformation, MemorySegment SecurityDescriptor) {
        var mh$ = SetKernelObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetKernelObjectSecurity", Handle, SecurityInformation, SecurityDescriptor);
            }
            return (int)mh$.invokeExact(Handle, SecurityInformation, SecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetPrivateObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static FunctionDescriptor SetPrivateObjectSecurity$descriptor() {
        return SetPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static MethodHandle SetPrivateObjectSecurity$handle() {
        return SetPrivateObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static MemorySegment SetPrivateObjectSecurity$address() {
        return SetPrivateObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static int SetPrivateObjectSecurity(int SecurityInformation, MemorySegment ModificationDescriptor, MemorySegment ObjectsSecurityDescriptor, MemorySegment GenericMapping, MemorySegment Token) {
        var mh$ = SetPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPrivateObjectSecurity", SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, GenericMapping, Token);
            }
            return (int)mh$.invokeExact(SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, GenericMapping, Token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPrivateObjectSecurityEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetPrivateObjectSecurityEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static FunctionDescriptor SetPrivateObjectSecurityEx$descriptor() {
        return SetPrivateObjectSecurityEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static MethodHandle SetPrivateObjectSecurityEx$handle() {
        return SetPrivateObjectSecurityEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static MemorySegment SetPrivateObjectSecurityEx$address() {
        return SetPrivateObjectSecurityEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static int SetPrivateObjectSecurityEx(int SecurityInformation, MemorySegment ModificationDescriptor, MemorySegment ObjectsSecurityDescriptor, int AutoInheritFlags, MemorySegment GenericMapping, MemorySegment Token) {
        var mh$ = SetPrivateObjectSecurityEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPrivateObjectSecurityEx", SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, AutoInheritFlags, GenericMapping, Token);
            }
            return (int)mh$.invokeExact(SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, AutoInheritFlags, GenericMapping, Token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityAccessMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSecurityAccessMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor SetSecurityAccessMask$descriptor() {
        return SetSecurityAccessMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static MethodHandle SetSecurityAccessMask$handle() {
        return SetSecurityAccessMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static MemorySegment SetSecurityAccessMask$address() {
        return SetSecurityAccessMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static void SetSecurityAccessMask(int SecurityInformation, MemorySegment DesiredAccess) {
        var mh$ = SetSecurityAccessMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityAccessMask", SecurityInformation, DesiredAccess);
            }
            mh$.invokeExact(SecurityInformation, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_SHORT,
            wgl_h.C_SHORT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSecurityDescriptorControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorControl$descriptor() {
        return SetSecurityDescriptorControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
     * }
     */
    public static MethodHandle SetSecurityDescriptorControl$handle() {
        return SetSecurityDescriptorControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
     * }
     */
    public static MemorySegment SetSecurityDescriptorControl$address() {
        return SetSecurityDescriptorControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
     * }
     */
    public static int SetSecurityDescriptorControl(MemorySegment pSecurityDescriptor, short ControlBitsOfInterest, short ControlBitsToSet) {
        var mh$ = SetSecurityDescriptorControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorControl", pSecurityDescriptor, ControlBitsOfInterest, ControlBitsToSet);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, ControlBitsOfInterest, ControlBitsToSet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorDacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSecurityDescriptorDacl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorDacl$descriptor() {
        return SetSecurityDescriptorDacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorDacl$handle() {
        return SetSecurityDescriptorDacl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted)
     * }
     */
    public static MemorySegment SetSecurityDescriptorDacl$address() {
        return SetSecurityDescriptorDacl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted)
     * }
     */
    public static int SetSecurityDescriptorDacl(MemorySegment pSecurityDescriptor, int bDaclPresent, MemorySegment pDacl, int bDaclDefaulted) {
        var mh$ = SetSecurityDescriptorDacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorDacl", pSecurityDescriptor, bDaclPresent, pDacl, bDaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, bDaclPresent, pDacl, bDaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSecurityDescriptorGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorGroup$descriptor() {
        return SetSecurityDescriptorGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorGroup$handle() {
        return SetSecurityDescriptorGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)
     * }
     */
    public static MemorySegment SetSecurityDescriptorGroup$address() {
        return SetSecurityDescriptorGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)
     * }
     */
    public static int SetSecurityDescriptorGroup(MemorySegment pSecurityDescriptor, MemorySegment pGroup, int bGroupDefaulted) {
        var mh$ = SetSecurityDescriptorGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorGroup", pSecurityDescriptor, pGroup, bGroupDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pGroup, bGroupDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorOwner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSecurityDescriptorOwner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorOwner$descriptor() {
        return SetSecurityDescriptorOwner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorOwner$handle() {
        return SetSecurityDescriptorOwner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)
     * }
     */
    public static MemorySegment SetSecurityDescriptorOwner$address() {
        return SetSecurityDescriptorOwner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)
     * }
     */
    public static int SetSecurityDescriptorOwner(MemorySegment pSecurityDescriptor, MemorySegment pOwner, int bOwnerDefaulted) {
        var mh$ = SetSecurityDescriptorOwner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorOwner", pSecurityDescriptor, pOwner, bOwnerDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pOwner, bOwnerDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorRMControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSecurityDescriptorRMControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorRMControl$descriptor() {
        return SetSecurityDescriptorRMControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static MethodHandle SetSecurityDescriptorRMControl$handle() {
        return SetSecurityDescriptorRMControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static MemorySegment SetSecurityDescriptorRMControl$address() {
        return SetSecurityDescriptorRMControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static int SetSecurityDescriptorRMControl(MemorySegment SecurityDescriptor, MemorySegment RMControl) {
        var mh$ = SetSecurityDescriptorRMControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorRMControl", SecurityDescriptor, RMControl);
            }
            return (int)mh$.invokeExact(SecurityDescriptor, RMControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorSacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetSecurityDescriptorSacl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorSacl$descriptor() {
        return SetSecurityDescriptorSacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorSacl$handle() {
        return SetSecurityDescriptorSacl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted)
     * }
     */
    public static MemorySegment SetSecurityDescriptorSacl$address() {
        return SetSecurityDescriptorSacl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted)
     * }
     */
    public static int SetSecurityDescriptorSacl(MemorySegment pSecurityDescriptor, int bSaclPresent, MemorySegment pSacl, int bSaclDefaulted) {
        var mh$ = SetSecurityDescriptorSacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorSacl", pSecurityDescriptor, bSaclPresent, pSacl, bSaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, bSaclPresent, pSacl, bSaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTokenInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetTokenInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength)
     * }
     */
    public static FunctionDescriptor SetTokenInformation$descriptor() {
        return SetTokenInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength)
     * }
     */
    public static MethodHandle SetTokenInformation$handle() {
        return SetTokenInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength)
     * }
     */
    public static MemorySegment SetTokenInformation$address() {
        return SetTokenInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength)
     * }
     */
    public static int SetTokenInformation(MemorySegment TokenHandle, int TokenInformationClass, MemorySegment TokenInformation, int TokenInformationLength) {
        var mh$ = SetTokenInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTokenInformation", TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength);
            }
            return (int)mh$.invokeExact(TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCachedSigningLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetCachedSigningLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile)
     * }
     */
    public static FunctionDescriptor SetCachedSigningLevel$descriptor() {
        return SetCachedSigningLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile)
     * }
     */
    public static MethodHandle SetCachedSigningLevel$handle() {
        return SetCachedSigningLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile)
     * }
     */
    public static MemorySegment SetCachedSigningLevel$address() {
        return SetCachedSigningLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile)
     * }
     */
    public static int SetCachedSigningLevel(MemorySegment SourceFiles, int SourceFileCount, int Flags, MemorySegment TargetFile) {
        var mh$ = SetCachedSigningLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCachedSigningLevel", SourceFiles, SourceFileCount, Flags, TargetFile);
            }
            return (int)mh$.invokeExact(SourceFiles, SourceFileCount, Flags, TargetFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCachedSigningLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetCachedSigningLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm)
     * }
     */
    public static FunctionDescriptor GetCachedSigningLevel$descriptor() {
        return GetCachedSigningLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm)
     * }
     */
    public static MethodHandle GetCachedSigningLevel$handle() {
        return GetCachedSigningLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm)
     * }
     */
    public static MemorySegment GetCachedSigningLevel$address() {
        return GetCachedSigningLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm)
     * }
     */
    public static int GetCachedSigningLevel(MemorySegment File, MemorySegment Flags, MemorySegment SigningLevel, MemorySegment Thumbprint, MemorySegment ThumbprintSize, MemorySegment ThumbprintAlgorithm) {
        var mh$ = GetCachedSigningLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCachedSigningLevel", File, Flags, SigningLevel, Thumbprint, ThumbprintSize, ThumbprintAlgorithm);
            }
            return (int)mh$.invokeExact(File, Flags, SigningLevel, Thumbprint, ThumbprintSize, ThumbprintAlgorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CveEventWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CveEventWrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails)
     * }
     */
    public static FunctionDescriptor CveEventWrite$descriptor() {
        return CveEventWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails)
     * }
     */
    public static MethodHandle CveEventWrite$handle() {
        return CveEventWrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails)
     * }
     */
    public static MemorySegment CveEventWrite$address() {
        return CveEventWrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails)
     * }
     */
    public static int CveEventWrite(MemorySegment CveId, MemorySegment AdditionalDetails) {
        var mh$ = CveEventWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CveEventWrite", CveId, AdditionalDetails);
            }
            return (int)mh$.invokeExact(CveId, AdditionalDetails);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeriveCapabilitySidsFromName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeriveCapabilitySidsFromName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeriveCapabilitySidsFromName(LPCWSTR CapName, PSID **CapabilityGroupSids, DWORD *CapabilityGroupSidCount, PSID **CapabilitySids, DWORD *CapabilitySidCount)
     * }
     */
    public static FunctionDescriptor DeriveCapabilitySidsFromName$descriptor() {
        return DeriveCapabilitySidsFromName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeriveCapabilitySidsFromName(LPCWSTR CapName, PSID **CapabilityGroupSids, DWORD *CapabilityGroupSidCount, PSID **CapabilitySids, DWORD *CapabilitySidCount)
     * }
     */
    public static MethodHandle DeriveCapabilitySidsFromName$handle() {
        return DeriveCapabilitySidsFromName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeriveCapabilitySidsFromName(LPCWSTR CapName, PSID **CapabilityGroupSids, DWORD *CapabilityGroupSidCount, PSID **CapabilitySids, DWORD *CapabilitySidCount)
     * }
     */
    public static MemorySegment DeriveCapabilitySidsFromName$address() {
        return DeriveCapabilitySidsFromName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeriveCapabilitySidsFromName(LPCWSTR CapName, PSID **CapabilityGroupSids, DWORD *CapabilityGroupSidCount, PSID **CapabilitySids, DWORD *CapabilitySidCount)
     * }
     */
    public static int DeriveCapabilitySidsFromName(MemorySegment CapName, MemorySegment CapabilityGroupSids, MemorySegment CapabilityGroupSidCount, MemorySegment CapabilitySids, MemorySegment CapabilitySidCount) {
        var mh$ = DeriveCapabilitySidsFromName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeriveCapabilitySidsFromName", CapName, CapabilityGroupSids, CapabilityGroupSidCount, CapabilitySids, CapabilitySidCount);
            }
            return (int)mh$.invokeExact(CapName, CapabilityGroupSids, CapabilityGroupSidCount, CapabilitySids, CapabilitySidCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateNamespaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreatePrivateNamespaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor CreatePrivateNamespaceW$descriptor() {
        return CreatePrivateNamespaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle CreatePrivateNamespaceW$handle() {
        return CreatePrivateNamespaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment CreatePrivateNamespaceW$address() {
        return CreatePrivateNamespaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment CreatePrivateNamespaceW(MemorySegment lpPrivateNamespaceAttributes, MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = CreatePrivateNamespaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateNamespaceW", lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenPrivateNamespaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("OpenPrivateNamespaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor OpenPrivateNamespaceW$descriptor() {
        return OpenPrivateNamespaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle OpenPrivateNamespaceW$handle() {
        return OpenPrivateNamespaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment OpenPrivateNamespaceW$address() {
        return OpenPrivateNamespaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment OpenPrivateNamespaceW(MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = OpenPrivateNamespaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenPrivateNamespaceW", lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClosePrivateNamespace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_CHAR,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("ClosePrivateNamespace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN ClosePrivateNamespace(HANDLE Handle, ULONG Flags)
     * }
     */
    public static FunctionDescriptor ClosePrivateNamespace$descriptor() {
        return ClosePrivateNamespace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN ClosePrivateNamespace(HANDLE Handle, ULONG Flags)
     * }
     */
    public static MethodHandle ClosePrivateNamespace$handle() {
        return ClosePrivateNamespace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN ClosePrivateNamespace(HANDLE Handle, ULONG Flags)
     * }
     */
    public static MemorySegment ClosePrivateNamespace$address() {
        return ClosePrivateNamespace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN ClosePrivateNamespace(HANDLE Handle, ULONG Flags)
     * }
     */
    public static byte ClosePrivateNamespace(MemorySegment Handle, int Flags) {
        var mh$ = ClosePrivateNamespace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClosePrivateNamespace", Handle, Flags);
            }
            return (byte)mh$.invokeExact(Handle, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBoundaryDescriptorW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("CreateBoundaryDescriptorW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateBoundaryDescriptorW$descriptor() {
        return CreateBoundaryDescriptorW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
     * }
     */
    public static MethodHandle CreateBoundaryDescriptorW$handle() {
        return CreateBoundaryDescriptorW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
     * }
     */
    public static MemorySegment CreateBoundaryDescriptorW$address() {
        return CreateBoundaryDescriptorW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
     * }
     */
    public static MemorySegment CreateBoundaryDescriptorW(MemorySegment Name, int Flags) {
        var mh$ = CreateBoundaryDescriptorW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBoundaryDescriptorW", Name, Flags);
            }
            return (MemorySegment)mh$.invokeExact(Name, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddSIDToBoundaryDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("AddSIDToBoundaryDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
     * }
     */
    public static FunctionDescriptor AddSIDToBoundaryDescriptor$descriptor() {
        return AddSIDToBoundaryDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
     * }
     */
    public static MethodHandle AddSIDToBoundaryDescriptor$handle() {
        return AddSIDToBoundaryDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
     * }
     */
    public static MemorySegment AddSIDToBoundaryDescriptor$address() {
        return AddSIDToBoundaryDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
     * }
     */
    public static int AddSIDToBoundaryDescriptor(MemorySegment BoundaryDescriptor, MemorySegment RequiredSid) {
        var mh$ = AddSIDToBoundaryDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddSIDToBoundaryDescriptor", BoundaryDescriptor, RequiredSid);
            }
            return (int)mh$.invokeExact(BoundaryDescriptor, RequiredSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteBoundaryDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("DeleteBoundaryDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor)
     * }
     */
    public static FunctionDescriptor DeleteBoundaryDescriptor$descriptor() {
        return DeleteBoundaryDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor)
     * }
     */
    public static MethodHandle DeleteBoundaryDescriptor$handle() {
        return DeleteBoundaryDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor)
     * }
     */
    public static MemorySegment DeleteBoundaryDescriptor$address() {
        return DeleteBoundaryDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor)
     * }
     */
    public static void DeleteBoundaryDescriptor(MemorySegment BoundaryDescriptor) {
        var mh$ = DeleteBoundaryDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteBoundaryDescriptor", BoundaryDescriptor);
            }
            mh$.invokeExact(BoundaryDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaHighestNodeNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNumaHighestNodeNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaHighestNodeNumber$descriptor() {
        return GetNumaHighestNodeNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
     * }
     */
    public static MethodHandle GetNumaHighestNodeNumber$handle() {
        return GetNumaHighestNodeNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
     * }
     */
    public static MemorySegment GetNumaHighestNodeNumber$address() {
        return GetNumaHighestNodeNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
     * }
     */
    public static int GetNumaHighestNodeNumber(MemorySegment HighestNodeNumber) {
        var mh$ = GetNumaHighestNodeNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaHighestNodeNumber", HighestNodeNumber);
            }
            return (int)mh$.invokeExact(HighestNodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeProcessorMaskEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNumaNodeProcessorMaskEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
     * }
     */
    public static FunctionDescriptor GetNumaNodeProcessorMaskEx$descriptor() {
        return GetNumaNodeProcessorMaskEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
     * }
     */
    public static MethodHandle GetNumaNodeProcessorMaskEx$handle() {
        return GetNumaNodeProcessorMaskEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
     * }
     */
    public static MemorySegment GetNumaNodeProcessorMaskEx$address() {
        return GetNumaNodeProcessorMaskEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
     * }
     */
    public static int GetNumaNodeProcessorMaskEx(short Node, MemorySegment ProcessorMask) {
        var mh$ = GetNumaNodeProcessorMaskEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeProcessorMaskEx", Node, ProcessorMask);
            }
            return (int)mh$.invokeExact(Node, ProcessorMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProximityNodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_LONG,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetNumaProximityNodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProximityNodeEx$descriptor() {
        return GetNumaProximityNodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProximityNodeEx$handle() {
        return GetNumaProximityNodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber)
     * }
     */
    public static MemorySegment GetNumaProximityNodeEx$address() {
        return GetNumaProximityNodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber)
     * }
     */
    public static int GetNumaProximityNodeEx(int ProximityId, MemorySegment NodeNumber) {
        var mh$ = GetNumaProximityNodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProximityNodeEx", ProximityId, NodeNumber);
            }
            return (int)mh$.invokeExact(ProximityId, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessGroupAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetProcessGroupAffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray)
     * }
     */
    public static FunctionDescriptor GetProcessGroupAffinity$descriptor() {
        return GetProcessGroupAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray)
     * }
     */
    public static MethodHandle GetProcessGroupAffinity$handle() {
        return GetProcessGroupAffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray)
     * }
     */
    public static MemorySegment GetProcessGroupAffinity$address() {
        return GetProcessGroupAffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray)
     * }
     */
    public static int GetProcessGroupAffinity(MemorySegment hProcess, MemorySegment GroupCount, MemorySegment GroupArray) {
        var mh$ = GetProcessGroupAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessGroupAffinity", hProcess, GroupCount, GroupArray);
            }
            return (int)mh$.invokeExact(hProcess, GroupCount, GroupArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadGroupAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetThreadGroupAffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity)
     * }
     */
    public static FunctionDescriptor GetThreadGroupAffinity$descriptor() {
        return GetThreadGroupAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity)
     * }
     */
    public static MethodHandle GetThreadGroupAffinity$handle() {
        return GetThreadGroupAffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity)
     * }
     */
    public static MemorySegment GetThreadGroupAffinity$address() {
        return GetThreadGroupAffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity)
     * }
     */
    public static int GetThreadGroupAffinity(MemorySegment hThread, MemorySegment GroupAffinity) {
        var mh$ = GetThreadGroupAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadGroupAffinity", hThread, GroupAffinity);
            }
            return (int)mh$.invokeExact(hThread, GroupAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadGroupAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("SetThreadGroupAffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity)
     * }
     */
    public static FunctionDescriptor SetThreadGroupAffinity$descriptor() {
        return SetThreadGroupAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity)
     * }
     */
    public static MethodHandle SetThreadGroupAffinity$handle() {
        return SetThreadGroupAffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity)
     * }
     */
    public static MemorySegment SetThreadGroupAffinity$address() {
        return SetThreadGroupAffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity)
     * }
     */
    public static int SetThreadGroupAffinity(MemorySegment hThread, MemorySegment GroupAffinity, MemorySegment PreviousGroupAffinity) {
        var mh$ = SetThreadGroupAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadGroupAffinity", hThread, GroupAffinity, PreviousGroupAffinity);
            }
            return (int)mh$.invokeExact(hThread, GroupAffinity, PreviousGroupAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAppContainerNamedObjectPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER,
            wgl_h.C_LONG,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("GetAppContainerNamedObjectPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength)
     * }
     */
    public static FunctionDescriptor GetAppContainerNamedObjectPath$descriptor() {
        return GetAppContainerNamedObjectPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength)
     * }
     */
    public static MethodHandle GetAppContainerNamedObjectPath$handle() {
        return GetAppContainerNamedObjectPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength)
     * }
     */
    public static MemorySegment GetAppContainerNamedObjectPath$address() {
        return GetAppContainerNamedObjectPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength)
     * }
     */
    public static int GetAppContainerNamedObjectPath(MemorySegment Token, MemorySegment AppContainerSid, int ObjectPathLength, MemorySegment ObjectPath, MemorySegment ReturnLength) {
        var mh$ = GetAppContainerNamedObjectPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAppContainerNamedObjectPath", Token, AppContainerSid, ObjectPathLength, ObjectPath, ReturnLength);
            }
            return (int)mh$.invokeExact(Token, AppContainerSid, ObjectPathLength, ObjectPath, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryThreadCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryThreadCycleTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime)
     * }
     */
    public static FunctionDescriptor QueryThreadCycleTime$descriptor() {
        return QueryThreadCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime)
     * }
     */
    public static MethodHandle QueryThreadCycleTime$handle() {
        return QueryThreadCycleTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime)
     * }
     */
    public static MemorySegment QueryThreadCycleTime$address() {
        return QueryThreadCycleTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime)
     * }
     */
    public static int QueryThreadCycleTime(MemorySegment ThreadHandle, MemorySegment CycleTime) {
        var mh$ = QueryThreadCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryThreadCycleTime", ThreadHandle, CycleTime);
            }
            return (int)mh$.invokeExact(ThreadHandle, CycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryProcessCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryProcessCycleTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime)
     * }
     */
    public static FunctionDescriptor QueryProcessCycleTime$descriptor() {
        return QueryProcessCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime)
     * }
     */
    public static MethodHandle QueryProcessCycleTime$handle() {
        return QueryProcessCycleTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime)
     * }
     */
    public static MemorySegment QueryProcessCycleTime$address() {
        return QueryProcessCycleTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime)
     * }
     */
    public static int QueryProcessCycleTime(MemorySegment ProcessHandle, MemorySegment CycleTime) {
        var mh$ = QueryProcessCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryProcessCycleTime", ProcessHandle, CycleTime);
            }
            return (int)mh$.invokeExact(ProcessHandle, CycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryIdleProcessorCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryIdleProcessorCycleTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static FunctionDescriptor QueryIdleProcessorCycleTime$descriptor() {
        return QueryIdleProcessorCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static MethodHandle QueryIdleProcessorCycleTime$handle() {
        return QueryIdleProcessorCycleTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static MemorySegment QueryIdleProcessorCycleTime$address() {
        return QueryIdleProcessorCycleTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static int QueryIdleProcessorCycleTime(MemorySegment BufferLength, MemorySegment ProcessorIdleCycleTime) {
        var mh$ = QueryIdleProcessorCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryIdleProcessorCycleTime", BufferLength, ProcessorIdleCycleTime);
            }
            return (int)mh$.invokeExact(BufferLength, ProcessorIdleCycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryIdleProcessorCycleTimeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_SHORT,
            wgl_h.C_POINTER,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryIdleProcessorCycleTimeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static FunctionDescriptor QueryIdleProcessorCycleTimeEx$descriptor() {
        return QueryIdleProcessorCycleTimeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static MethodHandle QueryIdleProcessorCycleTimeEx$handle() {
        return QueryIdleProcessorCycleTimeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static MemorySegment QueryIdleProcessorCycleTimeEx$address() {
        return QueryIdleProcessorCycleTimeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static int QueryIdleProcessorCycleTimeEx(short Group, MemorySegment BufferLength, MemorySegment ProcessorIdleCycleTime) {
        var mh$ = QueryIdleProcessorCycleTimeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryIdleProcessorCycleTimeEx", Group, BufferLength, ProcessorIdleCycleTime);
            }
            return (int)mh$.invokeExact(Group, BufferLength, ProcessorIdleCycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryInterruptTimePrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryInterruptTimePrecise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
     * }
     */
    public static FunctionDescriptor QueryInterruptTimePrecise$descriptor() {
        return QueryInterruptTimePrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
     * }
     */
    public static MethodHandle QueryInterruptTimePrecise$handle() {
        return QueryInterruptTimePrecise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
     * }
     */
    public static MemorySegment QueryInterruptTimePrecise$address() {
        return QueryInterruptTimePrecise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
     * }
     */
    public static void QueryInterruptTimePrecise(MemorySegment lpInterruptTimePrecise) {
        var mh$ = QueryInterruptTimePrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryInterruptTimePrecise", lpInterruptTimePrecise);
            }
            mh$.invokeExact(lpInterruptTimePrecise);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryUnbiasedInterruptTimePrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryUnbiasedInterruptTimePrecise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
     * }
     */
    public static FunctionDescriptor QueryUnbiasedInterruptTimePrecise$descriptor() {
        return QueryUnbiasedInterruptTimePrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
     * }
     */
    public static MethodHandle QueryUnbiasedInterruptTimePrecise$handle() {
        return QueryUnbiasedInterruptTimePrecise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
     * }
     */
    public static MemorySegment QueryUnbiasedInterruptTimePrecise$address() {
        return QueryUnbiasedInterruptTimePrecise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
     * }
     */
    public static void QueryUnbiasedInterruptTimePrecise(MemorySegment lpUnbiasedInterruptTimePrecise) {
        var mh$ = QueryUnbiasedInterruptTimePrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryUnbiasedInterruptTimePrecise", lpUnbiasedInterruptTimePrecise);
            }
            mh$.invokeExact(lpUnbiasedInterruptTimePrecise);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryInterruptTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryInterruptTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QueryInterruptTime(PULONGLONG lpInterruptTime)
     * }
     */
    public static FunctionDescriptor QueryInterruptTime$descriptor() {
        return QueryInterruptTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QueryInterruptTime(PULONGLONG lpInterruptTime)
     * }
     */
    public static MethodHandle QueryInterruptTime$handle() {
        return QueryInterruptTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void QueryInterruptTime(PULONGLONG lpInterruptTime)
     * }
     */
    public static MemorySegment QueryInterruptTime$address() {
        return QueryInterruptTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void QueryInterruptTime(PULONGLONG lpInterruptTime)
     * }
     */
    public static void QueryInterruptTime(MemorySegment lpInterruptTime) {
        var mh$ = QueryInterruptTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryInterruptTime", lpInterruptTime);
            }
            mh$.invokeExact(lpInterruptTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryUnbiasedInterruptTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            wgl_h.C_INT,
            wgl_h.C_POINTER
        );

        public static final MemorySegment ADDR = wgl_h.findOrThrow("QueryUnbiasedInterruptTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
     * }
     */
    public static FunctionDescriptor QueryUnbiasedInterruptTime$descriptor() {
        return QueryUnbiasedInterruptTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
     * }
     */
    public static MethodHandle QueryUnbiasedInterruptTime$handle() {
        return QueryUnbiasedInterruptTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
     * }
     */
    public static MemorySegment QueryUnbiasedInterruptTime$address() {
        return QueryUnbiasedInterruptTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
     * }
     */
    public static int QueryUnbiasedInterruptTime(MemorySegment UnbiasedTime) {
        var mh$ = QueryUnbiasedInterruptTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryUnbiasedInterruptTime", UnbiasedTime);
            }
            return (int)mh$.invokeExact(UnbiasedTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

