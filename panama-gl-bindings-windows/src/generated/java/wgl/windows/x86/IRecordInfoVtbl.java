// Generated by jextract

package wgl.windows.x86;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class IRecordInfoVtbl {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("QueryInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("AddRef"),
        Constants$root.C_POINTER$LAYOUT.withName("Release"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordInit"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordClear"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordCopy"),
        Constants$root.C_POINTER$LAYOUT.withName("GetGuid"),
        Constants$root.C_POINTER$LAYOUT.withName("GetName"),
        Constants$root.C_POINTER$LAYOUT.withName("GetSize"),
        Constants$root.C_POINTER$LAYOUT.withName("GetTypeInfo"),
        Constants$root.C_POINTER$LAYOUT.withName("GetField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetFieldNoCopy"),
        Constants$root.C_POINTER$LAYOUT.withName("PutField"),
        Constants$root.C_POINTER$LAYOUT.withName("PutFieldNoCopy"),
        Constants$root.C_POINTER$LAYOUT.withName("GetFieldNames"),
        Constants$root.C_POINTER$LAYOUT.withName("IsMatchingType"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordCreate"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordCreateCopy"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordDestroy")
    ).withName("IRecordInfoVtbl");
    public static MemoryLayout $LAYOUT() {
        return IRecordInfoVtbl.$struct$LAYOUT;
    }
    static final FunctionDescriptor QueryInterface$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.QueryInterface$FUNC
    );
    public interface QueryInterface {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(QueryInterface fi, MemorySession session) {
            return RuntimeHelper.upcallStub(QueryInterface.class, fi, IRecordInfoVtbl.QueryInterface$FUNC, session);
        }
        static QueryInterface ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IRecordInfoVtbl.QueryInterface$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle QueryInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("QueryInterface"));
    public static VarHandle QueryInterface$VH() {
        return IRecordInfoVtbl.QueryInterface$VH;
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.QueryInterface$VH.get(seg);
    }
    public static void QueryInterface$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.QueryInterface$VH.set(seg, x);
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.QueryInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void QueryInterface$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.QueryInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static QueryInterface QueryInterface (MemorySegment segment, MemorySession session) {
        return QueryInterface.ofAddress(QueryInterface$get(segment), session);
    }
    static final FunctionDescriptor AddRef$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.AddRef$FUNC
    );
    public interface AddRef {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(AddRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AddRef.class, fi, IRecordInfoVtbl.AddRef$FUNC, session);
        }
        static AddRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IRecordInfoVtbl.AddRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AddRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AddRef"));
    public static VarHandle AddRef$VH() {
        return IRecordInfoVtbl.AddRef$VH;
    }
    public static MemoryAddress AddRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.AddRef$VH.get(seg);
    }
    public static void AddRef$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.AddRef$VH.set(seg, x);
    }
    public static MemoryAddress AddRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.AddRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AddRef$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.AddRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AddRef AddRef (MemorySegment segment, MemorySession session) {
        return AddRef.ofAddress(AddRef$get(segment), session);
    }
    static final FunctionDescriptor Release$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.Release$FUNC
    );
    public interface Release {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(Release fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Release.class, fi, IRecordInfoVtbl.Release$FUNC, session);
        }
        static Release ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IRecordInfoVtbl.Release$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Release"));
    public static VarHandle Release$VH() {
        return IRecordInfoVtbl.Release$VH;
    }
    public static MemoryAddress Release$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.Release$VH.get(seg);
    }
    public static void Release$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.Release$VH.set(seg, x);
    }
    public static MemoryAddress Release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.Release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Release$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.Release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Release Release (MemorySegment segment, MemorySession session) {
        return Release.ofAddress(Release$get(segment), session);
    }
    static final FunctionDescriptor RecordInit$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordInit$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordInit$FUNC
    );
    public interface RecordInit {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(RecordInit fi, MemorySession session) {
            return RuntimeHelper.upcallStub(RecordInit.class, fi, IRecordInfoVtbl.RecordInit$FUNC, session);
        }
        static RecordInit ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordInit$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordInit$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordInit"));
    public static VarHandle RecordInit$VH() {
        return IRecordInfoVtbl.RecordInit$VH;
    }
    public static MemoryAddress RecordInit$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordInit$VH.get(seg);
    }
    public static void RecordInit$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordInit$VH.set(seg, x);
    }
    public static MemoryAddress RecordInit$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordInit$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordInit$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordInit$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordInit RecordInit (MemorySegment segment, MemorySession session) {
        return RecordInit.ofAddress(RecordInit$get(segment), session);
    }
    static final FunctionDescriptor RecordClear$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordClear$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordClear$FUNC
    );
    public interface RecordClear {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(RecordClear fi, MemorySession session) {
            return RuntimeHelper.upcallStub(RecordClear.class, fi, IRecordInfoVtbl.RecordClear$FUNC, session);
        }
        static RecordClear ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordClear$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordClear$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordClear"));
    public static VarHandle RecordClear$VH() {
        return IRecordInfoVtbl.RecordClear$VH;
    }
    public static MemoryAddress RecordClear$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordClear$VH.get(seg);
    }
    public static void RecordClear$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordClear$VH.set(seg, x);
    }
    public static MemoryAddress RecordClear$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordClear$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordClear$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordClear$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordClear RecordClear (MemorySegment segment, MemorySession session) {
        return RecordClear.ofAddress(RecordClear$get(segment), session);
    }
    static final FunctionDescriptor RecordCopy$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordCopy$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordCopy$FUNC
    );
    public interface RecordCopy {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(RecordCopy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(RecordCopy.class, fi, IRecordInfoVtbl.RecordCopy$FUNC, session);
        }
        static RecordCopy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordCopy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordCopy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordCopy"));
    public static VarHandle RecordCopy$VH() {
        return IRecordInfoVtbl.RecordCopy$VH;
    }
    public static MemoryAddress RecordCopy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordCopy$VH.get(seg);
    }
    public static void RecordCopy$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordCopy$VH.set(seg, x);
    }
    public static MemoryAddress RecordCopy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordCopy$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordCopy RecordCopy (MemorySegment segment, MemorySession session) {
        return RecordCopy.ofAddress(RecordCopy$get(segment), session);
    }
    static final FunctionDescriptor GetGuid$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetGuid$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetGuid$FUNC
    );
    public interface GetGuid {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetGuid fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetGuid.class, fi, IRecordInfoVtbl.GetGuid$FUNC, session);
        }
        static GetGuid ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetGuid$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetGuid$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetGuid"));
    public static VarHandle GetGuid$VH() {
        return IRecordInfoVtbl.GetGuid$VH;
    }
    public static MemoryAddress GetGuid$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetGuid$VH.get(seg);
    }
    public static void GetGuid$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetGuid$VH.set(seg, x);
    }
    public static MemoryAddress GetGuid$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetGuid$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetGuid$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetGuid$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetGuid GetGuid (MemorySegment segment, MemorySession session) {
        return GetGuid.ofAddress(GetGuid$get(segment), session);
    }
    static final FunctionDescriptor GetName$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetName$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetName$FUNC
    );
    public interface GetName {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetName fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetName.class, fi, IRecordInfoVtbl.GetName$FUNC, session);
        }
        static GetName ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetName$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetName$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetName"));
    public static VarHandle GetName$VH() {
        return IRecordInfoVtbl.GetName$VH;
    }
    public static MemoryAddress GetName$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetName$VH.get(seg);
    }
    public static void GetName$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetName$VH.set(seg, x);
    }
    public static MemoryAddress GetName$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetName$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetName$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetName$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetName GetName (MemorySegment segment, MemorySession session) {
        return GetName.ofAddress(GetName$get(segment), session);
    }
    static final FunctionDescriptor GetSize$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetSize$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetSize$FUNC
    );
    public interface GetSize {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetSize fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetSize.class, fi, IRecordInfoVtbl.GetSize$FUNC, session);
        }
        static GetSize ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetSize$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetSize$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetSize"));
    public static VarHandle GetSize$VH() {
        return IRecordInfoVtbl.GetSize$VH;
    }
    public static MemoryAddress GetSize$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetSize$VH.get(seg);
    }
    public static void GetSize$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetSize$VH.set(seg, x);
    }
    public static MemoryAddress GetSize$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetSize$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetSize$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetSize$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetSize GetSize (MemorySegment segment, MemorySession session) {
        return GetSize.ofAddress(GetSize$get(segment), session);
    }
    static final FunctionDescriptor GetTypeInfo$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetTypeInfo$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetTypeInfo$FUNC
    );
    public interface GetTypeInfo {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetTypeInfo fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetTypeInfo.class, fi, IRecordInfoVtbl.GetTypeInfo$FUNC, session);
        }
        static GetTypeInfo ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetTypeInfo$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetTypeInfo$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetTypeInfo"));
    public static VarHandle GetTypeInfo$VH() {
        return IRecordInfoVtbl.GetTypeInfo$VH;
    }
    public static MemoryAddress GetTypeInfo$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetTypeInfo$VH.get(seg);
    }
    public static void GetTypeInfo$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetTypeInfo$VH.set(seg, x);
    }
    public static MemoryAddress GetTypeInfo$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetTypeInfo$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetTypeInfo$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetTypeInfo$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetTypeInfo GetTypeInfo (MemorySegment segment, MemorySession session) {
        return GetTypeInfo.ofAddress(GetTypeInfo$get(segment), session);
    }
    static final FunctionDescriptor GetField$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetField$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetField$FUNC
    );
    public interface GetField {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(GetField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetField.class, fi, IRecordInfoVtbl.GetField$FUNC, session);
        }
        static GetField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)IRecordInfoVtbl.GetField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetField"));
    public static VarHandle GetField$VH() {
        return IRecordInfoVtbl.GetField$VH;
    }
    public static MemoryAddress GetField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetField$VH.get(seg);
    }
    public static void GetField$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetField$VH.set(seg, x);
    }
    public static MemoryAddress GetField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetField$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetField GetField (MemorySegment segment, MemorySession session) {
        return GetField.ofAddress(GetField$get(segment), session);
    }
    static final FunctionDescriptor GetFieldNoCopy$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFieldNoCopy$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetFieldNoCopy$FUNC
    );
    public interface GetFieldNoCopy {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(GetFieldNoCopy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetFieldNoCopy.class, fi, IRecordInfoVtbl.GetFieldNoCopy$FUNC, session);
        }
        static GetFieldNoCopy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)IRecordInfoVtbl.GetFieldNoCopy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFieldNoCopy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetFieldNoCopy"));
    public static VarHandle GetFieldNoCopy$VH() {
        return IRecordInfoVtbl.GetFieldNoCopy$VH;
    }
    public static MemoryAddress GetFieldNoCopy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetFieldNoCopy$VH.get(seg);
    }
    public static void GetFieldNoCopy$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetFieldNoCopy$VH.set(seg, x);
    }
    public static MemoryAddress GetFieldNoCopy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetFieldNoCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFieldNoCopy$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetFieldNoCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFieldNoCopy GetFieldNoCopy (MemorySegment segment, MemorySession session) {
        return GetFieldNoCopy.ofAddress(GetFieldNoCopy$get(segment), session);
    }
    static final FunctionDescriptor PutField$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle PutField$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.PutField$FUNC
    );
    public interface PutField {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(PutField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(PutField.class, fi, IRecordInfoVtbl.PutField$FUNC, session);
        }
        static PutField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)IRecordInfoVtbl.PutField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle PutField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("PutField"));
    public static VarHandle PutField$VH() {
        return IRecordInfoVtbl.PutField$VH;
    }
    public static MemoryAddress PutField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.PutField$VH.get(seg);
    }
    public static void PutField$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.PutField$VH.set(seg, x);
    }
    public static MemoryAddress PutField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.PutField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void PutField$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.PutField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static PutField PutField (MemorySegment segment, MemorySession session) {
        return PutField.ofAddress(PutField$get(segment), session);
    }
    static final FunctionDescriptor PutFieldNoCopy$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle PutFieldNoCopy$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.PutFieldNoCopy$FUNC
    );
    public interface PutFieldNoCopy {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(PutFieldNoCopy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(PutFieldNoCopy.class, fi, IRecordInfoVtbl.PutFieldNoCopy$FUNC, session);
        }
        static PutFieldNoCopy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)IRecordInfoVtbl.PutFieldNoCopy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle PutFieldNoCopy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("PutFieldNoCopy"));
    public static VarHandle PutFieldNoCopy$VH() {
        return IRecordInfoVtbl.PutFieldNoCopy$VH;
    }
    public static MemoryAddress PutFieldNoCopy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.PutFieldNoCopy$VH.get(seg);
    }
    public static void PutFieldNoCopy$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.PutFieldNoCopy$VH.set(seg, x);
    }
    public static MemoryAddress PutFieldNoCopy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.PutFieldNoCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void PutFieldNoCopy$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.PutFieldNoCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static PutFieldNoCopy PutFieldNoCopy (MemorySegment segment, MemorySession session) {
        return PutFieldNoCopy.ofAddress(PutFieldNoCopy$get(segment), session);
    }
    static final FunctionDescriptor GetFieldNames$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFieldNames$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetFieldNames$FUNC
    );
    public interface GetFieldNames {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetFieldNames fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetFieldNames.class, fi, IRecordInfoVtbl.GetFieldNames$FUNC, session);
        }
        static GetFieldNames ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IRecordInfoVtbl.GetFieldNames$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFieldNames$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetFieldNames"));
    public static VarHandle GetFieldNames$VH() {
        return IRecordInfoVtbl.GetFieldNames$VH;
    }
    public static MemoryAddress GetFieldNames$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetFieldNames$VH.get(seg);
    }
    public static void GetFieldNames$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetFieldNames$VH.set(seg, x);
    }
    public static MemoryAddress GetFieldNames$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.GetFieldNames$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFieldNames$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetFieldNames$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFieldNames GetFieldNames (MemorySegment segment, MemorySession session) {
        return GetFieldNames.ofAddress(GetFieldNames$get(segment), session);
    }
    static final FunctionDescriptor IsMatchingType$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle IsMatchingType$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.IsMatchingType$FUNC
    );
    public interface IsMatchingType {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(IsMatchingType fi, MemorySession session) {
            return RuntimeHelper.upcallStub(IsMatchingType.class, fi, IRecordInfoVtbl.IsMatchingType$FUNC, session);
        }
        static IsMatchingType ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.IsMatchingType$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle IsMatchingType$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("IsMatchingType"));
    public static VarHandle IsMatchingType$VH() {
        return IRecordInfoVtbl.IsMatchingType$VH;
    }
    public static MemoryAddress IsMatchingType$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.IsMatchingType$VH.get(seg);
    }
    public static void IsMatchingType$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.IsMatchingType$VH.set(seg, x);
    }
    public static MemoryAddress IsMatchingType$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.IsMatchingType$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IsMatchingType$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.IsMatchingType$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static IsMatchingType IsMatchingType (MemorySegment segment, MemorySession session) {
        return IsMatchingType.ofAddress(IsMatchingType$get(segment), session);
    }
    static final FunctionDescriptor RecordCreate$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordCreate$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordCreate$FUNC
    );
    public interface RecordCreate {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(RecordCreate fi, MemorySession session) {
            return RuntimeHelper.upcallStub(RecordCreate.class, fi, IRecordInfoVtbl.RecordCreate$FUNC, session);
        }
        static RecordCreate ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordCreate$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordCreate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordCreate"));
    public static VarHandle RecordCreate$VH() {
        return IRecordInfoVtbl.RecordCreate$VH;
    }
    public static MemoryAddress RecordCreate$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordCreate$VH.get(seg);
    }
    public static void RecordCreate$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordCreate$VH.set(seg, x);
    }
    public static MemoryAddress RecordCreate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordCreate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordCreate$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordCreate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordCreate RecordCreate (MemorySegment segment, MemorySession session) {
        return RecordCreate.ofAddress(RecordCreate$get(segment), session);
    }
    static final FunctionDescriptor RecordCreateCopy$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordCreateCopy$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordCreateCopy$FUNC
    );
    public interface RecordCreateCopy {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(RecordCreateCopy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(RecordCreateCopy.class, fi, IRecordInfoVtbl.RecordCreateCopy$FUNC, session);
        }
        static RecordCreateCopy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordCreateCopy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordCreateCopy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordCreateCopy"));
    public static VarHandle RecordCreateCopy$VH() {
        return IRecordInfoVtbl.RecordCreateCopy$VH;
    }
    public static MemoryAddress RecordCreateCopy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordCreateCopy$VH.get(seg);
    }
    public static void RecordCreateCopy$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordCreateCopy$VH.set(seg, x);
    }
    public static MemoryAddress RecordCreateCopy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordCreateCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordCreateCopy$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordCreateCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordCreateCopy RecordCreateCopy (MemorySegment segment, MemorySession session) {
        return RecordCreateCopy.ofAddress(RecordCreateCopy$get(segment), session);
    }
    static final FunctionDescriptor RecordDestroy$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordDestroy$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordDestroy$FUNC
    );
    public interface RecordDestroy {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(RecordDestroy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(RecordDestroy.class, fi, IRecordInfoVtbl.RecordDestroy$FUNC, session);
        }
        static RecordDestroy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordDestroy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordDestroy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordDestroy"));
    public static VarHandle RecordDestroy$VH() {
        return IRecordInfoVtbl.RecordDestroy$VH;
    }
    public static MemoryAddress RecordDestroy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordDestroy$VH.get(seg);
    }
    public static void RecordDestroy$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordDestroy$VH.set(seg, x);
    }
    public static MemoryAddress RecordDestroy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IRecordInfoVtbl.RecordDestroy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordDestroy$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordDestroy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordDestroy RecordDestroy (MemorySegment segment, MemorySession session) {
        return RecordDestroy.ofAddress(RecordDestroy$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


