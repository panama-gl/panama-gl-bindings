// Generated by jextract

package wglext.windows.x86;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
 class wglext_h_20 extends wglext_h_19 {

    public static OfAddress LPSHELLEXECUTEINFOW = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPSHELLEXECUTEINFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle ShellExecuteExA$MH() {
        return RuntimeHelper.requireNonNull(constants$714.ShellExecuteExA$MH,"ShellExecuteExA");
    }
    public static int ShellExecuteExA ( Addressable pExecInfo) {
        var mh$ = ShellExecuteExA$MH();
        try {
            return (int)mh$.invokeExact(pExecInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle ShellExecuteExW$MH() {
        return RuntimeHelper.requireNonNull(constants$714.ShellExecuteExW$MH,"ShellExecuteExW");
    }
    public static int ShellExecuteExW ( Addressable pExecInfo) {
        var mh$ = ShellExecuteExW$MH();
        try {
            return (int)mh$.invokeExact(pExecInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PSHCREATEPROCESSINFOW = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle SHCreateProcessAsUserW$MH() {
        return RuntimeHelper.requireNonNull(constants$714.SHCreateProcessAsUserW$MH,"SHCreateProcessAsUserW");
    }
    public static int SHCreateProcessAsUserW ( Addressable pscpi) {
        var mh$ = SHCreateProcessAsUserW$MH();
        try {
            return (int)mh$.invokeExact(pscpi);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHEvaluateSystemCommandTemplate$MH() {
        return RuntimeHelper.requireNonNull(constants$714.SHEvaluateSystemCommandTemplate$MH,"SHEvaluateSystemCommandTemplate");
    }
    public static int SHEvaluateSystemCommandTemplate ( Addressable pszCmdTemplate,  Addressable ppszApplication,  Addressable ppszCommandLine,  Addressable ppszParameters) {
        var mh$ = SHEvaluateSystemCommandTemplate$MH();
        try {
            return (int)mh$.invokeExact(pszCmdTemplate, ppszApplication, ppszCommandLine, ppszParameters);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static int ASSOCCLASS_SHELL_KEY() {
        return (int)0L;
    }
    public static int ASSOCCLASS_PROGID_KEY() {
        return (int)1L;
    }
    public static int ASSOCCLASS_PROGID_STR() {
        return (int)2L;
    }
    public static int ASSOCCLASS_CLSID_KEY() {
        return (int)3L;
    }
    public static int ASSOCCLASS_CLSID_STR() {
        return (int)4L;
    }
    public static int ASSOCCLASS_APP_KEY() {
        return (int)5L;
    }
    public static int ASSOCCLASS_APP_STR() {
        return (int)6L;
    }
    public static int ASSOCCLASS_SYSTEM_STR() {
        return (int)7L;
    }
    public static int ASSOCCLASS_FOLDER() {
        return (int)8L;
    }
    public static int ASSOCCLASS_STAR() {
        return (int)9L;
    }
    public static int ASSOCCLASS_FIXED_PROGID_STR() {
        return (int)10L;
    }
    public static int ASSOCCLASS_PROTOCOL_STR() {
        return (int)11L;
    }
    public static MethodHandle AssocCreateForClasses$MH() {
        return RuntimeHelper.requireNonNull(constants$714.AssocCreateForClasses$MH,"AssocCreateForClasses");
    }
    public static int AssocCreateForClasses ( Addressable rgClasses,  int cClasses,  Addressable riid,  Addressable ppv) {
        var mh$ = AssocCreateForClasses$MH();
        try {
            return (int)mh$.invokeExact(rgClasses, cClasses, riid, ppv);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress LPSHQUERYRBINFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle SHQueryRecycleBinA$MH() {
        return RuntimeHelper.requireNonNull(constants$715.SHQueryRecycleBinA$MH,"SHQueryRecycleBinA");
    }
    public static int SHQueryRecycleBinA ( Addressable pszRootPath,  Addressable pSHQueryRBInfo) {
        var mh$ = SHQueryRecycleBinA$MH();
        try {
            return (int)mh$.invokeExact(pszRootPath, pSHQueryRBInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHQueryRecycleBinW$MH() {
        return RuntimeHelper.requireNonNull(constants$715.SHQueryRecycleBinW$MH,"SHQueryRecycleBinW");
    }
    public static int SHQueryRecycleBinW ( Addressable pszRootPath,  Addressable pSHQueryRBInfo) {
        var mh$ = SHQueryRecycleBinW$MH();
        try {
            return (int)mh$.invokeExact(pszRootPath, pSHQueryRBInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHEmptyRecycleBinA$MH() {
        return RuntimeHelper.requireNonNull(constants$715.SHEmptyRecycleBinA$MH,"SHEmptyRecycleBinA");
    }
    public static int SHEmptyRecycleBinA ( Addressable hwnd,  Addressable pszRootPath,  int dwFlags) {
        var mh$ = SHEmptyRecycleBinA$MH();
        try {
            return (int)mh$.invokeExact(hwnd, pszRootPath, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHEmptyRecycleBinW$MH() {
        return RuntimeHelper.requireNonNull(constants$715.SHEmptyRecycleBinW$MH,"SHEmptyRecycleBinW");
    }
    public static int SHEmptyRecycleBinW ( Addressable hwnd,  Addressable pszRootPath,  int dwFlags) {
        var mh$ = SHEmptyRecycleBinW$MH();
        try {
            return (int)mh$.invokeExact(hwnd, pszRootPath, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static int QUNS_NOT_PRESENT() {
        return (int)1L;
    }
    public static int QUNS_BUSY() {
        return (int)2L;
    }
    public static int QUNS_RUNNING_D3D_FULL_SCREEN() {
        return (int)3L;
    }
    public static int QUNS_PRESENTATION_MODE() {
        return (int)4L;
    }
    public static int QUNS_ACCEPTS_NOTIFICATIONS() {
        return (int)5L;
    }
    public static int QUNS_QUIET_TIME() {
        return (int)6L;
    }
    public static int QUNS_APP() {
        return (int)7L;
    }
    public static MethodHandle SHQueryUserNotificationState$MH() {
        return RuntimeHelper.requireNonNull(constants$715.SHQueryUserNotificationState$MH,"SHQueryUserNotificationState");
    }
    public static int SHQueryUserNotificationState ( Addressable pquns) {
        var mh$ = SHQueryUserNotificationState$MH();
        try {
            return (int)mh$.invokeExact(pquns);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHGetPropertyStoreForWindow$MH() {
        return RuntimeHelper.requireNonNull(constants$715.SHGetPropertyStoreForWindow$MH,"SHGetPropertyStoreForWindow");
    }
    public static int SHGetPropertyStoreForWindow ( Addressable hwnd,  Addressable riid,  Addressable ppv) {
        var mh$ = SHGetPropertyStoreForWindow$MH();
        try {
            return (int)mh$.invokeExact(hwnd, riid, ppv);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PNOTIFYICONDATAA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNOTIFYICONDATAW = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNOTIFYICONDATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNOTIFYICONIDENTIFIER = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle Shell_NotifyIconA$MH() {
        return RuntimeHelper.requireNonNull(constants$716.Shell_NotifyIconA$MH,"Shell_NotifyIconA");
    }
    public static int Shell_NotifyIconA ( int dwMessage,  Addressable lpData) {
        var mh$ = Shell_NotifyIconA$MH();
        try {
            return (int)mh$.invokeExact(dwMessage, lpData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle Shell_NotifyIconW$MH() {
        return RuntimeHelper.requireNonNull(constants$716.Shell_NotifyIconW$MH,"Shell_NotifyIconW");
    }
    public static int Shell_NotifyIconW ( int dwMessage,  Addressable lpData) {
        var mh$ = Shell_NotifyIconW$MH();
        try {
            return (int)mh$.invokeExact(dwMessage, lpData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle Shell_NotifyIconGetRect$MH() {
        return RuntimeHelper.requireNonNull(constants$716.Shell_NotifyIconGetRect$MH,"Shell_NotifyIconGetRect");
    }
    public static int Shell_NotifyIconGetRect ( Addressable identifier,  Addressable iconLocation) {
        var mh$ = Shell_NotifyIconGetRect$MH();
        try {
            return (int)mh$.invokeExact(identifier, iconLocation);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHGetFileInfoA$MH() {
        return RuntimeHelper.requireNonNull(constants$716.SHGetFileInfoA$MH,"SHGetFileInfoA");
    }
    public static long SHGetFileInfoA ( Addressable pszPath,  int dwFileAttributes,  Addressable psfi,  int cbFileInfo,  int uFlags) {
        var mh$ = SHGetFileInfoA$MH();
        try {
            return (long)mh$.invokeExact(pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHGetFileInfoW$MH() {
        return RuntimeHelper.requireNonNull(constants$716.SHGetFileInfoW$MH,"SHGetFileInfoW");
    }
    public static long SHGetFileInfoW ( Addressable pszPath,  int dwFileAttributes,  Addressable psfi,  int cbFileInfo,  int uFlags) {
        var mh$ = SHGetFileInfoW$MH();
        try {
            return (long)mh$.invokeExact(pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static int SIID_DOCNOASSOC() {
        return (int)0L;
    }
    public static int SIID_DOCASSOC() {
        return (int)1L;
    }
    public static int SIID_APPLICATION() {
        return (int)2L;
    }
    public static int SIID_FOLDER() {
        return (int)3L;
    }
    public static int SIID_FOLDEROPEN() {
        return (int)4L;
    }
    public static int SIID_DRIVE525() {
        return (int)5L;
    }
    public static int SIID_DRIVE35() {
        return (int)6L;
    }
    public static int SIID_DRIVEREMOVE() {
        return (int)7L;
    }
    public static int SIID_DRIVEFIXED() {
        return (int)8L;
    }
    public static int SIID_DRIVENET() {
        return (int)9L;
    }
    public static int SIID_DRIVENETDISABLED() {
        return (int)10L;
    }
    public static int SIID_DRIVECD() {
        return (int)11L;
    }
    public static int SIID_DRIVERAM() {
        return (int)12L;
    }
    public static int SIID_WORLD() {
        return (int)13L;
    }
    public static int SIID_SERVER() {
        return (int)15L;
    }
    public static int SIID_PRINTER() {
        return (int)16L;
    }
    public static int SIID_MYNETWORK() {
        return (int)17L;
    }
    public static int SIID_FIND() {
        return (int)22L;
    }
    public static int SIID_HELP() {
        return (int)23L;
    }
    public static int SIID_SHARE() {
        return (int)28L;
    }
    public static int SIID_LINK() {
        return (int)29L;
    }
    public static int SIID_SLOWFILE() {
        return (int)30L;
    }
    public static int SIID_RECYCLER() {
        return (int)31L;
    }
    public static int SIID_RECYCLERFULL() {
        return (int)32L;
    }
    public static int SIID_MEDIACDAUDIO() {
        return (int)40L;
    }
    public static int SIID_LOCK() {
        return (int)47L;
    }
    public static int SIID_AUTOLIST() {
        return (int)49L;
    }
    public static int SIID_PRINTERNET() {
        return (int)50L;
    }
    public static int SIID_SERVERSHARE() {
        return (int)51L;
    }
    public static int SIID_PRINTERFAX() {
        return (int)52L;
    }
    public static int SIID_PRINTERFAXNET() {
        return (int)53L;
    }
    public static int SIID_PRINTERFILE() {
        return (int)54L;
    }
    public static int SIID_STACK() {
        return (int)55L;
    }
    public static int SIID_MEDIASVCD() {
        return (int)56L;
    }
    public static int SIID_STUFFEDFOLDER() {
        return (int)57L;
    }
    public static int SIID_DRIVEUNKNOWN() {
        return (int)58L;
    }
    public static int SIID_DRIVEDVD() {
        return (int)59L;
    }
    public static int SIID_MEDIADVD() {
        return (int)60L;
    }
    public static int SIID_MEDIADVDRAM() {
        return (int)61L;
    }
    public static int SIID_MEDIADVDRW() {
        return (int)62L;
    }
    public static int SIID_MEDIADVDR() {
        return (int)63L;
    }
    public static int SIID_MEDIADVDROM() {
        return (int)64L;
    }
    public static int SIID_MEDIACDAUDIOPLUS() {
        return (int)65L;
    }
    public static int SIID_MEDIACDRW() {
        return (int)66L;
    }
    public static int SIID_MEDIACDR() {
        return (int)67L;
    }
    public static int SIID_MEDIACDBURN() {
        return (int)68L;
    }
    public static int SIID_MEDIABLANKCD() {
        return (int)69L;
    }
    public static int SIID_MEDIACDROM() {
        return (int)70L;
    }
    public static int SIID_AUDIOFILES() {
        return (int)71L;
    }
    public static int SIID_IMAGEFILES() {
        return (int)72L;
    }
    public static int SIID_VIDEOFILES() {
        return (int)73L;
    }
    public static int SIID_MIXEDFILES() {
        return (int)74L;
    }
    public static int SIID_FOLDERBACK() {
        return (int)75L;
    }
    public static int SIID_FOLDERFRONT() {
        return (int)76L;
    }
    public static int SIID_SHIELD() {
        return (int)77L;
    }
    public static int SIID_WARNING() {
        return (int)78L;
    }
    public static int SIID_INFO() {
        return (int)79L;
    }
    public static int SIID_ERROR() {
        return (int)80L;
    }
    public static int SIID_KEY() {
        return (int)81L;
    }
    public static int SIID_SOFTWARE() {
        return (int)82L;
    }
    public static int SIID_RENAME() {
        return (int)83L;
    }
    public static int SIID_DELETE() {
        return (int)84L;
    }
    public static int SIID_MEDIAAUDIODVD() {
        return (int)85L;
    }
    public static int SIID_MEDIAMOVIEDVD() {
        return (int)86L;
    }
    public static int SIID_MEDIAENHANCEDCD() {
        return (int)87L;
    }
    public static int SIID_MEDIAENHANCEDDVD() {
        return (int)88L;
    }
    public static int SIID_MEDIAHDDVD() {
        return (int)89L;
    }
    public static int SIID_MEDIABLURAY() {
        return (int)90L;
    }
    public static int SIID_MEDIAVCD() {
        return (int)91L;
    }
    public static int SIID_MEDIADVDPLUSR() {
        return (int)92L;
    }
    public static int SIID_MEDIADVDPLUSRW() {
        return (int)93L;
    }
    public static int SIID_DESKTOPPC() {
        return (int)94L;
    }
    public static int SIID_MOBILEPC() {
        return (int)95L;
    }
    public static int SIID_USERS() {
        return (int)96L;
    }
    public static int SIID_MEDIASMARTMEDIA() {
        return (int)97L;
    }
    public static int SIID_MEDIACOMPACTFLASH() {
        return (int)98L;
    }
    public static int SIID_DEVICECELLPHONE() {
        return (int)99L;
    }
    public static int SIID_DEVICECAMERA() {
        return (int)100L;
    }
    public static int SIID_DEVICEVIDEOCAMERA() {
        return (int)101L;
    }
    public static int SIID_DEVICEAUDIOPLAYER() {
        return (int)102L;
    }
    public static int SIID_NETWORKCONNECT() {
        return (int)103L;
    }
    public static int SIID_INTERNET() {
        return (int)104L;
    }
    public static int SIID_ZIPFILE() {
        return (int)105L;
    }
    public static int SIID_SETTINGS() {
        return (int)106L;
    }
    public static int SIID_DRIVEHDDVD() {
        return (int)132L;
    }
    public static int SIID_DRIVEBD() {
        return (int)133L;
    }
    public static int SIID_MEDIAHDDVDROM() {
        return (int)134L;
    }
    public static int SIID_MEDIAHDDVDR() {
        return (int)135L;
    }
    public static int SIID_MEDIAHDDVDRAM() {
        return (int)136L;
    }
    public static int SIID_MEDIABDROM() {
        return (int)137L;
    }
    public static int SIID_MEDIABDR() {
        return (int)138L;
    }
    public static int SIID_MEDIABDRE() {
        return (int)139L;
    }
    public static int SIID_CLUSTEREDDRIVE() {
        return (int)140L;
    }
    public static int SIID_MAX_ICONS() {
        return (int)181L;
    }
    public static MethodHandle SHGetStockIconInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$716.SHGetStockIconInfo$MH,"SHGetStockIconInfo");
    }
    public static int SHGetStockIconInfo ( int siid,  int uFlags,  Addressable psii) {
        var mh$ = SHGetStockIconInfo$MH();
        try {
            return (int)mh$.invokeExact(siid, uFlags, psii);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHGetDiskFreeSpaceExA$MH() {
        return RuntimeHelper.requireNonNull(constants$717.SHGetDiskFreeSpaceExA$MH,"SHGetDiskFreeSpaceExA");
    }
    public static int SHGetDiskFreeSpaceExA ( Addressable pszDirectoryName,  Addressable pulFreeBytesAvailableToCaller,  Addressable pulTotalNumberOfBytes,  Addressable pulTotalNumberOfFreeBytes) {
        var mh$ = SHGetDiskFreeSpaceExA$MH();
        try {
            return (int)mh$.invokeExact(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHGetDiskFreeSpaceExW$MH() {
        return RuntimeHelper.requireNonNull(constants$717.SHGetDiskFreeSpaceExW$MH,"SHGetDiskFreeSpaceExW");
    }
    public static int SHGetDiskFreeSpaceExW ( Addressable pszDirectoryName,  Addressable pulFreeBytesAvailableToCaller,  Addressable pulTotalNumberOfBytes,  Addressable pulTotalNumberOfFreeBytes) {
        var mh$ = SHGetDiskFreeSpaceExW$MH();
        try {
            return (int)mh$.invokeExact(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHGetNewLinkInfoA$MH() {
        return RuntimeHelper.requireNonNull(constants$717.SHGetNewLinkInfoA$MH,"SHGetNewLinkInfoA");
    }
    public static int SHGetNewLinkInfoA ( Addressable pszLinkTo,  Addressable pszDir,  Addressable pszName,  Addressable pfMustCopy,  int uFlags) {
        var mh$ = SHGetNewLinkInfoA$MH();
        try {
            return (int)mh$.invokeExact(pszLinkTo, pszDir, pszName, pfMustCopy, uFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHGetNewLinkInfoW$MH() {
        return RuntimeHelper.requireNonNull(constants$717.SHGetNewLinkInfoW$MH,"SHGetNewLinkInfoW");
    }
    public static int SHGetNewLinkInfoW ( Addressable pszLinkTo,  Addressable pszDir,  Addressable pszName,  Addressable pfMustCopy,  int uFlags) {
        var mh$ = SHGetNewLinkInfoW$MH();
        try {
            return (int)mh$.invokeExact(pszLinkTo, pszDir, pszName, pfMustCopy, uFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHInvokePrinterCommandA$MH() {
        return RuntimeHelper.requireNonNull(constants$717.SHInvokePrinterCommandA$MH,"SHInvokePrinterCommandA");
    }
    public static int SHInvokePrinterCommandA ( Addressable hwnd,  int uAction,  Addressable lpBuf1,  Addressable lpBuf2,  int fModal) {
        var mh$ = SHInvokePrinterCommandA$MH();
        try {
            return (int)mh$.invokeExact(hwnd, uAction, lpBuf1, lpBuf2, fModal);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHInvokePrinterCommandW$MH() {
        return RuntimeHelper.requireNonNull(constants$717.SHInvokePrinterCommandW$MH,"SHInvokePrinterCommandW");
    }
    public static int SHInvokePrinterCommandW ( Addressable hwnd,  int uAction,  Addressable lpBuf1,  Addressable lpBuf2,  int fModal) {
        var mh$ = SHInvokePrinterCommandW$MH();
        try {
            return (int)mh$.invokeExact(hwnd, uAction, lpBuf1, lpBuf2, fModal);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress POPEN_PRINTER_PROPS_INFOA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POPEN_PRINTER_PROPS_INFOW = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POPEN_PRINTER_PROPS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle SHLoadNonloadedIconOverlayIdentifiers$MH() {
        return RuntimeHelper.requireNonNull(constants$718.SHLoadNonloadedIconOverlayIdentifiers$MH,"SHLoadNonloadedIconOverlayIdentifiers");
    }
    public static int SHLoadNonloadedIconOverlayIdentifiers () {
        var mh$ = SHLoadNonloadedIconOverlayIdentifiers$MH();
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHIsFileAvailableOffline$MH() {
        return RuntimeHelper.requireNonNull(constants$718.SHIsFileAvailableOffline$MH,"SHIsFileAvailableOffline");
    }
    public static int SHIsFileAvailableOffline ( Addressable pwszPath,  Addressable pdwStatus) {
        var mh$ = SHIsFileAvailableOffline$MH();
        try {
            return (int)mh$.invokeExact(pwszPath, pdwStatus);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHSetLocalizedName$MH() {
        return RuntimeHelper.requireNonNull(constants$718.SHSetLocalizedName$MH,"SHSetLocalizedName");
    }
    public static int SHSetLocalizedName ( Addressable pszPath,  Addressable pszResModule,  int idsRes) {
        var mh$ = SHSetLocalizedName$MH();
        try {
            return (int)mh$.invokeExact(pszPath, pszResModule, idsRes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHRemoveLocalizedName$MH() {
        return RuntimeHelper.requireNonNull(constants$718.SHRemoveLocalizedName$MH,"SHRemoveLocalizedName");
    }
    public static int SHRemoveLocalizedName ( Addressable pszPath) {
        var mh$ = SHRemoveLocalizedName$MH();
        try {
            return (int)mh$.invokeExact(pszPath);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHGetLocalizedName$MH() {
        return RuntimeHelper.requireNonNull(constants$718.SHGetLocalizedName$MH,"SHGetLocalizedName");
    }
    public static int SHGetLocalizedName ( Addressable pszPath,  Addressable pszResModule,  int cch,  Addressable pidsRes) {
        var mh$ = SHGetLocalizedName$MH();
        try {
            return (int)mh$.invokeExact(pszPath, pszResModule, cch, pidsRes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle ShellMessageBoxA$MH() {
        return RuntimeHelper.requireNonNull(constants$718.ShellMessageBoxA$MH,"ShellMessageBoxA");
    }
    public static int ShellMessageBoxA ( Addressable hAppInst,  Addressable hWnd,  Addressable lpcText,  Addressable lpcTitle,  int fuStyle, Object... x5) {
        var mh$ = ShellMessageBoxA$MH();
        try {
            return (int)mh$.invokeExact(hAppInst, hWnd, lpcText, lpcTitle, fuStyle, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle ShellMessageBoxW$MH() {
        return RuntimeHelper.requireNonNull(constants$719.ShellMessageBoxW$MH,"ShellMessageBoxW");
    }
    public static int ShellMessageBoxW ( Addressable hAppInst,  Addressable hWnd,  Addressable lpcText,  Addressable lpcTitle,  int fuStyle, Object... x5) {
        var mh$ = ShellMessageBoxW$MH();
        try {
            return (int)mh$.invokeExact(hAppInst, hWnd, lpcText, lpcTitle, fuStyle, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle IsLFNDriveA$MH() {
        return RuntimeHelper.requireNonNull(constants$719.IsLFNDriveA$MH,"IsLFNDriveA");
    }
    public static int IsLFNDriveA ( Addressable pszPath) {
        var mh$ = IsLFNDriveA$MH();
        try {
            return (int)mh$.invokeExact(pszPath);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle IsLFNDriveW$MH() {
        return RuntimeHelper.requireNonNull(constants$719.IsLFNDriveW$MH,"IsLFNDriveW");
    }
    public static int IsLFNDriveW ( Addressable pszPath) {
        var mh$ = IsLFNDriveW$MH();
        try {
            return (int)mh$.invokeExact(pszPath);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHEnumerateUnreadMailAccountsA$MH() {
        return RuntimeHelper.requireNonNull(constants$719.SHEnumerateUnreadMailAccountsA$MH,"SHEnumerateUnreadMailAccountsA");
    }
    public static int SHEnumerateUnreadMailAccountsA ( Addressable hKeyUser,  int dwIndex,  Addressable pszMailAddress,  int cchMailAddress) {
        var mh$ = SHEnumerateUnreadMailAccountsA$MH();
        try {
            return (int)mh$.invokeExact(hKeyUser, dwIndex, pszMailAddress, cchMailAddress);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHEnumerateUnreadMailAccountsW$MH() {
        return RuntimeHelper.requireNonNull(constants$719.SHEnumerateUnreadMailAccountsW$MH,"SHEnumerateUnreadMailAccountsW");
    }
    public static int SHEnumerateUnreadMailAccountsW ( Addressable hKeyUser,  int dwIndex,  Addressable pszMailAddress,  int cchMailAddress) {
        var mh$ = SHEnumerateUnreadMailAccountsW$MH();
        try {
            return (int)mh$.invokeExact(hKeyUser, dwIndex, pszMailAddress, cchMailAddress);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHGetUnreadMailCountA$MH() {
        return RuntimeHelper.requireNonNull(constants$719.SHGetUnreadMailCountA$MH,"SHGetUnreadMailCountA");
    }
    public static int SHGetUnreadMailCountA ( Addressable hKeyUser,  Addressable pszMailAddress,  Addressable pdwCount,  Addressable pFileTime,  Addressable pszShellExecuteCommand,  int cchShellExecuteCommand) {
        var mh$ = SHGetUnreadMailCountA$MH();
        try {
            return (int)mh$.invokeExact(hKeyUser, pszMailAddress, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHGetUnreadMailCountW$MH() {
        return RuntimeHelper.requireNonNull(constants$720.SHGetUnreadMailCountW$MH,"SHGetUnreadMailCountW");
    }
    public static int SHGetUnreadMailCountW ( Addressable hKeyUser,  Addressable pszMailAddress,  Addressable pdwCount,  Addressable pFileTime,  Addressable pszShellExecuteCommand,  int cchShellExecuteCommand) {
        var mh$ = SHGetUnreadMailCountW$MH();
        try {
            return (int)mh$.invokeExact(hKeyUser, pszMailAddress, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHSetUnreadMailCountA$MH() {
        return RuntimeHelper.requireNonNull(constants$720.SHSetUnreadMailCountA$MH,"SHSetUnreadMailCountA");
    }
    public static int SHSetUnreadMailCountA ( Addressable pszMailAddress,  int dwCount,  Addressable pszShellExecuteCommand) {
        var mh$ = SHSetUnreadMailCountA$MH();
        try {
            return (int)mh$.invokeExact(pszMailAddress, dwCount, pszShellExecuteCommand);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHSetUnreadMailCountW$MH() {
        return RuntimeHelper.requireNonNull(constants$720.SHSetUnreadMailCountW$MH,"SHSetUnreadMailCountW");
    }
    public static int SHSetUnreadMailCountW ( Addressable pszMailAddress,  int dwCount,  Addressable pszShellExecuteCommand) {
        var mh$ = SHSetUnreadMailCountW$MH();
        try {
            return (int)mh$.invokeExact(pszMailAddress, dwCount, pszShellExecuteCommand);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHTestTokenMembership$MH() {
        return RuntimeHelper.requireNonNull(constants$720.SHTestTokenMembership$MH,"SHTestTokenMembership");
    }
    public static int SHTestTokenMembership ( Addressable hToken,  int ulRID) {
        var mh$ = SHTestTokenMembership$MH();
        try {
            return (int)mh$.invokeExact(hToken, ulRID);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SHGetImageList$MH() {
        return RuntimeHelper.requireNonNull(constants$720.SHGetImageList$MH,"SHGetImageList");
    }
    public static int SHGetImageList ( int iImageList,  Addressable riid,  Addressable ppvObj) {
        var mh$ = SHGetImageList$MH();
        try {
            return (int)mh$.invokeExact(iImageList, riid, ppvObj);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle InitNetworkAddressControl$MH() {
        return RuntimeHelper.requireNonNull(constants$721.InitNetworkAddressControl$MH,"InitNetworkAddressControl");
    }
    public static int InitNetworkAddressControl () {
        var mh$ = InitNetworkAddressControl$MH();
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PNC_ADDRESS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle SHGetDriveMedia$MH() {
        return RuntimeHelper.requireNonNull(constants$721.SHGetDriveMedia$MH,"SHGetDriveMedia");
    }
    public static int SHGetDriveMedia ( Addressable pszDrive,  Addressable pdwMediaContent) {
        var mh$ = SHGetDriveMedia$MH();
        try {
            return (int)mh$.invokeExact(pszDrive, pdwMediaContent);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PPERF_DATA_BLOCK = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PPERF_OBJECT_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PPERF_COUNTER_DEFINITION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PPERF_INSTANCE_DEFINITION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PPERF_COUNTER_BLOCK = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle __WSAFDIsSet$MH() {
        return RuntimeHelper.requireNonNull(constants$723.__WSAFDIsSet$MH,"__WSAFDIsSet");
    }
    public static int __WSAFDIsSet ( long x0,  Addressable x1) {
        var mh$ = __WSAFDIsSet$MH();
        try {
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PIN_ADDR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPIN_ADDR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPWSADATA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle accept$MH() {
        return RuntimeHelper.requireNonNull(constants$723.accept$MH,"accept");
    }
    public static long accept ( long s,  Addressable addr,  Addressable addrlen) {
        var mh$ = accept$MH();
        try {
            return (long)mh$.invokeExact(s, addr, addrlen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle bind$MH() {
        return RuntimeHelper.requireNonNull(constants$723.bind$MH,"bind");
    }
    public static int bind ( long s,  Addressable addr,  int namelen) {
        var mh$ = bind$MH();
        try {
            return (int)mh$.invokeExact(s, addr, namelen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle closesocket$MH() {
        return RuntimeHelper.requireNonNull(constants$723.closesocket$MH,"closesocket");
    }
    public static int closesocket ( long s) {
        var mh$ = closesocket$MH();
        try {
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle connect$MH() {
        return RuntimeHelper.requireNonNull(constants$723.connect$MH,"connect");
    }
    public static int connect ( long s,  Addressable name,  int namelen) {
        var mh$ = connect$MH();
        try {
            return (int)mh$.invokeExact(s, name, namelen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle ioctlsocket$MH() {
        return RuntimeHelper.requireNonNull(constants$724.ioctlsocket$MH,"ioctlsocket");
    }
    public static int ioctlsocket ( long s,  int cmd,  Addressable argp) {
        var mh$ = ioctlsocket$MH();
        try {
            return (int)mh$.invokeExact(s, cmd, argp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle getpeername$MH() {
        return RuntimeHelper.requireNonNull(constants$724.getpeername$MH,"getpeername");
    }
    public static int getpeername ( long s,  Addressable name,  Addressable namelen) {
        var mh$ = getpeername$MH();
        try {
            return (int)mh$.invokeExact(s, name, namelen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle getsockname$MH() {
        return RuntimeHelper.requireNonNull(constants$724.getsockname$MH,"getsockname");
    }
    public static int getsockname ( long s,  Addressable name,  Addressable namelen) {
        var mh$ = getsockname$MH();
        try {
            return (int)mh$.invokeExact(s, name, namelen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle getsockopt$MH() {
        return RuntimeHelper.requireNonNull(constants$724.getsockopt$MH,"getsockopt");
    }
    public static int getsockopt ( long s,  int level,  int optname,  Addressable optval,  Addressable optlen) {
        var mh$ = getsockopt$MH();
        try {
            return (int)mh$.invokeExact(s, level, optname, optval, optlen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle htonl$MH() {
        return RuntimeHelper.requireNonNull(constants$724.htonl$MH,"htonl");
    }
    public static int htonl ( int hostlong) {
        var mh$ = htonl$MH();
        try {
            return (int)mh$.invokeExact(hostlong);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle htons$MH() {
        return RuntimeHelper.requireNonNull(constants$724.htons$MH,"htons");
    }
    public static short htons ( short hostshort) {
        var mh$ = htons$MH();
        try {
            return (short)mh$.invokeExact(hostshort);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle inet_addr$MH() {
        return RuntimeHelper.requireNonNull(constants$725.inet_addr$MH,"inet_addr");
    }
    public static int inet_addr ( Addressable cp) {
        var mh$ = inet_addr$MH();
        try {
            return (int)mh$.invokeExact(cp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle inet_ntoa$MH() {
        return RuntimeHelper.requireNonNull(constants$725.inet_ntoa$MH,"inet_ntoa");
    }
    public static MemoryAddress inet_ntoa ( MemorySegment in) {
        var mh$ = inet_ntoa$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(in);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle listen$MH() {
        return RuntimeHelper.requireNonNull(constants$725.listen$MH,"listen");
    }
    public static int listen ( long s,  int backlog) {
        var mh$ = listen$MH();
        try {
            return (int)mh$.invokeExact(s, backlog);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle ntohl$MH() {
        return RuntimeHelper.requireNonNull(constants$725.ntohl$MH,"ntohl");
    }
    public static int ntohl ( int netlong) {
        var mh$ = ntohl$MH();
        try {
            return (int)mh$.invokeExact(netlong);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle ntohs$MH() {
        return RuntimeHelper.requireNonNull(constants$725.ntohs$MH,"ntohs");
    }
    public static short ntohs ( short netshort) {
        var mh$ = ntohs$MH();
        try {
            return (short)mh$.invokeExact(netshort);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle recv$MH() {
        return RuntimeHelper.requireNonNull(constants$725.recv$MH,"recv");
    }
    public static int recv ( long s,  Addressable buf,  int len,  int flags) {
        var mh$ = recv$MH();
        try {
            return (int)mh$.invokeExact(s, buf, len, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle recvfrom$MH() {
        return RuntimeHelper.requireNonNull(constants$726.recvfrom$MH,"recvfrom");
    }
    public static int recvfrom ( long s,  Addressable buf,  int len,  int flags,  Addressable from,  Addressable fromlen) {
        var mh$ = recvfrom$MH();
        try {
            return (int)mh$.invokeExact(s, buf, len, flags, from, fromlen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle select$MH() {
        return RuntimeHelper.requireNonNull(constants$726.select$MH,"select");
    }
    public static int select ( int nfds,  Addressable readfds,  Addressable writefds,  Addressable exceptfds,  Addressable timeout) {
        var mh$ = select$MH();
        try {
            return (int)mh$.invokeExact(nfds, readfds, writefds, exceptfds, timeout);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle send$MH() {
        return RuntimeHelper.requireNonNull(constants$726.send$MH,"send");
    }
    public static int send ( long s,  Addressable buf,  int len,  int flags) {
        var mh$ = send$MH();
        try {
            return (int)mh$.invokeExact(s, buf, len, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sendto$MH() {
        return RuntimeHelper.requireNonNull(constants$726.sendto$MH,"sendto");
    }
    public static int sendto ( long s,  Addressable buf,  int len,  int flags,  Addressable to,  int tolen) {
        var mh$ = sendto$MH();
        try {
            return (int)mh$.invokeExact(s, buf, len, flags, to, tolen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle setsockopt$MH() {
        return RuntimeHelper.requireNonNull(constants$726.setsockopt$MH,"setsockopt");
    }
    public static int setsockopt ( long s,  int level,  int optname,  Addressable optval,  int optlen) {
        var mh$ = setsockopt$MH();
        try {
            return (int)mh$.invokeExact(s, level, optname, optval, optlen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle shutdown$MH() {
        return RuntimeHelper.requireNonNull(constants$726.shutdown$MH,"shutdown");
    }
    public static int shutdown ( long s,  int how) {
        var mh$ = shutdown$MH();
        try {
            return (int)mh$.invokeExact(s, how);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle socket$MH() {
        return RuntimeHelper.requireNonNull(constants$727.socket$MH,"socket");
    }
    public static long socket ( int af,  int type,  int protocol) {
        var mh$ = socket$MH();
        try {
            return (long)mh$.invokeExact(af, type, protocol);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle gethostbyaddr$MH() {
        return RuntimeHelper.requireNonNull(constants$727.gethostbyaddr$MH,"gethostbyaddr");
    }
    public static MemoryAddress gethostbyaddr ( Addressable addr,  int len,  int type) {
        var mh$ = gethostbyaddr$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(addr, len, type);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle gethostbyname$MH() {
        return RuntimeHelper.requireNonNull(constants$727.gethostbyname$MH,"gethostbyname");
    }
    public static MemoryAddress gethostbyname ( Addressable name) {
        var mh$ = gethostbyname$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(name);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle gethostname$MH() {
        return RuntimeHelper.requireNonNull(constants$727.gethostname$MH,"gethostname");
    }
    public static int gethostname ( Addressable name,  int namelen) {
        var mh$ = gethostname$MH();
        try {
            return (int)mh$.invokeExact(name, namelen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle getservbyport$MH() {
        return RuntimeHelper.requireNonNull(constants$727.getservbyport$MH,"getservbyport");
    }
    public static MemoryAddress getservbyport ( int port,  Addressable proto) {
        var mh$ = getservbyport$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(port, proto);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle getservbyname$MH() {
        return RuntimeHelper.requireNonNull(constants$727.getservbyname$MH,"getservbyname");
    }
    public static MemoryAddress getservbyname ( Addressable name,  Addressable proto) {
        var mh$ = getservbyname$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(name, proto);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle getprotobynumber$MH() {
        return RuntimeHelper.requireNonNull(constants$728.getprotobynumber$MH,"getprotobynumber");
    }
    public static MemoryAddress getprotobynumber ( int proto) {
        var mh$ = getprotobynumber$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(proto);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle getprotobyname$MH() {
        return RuntimeHelper.requireNonNull(constants$728.getprotobyname$MH,"getprotobyname");
    }
    public static MemoryAddress getprotobyname ( Addressable name) {
        var mh$ = getprotobyname$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(name);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSAStartup$MH() {
        return RuntimeHelper.requireNonNull(constants$728.WSAStartup$MH,"WSAStartup");
    }
    public static int WSAStartup ( short wVersionRequired,  Addressable lpWSAData) {
        var mh$ = WSAStartup$MH();
        try {
            return (int)mh$.invokeExact(wVersionRequired, lpWSAData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSACleanup$MH() {
        return RuntimeHelper.requireNonNull(constants$728.WSACleanup$MH,"WSACleanup");
    }
    public static int WSACleanup () {
        var mh$ = WSACleanup$MH();
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSASetLastError$MH() {
        return RuntimeHelper.requireNonNull(constants$728.WSASetLastError$MH,"WSASetLastError");
    }
    public static void WSASetLastError ( int iError) {
        var mh$ = WSASetLastError$MH();
        try {
            mh$.invokeExact(iError);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSAGetLastError$MH() {
        return RuntimeHelper.requireNonNull(constants$728.WSAGetLastError$MH,"WSAGetLastError");
    }
    public static int WSAGetLastError () {
        var mh$ = WSAGetLastError$MH();
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSAIsBlocking$MH() {
        return RuntimeHelper.requireNonNull(constants$729.WSAIsBlocking$MH,"WSAIsBlocking");
    }
    public static int WSAIsBlocking () {
        var mh$ = WSAIsBlocking$MH();
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSAUnhookBlockingHook$MH() {
        return RuntimeHelper.requireNonNull(constants$729.WSAUnhookBlockingHook$MH,"WSAUnhookBlockingHook");
    }
    public static int WSAUnhookBlockingHook () {
        var mh$ = WSAUnhookBlockingHook$MH();
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSASetBlockingHook$MH() {
        return RuntimeHelper.requireNonNull(constants$729.WSASetBlockingHook$MH,"WSASetBlockingHook");
    }
    public static MemoryAddress WSASetBlockingHook ( Addressable lpBlockFunc) {
        var mh$ = WSASetBlockingHook$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(lpBlockFunc);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSACancelBlockingCall$MH() {
        return RuntimeHelper.requireNonNull(constants$729.WSACancelBlockingCall$MH,"WSACancelBlockingCall");
    }
    public static int WSACancelBlockingCall () {
        var mh$ = WSACancelBlockingCall$MH();
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSAAsyncGetServByName$MH() {
        return RuntimeHelper.requireNonNull(constants$729.WSAAsyncGetServByName$MH,"WSAAsyncGetServByName");
    }
    public static MemoryAddress WSAAsyncGetServByName ( Addressable hWnd,  int wMsg,  Addressable name,  Addressable proto,  Addressable buf,  int buflen) {
        var mh$ = WSAAsyncGetServByName$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hWnd, wMsg, name, proto, buf, buflen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSAAsyncGetServByPort$MH() {
        return RuntimeHelper.requireNonNull(constants$729.WSAAsyncGetServByPort$MH,"WSAAsyncGetServByPort");
    }
    public static MemoryAddress WSAAsyncGetServByPort ( Addressable hWnd,  int wMsg,  int port,  Addressable proto,  Addressable buf,  int buflen) {
        var mh$ = WSAAsyncGetServByPort$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hWnd, wMsg, port, proto, buf, buflen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSAAsyncGetProtoByName$MH() {
        return RuntimeHelper.requireNonNull(constants$730.WSAAsyncGetProtoByName$MH,"WSAAsyncGetProtoByName");
    }
    public static MemoryAddress WSAAsyncGetProtoByName ( Addressable hWnd,  int wMsg,  Addressable name,  Addressable buf,  int buflen) {
        var mh$ = WSAAsyncGetProtoByName$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hWnd, wMsg, name, buf, buflen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSAAsyncGetProtoByNumber$MH() {
        return RuntimeHelper.requireNonNull(constants$730.WSAAsyncGetProtoByNumber$MH,"WSAAsyncGetProtoByNumber");
    }
    public static MemoryAddress WSAAsyncGetProtoByNumber ( Addressable hWnd,  int wMsg,  int number,  Addressable buf,  int buflen) {
        var mh$ = WSAAsyncGetProtoByNumber$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hWnd, wMsg, number, buf, buflen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSAAsyncGetHostByName$MH() {
        return RuntimeHelper.requireNonNull(constants$730.WSAAsyncGetHostByName$MH,"WSAAsyncGetHostByName");
    }
    public static MemoryAddress WSAAsyncGetHostByName ( Addressable hWnd,  int wMsg,  Addressable name,  Addressable buf,  int buflen) {
        var mh$ = WSAAsyncGetHostByName$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hWnd, wMsg, name, buf, buflen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSAAsyncGetHostByAddr$MH() {
        return RuntimeHelper.requireNonNull(constants$730.WSAAsyncGetHostByAddr$MH,"WSAAsyncGetHostByAddr");
    }
    public static MemoryAddress WSAAsyncGetHostByAddr ( Addressable hWnd,  int wMsg,  Addressable addr,  int len,  int type,  Addressable buf,  int buflen) {
        var mh$ = WSAAsyncGetHostByAddr$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hWnd, wMsg, addr, len, type, buf, buflen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSACancelAsyncRequest$MH() {
        return RuntimeHelper.requireNonNull(constants$730.WSACancelAsyncRequest$MH,"WSACancelAsyncRequest");
    }
    public static int WSACancelAsyncRequest ( Addressable hAsyncTaskHandle) {
        var mh$ = WSACancelAsyncRequest$MH();
        try {
            return (int)mh$.invokeExact(hAsyncTaskHandle);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSAAsyncSelect$MH() {
        return RuntimeHelper.requireNonNull(constants$730.WSAAsyncSelect$MH,"WSAAsyncSelect");
    }
    public static int WSAAsyncSelect ( long s,  Addressable hWnd,  int wMsg,  int lEvent) {
        var mh$ = WSAAsyncSelect$MH();
        try {
            return (int)mh$.invokeExact(s, hWnd, wMsg, lEvent);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WSARecvEx$MH() {
        return RuntimeHelper.requireNonNull(constants$731.WSARecvEx$MH,"WSARecvEx");
    }
    public static int WSARecvEx ( long s,  Addressable buf,  int len,  Addressable flags) {
        var mh$ = WSARecvEx$MH();
        try {
            return (int)mh$.invokeExact(s, buf, len, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PTRANSMIT_FILE_BUFFERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPTRANSMIT_FILE_BUFFERS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle TransmitFile$MH() {
        return RuntimeHelper.requireNonNull(constants$731.TransmitFile$MH,"TransmitFile");
    }
    public static int TransmitFile ( long hSocket,  Addressable hFile,  int nNumberOfBytesToWrite,  int nNumberOfBytesPerSend,  Addressable lpOverlapped,  Addressable lpTransmitBuffers,  int dwReserved) {
        var mh$ = TransmitFile$MH();
        try {
            return (int)mh$.invokeExact(hSocket, hFile, nNumberOfBytesToWrite, nNumberOfBytesPerSend, lpOverlapped, lpTransmitBuffers, dwReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle AcceptEx$MH() {
        return RuntimeHelper.requireNonNull(constants$731.AcceptEx$MH,"AcceptEx");
    }
    public static int AcceptEx ( long sListenSocket,  long sAcceptSocket,  Addressable lpOutputBuffer,  int dwReceiveDataLength,  int dwLocalAddressLength,  int dwRemoteAddressLength,  Addressable lpdwBytesReceived,  Addressable lpOverlapped) {
        var mh$ = AcceptEx$MH();
        try {
            return (int)mh$.invokeExact(sListenSocket, sAcceptSocket, lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, lpdwBytesReceived, lpOverlapped);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetAcceptExSockaddrs$MH() {
        return RuntimeHelper.requireNonNull(constants$731.GetAcceptExSockaddrs$MH,"GetAcceptExSockaddrs");
    }
    public static void GetAcceptExSockaddrs ( Addressable lpOutputBuffer,  int dwReceiveDataLength,  int dwLocalAddressLength,  int dwRemoteAddressLength,  Addressable LocalSockaddr,  Addressable LocalSockaddrLength,  Addressable RemoteSockaddr,  Addressable RemoteSockaddrLength) {
        var mh$ = GetAcceptExSockaddrs$MH();
        try {
            mh$.invokeExact(lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, LocalSockaddr, LocalSockaddrLength, RemoteSockaddr, RemoteSockaddrLength);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PSOCKADDR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPSOCKADDR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSOCKADDR_IN = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPSOCKADDR_IN = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PLINGER = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPLINGER = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PFD_SET = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPFD_SET = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PHOSTENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPHOSTENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSERVENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPSERVENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PPROTOENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPPROTOENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PTIMEVAL = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress LPTIMEVAL = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMS_KEY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PHMAC_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSCHANNEL_ALG = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PKEY_TYPE_SUBTYPE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_RC4_KEY_STATE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_DES_KEY_STATE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_3DES_KEY_STATE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_AES_128_KEY_STATE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_AES_256_KEY_STATE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_INTEGER_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_UINT_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_OBJID_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_NAME_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_RDN_VALUE_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDATA_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_DATA_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_HASH_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_DIGEST_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_DER_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ATTR_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMS_DH_KEY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptAcquireContextA$MH() {
        return RuntimeHelper.requireNonNull(constants$731.CryptAcquireContextA$MH,"CryptAcquireContextA");
    }
    public static int CryptAcquireContextA ( Addressable phProv,  Addressable szContainer,  Addressable szProvider,  int dwProvType,  int dwFlags) {
        var mh$ = CryptAcquireContextA$MH();
        try {
            return (int)mh$.invokeExact(phProv, szContainer, szProvider, dwProvType, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptAcquireContextW$MH() {
        return RuntimeHelper.requireNonNull(constants$731.CryptAcquireContextW$MH,"CryptAcquireContextW");
    }
    public static int CryptAcquireContextW ( Addressable phProv,  Addressable szContainer,  Addressable szProvider,  int dwProvType,  int dwFlags) {
        var mh$ = CryptAcquireContextW$MH();
        try {
            return (int)mh$.invokeExact(phProv, szContainer, szProvider, dwProvType, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptReleaseContext$MH() {
        return RuntimeHelper.requireNonNull(constants$732.CryptReleaseContext$MH,"CryptReleaseContext");
    }
    public static int CryptReleaseContext ( long hProv,  int dwFlags) {
        var mh$ = CryptReleaseContext$MH();
        try {
            return (int)mh$.invokeExact(hProv, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGenKey$MH() {
        return RuntimeHelper.requireNonNull(constants$732.CryptGenKey$MH,"CryptGenKey");
    }
    public static int CryptGenKey ( long hProv,  int Algid,  int dwFlags,  Addressable phKey) {
        var mh$ = CryptGenKey$MH();
        try {
            return (int)mh$.invokeExact(hProv, Algid, dwFlags, phKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDeriveKey$MH() {
        return RuntimeHelper.requireNonNull(constants$732.CryptDeriveKey$MH,"CryptDeriveKey");
    }
    public static int CryptDeriveKey ( long hProv,  int Algid,  long hBaseData,  int dwFlags,  Addressable phKey) {
        var mh$ = CryptDeriveKey$MH();
        try {
            return (int)mh$.invokeExact(hProv, Algid, hBaseData, dwFlags, phKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDestroyKey$MH() {
        return RuntimeHelper.requireNonNull(constants$732.CryptDestroyKey$MH,"CryptDestroyKey");
    }
    public static int CryptDestroyKey ( long hKey) {
        var mh$ = CryptDestroyKey$MH();
        try {
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetKeyParam$MH() {
        return RuntimeHelper.requireNonNull(constants$732.CryptSetKeyParam$MH,"CryptSetKeyParam");
    }
    public static int CryptSetKeyParam ( long hKey,  int dwParam,  Addressable pbData,  int dwFlags) {
        var mh$ = CryptSetKeyParam$MH();
        try {
            return (int)mh$.invokeExact(hKey, dwParam, pbData, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetKeyParam$MH() {
        return RuntimeHelper.requireNonNull(constants$732.CryptGetKeyParam$MH,"CryptGetKeyParam");
    }
    public static int CryptGetKeyParam ( long hKey,  int dwParam,  Addressable pbData,  Addressable pdwDataLen,  int dwFlags) {
        var mh$ = CryptGetKeyParam$MH();
        try {
            return (int)mh$.invokeExact(hKey, dwParam, pbData, pdwDataLen, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetHashParam$MH() {
        return RuntimeHelper.requireNonNull(constants$733.CryptSetHashParam$MH,"CryptSetHashParam");
    }
    public static int CryptSetHashParam ( long hHash,  int dwParam,  Addressable pbData,  int dwFlags) {
        var mh$ = CryptSetHashParam$MH();
        try {
            return (int)mh$.invokeExact(hHash, dwParam, pbData, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetHashParam$MH() {
        return RuntimeHelper.requireNonNull(constants$733.CryptGetHashParam$MH,"CryptGetHashParam");
    }
    public static int CryptGetHashParam ( long hHash,  int dwParam,  Addressable pbData,  Addressable pdwDataLen,  int dwFlags) {
        var mh$ = CryptGetHashParam$MH();
        try {
            return (int)mh$.invokeExact(hHash, dwParam, pbData, pdwDataLen, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetProvParam$MH() {
        return RuntimeHelper.requireNonNull(constants$733.CryptSetProvParam$MH,"CryptSetProvParam");
    }
    public static int CryptSetProvParam ( long hProv,  int dwParam,  Addressable pbData,  int dwFlags) {
        var mh$ = CryptSetProvParam$MH();
        try {
            return (int)mh$.invokeExact(hProv, dwParam, pbData, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetProvParam$MH() {
        return RuntimeHelper.requireNonNull(constants$733.CryptGetProvParam$MH,"CryptGetProvParam");
    }
    public static int CryptGetProvParam ( long hProv,  int dwParam,  Addressable pbData,  Addressable pdwDataLen,  int dwFlags) {
        var mh$ = CryptGetProvParam$MH();
        try {
            return (int)mh$.invokeExact(hProv, dwParam, pbData, pdwDataLen, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGenRandom$MH() {
        return RuntimeHelper.requireNonNull(constants$733.CryptGenRandom$MH,"CryptGenRandom");
    }
    public static int CryptGenRandom ( long hProv,  int dwLen,  Addressable pbBuffer) {
        var mh$ = CryptGenRandom$MH();
        try {
            return (int)mh$.invokeExact(hProv, dwLen, pbBuffer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetUserKey$MH() {
        return RuntimeHelper.requireNonNull(constants$733.CryptGetUserKey$MH,"CryptGetUserKey");
    }
    public static int CryptGetUserKey ( long hProv,  int dwKeySpec,  Addressable phUserKey) {
        var mh$ = CryptGetUserKey$MH();
        try {
            return (int)mh$.invokeExact(hProv, dwKeySpec, phUserKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptExportKey$MH() {
        return RuntimeHelper.requireNonNull(constants$734.CryptExportKey$MH,"CryptExportKey");
    }
    public static int CryptExportKey ( long hKey,  long hExpKey,  int dwBlobType,  int dwFlags,  Addressable pbData,  Addressable pdwDataLen) {
        var mh$ = CryptExportKey$MH();
        try {
            return (int)mh$.invokeExact(hKey, hExpKey, dwBlobType, dwFlags, pbData, pdwDataLen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptImportKey$MH() {
        return RuntimeHelper.requireNonNull(constants$734.CryptImportKey$MH,"CryptImportKey");
    }
    public static int CryptImportKey ( long hProv,  Addressable pbData,  int dwDataLen,  long hPubKey,  int dwFlags,  Addressable phKey) {
        var mh$ = CryptImportKey$MH();
        try {
            return (int)mh$.invokeExact(hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEncrypt$MH() {
        return RuntimeHelper.requireNonNull(constants$734.CryptEncrypt$MH,"CryptEncrypt");
    }
    public static int CryptEncrypt ( long hKey,  long hHash,  int Final,  int dwFlags,  Addressable pbData,  Addressable pdwDataLen,  int dwBufLen) {
        var mh$ = CryptEncrypt$MH();
        try {
            return (int)mh$.invokeExact(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDecrypt$MH() {
        return RuntimeHelper.requireNonNull(constants$734.CryptDecrypt$MH,"CryptDecrypt");
    }
    public static int CryptDecrypt ( long hKey,  long hHash,  int Final,  int dwFlags,  Addressable pbData,  Addressable pdwDataLen) {
        var mh$ = CryptDecrypt$MH();
        try {
            return (int)mh$.invokeExact(hKey, hHash, Final, dwFlags, pbData, pdwDataLen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptCreateHash$MH() {
        return RuntimeHelper.requireNonNull(constants$734.CryptCreateHash$MH,"CryptCreateHash");
    }
    public static int CryptCreateHash ( long hProv,  int Algid,  long hKey,  int dwFlags,  Addressable phHash) {
        var mh$ = CryptCreateHash$MH();
        try {
            return (int)mh$.invokeExact(hProv, Algid, hKey, dwFlags, phHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashData$MH() {
        return RuntimeHelper.requireNonNull(constants$734.CryptHashData$MH,"CryptHashData");
    }
    public static int CryptHashData ( long hHash,  Addressable pbData,  int dwDataLen,  int dwFlags) {
        var mh$ = CryptHashData$MH();
        try {
            return (int)mh$.invokeExact(hHash, pbData, dwDataLen, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashSessionKey$MH() {
        return RuntimeHelper.requireNonNull(constants$735.CryptHashSessionKey$MH,"CryptHashSessionKey");
    }
    public static int CryptHashSessionKey ( long hHash,  long hKey,  int dwFlags) {
        var mh$ = CryptHashSessionKey$MH();
        try {
            return (int)mh$.invokeExact(hHash, hKey, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDestroyHash$MH() {
        return RuntimeHelper.requireNonNull(constants$735.CryptDestroyHash$MH,"CryptDestroyHash");
    }
    public static int CryptDestroyHash ( long hHash) {
        var mh$ = CryptDestroyHash$MH();
        try {
            return (int)mh$.invokeExact(hHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSignHashA$MH() {
        return RuntimeHelper.requireNonNull(constants$735.CryptSignHashA$MH,"CryptSignHashA");
    }
    public static int CryptSignHashA ( long hHash,  int dwKeySpec,  Addressable szDescription,  int dwFlags,  Addressable pbSignature,  Addressable pdwSigLen) {
        var mh$ = CryptSignHashA$MH();
        try {
            return (int)mh$.invokeExact(hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSignHashW$MH() {
        return RuntimeHelper.requireNonNull(constants$735.CryptSignHashW$MH,"CryptSignHashW");
    }
    public static int CryptSignHashW ( long hHash,  int dwKeySpec,  Addressable szDescription,  int dwFlags,  Addressable pbSignature,  Addressable pdwSigLen) {
        var mh$ = CryptSignHashW$MH();
        try {
            return (int)mh$.invokeExact(hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifySignatureA$MH() {
        return RuntimeHelper.requireNonNull(constants$735.CryptVerifySignatureA$MH,"CryptVerifySignatureA");
    }
    public static int CryptVerifySignatureA ( long hHash,  Addressable pbSignature,  int dwSigLen,  long hPubKey,  Addressable szDescription,  int dwFlags) {
        var mh$ = CryptVerifySignatureA$MH();
        try {
            return (int)mh$.invokeExact(hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifySignatureW$MH() {
        return RuntimeHelper.requireNonNull(constants$735.CryptVerifySignatureW$MH,"CryptVerifySignatureW");
    }
    public static int CryptVerifySignatureW ( long hHash,  Addressable pbSignature,  int dwSigLen,  long hPubKey,  Addressable szDescription,  int dwFlags) {
        var mh$ = CryptVerifySignatureW$MH();
        try {
            return (int)mh$.invokeExact(hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetProviderA$MH() {
        return RuntimeHelper.requireNonNull(constants$736.CryptSetProviderA$MH,"CryptSetProviderA");
    }
    public static int CryptSetProviderA ( Addressable pszProvName,  int dwProvType) {
        var mh$ = CryptSetProviderA$MH();
        try {
            return (int)mh$.invokeExact(pszProvName, dwProvType);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetProviderW$MH() {
        return RuntimeHelper.requireNonNull(constants$736.CryptSetProviderW$MH,"CryptSetProviderW");
    }
    public static int CryptSetProviderW ( Addressable pszProvName,  int dwProvType) {
        var mh$ = CryptSetProviderW$MH();
        try {
            return (int)mh$.invokeExact(pszProvName, dwProvType);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetProviderExA$MH() {
        return RuntimeHelper.requireNonNull(constants$736.CryptSetProviderExA$MH,"CryptSetProviderExA");
    }
    public static int CryptSetProviderExA ( Addressable pszProvName,  int dwProvType,  Addressable pdwReserved,  int dwFlags) {
        var mh$ = CryptSetProviderExA$MH();
        try {
            return (int)mh$.invokeExact(pszProvName, dwProvType, pdwReserved, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetProviderExW$MH() {
        return RuntimeHelper.requireNonNull(constants$736.CryptSetProviderExW$MH,"CryptSetProviderExW");
    }
    public static int CryptSetProviderExW ( Addressable pszProvName,  int dwProvType,  Addressable pdwReserved,  int dwFlags) {
        var mh$ = CryptSetProviderExW$MH();
        try {
            return (int)mh$.invokeExact(pszProvName, dwProvType, pdwReserved, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetDefaultProviderA$MH() {
        return RuntimeHelper.requireNonNull(constants$736.CryptGetDefaultProviderA$MH,"CryptGetDefaultProviderA");
    }
    public static int CryptGetDefaultProviderA ( int dwProvType,  Addressable pdwReserved,  int dwFlags,  Addressable pszProvName,  Addressable pcbProvName) {
        var mh$ = CryptGetDefaultProviderA$MH();
        try {
            return (int)mh$.invokeExact(dwProvType, pdwReserved, dwFlags, pszProvName, pcbProvName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetDefaultProviderW$MH() {
        return RuntimeHelper.requireNonNull(constants$736.CryptGetDefaultProviderW$MH,"CryptGetDefaultProviderW");
    }
    public static int CryptGetDefaultProviderW ( int dwProvType,  Addressable pdwReserved,  int dwFlags,  Addressable pszProvName,  Addressable pcbProvName) {
        var mh$ = CryptGetDefaultProviderW$MH();
        try {
            return (int)mh$.invokeExact(dwProvType, pdwReserved, dwFlags, pszProvName, pcbProvName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEnumProviderTypesA$MH() {
        return RuntimeHelper.requireNonNull(constants$737.CryptEnumProviderTypesA$MH,"CryptEnumProviderTypesA");
    }
    public static int CryptEnumProviderTypesA ( int dwIndex,  Addressable pdwReserved,  int dwFlags,  Addressable pdwProvType,  Addressable szTypeName,  Addressable pcbTypeName) {
        var mh$ = CryptEnumProviderTypesA$MH();
        try {
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szTypeName, pcbTypeName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEnumProviderTypesW$MH() {
        return RuntimeHelper.requireNonNull(constants$737.CryptEnumProviderTypesW$MH,"CryptEnumProviderTypesW");
    }
    public static int CryptEnumProviderTypesW ( int dwIndex,  Addressable pdwReserved,  int dwFlags,  Addressable pdwProvType,  Addressable szTypeName,  Addressable pcbTypeName) {
        var mh$ = CryptEnumProviderTypesW$MH();
        try {
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szTypeName, pcbTypeName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEnumProvidersA$MH() {
        return RuntimeHelper.requireNonNull(constants$737.CryptEnumProvidersA$MH,"CryptEnumProvidersA");
    }
    public static int CryptEnumProvidersA ( int dwIndex,  Addressable pdwReserved,  int dwFlags,  Addressable pdwProvType,  Addressable szProvName,  Addressable pcbProvName) {
        var mh$ = CryptEnumProvidersA$MH();
        try {
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szProvName, pcbProvName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEnumProvidersW$MH() {
        return RuntimeHelper.requireNonNull(constants$737.CryptEnumProvidersW$MH,"CryptEnumProvidersW");
    }
    public static int CryptEnumProvidersW ( int dwIndex,  Addressable pdwReserved,  int dwFlags,  Addressable pdwProvType,  Addressable szProvName,  Addressable pcbProvName) {
        var mh$ = CryptEnumProvidersW$MH();
        try {
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szProvName, pcbProvName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptContextAddRef$MH() {
        return RuntimeHelper.requireNonNull(constants$737.CryptContextAddRef$MH,"CryptContextAddRef");
    }
    public static int CryptContextAddRef ( long hProv,  Addressable pdwReserved,  int dwFlags) {
        var mh$ = CryptContextAddRef$MH();
        try {
            return (int)mh$.invokeExact(hProv, pdwReserved, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDuplicateKey$MH() {
        return RuntimeHelper.requireNonNull(constants$737.CryptDuplicateKey$MH,"CryptDuplicateKey");
    }
    public static int CryptDuplicateKey ( long hKey,  Addressable pdwReserved,  int dwFlags,  Addressable phKey) {
        var mh$ = CryptDuplicateKey$MH();
        try {
            return (int)mh$.invokeExact(hKey, pdwReserved, dwFlags, phKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDuplicateHash$MH() {
        return RuntimeHelper.requireNonNull(constants$738.CryptDuplicateHash$MH,"CryptDuplicateHash");
    }
    public static int CryptDuplicateHash ( long hHash,  Addressable pdwReserved,  int dwFlags,  Addressable phHash) {
        var mh$ = CryptDuplicateHash$MH();
        try {
            return (int)mh$.invokeExact(hHash, pdwReserved, dwFlags, phHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetEncSChannel$MH() {
        return RuntimeHelper.requireNonNull(constants$738.GetEncSChannel$MH,"GetEncSChannel");
    }
    public static int GetEncSChannel ( Addressable pData,  Addressable dwDecSize) {
        var mh$ = GetEncSChannel$MH();
        try {
            return (int)mh$.invokeExact(pData, dwDecSize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfInt NTSTATUS = Constants$root.C_LONG$LAYOUT;
    public static OfAddress PNTSTATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PBCryptBuffer = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PBCryptBufferDesc = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress BCRYPT_HANDLE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress BCRYPT_ALG_HANDLE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress BCRYPT_KEY_HANDLE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress BCRYPT_HASH_HANDLE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress BCRYPT_SECRET_HANDLE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PBCRYPT_ECCKEY_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSSL_ECCKEY_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static int BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE() {
        return (int)1L;
    }
    public static int BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE() {
        return (int)2L;
    }
    public static int BCRYPT_ECC_PRIME_MONTGOMERY_CURVE() {
        return (int)3L;
    }
    public static int BCRYPT_NO_CURVE_GENERATION_ALG_ID() {
        return (int)0L;
    }
    public static OfAddress PBCRYPT_ECCFULLKEY_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PBCRYPT_DH_KEY_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PBCRYPT_DSA_KEY_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static int DSA_HASH_ALGORITHM_SHA1() {
        return (int)0L;
    }
    public static int DSA_HASH_ALGORITHM_SHA256() {
        return (int)1L;
    }
    public static int DSA_HASH_ALGORITHM_SHA512() {
        return (int)2L;
    }
    public static int DSA_FIPS186_2() {
        return (int)0L;
    }
    public static int DSA_FIPS186_3() {
        return (int)1L;
    }
    public static OfAddress PBCRYPT_DSA_KEY_BLOB_V2 = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PBCRYPT_KEY_DATA_BLOB_HEADER = Constants$root.C_POINTER$LAYOUT;
    public static int BCRYPT_HASH_OPERATION_HASH_DATA() {
        return (int)1L;
    }
    public static int BCRYPT_HASH_OPERATION_FINISH_HASH() {
        return (int)2L;
    }
    public static int BCRYPT_OPERATION_TYPE_HASH() {
        return (int)1L;
    }
    public static MethodHandle BCryptOpenAlgorithmProvider$MH() {
        return RuntimeHelper.requireNonNull(constants$738.BCryptOpenAlgorithmProvider$MH,"BCryptOpenAlgorithmProvider");
    }
    public static int BCryptOpenAlgorithmProvider ( Addressable phAlgorithm,  Addressable pszAlgId,  Addressable pszImplementation,  int dwFlags) {
        var mh$ = BCryptOpenAlgorithmProvider$MH();
        try {
            return (int)mh$.invokeExact(phAlgorithm, pszAlgId, pszImplementation, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptEnumAlgorithms$MH() {
        return RuntimeHelper.requireNonNull(constants$738.BCryptEnumAlgorithms$MH,"BCryptEnumAlgorithms");
    }
    public static int BCryptEnumAlgorithms ( int dwAlgOperations,  Addressable pAlgCount,  Addressable ppAlgList,  int dwFlags) {
        var mh$ = BCryptEnumAlgorithms$MH();
        try {
            return (int)mh$.invokeExact(dwAlgOperations, pAlgCount, ppAlgList, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptEnumProviders$MH() {
        return RuntimeHelper.requireNonNull(constants$738.BCryptEnumProviders$MH,"BCryptEnumProviders");
    }
    public static int BCryptEnumProviders ( Addressable pszAlgId,  Addressable pImplCount,  Addressable ppImplList,  int dwFlags) {
        var mh$ = BCryptEnumProviders$MH();
        try {
            return (int)mh$.invokeExact(pszAlgId, pImplCount, ppImplList, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptGetProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$738.BCryptGetProperty$MH,"BCryptGetProperty");
    }
    public static int BCryptGetProperty ( Addressable hObject,  Addressable pszProperty,  Addressable pbOutput,  int cbOutput,  Addressable pcbResult,  int dwFlags) {
        var mh$ = BCryptGetProperty$MH();
        try {
            return (int)mh$.invokeExact(hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptSetProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$739.BCryptSetProperty$MH,"BCryptSetProperty");
    }
    public static int BCryptSetProperty ( Addressable hObject,  Addressable pszProperty,  Addressable pbInput,  int cbInput,  int dwFlags) {
        var mh$ = BCryptSetProperty$MH();
        try {
            return (int)mh$.invokeExact(hObject, pszProperty, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptCloseAlgorithmProvider$MH() {
        return RuntimeHelper.requireNonNull(constants$739.BCryptCloseAlgorithmProvider$MH,"BCryptCloseAlgorithmProvider");
    }
    public static int BCryptCloseAlgorithmProvider ( Addressable hAlgorithm,  int dwFlags) {
        var mh$ = BCryptCloseAlgorithmProvider$MH();
        try {
            return (int)mh$.invokeExact(hAlgorithm, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptFreeBuffer$MH() {
        return RuntimeHelper.requireNonNull(constants$739.BCryptFreeBuffer$MH,"BCryptFreeBuffer");
    }
    public static void BCryptFreeBuffer ( Addressable pvBuffer) {
        var mh$ = BCryptFreeBuffer$MH();
        try {
            mh$.invokeExact(pvBuffer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptGenerateSymmetricKey$MH() {
        return RuntimeHelper.requireNonNull(constants$739.BCryptGenerateSymmetricKey$MH,"BCryptGenerateSymmetricKey");
    }
    public static int BCryptGenerateSymmetricKey ( Addressable hAlgorithm,  Addressable phKey,  Addressable pbKeyObject,  int cbKeyObject,  Addressable pbSecret,  int cbSecret,  int dwFlags) {
        var mh$ = BCryptGenerateSymmetricKey$MH();
        try {
            return (int)mh$.invokeExact(hAlgorithm, phKey, pbKeyObject, cbKeyObject, pbSecret, cbSecret, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptGenerateKeyPair$MH() {
        return RuntimeHelper.requireNonNull(constants$739.BCryptGenerateKeyPair$MH,"BCryptGenerateKeyPair");
    }
    public static int BCryptGenerateKeyPair ( Addressable hAlgorithm,  Addressable phKey,  int dwLength,  int dwFlags) {
        var mh$ = BCryptGenerateKeyPair$MH();
        try {
            return (int)mh$.invokeExact(hAlgorithm, phKey, dwLength, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptEncrypt$MH() {
        return RuntimeHelper.requireNonNull(constants$739.BCryptEncrypt$MH,"BCryptEncrypt");
    }
    public static int BCryptEncrypt ( Addressable hKey,  Addressable pbInput,  int cbInput,  Addressable pPaddingInfo,  Addressable pbIV,  int cbIV,  Addressable pbOutput,  int cbOutput,  Addressable pcbResult,  int dwFlags) {
        var mh$ = BCryptEncrypt$MH();
        try {
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptDecrypt$MH() {
        return RuntimeHelper.requireNonNull(constants$740.BCryptDecrypt$MH,"BCryptDecrypt");
    }
    public static int BCryptDecrypt ( Addressable hKey,  Addressable pbInput,  int cbInput,  Addressable pPaddingInfo,  Addressable pbIV,  int cbIV,  Addressable pbOutput,  int cbOutput,  Addressable pcbResult,  int dwFlags) {
        var mh$ = BCryptDecrypt$MH();
        try {
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptExportKey$MH() {
        return RuntimeHelper.requireNonNull(constants$740.BCryptExportKey$MH,"BCryptExportKey");
    }
    public static int BCryptExportKey ( Addressable hKey,  Addressable hExportKey,  Addressable pszBlobType,  Addressable pbOutput,  int cbOutput,  Addressable pcbResult,  int dwFlags) {
        var mh$ = BCryptExportKey$MH();
        try {
            return (int)mh$.invokeExact(hKey, hExportKey, pszBlobType, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptImportKey$MH() {
        return RuntimeHelper.requireNonNull(constants$740.BCryptImportKey$MH,"BCryptImportKey");
    }
    public static int BCryptImportKey ( Addressable hAlgorithm,  Addressable hImportKey,  Addressable pszBlobType,  Addressable phKey,  Addressable pbKeyObject,  int cbKeyObject,  Addressable pbInput,  int cbInput,  int dwFlags) {
        var mh$ = BCryptImportKey$MH();
        try {
            return (int)mh$.invokeExact(hAlgorithm, hImportKey, pszBlobType, phKey, pbKeyObject, cbKeyObject, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptImportKeyPair$MH() {
        return RuntimeHelper.requireNonNull(constants$740.BCryptImportKeyPair$MH,"BCryptImportKeyPair");
    }
    public static int BCryptImportKeyPair ( Addressable hAlgorithm,  Addressable hImportKey,  Addressable pszBlobType,  Addressable phKey,  Addressable pbInput,  int cbInput,  int dwFlags) {
        var mh$ = BCryptImportKeyPair$MH();
        try {
            return (int)mh$.invokeExact(hAlgorithm, hImportKey, pszBlobType, phKey, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptDuplicateKey$MH() {
        return RuntimeHelper.requireNonNull(constants$740.BCryptDuplicateKey$MH,"BCryptDuplicateKey");
    }
    public static int BCryptDuplicateKey ( Addressable hKey,  Addressable phNewKey,  Addressable pbKeyObject,  int cbKeyObject,  int dwFlags) {
        var mh$ = BCryptDuplicateKey$MH();
        try {
            return (int)mh$.invokeExact(hKey, phNewKey, pbKeyObject, cbKeyObject, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptFinalizeKeyPair$MH() {
        return RuntimeHelper.requireNonNull(constants$740.BCryptFinalizeKeyPair$MH,"BCryptFinalizeKeyPair");
    }
    public static int BCryptFinalizeKeyPair ( Addressable hKey,  int dwFlags) {
        var mh$ = BCryptFinalizeKeyPair$MH();
        try {
            return (int)mh$.invokeExact(hKey, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptDestroyKey$MH() {
        return RuntimeHelper.requireNonNull(constants$741.BCryptDestroyKey$MH,"BCryptDestroyKey");
    }
    public static int BCryptDestroyKey ( Addressable hKey) {
        var mh$ = BCryptDestroyKey$MH();
        try {
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptDestroySecret$MH() {
        return RuntimeHelper.requireNonNull(constants$741.BCryptDestroySecret$MH,"BCryptDestroySecret");
    }
    public static int BCryptDestroySecret ( Addressable hSecret) {
        var mh$ = BCryptDestroySecret$MH();
        try {
            return (int)mh$.invokeExact(hSecret);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptSignHash$MH() {
        return RuntimeHelper.requireNonNull(constants$741.BCryptSignHash$MH,"BCryptSignHash");
    }
    public static int BCryptSignHash ( Addressable hKey,  Addressable pPaddingInfo,  Addressable pbInput,  int cbInput,  Addressable pbOutput,  int cbOutput,  Addressable pcbResult,  int dwFlags) {
        var mh$ = BCryptSignHash$MH();
        try {
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbInput, cbInput, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptVerifySignature$MH() {
        return RuntimeHelper.requireNonNull(constants$741.BCryptVerifySignature$MH,"BCryptVerifySignature");
    }
    public static int BCryptVerifySignature ( Addressable hKey,  Addressable pPaddingInfo,  Addressable pbHash,  int cbHash,  Addressable pbSignature,  int cbSignature,  int dwFlags) {
        var mh$ = BCryptVerifySignature$MH();
        try {
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbHash, cbHash, pbSignature, cbSignature, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptSecretAgreement$MH() {
        return RuntimeHelper.requireNonNull(constants$741.BCryptSecretAgreement$MH,"BCryptSecretAgreement");
    }
    public static int BCryptSecretAgreement ( Addressable hPrivKey,  Addressable hPubKey,  Addressable phAgreedSecret,  int dwFlags) {
        var mh$ = BCryptSecretAgreement$MH();
        try {
            return (int)mh$.invokeExact(hPrivKey, hPubKey, phAgreedSecret, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptDeriveKey$MH() {
        return RuntimeHelper.requireNonNull(constants$741.BCryptDeriveKey$MH,"BCryptDeriveKey");
    }
    public static int BCryptDeriveKey ( Addressable hSharedSecret,  Addressable pwszKDF,  Addressable pParameterList,  Addressable pbDerivedKey,  int cbDerivedKey,  Addressable pcbResult,  int dwFlags) {
        var mh$ = BCryptDeriveKey$MH();
        try {
            return (int)mh$.invokeExact(hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptKeyDerivation$MH() {
        return RuntimeHelper.requireNonNull(constants$742.BCryptKeyDerivation$MH,"BCryptKeyDerivation");
    }
    public static int BCryptKeyDerivation ( Addressable hKey,  Addressable pParameterList,  Addressable pbDerivedKey,  int cbDerivedKey,  Addressable pcbResult,  int dwFlags) {
        var mh$ = BCryptKeyDerivation$MH();
        try {
            return (int)mh$.invokeExact(hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptCreateHash$MH() {
        return RuntimeHelper.requireNonNull(constants$742.BCryptCreateHash$MH,"BCryptCreateHash");
    }
    public static int BCryptCreateHash ( Addressable hAlgorithm,  Addressable phHash,  Addressable pbHashObject,  int cbHashObject,  Addressable pbSecret,  int cbSecret,  int dwFlags) {
        var mh$ = BCryptCreateHash$MH();
        try {
            return (int)mh$.invokeExact(hAlgorithm, phHash, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptHashData$MH() {
        return RuntimeHelper.requireNonNull(constants$742.BCryptHashData$MH,"BCryptHashData");
    }
    public static int BCryptHashData ( Addressable hHash,  Addressable pbInput,  int cbInput,  int dwFlags) {
        var mh$ = BCryptHashData$MH();
        try {
            return (int)mh$.invokeExact(hHash, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptFinishHash$MH() {
        return RuntimeHelper.requireNonNull(constants$742.BCryptFinishHash$MH,"BCryptFinishHash");
    }
    public static int BCryptFinishHash ( Addressable hHash,  Addressable pbOutput,  int cbOutput,  int dwFlags) {
        var mh$ = BCryptFinishHash$MH();
        try {
            return (int)mh$.invokeExact(hHash, pbOutput, cbOutput, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptCreateMultiHash$MH() {
        return RuntimeHelper.requireNonNull(constants$742.BCryptCreateMultiHash$MH,"BCryptCreateMultiHash");
    }
    public static int BCryptCreateMultiHash ( Addressable hAlgorithm,  Addressable phHash,  int nHashes,  Addressable pbHashObject,  int cbHashObject,  Addressable pbSecret,  int cbSecret,  int dwFlags) {
        var mh$ = BCryptCreateMultiHash$MH();
        try {
            return (int)mh$.invokeExact(hAlgorithm, phHash, nHashes, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptProcessMultiOperations$MH() {
        return RuntimeHelper.requireNonNull(constants$742.BCryptProcessMultiOperations$MH,"BCryptProcessMultiOperations");
    }
    public static int BCryptProcessMultiOperations ( Addressable hObject,  int operationType,  Addressable pOperations,  int cbOperations,  int dwFlags) {
        var mh$ = BCryptProcessMultiOperations$MH();
        try {
            return (int)mh$.invokeExact(hObject, operationType, pOperations, cbOperations, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptDuplicateHash$MH() {
        return RuntimeHelper.requireNonNull(constants$743.BCryptDuplicateHash$MH,"BCryptDuplicateHash");
    }
    public static int BCryptDuplicateHash ( Addressable hHash,  Addressable phNewHash,  Addressable pbHashObject,  int cbHashObject,  int dwFlags) {
        var mh$ = BCryptDuplicateHash$MH();
        try {
            return (int)mh$.invokeExact(hHash, phNewHash, pbHashObject, cbHashObject, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptDestroyHash$MH() {
        return RuntimeHelper.requireNonNull(constants$743.BCryptDestroyHash$MH,"BCryptDestroyHash");
    }
    public static int BCryptDestroyHash ( Addressable hHash) {
        var mh$ = BCryptDestroyHash$MH();
        try {
            return (int)mh$.invokeExact(hHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptHash$MH() {
        return RuntimeHelper.requireNonNull(constants$743.BCryptHash$MH,"BCryptHash");
    }
    public static int BCryptHash ( Addressable hAlgorithm,  Addressable pbSecret,  int cbSecret,  Addressable pbInput,  int cbInput,  Addressable pbOutput,  int cbOutput) {
        var mh$ = BCryptHash$MH();
        try {
            return (int)mh$.invokeExact(hAlgorithm, pbSecret, cbSecret, pbInput, cbInput, pbOutput, cbOutput);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptGenRandom$MH() {
        return RuntimeHelper.requireNonNull(constants$743.BCryptGenRandom$MH,"BCryptGenRandom");
    }
    public static int BCryptGenRandom ( Addressable hAlgorithm,  Addressable pbBuffer,  int cbBuffer,  int dwFlags) {
        var mh$ = BCryptGenRandom$MH();
        try {
            return (int)mh$.invokeExact(hAlgorithm, pbBuffer, cbBuffer, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptDeriveKeyCapi$MH() {
        return RuntimeHelper.requireNonNull(constants$743.BCryptDeriveKeyCapi$MH,"BCryptDeriveKeyCapi");
    }
    public static int BCryptDeriveKeyCapi ( Addressable hHash,  Addressable hTargetAlg,  Addressable pbDerivedKey,  int cbDerivedKey,  int dwFlags) {
        var mh$ = BCryptDeriveKeyCapi$MH();
        try {
            return (int)mh$.invokeExact(hHash, hTargetAlg, pbDerivedKey, cbDerivedKey, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptDeriveKeyPBKDF2$MH() {
        return RuntimeHelper.requireNonNull(constants$743.BCryptDeriveKeyPBKDF2$MH,"BCryptDeriveKeyPBKDF2");
    }
    public static int BCryptDeriveKeyPBKDF2 ( Addressable hPrf,  Addressable pbPassword,  int cbPassword,  Addressable pbSalt,  int cbSalt,  long cIterations,  Addressable pbDerivedKey,  int cbDerivedKey,  int dwFlags) {
        var mh$ = BCryptDeriveKeyPBKDF2$MH();
        try {
            return (int)mh$.invokeExact(hPrf, pbPassword, cbPassword, pbSalt, cbSalt, cIterations, pbDerivedKey, cbDerivedKey, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PBCRYPT_INTERFACE_VERSION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_INTERFACE_REG = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_IMAGE_REG = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PROVIDER_REG = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PROVIDERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CONTEXT_CONFIG = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CONTEXT_FUNCTION_CONFIG = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CONTEXTS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CONTEXT_FUNCTIONS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CONTEXT_FUNCTION_PROVIDERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PROPERTY_REF = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_IMAGE_REF = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PROVIDER_REF = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PROVIDER_REFS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle BCryptQueryProviderRegistration$MH() {
        return RuntimeHelper.requireNonNull(constants$744.BCryptQueryProviderRegistration$MH,"BCryptQueryProviderRegistration");
    }
    public static int BCryptQueryProviderRegistration ( Addressable pszProvider,  int dwMode,  int dwInterface,  Addressable pcbBuffer,  Addressable ppBuffer) {
        var mh$ = BCryptQueryProviderRegistration$MH();
        try {
            return (int)mh$.invokeExact(pszProvider, dwMode, dwInterface, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptEnumRegisteredProviders$MH() {
        return RuntimeHelper.requireNonNull(constants$744.BCryptEnumRegisteredProviders$MH,"BCryptEnumRegisteredProviders");
    }
    public static int BCryptEnumRegisteredProviders ( Addressable pcbBuffer,  Addressable ppBuffer) {
        var mh$ = BCryptEnumRegisteredProviders$MH();
        try {
            return (int)mh$.invokeExact(pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptCreateContext$MH() {
        return RuntimeHelper.requireNonNull(constants$744.BCryptCreateContext$MH,"BCryptCreateContext");
    }
    public static int BCryptCreateContext ( int dwTable,  Addressable pszContext,  Addressable pConfig) {
        var mh$ = BCryptCreateContext$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext, pConfig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptDeleteContext$MH() {
        return RuntimeHelper.requireNonNull(constants$744.BCryptDeleteContext$MH,"BCryptDeleteContext");
    }
    public static int BCryptDeleteContext ( int dwTable,  Addressable pszContext) {
        var mh$ = BCryptDeleteContext$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptEnumContexts$MH() {
        return RuntimeHelper.requireNonNull(constants$744.BCryptEnumContexts$MH,"BCryptEnumContexts");
    }
    public static int BCryptEnumContexts ( int dwTable,  Addressable pcbBuffer,  Addressable ppBuffer) {
        var mh$ = BCryptEnumContexts$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptConfigureContext$MH() {
        return RuntimeHelper.requireNonNull(constants$744.BCryptConfigureContext$MH,"BCryptConfigureContext");
    }
    public static int BCryptConfigureContext ( int dwTable,  Addressable pszContext,  Addressable pConfig) {
        var mh$ = BCryptConfigureContext$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext, pConfig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptQueryContextConfiguration$MH() {
        return RuntimeHelper.requireNonNull(constants$745.BCryptQueryContextConfiguration$MH,"BCryptQueryContextConfiguration");
    }
    public static int BCryptQueryContextConfiguration ( int dwTable,  Addressable pszContext,  Addressable pcbBuffer,  Addressable ppBuffer) {
        var mh$ = BCryptQueryContextConfiguration$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptAddContextFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$745.BCryptAddContextFunction$MH,"BCryptAddContextFunction");
    }
    public static int BCryptAddContextFunction ( int dwTable,  Addressable pszContext,  int dwInterface,  Addressable pszFunction,  int dwPosition) {
        var mh$ = BCryptAddContextFunction$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, dwPosition);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptRemoveContextFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$745.BCryptRemoveContextFunction$MH,"BCryptRemoveContextFunction");
    }
    public static int BCryptRemoveContextFunction ( int dwTable,  Addressable pszContext,  int dwInterface,  Addressable pszFunction) {
        var mh$ = BCryptRemoveContextFunction$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptEnumContextFunctions$MH() {
        return RuntimeHelper.requireNonNull(constants$745.BCryptEnumContextFunctions$MH,"BCryptEnumContextFunctions");
    }
    public static int BCryptEnumContextFunctions ( int dwTable,  Addressable pszContext,  int dwInterface,  Addressable pcbBuffer,  Addressable ppBuffer) {
        var mh$ = BCryptEnumContextFunctions$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptConfigureContextFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$745.BCryptConfigureContextFunction$MH,"BCryptConfigureContextFunction");
    }
    public static int BCryptConfigureContextFunction ( int dwTable,  Addressable pszContext,  int dwInterface,  Addressable pszFunction,  Addressable pConfig) {
        var mh$ = BCryptConfigureContextFunction$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pConfig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptQueryContextFunctionConfiguration$MH() {
        return RuntimeHelper.requireNonNull(constants$745.BCryptQueryContextFunctionConfiguration$MH,"BCryptQueryContextFunctionConfiguration");
    }
    public static int BCryptQueryContextFunctionConfiguration ( int dwTable,  Addressable pszContext,  int dwInterface,  Addressable pszFunction,  Addressable pcbBuffer,  Addressable ppBuffer) {
        var mh$ = BCryptQueryContextFunctionConfiguration$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptEnumContextFunctionProviders$MH() {
        return RuntimeHelper.requireNonNull(constants$746.BCryptEnumContextFunctionProviders$MH,"BCryptEnumContextFunctionProviders");
    }
    public static int BCryptEnumContextFunctionProviders ( int dwTable,  Addressable pszContext,  int dwInterface,  Addressable pszFunction,  Addressable pcbBuffer,  Addressable ppBuffer) {
        var mh$ = BCryptEnumContextFunctionProviders$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptSetContextFunctionProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$746.BCryptSetContextFunctionProperty$MH,"BCryptSetContextFunctionProperty");
    }
    public static int BCryptSetContextFunctionProperty ( int dwTable,  Addressable pszContext,  int dwInterface,  Addressable pszFunction,  Addressable pszProperty,  int cbValue,  Addressable pbValue) {
        var mh$ = BCryptSetContextFunctionProperty$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pszProperty, cbValue, pbValue);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptQueryContextFunctionProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$746.BCryptQueryContextFunctionProperty$MH,"BCryptQueryContextFunctionProperty");
    }
    public static int BCryptQueryContextFunctionProperty ( int dwTable,  Addressable pszContext,  int dwInterface,  Addressable pszFunction,  Addressable pszProperty,  Addressable pcbValue,  Addressable ppbValue) {
        var mh$ = BCryptQueryContextFunctionProperty$MH();
        try {
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pszProperty, pcbValue, ppbValue);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptRegisterConfigChangeNotify$MH() {
        return RuntimeHelper.requireNonNull(constants$746.BCryptRegisterConfigChangeNotify$MH,"BCryptRegisterConfigChangeNotify");
    }
    public static int BCryptRegisterConfigChangeNotify ( Addressable phEvent) {
        var mh$ = BCryptRegisterConfigChangeNotify$MH();
        try {
            return (int)mh$.invokeExact(phEvent);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptUnregisterConfigChangeNotify$MH() {
        return RuntimeHelper.requireNonNull(constants$746.BCryptUnregisterConfigChangeNotify$MH,"BCryptUnregisterConfigChangeNotify");
    }
    public static int BCryptUnregisterConfigChangeNotify ( Addressable hEvent) {
        var mh$ = BCryptUnregisterConfigChangeNotify$MH();
        try {
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptResolveProviders$MH() {
        return RuntimeHelper.requireNonNull(constants$746.BCryptResolveProviders$MH,"BCryptResolveProviders");
    }
    public static int BCryptResolveProviders ( Addressable pszContext,  int dwInterface,  Addressable pszFunction,  Addressable pszProvider,  int dwMode,  int dwFlags,  Addressable pcbBuffer,  Addressable ppBuffer) {
        var mh$ = BCryptResolveProviders$MH();
        try {
            return (int)mh$.invokeExact(pszContext, dwInterface, pszFunction, pszProvider, dwMode, dwFlags, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle BCryptGetFipsAlgorithmMode$MH() {
        return RuntimeHelper.requireNonNull(constants$747.BCryptGetFipsAlgorithmMode$MH,"BCryptGetFipsAlgorithmMode");
    }
    public static int BCryptGetFipsAlgorithmMode ( Addressable pfEnabled) {
        var mh$ = BCryptGetFipsAlgorithmMode$MH();
        try {
            return (int)mh$.invokeExact(pfEnabled);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CngGetFipsAlgorithmMode$MH() {
        return RuntimeHelper.requireNonNull(constants$747.CngGetFipsAlgorithmMode$MH,"CngGetFipsAlgorithmMode");
    }
    public static byte CngGetFipsAlgorithmMode () {
        var mh$ = CngGetFipsAlgorithmMode$MH();
        try {
            return (byte)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfInt SECURITY_STATUS = Constants$root.C_LONG$LAYOUT;
    public static OfAddress PNCryptBuffer = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNCryptBufferDesc = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNCRYPT_CIPHER_PADDING_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNCRYPT_VSM_KEY_ATTESTATION_STATEMENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNCRYPT_EXPORTED_ISOLATED_KEY_HEADER = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle NCryptOpenStorageProvider$MH() {
        return RuntimeHelper.requireNonNull(constants$748.NCryptOpenStorageProvider$MH,"NCryptOpenStorageProvider");
    }
    public static int NCryptOpenStorageProvider ( Addressable phProvider,  Addressable pszProviderName,  int dwFlags) {
        var mh$ = NCryptOpenStorageProvider$MH();
        try {
            return (int)mh$.invokeExact(phProvider, pszProviderName, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptEnumAlgorithms$MH() {
        return RuntimeHelper.requireNonNull(constants$748.NCryptEnumAlgorithms$MH,"NCryptEnumAlgorithms");
    }
    public static int NCryptEnumAlgorithms ( long hProvider,  int dwAlgOperations,  Addressable pdwAlgCount,  Addressable ppAlgList,  int dwFlags) {
        var mh$ = NCryptEnumAlgorithms$MH();
        try {
            return (int)mh$.invokeExact(hProvider, dwAlgOperations, pdwAlgCount, ppAlgList, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptIsAlgSupported$MH() {
        return RuntimeHelper.requireNonNull(constants$748.NCryptIsAlgSupported$MH,"NCryptIsAlgSupported");
    }
    public static int NCryptIsAlgSupported ( long hProvider,  Addressable pszAlgId,  int dwFlags) {
        var mh$ = NCryptIsAlgSupported$MH();
        try {
            return (int)mh$.invokeExact(hProvider, pszAlgId, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptEnumKeys$MH() {
        return RuntimeHelper.requireNonNull(constants$748.NCryptEnumKeys$MH,"NCryptEnumKeys");
    }
    public static int NCryptEnumKeys ( long hProvider,  Addressable pszScope,  Addressable ppKeyName,  Addressable ppEnumState,  int dwFlags) {
        var mh$ = NCryptEnumKeys$MH();
        try {
            return (int)mh$.invokeExact(hProvider, pszScope, ppKeyName, ppEnumState, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptEnumStorageProviders$MH() {
        return RuntimeHelper.requireNonNull(constants$748.NCryptEnumStorageProviders$MH,"NCryptEnumStorageProviders");
    }
    public static int NCryptEnumStorageProviders ( Addressable pdwProviderCount,  Addressable ppProviderList,  int dwFlags) {
        var mh$ = NCryptEnumStorageProviders$MH();
        try {
            return (int)mh$.invokeExact(pdwProviderCount, ppProviderList, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptFreeBuffer$MH() {
        return RuntimeHelper.requireNonNull(constants$748.NCryptFreeBuffer$MH,"NCryptFreeBuffer");
    }
    public static int NCryptFreeBuffer ( Addressable pvInput) {
        var mh$ = NCryptFreeBuffer$MH();
        try {
            return (int)mh$.invokeExact(pvInput);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptOpenKey$MH() {
        return RuntimeHelper.requireNonNull(constants$749.NCryptOpenKey$MH,"NCryptOpenKey");
    }
    public static int NCryptOpenKey ( long hProvider,  Addressable phKey,  Addressable pszKeyName,  int dwLegacyKeySpec,  int dwFlags) {
        var mh$ = NCryptOpenKey$MH();
        try {
            return (int)mh$.invokeExact(hProvider, phKey, pszKeyName, dwLegacyKeySpec, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptCreatePersistedKey$MH() {
        return RuntimeHelper.requireNonNull(constants$749.NCryptCreatePersistedKey$MH,"NCryptCreatePersistedKey");
    }
    public static int NCryptCreatePersistedKey ( long hProvider,  Addressable phKey,  Addressable pszAlgId,  Addressable pszKeyName,  int dwLegacyKeySpec,  int dwFlags) {
        var mh$ = NCryptCreatePersistedKey$MH();
        try {
            return (int)mh$.invokeExact(hProvider, phKey, pszAlgId, pszKeyName, dwLegacyKeySpec, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptGetProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$749.NCryptGetProperty$MH,"NCryptGetProperty");
    }
    public static int NCryptGetProperty ( long hObject,  Addressable pszProperty,  Addressable pbOutput,  int cbOutput,  Addressable pcbResult,  int dwFlags) {
        var mh$ = NCryptGetProperty$MH();
        try {
            return (int)mh$.invokeExact(hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptSetProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$749.NCryptSetProperty$MH,"NCryptSetProperty");
    }
    public static int NCryptSetProperty ( long hObject,  Addressable pszProperty,  Addressable pbInput,  int cbInput,  int dwFlags) {
        var mh$ = NCryptSetProperty$MH();
        try {
            return (int)mh$.invokeExact(hObject, pszProperty, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptFinalizeKey$MH() {
        return RuntimeHelper.requireNonNull(constants$749.NCryptFinalizeKey$MH,"NCryptFinalizeKey");
    }
    public static int NCryptFinalizeKey ( long hKey,  int dwFlags) {
        var mh$ = NCryptFinalizeKey$MH();
        try {
            return (int)mh$.invokeExact(hKey, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptEncrypt$MH() {
        return RuntimeHelper.requireNonNull(constants$749.NCryptEncrypt$MH,"NCryptEncrypt");
    }
    public static int NCryptEncrypt ( long hKey,  Addressable pbInput,  int cbInput,  Addressable pPaddingInfo,  Addressable pbOutput,  int cbOutput,  Addressable pcbResult,  int dwFlags) {
        var mh$ = NCryptEncrypt$MH();
        try {
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptDecrypt$MH() {
        return RuntimeHelper.requireNonNull(constants$750.NCryptDecrypt$MH,"NCryptDecrypt");
    }
    public static int NCryptDecrypt ( long hKey,  Addressable pbInput,  int cbInput,  Addressable pPaddingInfo,  Addressable pbOutput,  int cbOutput,  Addressable pcbResult,  int dwFlags) {
        var mh$ = NCryptDecrypt$MH();
        try {
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PNCRYPT_KEY_BLOB_HEADER = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PNCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle NCryptImportKey$MH() {
        return RuntimeHelper.requireNonNull(constants$750.NCryptImportKey$MH,"NCryptImportKey");
    }
    public static int NCryptImportKey ( long hProvider,  long hImportKey,  Addressable pszBlobType,  Addressable pParameterList,  Addressable phKey,  Addressable pbData,  int cbData,  int dwFlags) {
        var mh$ = NCryptImportKey$MH();
        try {
            return (int)mh$.invokeExact(hProvider, hImportKey, pszBlobType, pParameterList, phKey, pbData, cbData, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptExportKey$MH() {
        return RuntimeHelper.requireNonNull(constants$750.NCryptExportKey$MH,"NCryptExportKey");
    }
    public static int NCryptExportKey ( long hKey,  long hExportKey,  Addressable pszBlobType,  Addressable pParameterList,  Addressable pbOutput,  int cbOutput,  Addressable pcbResult,  int dwFlags) {
        var mh$ = NCryptExportKey$MH();
        try {
            return (int)mh$.invokeExact(hKey, hExportKey, pszBlobType, pParameterList, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptSignHash$MH() {
        return RuntimeHelper.requireNonNull(constants$750.NCryptSignHash$MH,"NCryptSignHash");
    }
    public static int NCryptSignHash ( long hKey,  Addressable pPaddingInfo,  Addressable pbHashValue,  int cbHashValue,  Addressable pbSignature,  int cbSignature,  Addressable pcbResult,  int dwFlags) {
        var mh$ = NCryptSignHash$MH();
        try {
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptVerifySignature$MH() {
        return RuntimeHelper.requireNonNull(constants$750.NCryptVerifySignature$MH,"NCryptVerifySignature");
    }
    public static int NCryptVerifySignature ( long hKey,  Addressable pPaddingInfo,  Addressable pbHashValue,  int cbHashValue,  Addressable pbSignature,  int cbSignature,  int dwFlags) {
        var mh$ = NCryptVerifySignature$MH();
        try {
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptDeleteKey$MH() {
        return RuntimeHelper.requireNonNull(constants$750.NCryptDeleteKey$MH,"NCryptDeleteKey");
    }
    public static int NCryptDeleteKey ( long hKey,  int dwFlags) {
        var mh$ = NCryptDeleteKey$MH();
        try {
            return (int)mh$.invokeExact(hKey, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptFreeObject$MH() {
        return RuntimeHelper.requireNonNull(constants$751.NCryptFreeObject$MH,"NCryptFreeObject");
    }
    public static int NCryptFreeObject ( long hObject) {
        var mh$ = NCryptFreeObject$MH();
        try {
            return (int)mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptIsKeyHandle$MH() {
        return RuntimeHelper.requireNonNull(constants$751.NCryptIsKeyHandle$MH,"NCryptIsKeyHandle");
    }
    public static int NCryptIsKeyHandle ( long hKey) {
        var mh$ = NCryptIsKeyHandle$MH();
        try {
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptTranslateHandle$MH() {
        return RuntimeHelper.requireNonNull(constants$751.NCryptTranslateHandle$MH,"NCryptTranslateHandle");
    }
    public static int NCryptTranslateHandle ( Addressable phProvider,  Addressable phKey,  long hLegacyProv,  long hLegacyKey,  int dwLegacyKeySpec,  int dwFlags) {
        var mh$ = NCryptTranslateHandle$MH();
        try {
            return (int)mh$.invokeExact(phProvider, phKey, hLegacyProv, hLegacyKey, dwLegacyKeySpec, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptNotifyChangeKey$MH() {
        return RuntimeHelper.requireNonNull(constants$751.NCryptNotifyChangeKey$MH,"NCryptNotifyChangeKey");
    }
    public static int NCryptNotifyChangeKey ( long hProvider,  Addressable phEvent,  int dwFlags) {
        var mh$ = NCryptNotifyChangeKey$MH();
        try {
            return (int)mh$.invokeExact(hProvider, phEvent, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptSecretAgreement$MH() {
        return RuntimeHelper.requireNonNull(constants$751.NCryptSecretAgreement$MH,"NCryptSecretAgreement");
    }
    public static int NCryptSecretAgreement ( long hPrivKey,  long hPubKey,  Addressable phAgreedSecret,  int dwFlags) {
        var mh$ = NCryptSecretAgreement$MH();
        try {
            return (int)mh$.invokeExact(hPrivKey, hPubKey, phAgreedSecret, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptDeriveKey$MH() {
        return RuntimeHelper.requireNonNull(constants$751.NCryptDeriveKey$MH,"NCryptDeriveKey");
    }
    public static int NCryptDeriveKey ( long hSharedSecret,  Addressable pwszKDF,  Addressable pParameterList,  Addressable pbDerivedKey,  int cbDerivedKey,  Addressable pcbResult,  int dwFlags) {
        var mh$ = NCryptDeriveKey$MH();
        try {
            return (int)mh$.invokeExact(hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptKeyDerivation$MH() {
        return RuntimeHelper.requireNonNull(constants$752.NCryptKeyDerivation$MH,"NCryptKeyDerivation");
    }
    public static int NCryptKeyDerivation ( long hKey,  Addressable pParameterList,  Addressable pbDerivedKey,  int cbDerivedKey,  Addressable pcbResult,  int dwFlags) {
        var mh$ = NCryptKeyDerivation$MH();
        try {
            return (int)mh$.invokeExact(hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptCreateClaim$MH() {
        return RuntimeHelper.requireNonNull(constants$752.NCryptCreateClaim$MH,"NCryptCreateClaim");
    }
    public static int NCryptCreateClaim ( long hSubjectKey,  long hAuthorityKey,  int dwClaimType,  Addressable pParameterList,  Addressable pbClaimBlob,  int cbClaimBlob,  Addressable pcbResult,  int dwFlags) {
        var mh$ = NCryptCreateClaim$MH();
        try {
            return (int)mh$.invokeExact(hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pcbResult, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle NCryptVerifyClaim$MH() {
        return RuntimeHelper.requireNonNull(constants$752.NCryptVerifyClaim$MH,"NCryptVerifyClaim");
    }
    public static int NCryptVerifyClaim ( long hSubjectKey,  long hAuthorityKey,  int dwClaimType,  Addressable pParameterList,  Addressable pbClaimBlob,  int cbClaimBlob,  Addressable pOutput,  int dwFlags) {
        var mh$ = NCryptVerifyClaim$MH();
        try {
            return (int)mh$.invokeExact(hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pOutput, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_BIT_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ALGORITHM_IDENTIFIER = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_OBJID_TABLE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_HASH_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_EXTENSION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_EXTENSION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ATTRIBUTE_TYPE_VALUE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ATTRIBUTE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ATTRIBUTES = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_RDN_ATTR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_RDN = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_NAME_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_NAME_VALUE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_PUBLIC_KEY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ECC_PRIVATE_KEY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PRIVATE_KEY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PKCS8_IMPORT_PARAMS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PRIVATE_KEY_BLOB_AND_PARAMS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PKCS8_EXPORT_PARAMS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_ENTRY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_OR_CRL_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_OR_CRL_BUNDLE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REQUEST_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_KEYGEN_REQUEST_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SIGNED_CONTENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCTL_USAGE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ENHKEY_USAGE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCTL_USAGE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_ENHKEY_USAGE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCTL_ENTRY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCTL_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_TIME_STAMP_REQUEST_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ENROLLMENT_NAME_VALUE_PAIR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CSP_PROVIDER = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptFormatObject$MH() {
        return RuntimeHelper.requireNonNull(constants$753.CryptFormatObject$MH,"CryptFormatObject");
    }
    public static int CryptFormatObject ( int dwCertEncodingType,  int dwFormatType,  int dwFormatStrType,  Addressable pFormatStruct,  Addressable lpszStructType,  Addressable pbEncoded,  int cbEncoded,  Addressable pbFormat,  Addressable pcbFormat) {
        var mh$ = CryptFormatObject$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct, lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_ENCODE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptEncodeObjectEx$MH() {
        return RuntimeHelper.requireNonNull(constants$754.CryptEncodeObjectEx$MH,"CryptEncodeObjectEx");
    }
    public static int CryptEncodeObjectEx ( int dwCertEncodingType,  Addressable lpszStructType,  Addressable pvStructInfo,  int dwFlags,  Addressable pEncodePara,  Addressable pvEncoded,  Addressable pcbEncoded) {
        var mh$ = CryptEncodeObjectEx$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pvEncoded, pcbEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEncodeObject$MH() {
        return RuntimeHelper.requireNonNull(constants$754.CryptEncodeObject$MH,"CryptEncodeObject");
    }
    public static int CryptEncodeObject ( int dwCertEncodingType,  Addressable lpszStructType,  Addressable pvStructInfo,  Addressable pbEncoded,  Addressable pcbEncoded) {
        var mh$ = CryptEncodeObject$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_DECODE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptDecodeObjectEx$MH() {
        return RuntimeHelper.requireNonNull(constants$754.CryptDecodeObjectEx$MH,"CryptDecodeObjectEx");
    }
    public static int CryptDecodeObjectEx ( int dwCertEncodingType,  Addressable lpszStructType,  Addressable pbEncoded,  int cbEncoded,  int dwFlags,  Addressable pDecodePara,  Addressable pvStructInfo,  Addressable pcbStructInfo) {
        var mh$ = CryptDecodeObjectEx$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDecodeObject$MH() {
        return RuntimeHelper.requireNonNull(constants$754.CryptDecodeObject$MH,"CryptDecodeObject");
    }
    public static int CryptDecodeObject ( int dwCertEncodingType,  Addressable lpszStructType,  Addressable pbEncoded,  int cbEncoded,  int dwFlags,  Addressable pvStructInfo,  Addressable pcbStructInfo) {
        var mh$ = CryptDecodeObject$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_EXTENSIONS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_AUTHORITY_KEY_ID_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_PRIVATE_KEY_VALIDITY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_KEY_ATTRIBUTES_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_ID = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_KEY_USAGE_RESTRICTION_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_OTHER_NAME = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ALT_NAME_ENTRY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ALT_NAME_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_BASIC_CONSTRAINTS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_BASIC_CONSTRAINTS2_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_QUALIFIER_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICIES_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_QUALIFIER_USER_NOTICE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCPS_URLS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY95_QUALIFIER1 = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_MAPPING = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_MAPPINGS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_CONSTRAINTS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CONTENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_SEQUENCE_OF_ANY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_AUTHORITY_KEY_ID2_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ACCESS_DESCRIPTION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_AUTHORITY_INFO_ACCESS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SUBJECT_INFO_ACCESS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_DIST_POINT_NAME = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_DIST_POINT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_DIST_POINTS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCROSS_CERT_DIST_POINTS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_PAIR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_ISSUING_DIST_POINT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_GENERAL_SUBTREE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_NAME_CONSTRAINTS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_DSS_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_DH_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ECC_SIGNATURE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_X942_DH_VALIDATION_PARAMS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_X942_DH_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_X942_OTHER_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ECC_CMS_SHARED_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_RC2_CBC_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_SMIME_CAPABILITY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_SMIME_CAPABILITIES = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_QC_STATEMENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_QC_STATEMENTS_EXT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_MASK_GEN_ALGORITHM = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_RSA_SSA_PSS_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PSOURCE_ALGORITHM = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_RSAES_OAEP_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_TAGGED_ATTRIBUTE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_TAGGED_CERT_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_TAGGED_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_TAGGED_CONTENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_TAGGED_OTHER_MSG = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_DATA_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_RESPONSE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_PEND_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_STATUS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_ADD_EXTENSIONS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_ADD_ATTRIBUTES_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_TEMPLATE_EXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_HASHED_URL = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_DETAILS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_REFERENCE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_IMAGE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_IMAGE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_AUDIO_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_AUDIO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_OTHER_LOGOTYPE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_EXT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_BIOMETRIC_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_BIOMETRIC_EXT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_SIGNATURE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_SIGNED_REQUEST_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_CERT_ID = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_REQUEST_ENTRY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_REQUEST_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_RESPONSE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_BASIC_SIGNED_RESPONSE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_BASIC_REVOKED_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_BASIC_RESPONSE_ENTRY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_BASIC_RESPONSE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SUPPORTED_ALGORITHM_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_TPM_SPECIFICATION_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress HCRYPTOIDFUNCSET = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress HCRYPTOIDFUNCADDR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_OID_FUNC_ENTRY = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptInstallOIDFunctionAddress$MH() {
        return RuntimeHelper.requireNonNull(constants$755.CryptInstallOIDFunctionAddress$MH,"CryptInstallOIDFunctionAddress");
    }
    public static int CryptInstallOIDFunctionAddress ( Addressable hModule,  int dwEncodingType,  Addressable pszFuncName,  int cFuncEntry,  Addressable rgFuncEntry,  int dwFlags) {
        var mh$ = CryptInstallOIDFunctionAddress$MH();
        try {
            return (int)mh$.invokeExact(hModule, dwEncodingType, pszFuncName, cFuncEntry, rgFuncEntry, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptInitOIDFunctionSet$MH() {
        return RuntimeHelper.requireNonNull(constants$755.CryptInitOIDFunctionSet$MH,"CryptInitOIDFunctionSet");
    }
    public static MemoryAddress CryptInitOIDFunctionSet ( Addressable pszFuncName,  int dwFlags) {
        var mh$ = CryptInitOIDFunctionSet$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pszFuncName, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetOIDFunctionAddress$MH() {
        return RuntimeHelper.requireNonNull(constants$755.CryptGetOIDFunctionAddress$MH,"CryptGetOIDFunctionAddress");
    }
    public static int CryptGetOIDFunctionAddress ( Addressable hFuncSet,  int dwEncodingType,  Addressable pszOID,  int dwFlags,  Addressable ppvFuncAddr,  Addressable phFuncAddr) {
        var mh$ = CryptGetOIDFunctionAddress$MH();
        try {
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pszOID, dwFlags, ppvFuncAddr, phFuncAddr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetDefaultOIDDllList$MH() {
        return RuntimeHelper.requireNonNull(constants$755.CryptGetDefaultOIDDllList$MH,"CryptGetDefaultOIDDllList");
    }
    public static int CryptGetDefaultOIDDllList ( Addressable hFuncSet,  int dwEncodingType,  Addressable pwszDllList,  Addressable pcchDllList) {
        var mh$ = CryptGetDefaultOIDDllList$MH();
        try {
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pwszDllList, pcchDllList);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetDefaultOIDFunctionAddress$MH() {
        return RuntimeHelper.requireNonNull(constants$755.CryptGetDefaultOIDFunctionAddress$MH,"CryptGetDefaultOIDFunctionAddress");
    }
    public static int CryptGetDefaultOIDFunctionAddress ( Addressable hFuncSet,  int dwEncodingType,  Addressable pwszDll,  int dwFlags,  Addressable ppvFuncAddr,  Addressable phFuncAddr) {
        var mh$ = CryptGetDefaultOIDFunctionAddress$MH();
        try {
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pwszDll, dwFlags, ppvFuncAddr, phFuncAddr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptFreeOIDFunctionAddress$MH() {
        return RuntimeHelper.requireNonNull(constants$755.CryptFreeOIDFunctionAddress$MH,"CryptFreeOIDFunctionAddress");
    }
    public static int CryptFreeOIDFunctionAddress ( Addressable hFuncAddr,  int dwFlags) {
        var mh$ = CryptFreeOIDFunctionAddress$MH();
        try {
            return (int)mh$.invokeExact(hFuncAddr, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptRegisterOIDFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$756.CryptRegisterOIDFunction$MH,"CryptRegisterOIDFunction");
    }
    public static int CryptRegisterOIDFunction ( int dwEncodingType,  Addressable pszFuncName,  Addressable pszOID,  Addressable pwszDll,  Addressable pszOverrideFuncName) {
        var mh$ = CryptRegisterOIDFunction$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnregisterOIDFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$756.CryptUnregisterOIDFunction$MH,"CryptUnregisterOIDFunction");
    }
    public static int CryptUnregisterOIDFunction ( int dwEncodingType,  Addressable pszFuncName,  Addressable pszOID) {
        var mh$ = CryptUnregisterOIDFunction$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptRegisterDefaultOIDFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$756.CryptRegisterDefaultOIDFunction$MH,"CryptRegisterDefaultOIDFunction");
    }
    public static int CryptRegisterDefaultOIDFunction ( int dwEncodingType,  Addressable pszFuncName,  int dwIndex,  Addressable pwszDll) {
        var mh$ = CryptRegisterDefaultOIDFunction$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, dwIndex, pwszDll);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnregisterDefaultOIDFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$756.CryptUnregisterDefaultOIDFunction$MH,"CryptUnregisterDefaultOIDFunction");
    }
    public static int CryptUnregisterDefaultOIDFunction ( int dwEncodingType,  Addressable pszFuncName,  Addressable pwszDll) {
        var mh$ = CryptUnregisterDefaultOIDFunction$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pwszDll);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetOIDFunctionValue$MH() {
        return RuntimeHelper.requireNonNull(constants$756.CryptSetOIDFunctionValue$MH,"CryptSetOIDFunctionValue");
    }
    public static int CryptSetOIDFunctionValue ( int dwEncodingType,  Addressable pszFuncName,  Addressable pszOID,  Addressable pwszValueName,  int dwValueType,  Addressable pbValueData,  int cbValueData) {
        var mh$ = CryptSetOIDFunctionValue$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszValueName, dwValueType, pbValueData, cbValueData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetOIDFunctionValue$MH() {
        return RuntimeHelper.requireNonNull(constants$756.CryptGetOIDFunctionValue$MH,"CryptGetOIDFunctionValue");
    }
    public static int CryptGetOIDFunctionValue ( int dwEncodingType,  Addressable pszFuncName,  Addressable pszOID,  Addressable pwszValueName,  Addressable pdwValueType,  Addressable pbValueData,  Addressable pcbValueData) {
        var mh$ = CryptGetOIDFunctionValue$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszValueName, pdwValueType, pbValueData, pcbValueData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEnumOIDFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$757.CryptEnumOIDFunction$MH,"CryptEnumOIDFunction");
    }
    public static int CryptEnumOIDFunction ( int dwEncodingType,  Addressable pszFuncName,  Addressable pszOID,  int dwFlags,  Addressable pvArg,  Addressable pfnEnumOIDFunc) {
        var mh$ = CryptEnumOIDFunction$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, dwFlags, pvArg, pfnEnumOIDFunc);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_OID_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCRYPT_OID_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptFindOIDInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$757.CryptFindOIDInfo$MH,"CryptFindOIDInfo");
    }
    public static MemoryAddress CryptFindOIDInfo ( int dwKeyType,  Addressable pvKey,  int dwGroupId) {
        var mh$ = CryptFindOIDInfo$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwKeyType, pvKey, dwGroupId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptRegisterOIDInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$757.CryptRegisterOIDInfo$MH,"CryptRegisterOIDInfo");
    }
    public static int CryptRegisterOIDInfo ( Addressable pInfo,  int dwFlags) {
        var mh$ = CryptRegisterOIDInfo$MH();
        try {
            return (int)mh$.invokeExact(pInfo, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnregisterOIDInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$757.CryptUnregisterOIDInfo$MH,"CryptUnregisterOIDInfo");
    }
    public static int CryptUnregisterOIDInfo ( Addressable pInfo) {
        var mh$ = CryptUnregisterOIDInfo$MH();
        try {
            return (int)mh$.invokeExact(pInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEnumOIDInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$758.CryptEnumOIDInfo$MH,"CryptEnumOIDInfo");
    }
    public static int CryptEnumOIDInfo ( int dwGroupId,  int dwFlags,  Addressable pvArg,  Addressable pfnEnumOIDInfo) {
        var mh$ = CryptEnumOIDInfo$MH();
        try {
            return (int)mh$.invokeExact(dwGroupId, dwFlags, pvArg, pfnEnumOIDInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptFindLocalizedName$MH() {
        return RuntimeHelper.requireNonNull(constants$758.CryptFindLocalizedName$MH,"CryptFindLocalizedName");
    }
    public static MemoryAddress CryptFindLocalizedName ( Addressable pwszCryptName) {
        var mh$ = CryptFindLocalizedName$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pwszCryptName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_STRONG_SIGN_SERIALIZED_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_STRONG_SIGN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_STRONG_SIGN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress HCRYPTMSG = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ISSUER_SERIAL_NUMBER = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ID = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_SIGNER_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_SIGNED_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_RECIPIENT_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_ENVELOPED_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_RC2_AUX_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_SP3_COMPATIBLE_AUX_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_RC4_AUX_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_HASHED_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_ENCRYPTED_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_STREAM_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptMsgOpenToEncode$MH() {
        return RuntimeHelper.requireNonNull(constants$759.CryptMsgOpenToEncode$MH,"CryptMsgOpenToEncode");
    }
    public static MemoryAddress CryptMsgOpenToEncode ( int dwMsgEncodingType,  int dwFlags,  int dwMsgType,  Addressable pvMsgEncodeInfo,  Addressable pszInnerContentObjID,  Addressable pStreamInfo) {
        var mh$ = CryptMsgOpenToEncode$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgCalculateEncodedLength$MH() {
        return RuntimeHelper.requireNonNull(constants$759.CryptMsgCalculateEncodedLength$MH,"CryptMsgCalculateEncodedLength");
    }
    public static int CryptMsgCalculateEncodedLength ( int dwMsgEncodingType,  int dwFlags,  int dwMsgType,  Addressable pvMsgEncodeInfo,  Addressable pszInnerContentObjID,  int cbData) {
        var mh$ = CryptMsgCalculateEncodedLength$MH();
        try {
            return (int)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, cbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgOpenToDecode$MH() {
        return RuntimeHelper.requireNonNull(constants$759.CryptMsgOpenToDecode$MH,"CryptMsgOpenToDecode");
    }
    public static MemoryAddress CryptMsgOpenToDecode ( int dwMsgEncodingType,  int dwFlags,  int dwMsgType,  long hCryptProv,  Addressable pRecipientInfo,  Addressable pStreamInfo) {
        var mh$ = CryptMsgOpenToDecode$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgDuplicate$MH() {
        return RuntimeHelper.requireNonNull(constants$759.CryptMsgDuplicate$MH,"CryptMsgDuplicate");
    }
    public static MemoryAddress CryptMsgDuplicate ( Addressable hCryptMsg) {
        var mh$ = CryptMsgDuplicate$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCryptMsg);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgClose$MH() {
        return RuntimeHelper.requireNonNull(constants$759.CryptMsgClose$MH,"CryptMsgClose");
    }
    public static int CryptMsgClose ( Addressable hCryptMsg) {
        var mh$ = CryptMsgClose$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgUpdate$MH() {
        return RuntimeHelper.requireNonNull(constants$759.CryptMsgUpdate$MH,"CryptMsgUpdate");
    }
    public static int CryptMsgUpdate ( Addressable hCryptMsg,  Addressable pbData,  int cbData,  int fFinal) {
        var mh$ = CryptMsgUpdate$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg, pbData, cbData, fFinal);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgGetParam$MH() {
        return RuntimeHelper.requireNonNull(constants$760.CryptMsgGetParam$MH,"CryptMsgGetParam");
    }
    public static int CryptMsgGetParam ( Addressable hCryptMsg,  int dwParamType,  int dwIndex,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CryptMsgGetParam$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg, dwParamType, dwIndex, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCMSG_SIGNER_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CMS_SIGNER_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_ATTR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_TRANS_RECIPIENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_AGREE_RECIPIENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_MAIL_LIST_RECIPIENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CMS_RECIPIENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptMsgControl$MH() {
        return RuntimeHelper.requireNonNull(constants$760.CryptMsgControl$MH,"CryptMsgControl");
    }
    public static int CryptMsgControl ( Addressable hCryptMsg,  int dwFlags,  int dwCtrlType,  Addressable pvCtrlPara) {
        var mh$ = CryptMsgControl$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_DECRYPT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptMsgVerifyCountersignatureEncoded$MH() {
        return RuntimeHelper.requireNonNull(constants$760.CryptMsgVerifyCountersignatureEncoded$MH,"CryptMsgVerifyCountersignatureEncoded");
    }
    public static int CryptMsgVerifyCountersignatureEncoded ( long hCryptProv,  int dwEncodingType,  Addressable pbSignerInfo,  int cbSignerInfo,  Addressable pbSignerInfoCountersignature,  int cbSignerInfoCountersignature,  Addressable pciCountersigner) {
        var mh$ = CryptMsgVerifyCountersignatureEncoded$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, pciCountersigner);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgVerifyCountersignatureEncodedEx$MH() {
        return RuntimeHelper.requireNonNull(constants$760.CryptMsgVerifyCountersignatureEncodedEx$MH,"CryptMsgVerifyCountersignatureEncodedEx");
    }
    public static int CryptMsgVerifyCountersignatureEncodedEx ( long hCryptProv,  int dwEncodingType,  Addressable pbSignerInfo,  int cbSignerInfo,  Addressable pbSignerInfoCountersignature,  int cbSignerInfoCountersignature,  int dwSignerType,  Addressable pvSigner,  int dwFlags,  Addressable pvExtra) {
        var mh$ = CryptMsgVerifyCountersignatureEncodedEx$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, dwSignerType, pvSigner, dwFlags, pvExtra);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgCountersign$MH() {
        return RuntimeHelper.requireNonNull(constants$760.CryptMsgCountersign$MH,"CryptMsgCountersign");
    }
    public static int CryptMsgCountersign ( Addressable hCryptMsg,  int dwIndex,  int cCountersigners,  Addressable rgCountersigners) {
        var mh$ = CryptMsgCountersign$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg, dwIndex, cCountersigners, rgCountersigners);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgCountersignEncoded$MH() {
        return RuntimeHelper.requireNonNull(constants$760.CryptMsgCountersignEncoded$MH,"CryptMsgCountersignEncoded");
    }
    public static int CryptMsgCountersignEncoded ( int dwEncodingType,  Addressable pbSignerInfo,  int cbSignerInfo,  int cCountersigners,  Addressable rgCountersigners,  Addressable pbCountersignature,  Addressable pcbCountersignature) {
        var mh$ = CryptMsgCountersignEncoded$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pbSignerInfo, cbSignerInfo, cCountersigners, rgCountersigners, pbCountersignature, pcbCountersignature);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCMSG_CONTENT_ENCRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_TRANS_ENCRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_AGREE_ENCRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_MAIL_LIST_ENCRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CNG_CONTENT_DECRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress HCERTSTORE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCRL_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCTL_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCTL_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static int KeyTypeOther() {
        return (int)0L;
    }
    public static int KeyTypeVirtualSmartCard() {
        return (int)1L;
    }
    public static int KeyTypePhysicalSmartCard() {
        return (int)2L;
    }
    public static int KeyTypePassport() {
        return (int)3L;
    }
    public static int KeyTypePassportRemote() {
        return (int)4L;
    }
    public static int KeyTypePassportSmartCard() {
        return (int)5L;
    }
    public static int KeyTypeHardware() {
        return (int)6L;
    }
    public static int KeyTypeSoftware() {
        return (int)7L;
    }
    public static int KeyTypeSelfSigned() {
        return (int)8L;
    }
    public static OfAddress PCRYPT_KEY_PROV_PARAM = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_KEY_PROV_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_KEY_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PROOT_INFO_LUID = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_SMART_CARD_ROOT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SYSTEM_STORE_RELOCATE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REGISTRY_STORE_CLIENT_GPT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REGISTRY_STORE_ROAMING_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LDAP_STORE_OPENED_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertOpenStore$MH() {
        return RuntimeHelper.requireNonNull(constants$766.CertOpenStore$MH,"CertOpenStore");
    }
    public static MemoryAddress CertOpenStore ( Addressable lpszStoreProvider,  int dwEncodingType,  long hCryptProv,  int dwFlags,  Addressable pvPara) {
        var mh$ = CertOpenStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress HCERTSTOREPROV = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_STORE_PROV_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_STORE_PROV_FIND_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_STORE_PROV_FIND_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertDuplicateStore$MH() {
        return RuntimeHelper.requireNonNull(constants$774.CertDuplicateStore$MH,"CertDuplicateStore");
    }
    public static MemoryAddress CertDuplicateStore ( Addressable hCertStore) {
        var mh$ = CertDuplicateStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSaveStore$MH() {
        return RuntimeHelper.requireNonNull(constants$774.CertSaveStore$MH,"CertSaveStore");
    }
    public static int CertSaveStore ( Addressable hCertStore,  int dwEncodingType,  int dwSaveAs,  int dwSaveTo,  Addressable pvSaveToPara,  int dwFlags) {
        var mh$ = CertSaveStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwEncodingType, dwSaveAs, dwSaveTo, pvSaveToPara, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCloseStore$MH() {
        return RuntimeHelper.requireNonNull(constants$774.CertCloseStore$MH,"CertCloseStore");
    }
    public static int CertCloseStore ( Addressable hCertStore,  int dwFlags) {
        var mh$ = CertCloseStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetSubjectCertificateFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$774.CertGetSubjectCertificateFromStore$MH,"CertGetSubjectCertificateFromStore");
    }
    public static MemoryAddress CertGetSubjectCertificateFromStore ( Addressable hCertStore,  int dwCertEncodingType,  Addressable pCertId) {
        var mh$ = CertGetSubjectCertificateFromStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, dwCertEncodingType, pCertId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCertificatesInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$774.CertEnumCertificatesInStore$MH,"CertEnumCertificatesInStore");
    }
    public static MemoryAddress CertEnumCertificatesInStore ( Addressable hCertStore,  Addressable pPrevCertContext) {
        var mh$ = CertEnumCertificatesInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, pPrevCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindCertificateInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$775.CertFindCertificateInStore$MH,"CertFindCertificateInStore");
    }
    public static MemoryAddress CertFindCertificateInStore ( Addressable hCertStore,  int dwCertEncodingType,  int dwFindFlags,  int dwFindType,  Addressable pvFindPara,  Addressable pPrevCertContext) {
        var mh$ = CertFindCertificateInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetIssuerCertificateFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$775.CertGetIssuerCertificateFromStore$MH,"CertGetIssuerCertificateFromStore");
    }
    public static MemoryAddress CertGetIssuerCertificateFromStore ( Addressable hCertStore,  Addressable pSubjectContext,  Addressable pPrevIssuerContext,  Addressable pdwFlags) {
        var mh$ = CertGetIssuerCertificateFromStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertVerifySubjectCertificateContext$MH() {
        return RuntimeHelper.requireNonNull(constants$775.CertVerifySubjectCertificateContext$MH,"CertVerifySubjectCertificateContext");
    }
    public static int CertVerifySubjectCertificateContext ( Addressable pSubject,  Addressable pIssuer,  Addressable pdwFlags) {
        var mh$ = CertVerifySubjectCertificateContext$MH();
        try {
            return (int)mh$.invokeExact(pSubject, pIssuer, pdwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDuplicateCertificateContext$MH() {
        return RuntimeHelper.requireNonNull(constants$775.CertDuplicateCertificateContext$MH,"CertDuplicateCertificateContext");
    }
    public static MemoryAddress CertDuplicateCertificateContext ( Addressable pCertContext) {
        var mh$ = CertDuplicateCertificateContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCreateCertificateContext$MH() {
        return RuntimeHelper.requireNonNull(constants$775.CertCreateCertificateContext$MH,"CertCreateCertificateContext");
    }
    public static MemoryAddress CertCreateCertificateContext ( int dwCertEncodingType,  Addressable pbCertEncoded,  int cbCertEncoded) {
        var mh$ = CertCreateCertificateContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwCertEncodingType, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCertificateContext$MH() {
        return RuntimeHelper.requireNonNull(constants$775.CertFreeCertificateContext$MH,"CertFreeCertificateContext");
    }
    public static int CertFreeCertificateContext ( Addressable pCertContext) {
        var mh$ = CertFreeCertificateContext$MH();
        try {
            return (int)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetCertificateContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$776.CertSetCertificateContextProperty$MH,"CertSetCertificateContextProperty");
    }
    public static int CertSetCertificateContextProperty ( Addressable pCertContext,  int dwPropId,  int dwFlags,  Addressable pvData) {
        var mh$ = CertSetCertificateContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetCertificateContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$776.CertGetCertificateContextProperty$MH,"CertGetCertificateContextProperty");
    }
    public static int CertGetCertificateContextProperty ( Addressable pCertContext,  int dwPropId,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CertGetCertificateContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCertificateContextProperties$MH() {
        return RuntimeHelper.requireNonNull(constants$776.CertEnumCertificateContextProperties$MH,"CertEnumCertificateContextProperties");
    }
    public static int CertEnumCertificateContextProperties ( Addressable pCertContext,  int dwPropId) {
        var mh$ = CertEnumCertificateContextProperties$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwPropId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCreateCTLEntryFromCertificateContextProperties$MH() {
        return RuntimeHelper.requireNonNull(constants$776.CertCreateCTLEntryFromCertificateContextProperties$MH,"CertCreateCTLEntryFromCertificateContextProperties");
    }
    public static int CertCreateCTLEntryFromCertificateContextProperties ( Addressable pCertContext,  int cOptAttr,  Addressable rgOptAttr,  int dwFlags,  Addressable pvReserved,  Addressable pCtlEntry,  Addressable pcbCtlEntry) {
        var mh$ = CertCreateCTLEntryFromCertificateContextProperties$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, cOptAttr, rgOptAttr, dwFlags, pvReserved, pCtlEntry, pcbCtlEntry);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetCertificateContextPropertiesFromCTLEntry$MH() {
        return RuntimeHelper.requireNonNull(constants$776.CertSetCertificateContextPropertiesFromCTLEntry$MH,"CertSetCertificateContextPropertiesFromCTLEntry");
    }
    public static int CertSetCertificateContextPropertiesFromCTLEntry ( Addressable pCertContext,  Addressable pCtlEntry,  int dwFlags) {
        var mh$ = CertSetCertificateContextPropertiesFromCTLEntry$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, pCtlEntry, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetCRLFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$776.CertGetCRLFromStore$MH,"CertGetCRLFromStore");
    }
    public static MemoryAddress CertGetCRLFromStore ( Addressable hCertStore,  Addressable pIssuerContext,  Addressable pPrevCrlContext,  Addressable pdwFlags) {
        var mh$ = CertGetCRLFromStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, pIssuerContext, pPrevCrlContext, pdwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCRLsInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$777.CertEnumCRLsInStore$MH,"CertEnumCRLsInStore");
    }
    public static MemoryAddress CertEnumCRLsInStore ( Addressable hCertStore,  Addressable pPrevCrlContext) {
        var mh$ = CertEnumCRLsInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, pPrevCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindCRLInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$777.CertFindCRLInStore$MH,"CertFindCRLInStore");
    }
    public static MemoryAddress CertFindCRLInStore ( Addressable hCertStore,  int dwCertEncodingType,  int dwFindFlags,  int dwFindType,  Addressable pvFindPara,  Addressable pPrevCrlContext) {
        var mh$ = CertFindCRLInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRL_FIND_ISSUED_FOR_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertDuplicateCRLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$777.CertDuplicateCRLContext$MH,"CertDuplicateCRLContext");
    }
    public static MemoryAddress CertDuplicateCRLContext ( Addressable pCrlContext) {
        var mh$ = CertDuplicateCRLContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCreateCRLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$777.CertCreateCRLContext$MH,"CertCreateCRLContext");
    }
    public static MemoryAddress CertCreateCRLContext ( int dwCertEncodingType,  Addressable pbCrlEncoded,  int cbCrlEncoded) {
        var mh$ = CertCreateCRLContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwCertEncodingType, pbCrlEncoded, cbCrlEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCRLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$777.CertFreeCRLContext$MH,"CertFreeCRLContext");
    }
    public static int CertFreeCRLContext ( Addressable pCrlContext) {
        var mh$ = CertFreeCRLContext$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetCRLContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$777.CertSetCRLContextProperty$MH,"CertSetCRLContextProperty");
    }
    public static int CertSetCRLContextProperty ( Addressable pCrlContext,  int dwPropId,  int dwFlags,  Addressable pvData) {
        var mh$ = CertSetCRLContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetCRLContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$778.CertGetCRLContextProperty$MH,"CertGetCRLContextProperty");
    }
    public static int CertGetCRLContextProperty ( Addressable pCrlContext,  int dwPropId,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CertGetCRLContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCRLContextProperties$MH() {
        return RuntimeHelper.requireNonNull(constants$778.CertEnumCRLContextProperties$MH,"CertEnumCRLContextProperties");
    }
    public static int CertEnumCRLContextProperties ( Addressable pCrlContext,  int dwPropId) {
        var mh$ = CertEnumCRLContextProperties$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext, dwPropId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindCertificateInCRL$MH() {
        return RuntimeHelper.requireNonNull(constants$778.CertFindCertificateInCRL$MH,"CertFindCertificateInCRL");
    }
    public static int CertFindCertificateInCRL ( Addressable pCert,  Addressable pCrlContext,  int dwFlags,  Addressable pvReserved,  Addressable ppCrlEntry) {
        var mh$ = CertFindCertificateInCRL$MH();
        try {
            return (int)mh$.invokeExact(pCert, pCrlContext, dwFlags, pvReserved, ppCrlEntry);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertIsValidCRLForCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$778.CertIsValidCRLForCertificate$MH,"CertIsValidCRLForCertificate");
    }
    public static int CertIsValidCRLForCertificate ( Addressable pCert,  Addressable pCrl,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CertIsValidCRLForCertificate$MH();
        try {
            return (int)mh$.invokeExact(pCert, pCrl, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddEncodedCertificateToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$778.CertAddEncodedCertificateToStore$MH,"CertAddEncodedCertificateToStore");
    }
    public static int CertAddEncodedCertificateToStore ( Addressable hCertStore,  int dwCertEncodingType,  Addressable pbCertEncoded,  int cbCertEncoded,  int dwAddDisposition,  Addressable ppCertContext) {
        var mh$ = CertAddEncodedCertificateToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCertificateContextToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$778.CertAddCertificateContextToStore$MH,"CertAddCertificateContextToStore");
    }
    public static int CertAddCertificateContextToStore ( Addressable hCertStore,  Addressable pCertContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCertificateContextToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddSerializedElementToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$779.CertAddSerializedElementToStore$MH,"CertAddSerializedElementToStore");
    }
    public static int CertAddSerializedElementToStore ( Addressable hCertStore,  Addressable pbElement,  int cbElement,  int dwAddDisposition,  int dwFlags,  int dwContextTypeFlags,  Addressable pdwContextType,  Addressable ppvContext) {
        var mh$ = CertAddSerializedElementToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pbElement, cbElement, dwAddDisposition, dwFlags, dwContextTypeFlags, pdwContextType, ppvContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDeleteCertificateFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$779.CertDeleteCertificateFromStore$MH,"CertDeleteCertificateFromStore");
    }
    public static int CertDeleteCertificateFromStore ( Addressable pCertContext) {
        var mh$ = CertDeleteCertificateFromStore$MH();
        try {
            return (int)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddEncodedCRLToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$779.CertAddEncodedCRLToStore$MH,"CertAddEncodedCRLToStore");
    }
    public static int CertAddEncodedCRLToStore ( Addressable hCertStore,  int dwCertEncodingType,  Addressable pbCrlEncoded,  int cbCrlEncoded,  int dwAddDisposition,  Addressable ppCrlContext) {
        var mh$ = CertAddEncodedCRLToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCRLContextToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$779.CertAddCRLContextToStore$MH,"CertAddCRLContextToStore");
    }
    public static int CertAddCRLContextToStore ( Addressable hCertStore,  Addressable pCrlContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCRLContextToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDeleteCRLFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$779.CertDeleteCRLFromStore$MH,"CertDeleteCRLFromStore");
    }
    public static int CertDeleteCRLFromStore ( Addressable pCrlContext) {
        var mh$ = CertDeleteCRLFromStore$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSerializeCertificateStoreElement$MH() {
        return RuntimeHelper.requireNonNull(constants$779.CertSerializeCertificateStoreElement$MH,"CertSerializeCertificateStoreElement");
    }
    public static int CertSerializeCertificateStoreElement ( Addressable pCertContext,  int dwFlags,  Addressable pbElement,  Addressable pcbElement) {
        var mh$ = CertSerializeCertificateStoreElement$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSerializeCRLStoreElement$MH() {
        return RuntimeHelper.requireNonNull(constants$780.CertSerializeCRLStoreElement$MH,"CertSerializeCRLStoreElement");
    }
    public static int CertSerializeCRLStoreElement ( Addressable pCrlContext,  int dwFlags,  Addressable pbElement,  Addressable pcbElement) {
        var mh$ = CertSerializeCRLStoreElement$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDuplicateCTLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$780.CertDuplicateCTLContext$MH,"CertDuplicateCTLContext");
    }
    public static MemoryAddress CertDuplicateCTLContext ( Addressable pCtlContext) {
        var mh$ = CertDuplicateCTLContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCreateCTLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$780.CertCreateCTLContext$MH,"CertCreateCTLContext");
    }
    public static MemoryAddress CertCreateCTLContext ( int dwMsgAndCertEncodingType,  Addressable pbCtlEncoded,  int cbCtlEncoded) {
        var mh$ = CertCreateCTLContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCTLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$780.CertFreeCTLContext$MH,"CertFreeCTLContext");
    }
    public static int CertFreeCTLContext ( Addressable pCtlContext) {
        var mh$ = CertFreeCTLContext$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetCTLContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$780.CertSetCTLContextProperty$MH,"CertSetCTLContextProperty");
    }
    public static int CertSetCTLContextProperty ( Addressable pCtlContext,  int dwPropId,  int dwFlags,  Addressable pvData) {
        var mh$ = CertSetCTLContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetCTLContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$780.CertGetCTLContextProperty$MH,"CertGetCTLContextProperty");
    }
    public static int CertGetCTLContextProperty ( Addressable pCtlContext,  int dwPropId,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CertGetCTLContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCTLContextProperties$MH() {
        return RuntimeHelper.requireNonNull(constants$781.CertEnumCTLContextProperties$MH,"CertEnumCTLContextProperties");
    }
    public static int CertEnumCTLContextProperties ( Addressable pCtlContext,  int dwPropId) {
        var mh$ = CertEnumCTLContextProperties$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext, dwPropId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCTLsInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$781.CertEnumCTLsInStore$MH,"CertEnumCTLsInStore");
    }
    public static MemoryAddress CertEnumCTLsInStore ( Addressable hCertStore,  Addressable pPrevCtlContext) {
        var mh$ = CertEnumCTLsInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, pPrevCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindSubjectInCTL$MH() {
        return RuntimeHelper.requireNonNull(constants$781.CertFindSubjectInCTL$MH,"CertFindSubjectInCTL");
    }
    public static MemoryAddress CertFindSubjectInCTL ( int dwEncodingType,  int dwSubjectType,  Addressable pvSubject,  Addressable pCtlContext,  int dwFlags) {
        var mh$ = CertFindSubjectInCTL$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCTL_ANY_SUBJECT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertFindCTLInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$781.CertFindCTLInStore$MH,"CertFindCTLInStore");
    }
    public static MemoryAddress CertFindCTLInStore ( Addressable hCertStore,  int dwMsgAndCertEncodingType,  int dwFindFlags,  int dwFindType,  Addressable pvFindPara,  Addressable pPrevCtlContext) {
        var mh$ = CertFindCTLInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, dwMsgAndCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCTL_FIND_USAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCTL_FIND_SUBJECT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertAddEncodedCTLToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$781.CertAddEncodedCTLToStore$MH,"CertAddEncodedCTLToStore");
    }
    public static int CertAddEncodedCTLToStore ( Addressable hCertStore,  int dwMsgAndCertEncodingType,  Addressable pbCtlEncoded,  int cbCtlEncoded,  int dwAddDisposition,  Addressable ppCtlContext) {
        var mh$ = CertAddEncodedCTLToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded, dwAddDisposition, ppCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCTLContextToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$781.CertAddCTLContextToStore$MH,"CertAddCTLContextToStore");
    }
    public static int CertAddCTLContextToStore ( Addressable hCertStore,  Addressable pCtlContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCTLContextToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSerializeCTLStoreElement$MH() {
        return RuntimeHelper.requireNonNull(constants$782.CertSerializeCTLStoreElement$MH,"CertSerializeCTLStoreElement");
    }
    public static int CertSerializeCTLStoreElement ( Addressable pCtlContext,  int dwFlags,  Addressable pbElement,  Addressable pcbElement) {
        var mh$ = CertSerializeCTLStoreElement$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDeleteCTLFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$782.CertDeleteCTLFromStore$MH,"CertDeleteCTLFromStore");
    }
    public static int CertDeleteCTLFromStore ( Addressable pCtlContext) {
        var mh$ = CertDeleteCTLFromStore$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCertificateLinkToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$782.CertAddCertificateLinkToStore$MH,"CertAddCertificateLinkToStore");
    }
    public static int CertAddCertificateLinkToStore ( Addressable hCertStore,  Addressable pCertContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCertificateLinkToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCRLLinkToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$782.CertAddCRLLinkToStore$MH,"CertAddCRLLinkToStore");
    }
    public static int CertAddCRLLinkToStore ( Addressable hCertStore,  Addressable pCrlContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCRLLinkToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCTLLinkToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$782.CertAddCTLLinkToStore$MH,"CertAddCTLLinkToStore");
    }
    public static int CertAddCTLLinkToStore ( Addressable hCertStore,  Addressable pCtlContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCTLLinkToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddStoreToCollection$MH() {
        return RuntimeHelper.requireNonNull(constants$782.CertAddStoreToCollection$MH,"CertAddStoreToCollection");
    }
    public static int CertAddStoreToCollection ( Addressable hCollectionStore,  Addressable hSiblingStore,  int dwUpdateFlags,  int dwPriority) {
        var mh$ = CertAddStoreToCollection$MH();
        try {
            return (int)mh$.invokeExact(hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRemoveStoreFromCollection$MH() {
        return RuntimeHelper.requireNonNull(constants$783.CertRemoveStoreFromCollection$MH,"CertRemoveStoreFromCollection");
    }
    public static void CertRemoveStoreFromCollection ( Addressable hCollectionStore,  Addressable hSiblingStore) {
        var mh$ = CertRemoveStoreFromCollection$MH();
        try {
            mh$.invokeExact(hCollectionStore, hSiblingStore);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertControlStore$MH() {
        return RuntimeHelper.requireNonNull(constants$783.CertControlStore$MH,"CertControlStore");
    }
    public static int CertControlStore ( Addressable hCertStore,  int dwFlags,  int dwCtrlType,  Addressable pvCtrlPara) {
        var mh$ = CertControlStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwFlags, dwCtrlType, pvCtrlPara);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetStoreProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$783.CertSetStoreProperty$MH,"CertSetStoreProperty");
    }
    public static int CertSetStoreProperty ( Addressable hCertStore,  int dwPropId,  int dwFlags,  Addressable pvData) {
        var mh$ = CertSetStoreProperty$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetStoreProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$783.CertGetStoreProperty$MH,"CertGetStoreProperty");
    }
    public static int CertGetStoreProperty ( Addressable hCertStore,  int dwPropId,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CertGetStoreProperty$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_CREATE_CONTEXT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertCreateContext$MH() {
        return RuntimeHelper.requireNonNull(constants$784.CertCreateContext$MH,"CertCreateContext");
    }
    public static MemoryAddress CertCreateContext ( int dwContextType,  int dwEncodingType,  Addressable pbEncoded,  int cbEncoded,  int dwFlags,  Addressable pCreatePara) {
        var mh$ = CertCreateContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwContextType, dwEncodingType, pbEncoded, cbEncoded, dwFlags, pCreatePara);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_SYSTEM_STORE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_PHYSICAL_STORE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertRegisterSystemStore$MH() {
        return RuntimeHelper.requireNonNull(constants$784.CertRegisterSystemStore$MH,"CertRegisterSystemStore");
    }
    public static int CertRegisterSystemStore ( Addressable pvSystemStore,  int dwFlags,  Addressable pStoreInfo,  Addressable pvReserved) {
        var mh$ = CertRegisterSystemStore$MH();
        try {
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pStoreInfo, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRegisterPhysicalStore$MH() {
        return RuntimeHelper.requireNonNull(constants$784.CertRegisterPhysicalStore$MH,"CertRegisterPhysicalStore");
    }
    public static int CertRegisterPhysicalStore ( Addressable pvSystemStore,  int dwFlags,  Addressable pwszStoreName,  Addressable pStoreInfo,  Addressable pvReserved) {
        var mh$ = CertRegisterPhysicalStore$MH();
        try {
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pwszStoreName, pStoreInfo, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertUnregisterSystemStore$MH() {
        return RuntimeHelper.requireNonNull(constants$784.CertUnregisterSystemStore$MH,"CertUnregisterSystemStore");
    }
    public static int CertUnregisterSystemStore ( Addressable pvSystemStore,  int dwFlags) {
        var mh$ = CertUnregisterSystemStore$MH();
        try {
            return (int)mh$.invokeExact(pvSystemStore, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertUnregisterPhysicalStore$MH() {
        return RuntimeHelper.requireNonNull(constants$784.CertUnregisterPhysicalStore$MH,"CertUnregisterPhysicalStore");
    }
    public static int CertUnregisterPhysicalStore ( Addressable pvSystemStore,  int dwFlags,  Addressable pwszStoreName) {
        var mh$ = CertUnregisterPhysicalStore$MH();
        try {
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pwszStoreName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumSystemStoreLocation$MH() {
        return RuntimeHelper.requireNonNull(constants$785.CertEnumSystemStoreLocation$MH,"CertEnumSystemStoreLocation");
    }
    public static int CertEnumSystemStoreLocation ( int dwFlags,  Addressable pvArg,  Addressable pfnEnum) {
        var mh$ = CertEnumSystemStoreLocation$MH();
        try {
            return (int)mh$.invokeExact(dwFlags, pvArg, pfnEnum);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumSystemStore$MH() {
        return RuntimeHelper.requireNonNull(constants$786.CertEnumSystemStore$MH,"CertEnumSystemStore");
    }
    public static int CertEnumSystemStore ( int dwFlags,  Addressable pvSystemStoreLocationPara,  Addressable pvArg,  Addressable pfnEnum) {
        var mh$ = CertEnumSystemStore$MH();
        try {
            return (int)mh$.invokeExact(dwFlags, pvSystemStoreLocationPara, pvArg, pfnEnum);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumPhysicalStore$MH() {
        return RuntimeHelper.requireNonNull(constants$786.CertEnumPhysicalStore$MH,"CertEnumPhysicalStore");
    }
    public static int CertEnumPhysicalStore ( Addressable pvSystemStore,  int dwFlags,  Addressable pvArg,  Addressable pfnEnum) {
        var mh$ = CertEnumPhysicalStore$MH();
        try {
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pvArg, pfnEnum);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetEnhancedKeyUsage$MH() {
        return RuntimeHelper.requireNonNull(constants$786.CertGetEnhancedKeyUsage$MH,"CertGetEnhancedKeyUsage");
    }
    public static int CertGetEnhancedKeyUsage ( Addressable pCertContext,  int dwFlags,  Addressable pUsage,  Addressable pcbUsage) {
        var mh$ = CertGetEnhancedKeyUsage$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwFlags, pUsage, pcbUsage);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetEnhancedKeyUsage$MH() {
        return RuntimeHelper.requireNonNull(constants$786.CertSetEnhancedKeyUsage$MH,"CertSetEnhancedKeyUsage");
    }
    public static int CertSetEnhancedKeyUsage ( Addressable pCertContext,  Addressable pUsage) {
        var mh$ = CertSetEnhancedKeyUsage$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, pUsage);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddEnhancedKeyUsageIdentifier$MH() {
        return RuntimeHelper.requireNonNull(constants$786.CertAddEnhancedKeyUsageIdentifier$MH,"CertAddEnhancedKeyUsageIdentifier");
    }
    public static int CertAddEnhancedKeyUsageIdentifier ( Addressable pCertContext,  Addressable pszUsageIdentifier) {
        var mh$ = CertAddEnhancedKeyUsageIdentifier$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, pszUsageIdentifier);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRemoveEnhancedKeyUsageIdentifier$MH() {
        return RuntimeHelper.requireNonNull(constants$786.CertRemoveEnhancedKeyUsageIdentifier$MH,"CertRemoveEnhancedKeyUsageIdentifier");
    }
    public static int CertRemoveEnhancedKeyUsageIdentifier ( Addressable pCertContext,  Addressable pszUsageIdentifier) {
        var mh$ = CertRemoveEnhancedKeyUsageIdentifier$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, pszUsageIdentifier);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetValidUsages$MH() {
        return RuntimeHelper.requireNonNull(constants$787.CertGetValidUsages$MH,"CertGetValidUsages");
    }
    public static int CertGetValidUsages ( int cCerts,  Addressable rghCerts,  Addressable cNumOIDs,  Addressable rghOIDs,  Addressable pcbOIDs) {
        var mh$ = CertGetValidUsages$MH();
        try {
            return (int)mh$.invokeExact(cCerts, rghCerts, cNumOIDs, rghOIDs, pcbOIDs);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgGetAndVerifySigner$MH() {
        return RuntimeHelper.requireNonNull(constants$787.CryptMsgGetAndVerifySigner$MH,"CryptMsgGetAndVerifySigner");
    }
    public static int CryptMsgGetAndVerifySigner ( Addressable hCryptMsg,  int cSignerStore,  Addressable rghSignerStore,  int dwFlags,  Addressable ppSigner,  Addressable pdwSignerIndex) {
        var mh$ = CryptMsgGetAndVerifySigner$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg, cSignerStore, rghSignerStore, dwFlags, ppSigner, pdwSignerIndex);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgSignCTL$MH() {
        return RuntimeHelper.requireNonNull(constants$787.CryptMsgSignCTL$MH,"CryptMsgSignCTL");
    }
    public static int CryptMsgSignCTL ( int dwMsgEncodingType,  Addressable pbCtlContent,  int cbCtlContent,  Addressable pSignInfo,  int dwFlags,  Addressable pbEncoded,  Addressable pcbEncoded) {
        var mh$ = CryptMsgSignCTL$MH();
        try {
            return (int)mh$.invokeExact(dwMsgEncodingType, pbCtlContent, cbCtlContent, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgEncodeAndSignCTL$MH() {
        return RuntimeHelper.requireNonNull(constants$787.CryptMsgEncodeAndSignCTL$MH,"CryptMsgEncodeAndSignCTL");
    }
    public static int CryptMsgEncodeAndSignCTL ( int dwMsgEncodingType,  Addressable pCtlInfo,  Addressable pSignInfo,  int dwFlags,  Addressable pbEncoded,  Addressable pcbEncoded) {
        var mh$ = CryptMsgEncodeAndSignCTL$MH();
        try {
            return (int)mh$.invokeExact(dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindSubjectInSortedCTL$MH() {
        return RuntimeHelper.requireNonNull(constants$787.CertFindSubjectInSortedCTL$MH,"CertFindSubjectInSortedCTL");
    }
    public static int CertFindSubjectInSortedCTL ( Addressable pSubjectIdentifier,  Addressable pCtlContext,  int dwFlags,  Addressable pvReserved,  Addressable pEncodedAttributes) {
        var mh$ = CertFindSubjectInSortedCTL$MH();
        try {
            return (int)mh$.invokeExact(pSubjectIdentifier, pCtlContext, dwFlags, pvReserved, pEncodedAttributes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumSubjectInSortedCTL$MH() {
        return RuntimeHelper.requireNonNull(constants$787.CertEnumSubjectInSortedCTL$MH,"CertEnumSubjectInSortedCTL");
    }
    public static int CertEnumSubjectInSortedCTL ( Addressable pCtlContext,  Addressable ppvNextSubject,  Addressable pSubjectIdentifier,  Addressable pEncodedAttributes) {
        var mh$ = CertEnumSubjectInSortedCTL$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext, ppvNextSubject, pSubjectIdentifier, pEncodedAttributes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCTL_VERIFY_USAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCTL_VERIFY_USAGE_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertVerifyCTLUsage$MH() {
        return RuntimeHelper.requireNonNull(constants$788.CertVerifyCTLUsage$MH,"CertVerifyCTLUsage");
    }
    public static int CertVerifyCTLUsage ( int dwEncodingType,  int dwSubjectType,  Addressable pvSubject,  Addressable pSubjectUsage,  int dwFlags,  Addressable pVerifyUsagePara,  Addressable pVerifyUsageStatus) {
        var mh$ = CertVerifyCTLUsage$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags, pVerifyUsagePara, pVerifyUsageStatus);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_REVOCATION_CRL_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REVOCATION_CHAIN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REVOCATION_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REVOCATION_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertVerifyRevocation$MH() {
        return RuntimeHelper.requireNonNull(constants$788.CertVerifyRevocation$MH,"CertVerifyRevocation");
    }
    public static int CertVerifyRevocation ( int dwEncodingType,  int dwRevType,  int cContext,  Addressable rgpvContext,  int dwFlags,  Addressable pRevPara,  Addressable pRevStatus) {
        var mh$ = CertVerifyRevocation$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, dwRevType, cContext, rgpvContext, dwFlags, pRevPara, pRevStatus);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCompareIntegerBlob$MH() {
        return RuntimeHelper.requireNonNull(constants$788.CertCompareIntegerBlob$MH,"CertCompareIntegerBlob");
    }
    public static int CertCompareIntegerBlob ( Addressable pInt1,  Addressable pInt2) {
        var mh$ = CertCompareIntegerBlob$MH();
        try {
            return (int)mh$.invokeExact(pInt1, pInt2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCompareCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$788.CertCompareCertificate$MH,"CertCompareCertificate");
    }
    public static int CertCompareCertificate ( int dwCertEncodingType,  Addressable pCertId1,  Addressable pCertId2) {
        var mh$ = CertCompareCertificate$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pCertId1, pCertId2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCompareCertificateName$MH() {
        return RuntimeHelper.requireNonNull(constants$788.CertCompareCertificateName$MH,"CertCompareCertificateName");
    }
    public static int CertCompareCertificateName ( int dwCertEncodingType,  Addressable pCertName1,  Addressable pCertName2) {
        var mh$ = CertCompareCertificateName$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pCertName1, pCertName2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertIsRDNAttrsInCertificateName$MH() {
        return RuntimeHelper.requireNonNull(constants$788.CertIsRDNAttrsInCertificateName$MH,"CertIsRDNAttrsInCertificateName");
    }
    public static int CertIsRDNAttrsInCertificateName ( int dwCertEncodingType,  int dwFlags,  Addressable pCertName,  Addressable pRDN) {
        var mh$ = CertIsRDNAttrsInCertificateName$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, dwFlags, pCertName, pRDN);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertComparePublicKeyInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$789.CertComparePublicKeyInfo$MH,"CertComparePublicKeyInfo");
    }
    public static int CertComparePublicKeyInfo ( int dwCertEncodingType,  Addressable pPublicKey1,  Addressable pPublicKey2) {
        var mh$ = CertComparePublicKeyInfo$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pPublicKey1, pPublicKey2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetPublicKeyLength$MH() {
        return RuntimeHelper.requireNonNull(constants$789.CertGetPublicKeyLength$MH,"CertGetPublicKeyLength");
    }
    public static int CertGetPublicKeyLength ( int dwCertEncodingType,  Addressable pPublicKey) {
        var mh$ = CertGetPublicKeyLength$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pPublicKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyCertificateSignature$MH() {
        return RuntimeHelper.requireNonNull(constants$789.CryptVerifyCertificateSignature$MH,"CryptVerifyCertificateSignature");
    }
    public static int CryptVerifyCertificateSignature ( long hCryptProv,  int dwCertEncodingType,  Addressable pbEncoded,  int cbEncoded,  Addressable pPublicKey) {
        var mh$ = CryptVerifyCertificateSignature$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pPublicKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyCertificateSignatureEx$MH() {
        return RuntimeHelper.requireNonNull(constants$789.CryptVerifyCertificateSignatureEx$MH,"CryptVerifyCertificateSignatureEx");
    }
    public static int CryptVerifyCertificateSignatureEx ( long hCryptProv,  int dwCertEncodingType,  int dwSubjectType,  Addressable pvSubject,  int dwIssuerType,  Addressable pvIssuer,  int dwFlags,  Addressable pvExtra) {
        var mh$ = CryptVerifyCertificateSignatureEx$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, dwSubjectType, pvSubject, dwIssuerType, pvIssuer, dwFlags, pvExtra);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertIsStrongHashToSign$MH() {
        return RuntimeHelper.requireNonNull(constants$789.CertIsStrongHashToSign$MH,"CertIsStrongHashToSign");
    }
    public static int CertIsStrongHashToSign ( Addressable pStrongSignPara,  Addressable pwszCNGHashAlgid,  Addressable pSigningCert) {
        var mh$ = CertIsStrongHashToSign$MH();
        try {
            return (int)mh$.invokeExact(pStrongSignPara, pwszCNGHashAlgid, pSigningCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashToBeSigned$MH() {
        return RuntimeHelper.requireNonNull(constants$789.CryptHashToBeSigned$MH,"CryptHashToBeSigned");
    }
    public static int CryptHashToBeSigned ( long hCryptProv,  int dwCertEncodingType,  Addressable pbEncoded,  int cbEncoded,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptHashToBeSigned$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$790.CryptHashCertificate$MH,"CryptHashCertificate");
    }
    public static int CryptHashCertificate ( long hCryptProv,  int Algid,  int dwFlags,  Addressable pbEncoded,  int cbEncoded,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptHashCertificate$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, Algid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashCertificate2$MH() {
        return RuntimeHelper.requireNonNull(constants$790.CryptHashCertificate2$MH,"CryptHashCertificate2");
    }
    public static int CryptHashCertificate2 ( Addressable pwszCNGHashAlgid,  int dwFlags,  Addressable pvReserved,  Addressable pbEncoded,  int cbEncoded,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptHashCertificate2$MH();
        try {
            return (int)mh$.invokeExact(pwszCNGHashAlgid, dwFlags, pvReserved, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSignCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$790.CryptSignCertificate$MH,"CryptSignCertificate");
    }
    public static int CryptSignCertificate ( long hCryptProvOrNCryptKey,  int dwKeySpec,  int dwCertEncodingType,  Addressable pbEncodedToBeSigned,  int cbEncodedToBeSigned,  Addressable pSignatureAlgorithm,  Addressable pvHashAuxInfo,  Addressable pbSignature,  Addressable pcbSignature) {
        var mh$ = CryptSignCertificate$MH();
        try {
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, pSignatureAlgorithm, pvHashAuxInfo, pbSignature, pcbSignature);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSignAndEncodeCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$790.CryptSignAndEncodeCertificate$MH,"CryptSignAndEncodeCertificate");
    }
    public static int CryptSignAndEncodeCertificate ( long hCryptProvOrNCryptKey,  int dwKeySpec,  int dwCertEncodingType,  Addressable lpszStructType,  Addressable pvStructInfo,  Addressable pSignatureAlgorithm,  Addressable pvHashAuxInfo,  Addressable pbEncoded,  Addressable pcbEncoded) {
        var mh$ = CryptSignAndEncodeCertificate$MH();
        try {
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, lpszStructType, pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertVerifyTimeValidity$MH() {
        return RuntimeHelper.requireNonNull(constants$791.CertVerifyTimeValidity$MH,"CertVerifyTimeValidity");
    }
    public static int CertVerifyTimeValidity ( Addressable pTimeToVerify,  Addressable pCertInfo) {
        var mh$ = CertVerifyTimeValidity$MH();
        try {
            return (int)mh$.invokeExact(pTimeToVerify, pCertInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertVerifyCRLTimeValidity$MH() {
        return RuntimeHelper.requireNonNull(constants$791.CertVerifyCRLTimeValidity$MH,"CertVerifyCRLTimeValidity");
    }
    public static int CertVerifyCRLTimeValidity ( Addressable pTimeToVerify,  Addressable pCrlInfo) {
        var mh$ = CertVerifyCRLTimeValidity$MH();
        try {
            return (int)mh$.invokeExact(pTimeToVerify, pCrlInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertVerifyValidityNesting$MH() {
        return RuntimeHelper.requireNonNull(constants$792.CertVerifyValidityNesting$MH,"CertVerifyValidityNesting");
    }
    public static int CertVerifyValidityNesting ( Addressable pSubjectInfo,  Addressable pIssuerInfo) {
        var mh$ = CertVerifyValidityNesting$MH();
        try {
            return (int)mh$.invokeExact(pSubjectInfo, pIssuerInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertVerifyCRLRevocation$MH() {
        return RuntimeHelper.requireNonNull(constants$792.CertVerifyCRLRevocation$MH,"CertVerifyCRLRevocation");
    }
    public static int CertVerifyCRLRevocation ( int dwCertEncodingType,  Addressable pCertId,  int cCrlInfo,  Addressable rgpCrlInfo) {
        var mh$ = CertVerifyCRLRevocation$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pCertId, cCrlInfo, rgpCrlInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAlgIdToOID$MH() {
        return RuntimeHelper.requireNonNull(constants$792.CertAlgIdToOID$MH,"CertAlgIdToOID");
    }
    public static MemoryAddress CertAlgIdToOID ( int dwAlgId) {
        var mh$ = CertAlgIdToOID$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwAlgId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertOIDToAlgId$MH() {
        return RuntimeHelper.requireNonNull(constants$792.CertOIDToAlgId$MH,"CertOIDToAlgId");
    }
    public static int CertOIDToAlgId ( Addressable pszObjId) {
        var mh$ = CertOIDToAlgId$MH();
        try {
            return (int)mh$.invokeExact(pszObjId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindExtension$MH() {
        return RuntimeHelper.requireNonNull(constants$792.CertFindExtension$MH,"CertFindExtension");
    }
    public static MemoryAddress CertFindExtension ( Addressable pszObjId,  int cExtensions,  Addressable rgExtensions) {
        var mh$ = CertFindExtension$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pszObjId, cExtensions, rgExtensions);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindAttribute$MH() {
        return RuntimeHelper.requireNonNull(constants$792.CertFindAttribute$MH,"CertFindAttribute");
    }
    public static MemoryAddress CertFindAttribute ( Addressable pszObjId,  int cAttr,  Addressable rgAttr) {
        var mh$ = CertFindAttribute$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pszObjId, cAttr, rgAttr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindRDNAttr$MH() {
        return RuntimeHelper.requireNonNull(constants$793.CertFindRDNAttr$MH,"CertFindRDNAttr");
    }
    public static MemoryAddress CertFindRDNAttr ( Addressable pszObjId,  Addressable pName) {
        var mh$ = CertFindRDNAttr$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pszObjId, pName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetIntendedKeyUsage$MH() {
        return RuntimeHelper.requireNonNull(constants$793.CertGetIntendedKeyUsage$MH,"CertGetIntendedKeyUsage");
    }
    public static int CertGetIntendedKeyUsage ( int dwCertEncodingType,  Addressable pCertInfo,  Addressable pbKeyUsage,  int cbKeyUsage) {
        var mh$ = CertGetIntendedKeyUsage$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pCertInfo, pbKeyUsage, cbKeyUsage);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress HCRYPTDEFAULTCONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptInstallDefaultContext$MH() {
        return RuntimeHelper.requireNonNull(constants$793.CryptInstallDefaultContext$MH,"CryptInstallDefaultContext");
    }
    public static int CryptInstallDefaultContext ( long hCryptProv,  int dwDefaultType,  Addressable pvDefaultPara,  int dwFlags,  Addressable pvReserved,  Addressable phDefaultContext) {
        var mh$ = CryptInstallDefaultContext$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, pvReserved, phDefaultContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptUninstallDefaultContext$MH() {
        return RuntimeHelper.requireNonNull(constants$793.CryptUninstallDefaultContext$MH,"CryptUninstallDefaultContext");
    }
    public static int CryptUninstallDefaultContext ( Addressable hDefaultContext,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CryptUninstallDefaultContext$MH();
        try {
            return (int)mh$.invokeExact(hDefaultContext, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptExportPublicKeyInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$793.CryptExportPublicKeyInfo$MH,"CryptExportPublicKeyInfo");
    }
    public static int CryptExportPublicKeyInfo ( long hCryptProvOrNCryptKey,  int dwKeySpec,  int dwCertEncodingType,  Addressable pInfo,  Addressable pcbInfo) {
        var mh$ = CryptExportPublicKeyInfo$MH();
        try {
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptExportPublicKeyInfoEx$MH() {
        return RuntimeHelper.requireNonNull(constants$793.CryptExportPublicKeyInfoEx$MH,"CryptExportPublicKeyInfoEx");
    }
    public static int CryptExportPublicKeyInfoEx ( long hCryptProvOrNCryptKey,  int dwKeySpec,  int dwCertEncodingType,  Addressable pszPublicKeyObjId,  int dwFlags,  Addressable pvAuxInfo,  Addressable pInfo,  Addressable pcbInfo) {
        var mh$ = CryptExportPublicKeyInfoEx$MH();
        try {
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptExportPublicKeyInfoFromBCryptKeyHandle$MH() {
        return RuntimeHelper.requireNonNull(constants$794.CryptExportPublicKeyInfoFromBCryptKeyHandle$MH,"CryptExportPublicKeyInfoFromBCryptKeyHandle");
    }
    public static int CryptExportPublicKeyInfoFromBCryptKeyHandle ( Addressable hBCryptKey,  int dwCertEncodingType,  Addressable pszPublicKeyObjId,  int dwFlags,  Addressable pvAuxInfo,  Addressable pInfo,  Addressable pcbInfo) {
        var mh$ = CryptExportPublicKeyInfoFromBCryptKeyHandle$MH();
        try {
            return (int)mh$.invokeExact(hBCryptKey, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptImportPublicKeyInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$794.CryptImportPublicKeyInfo$MH,"CryptImportPublicKeyInfo");
    }
    public static int CryptImportPublicKeyInfo ( long hCryptProv,  int dwCertEncodingType,  Addressable pInfo,  Addressable phKey) {
        var mh$ = CryptImportPublicKeyInfo$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pInfo, phKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptImportPublicKeyInfoEx$MH() {
        return RuntimeHelper.requireNonNull(constants$795.CryptImportPublicKeyInfoEx$MH,"CryptImportPublicKeyInfoEx");
    }
    public static int CryptImportPublicKeyInfoEx ( long hCryptProv,  int dwCertEncodingType,  Addressable pInfo,  int aiKeyAlg,  int dwFlags,  Addressable pvAuxInfo,  Addressable phKey) {
        var mh$ = CryptImportPublicKeyInfoEx$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pInfo, aiKeyAlg, dwFlags, pvAuxInfo, phKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptImportPublicKeyInfoEx2$MH() {
        return RuntimeHelper.requireNonNull(constants$795.CryptImportPublicKeyInfoEx2$MH,"CryptImportPublicKeyInfoEx2");
    }
    public static int CryptImportPublicKeyInfoEx2 ( int dwCertEncodingType,  Addressable pInfo,  int dwFlags,  Addressable pvAuxInfo,  Addressable phKey) {
        var mh$ = CryptImportPublicKeyInfoEx2$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pInfo, dwFlags, pvAuxInfo, phKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptAcquireCertificatePrivateKey$MH() {
        return RuntimeHelper.requireNonNull(constants$795.CryptAcquireCertificatePrivateKey$MH,"CryptAcquireCertificatePrivateKey");
    }
    public static int CryptAcquireCertificatePrivateKey ( Addressable pCert,  int dwFlags,  Addressable pvParameters,  Addressable phCryptProvOrNCryptKey,  Addressable pdwKeySpec,  Addressable pfCallerFreeProvOrNCryptKey) {
        var mh$ = CryptAcquireCertificatePrivateKey$MH();
        try {
            return (int)mh$.invokeExact(pCert, dwFlags, pvParameters, phCryptProvOrNCryptKey, pdwKeySpec, pfCallerFreeProvOrNCryptKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptFindCertificateKeyProvInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$795.CryptFindCertificateKeyProvInfo$MH,"CryptFindCertificateKeyProvInfo");
    }
    public static int CryptFindCertificateKeyProvInfo ( Addressable pCert,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CryptFindCertificateKeyProvInfo$MH();
        try {
            return (int)mh$.invokeExact(pCert, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptImportPKCS8$MH() {
        return RuntimeHelper.requireNonNull(constants$796.CryptImportPKCS8$MH,"CryptImportPKCS8");
    }
    public static int CryptImportPKCS8 ( MemorySegment sPrivateKeyAndParams,  int dwFlags,  Addressable phCryptProv,  Addressable pvAuxInfo) {
        var mh$ = CryptImportPKCS8$MH();
        try {
            return (int)mh$.invokeExact(sPrivateKeyAndParams, dwFlags, phCryptProv, pvAuxInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptExportPKCS8$MH() {
        return RuntimeHelper.requireNonNull(constants$796.CryptExportPKCS8$MH,"CryptExportPKCS8");
    }
    public static int CryptExportPKCS8 ( long hCryptProv,  int dwKeySpec,  Addressable pszPrivateKeyObjId,  int dwFlags,  Addressable pvAuxInfo,  Addressable pbPrivateKeyBlob,  Addressable pcbPrivateKeyBlob) {
        var mh$ = CryptExportPKCS8$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwKeySpec, pszPrivateKeyObjId, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptExportPKCS8Ex$MH() {
        return RuntimeHelper.requireNonNull(constants$797.CryptExportPKCS8Ex$MH,"CryptExportPKCS8Ex");
    }
    public static int CryptExportPKCS8Ex ( Addressable psExportParams,  int dwFlags,  Addressable pvAuxInfo,  Addressable pbPrivateKeyBlob,  Addressable pcbPrivateKeyBlob) {
        var mh$ = CryptExportPKCS8Ex$MH();
        try {
            return (int)mh$.invokeExact(psExportParams, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashPublicKeyInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$797.CryptHashPublicKeyInfo$MH,"CryptHashPublicKeyInfo");
    }
    public static int CryptHashPublicKeyInfo ( long hCryptProv,  int Algid,  int dwFlags,  int dwCertEncodingType,  Addressable pInfo,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptHashPublicKeyInfo$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, Algid, dwFlags, dwCertEncodingType, pInfo, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRDNValueToStrA$MH() {
        return RuntimeHelper.requireNonNull(constants$797.CertRDNValueToStrA$MH,"CertRDNValueToStrA");
    }
    public static int CertRDNValueToStrA ( int dwValueType,  Addressable pValue,  Addressable psz,  int csz) {
        var mh$ = CertRDNValueToStrA$MH();
        try {
            return (int)mh$.invokeExact(dwValueType, pValue, psz, csz);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRDNValueToStrW$MH() {
        return RuntimeHelper.requireNonNull(constants$797.CertRDNValueToStrW$MH,"CertRDNValueToStrW");
    }
    public static int CertRDNValueToStrW ( int dwValueType,  Addressable pValue,  Addressable psz,  int csz) {
        var mh$ = CertRDNValueToStrW$MH();
        try {
            return (int)mh$.invokeExact(dwValueType, pValue, psz, csz);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertNameToStrA$MH() {
        return RuntimeHelper.requireNonNull(constants$797.CertNameToStrA$MH,"CertNameToStrA");
    }
    public static int CertNameToStrA ( int dwCertEncodingType,  Addressable pName,  int dwStrType,  Addressable psz,  int csz) {
        var mh$ = CertNameToStrA$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pName, dwStrType, psz, csz);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertNameToStrW$MH() {
        return RuntimeHelper.requireNonNull(constants$797.CertNameToStrW$MH,"CertNameToStrW");
    }
    public static int CertNameToStrW ( int dwCertEncodingType,  Addressable pName,  int dwStrType,  Addressable psz,  int csz) {
        var mh$ = CertNameToStrW$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pName, dwStrType, psz, csz);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertStrToNameA$MH() {
        return RuntimeHelper.requireNonNull(constants$798.CertStrToNameA$MH,"CertStrToNameA");
    }
    public static int CertStrToNameA ( int dwCertEncodingType,  Addressable pszX500,  int dwStrType,  Addressable pvReserved,  Addressable pbEncoded,  Addressable pcbEncoded,  Addressable ppszError) {
        var mh$ = CertStrToNameA$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertStrToNameW$MH() {
        return RuntimeHelper.requireNonNull(constants$798.CertStrToNameW$MH,"CertStrToNameW");
    }
    public static int CertStrToNameW ( int dwCertEncodingType,  Addressable pszX500,  int dwStrType,  Addressable pvReserved,  Addressable pbEncoded,  Addressable pcbEncoded,  Addressable ppszError) {
        var mh$ = CertStrToNameW$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetNameStringA$MH() {
        return RuntimeHelper.requireNonNull(constants$798.CertGetNameStringA$MH,"CertGetNameStringA");
    }
    public static int CertGetNameStringA ( Addressable pCertContext,  int dwType,  int dwFlags,  Addressable pvTypePara,  Addressable pszNameString,  int cchNameString) {
        var mh$ = CertGetNameStringA$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetNameStringW$MH() {
        return RuntimeHelper.requireNonNull(constants$798.CertGetNameStringW$MH,"CertGetNameStringW");
    }
    public static int CertGetNameStringW ( Addressable pCertContext,  int dwType,  int dwFlags,  Addressable pvTypePara,  Addressable pszNameString,  int cchNameString) {
        var mh$ = CertGetNameStringW$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_SIGN_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_VERIFY_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ENCRYPT_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_DECRYPT_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_HASH_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_KEY_SIGN_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_KEY_VERIFY_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptSignMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$799.CryptSignMessage$MH,"CryptSignMessage");
    }
    public static int CryptSignMessage ( Addressable pSignPara,  int fDetachedSignature,  int cToBeSigned,  Addressable rgpbToBeSigned,  Addressable rgcbToBeSigned,  Addressable pbSignedBlob,  Addressable pcbSignedBlob) {
        var mh$ = CryptSignMessage$MH();
        try {
            return (int)mh$.invokeExact(pSignPara, fDetachedSignature, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, pbSignedBlob, pcbSignedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyMessageSignature$MH() {
        return RuntimeHelper.requireNonNull(constants$799.CryptVerifyMessageSignature$MH,"CryptVerifyMessageSignature");
    }
    public static int CryptVerifyMessageSignature ( Addressable pVerifyPara,  int dwSignerIndex,  Addressable pbSignedBlob,  int cbSignedBlob,  Addressable pbDecoded,  Addressable pcbDecoded,  Addressable ppSignerCert) {
        var mh$ = CryptVerifyMessageSignature$MH();
        try {
            return (int)mh$.invokeExact(pVerifyPara, dwSignerIndex, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded, ppSignerCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetMessageSignerCount$MH() {
        return RuntimeHelper.requireNonNull(constants$799.CryptGetMessageSignerCount$MH,"CryptGetMessageSignerCount");
    }
    public static int CryptGetMessageSignerCount ( int dwMsgEncodingType,  Addressable pbSignedBlob,  int cbSignedBlob) {
        var mh$ = CryptGetMessageSignerCount$MH();
        try {
            return (int)mh$.invokeExact(dwMsgEncodingType, pbSignedBlob, cbSignedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetMessageCertificates$MH() {
        return RuntimeHelper.requireNonNull(constants$799.CryptGetMessageCertificates$MH,"CryptGetMessageCertificates");
    }
    public static MemoryAddress CryptGetMessageCertificates ( int dwMsgAndCertEncodingType,  long hCryptProv,  int dwFlags,  Addressable pbSignedBlob,  int cbSignedBlob) {
        var mh$ = CryptGetMessageCertificates$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwMsgAndCertEncodingType, hCryptProv, dwFlags, pbSignedBlob, cbSignedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyDetachedMessageSignature$MH() {
        return RuntimeHelper.requireNonNull(constants$799.CryptVerifyDetachedMessageSignature$MH,"CryptVerifyDetachedMessageSignature");
    }
    public static int CryptVerifyDetachedMessageSignature ( Addressable pVerifyPara,  int dwSignerIndex,  Addressable pbDetachedSignBlob,  int cbDetachedSignBlob,  int cToBeSigned,  Addressable rgpbToBeSigned,  Addressable rgcbToBeSigned,  Addressable ppSignerCert) {
        var mh$ = CryptVerifyDetachedMessageSignature$MH();
        try {
            return (int)mh$.invokeExact(pVerifyPara, dwSignerIndex, pbDetachedSignBlob, cbDetachedSignBlob, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, ppSignerCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEncryptMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$799.CryptEncryptMessage$MH,"CryptEncryptMessage");
    }
    public static int CryptEncryptMessage ( Addressable pEncryptPara,  int cRecipientCert,  Addressable rgpRecipientCert,  Addressable pbToBeEncrypted,  int cbToBeEncrypted,  Addressable pbEncryptedBlob,  Addressable pcbEncryptedBlob) {
        var mh$ = CryptEncryptMessage$MH();
        try {
            return (int)mh$.invokeExact(pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeEncrypted, cbToBeEncrypted, pbEncryptedBlob, pcbEncryptedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDecryptMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$800.CryptDecryptMessage$MH,"CryptDecryptMessage");
    }
    public static int CryptDecryptMessage ( Addressable pDecryptPara,  Addressable pbEncryptedBlob,  int cbEncryptedBlob,  Addressable pbDecrypted,  Addressable pcbDecrypted,  Addressable ppXchgCert) {
        var mh$ = CryptDecryptMessage$MH();
        try {
            return (int)mh$.invokeExact(pDecryptPara, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSignAndEncryptMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$800.CryptSignAndEncryptMessage$MH,"CryptSignAndEncryptMessage");
    }
    public static int CryptSignAndEncryptMessage ( Addressable pSignPara,  Addressable pEncryptPara,  int cRecipientCert,  Addressable rgpRecipientCert,  Addressable pbToBeSignedAndEncrypted,  int cbToBeSignedAndEncrypted,  Addressable pbSignedAndEncryptedBlob,  Addressable pcbSignedAndEncryptedBlob) {
        var mh$ = CryptSignAndEncryptMessage$MH();
        try {
            return (int)mh$.invokeExact(pSignPara, pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, pbSignedAndEncryptedBlob, pcbSignedAndEncryptedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDecryptAndVerifyMessageSignature$MH() {
        return RuntimeHelper.requireNonNull(constants$800.CryptDecryptAndVerifyMessageSignature$MH,"CryptDecryptAndVerifyMessageSignature");
    }
    public static int CryptDecryptAndVerifyMessageSignature ( Addressable pDecryptPara,  Addressable pVerifyPara,  int dwSignerIndex,  Addressable pbEncryptedBlob,  int cbEncryptedBlob,  Addressable pbDecrypted,  Addressable pcbDecrypted,  Addressable ppXchgCert,  Addressable ppSignerCert) {
        var mh$ = CryptDecryptAndVerifyMessageSignature$MH();
        try {
            return (int)mh$.invokeExact(pDecryptPara, pVerifyPara, dwSignerIndex, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert, ppSignerCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDecodeMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$800.CryptDecodeMessage$MH,"CryptDecodeMessage");
    }
    public static int CryptDecodeMessage ( int dwMsgTypeFlags,  Addressable pDecryptPara,  Addressable pVerifyPara,  int dwSignerIndex,  Addressable pbEncodedBlob,  int cbEncodedBlob,  int dwPrevInnerContentType,  Addressable pdwMsgType,  Addressable pdwInnerContentType,  Addressable pbDecoded,  Addressable pcbDecoded,  Addressable ppXchgCert,  Addressable ppSignerCert) {
        var mh$ = CryptDecodeMessage$MH();
        try {
            return (int)mh$.invokeExact(dwMsgTypeFlags, pDecryptPara, pVerifyPara, dwSignerIndex, pbEncodedBlob, cbEncodedBlob, dwPrevInnerContentType, pdwMsgType, pdwInnerContentType, pbDecoded, pcbDecoded, ppXchgCert, ppSignerCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$800.CryptHashMessage$MH,"CryptHashMessage");
    }
    public static int CryptHashMessage ( Addressable pHashPara,  int fDetachedHash,  int cToBeHashed,  Addressable rgpbToBeHashed,  Addressable rgcbToBeHashed,  Addressable pbHashedBlob,  Addressable pcbHashedBlob,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptHashMessage$MH();
        try {
            return (int)mh$.invokeExact(pHashPara, fDetachedHash, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbHashedBlob, pcbHashedBlob, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyMessageHash$MH() {
        return RuntimeHelper.requireNonNull(constants$800.CryptVerifyMessageHash$MH,"CryptVerifyMessageHash");
    }
    public static int CryptVerifyMessageHash ( Addressable pHashPara,  Addressable pbHashedBlob,  int cbHashedBlob,  Addressable pbToBeHashed,  Addressable pcbToBeHashed,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptVerifyMessageHash$MH();
        try {
            return (int)mh$.invokeExact(pHashPara, pbHashedBlob, cbHashedBlob, pbToBeHashed, pcbToBeHashed, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyDetachedMessageHash$MH() {
        return RuntimeHelper.requireNonNull(constants$801.CryptVerifyDetachedMessageHash$MH,"CryptVerifyDetachedMessageHash");
    }
    public static int CryptVerifyDetachedMessageHash ( Addressable pHashPara,  Addressable pbDetachedHashBlob,  int cbDetachedHashBlob,  int cToBeHashed,  Addressable rgpbToBeHashed,  Addressable rgcbToBeHashed,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptVerifyDetachedMessageHash$MH();
        try {
            return (int)mh$.invokeExact(pHashPara, pbDetachedHashBlob, cbDetachedHashBlob, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSignMessageWithKey$MH() {
        return RuntimeHelper.requireNonNull(constants$801.CryptSignMessageWithKey$MH,"CryptSignMessageWithKey");
    }
    public static int CryptSignMessageWithKey ( Addressable pSignPara,  Addressable pbToBeSigned,  int cbToBeSigned,  Addressable pbSignedBlob,  Addressable pcbSignedBlob) {
        var mh$ = CryptSignMessageWithKey$MH();
        try {
            return (int)mh$.invokeExact(pSignPara, pbToBeSigned, cbToBeSigned, pbSignedBlob, pcbSignedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyMessageSignatureWithKey$MH() {
        return RuntimeHelper.requireNonNull(constants$801.CryptVerifyMessageSignatureWithKey$MH,"CryptVerifyMessageSignatureWithKey");
    }
    public static int CryptVerifyMessageSignatureWithKey ( Addressable pVerifyPara,  Addressable pPublicKeyInfo,  Addressable pbSignedBlob,  int cbSignedBlob,  Addressable pbDecoded,  Addressable pcbDecoded) {
        var mh$ = CryptVerifyMessageSignatureWithKey$MH();
        try {
            return (int)mh$.invokeExact(pVerifyPara, pPublicKeyInfo, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertOpenSystemStoreA$MH() {
        return RuntimeHelper.requireNonNull(constants$801.CertOpenSystemStoreA$MH,"CertOpenSystemStoreA");
    }
    public static MemoryAddress CertOpenSystemStoreA ( long hProv,  Addressable szSubsystemProtocol) {
        var mh$ = CertOpenSystemStoreA$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hProv, szSubsystemProtocol);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertOpenSystemStoreW$MH() {
        return RuntimeHelper.requireNonNull(constants$801.CertOpenSystemStoreW$MH,"CertOpenSystemStoreW");
    }
    public static MemoryAddress CertOpenSystemStoreW ( long hProv,  Addressable szSubsystemProtocol) {
        var mh$ = CertOpenSystemStoreW$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hProv, szSubsystemProtocol);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddEncodedCertificateToSystemStoreA$MH() {
        return RuntimeHelper.requireNonNull(constants$801.CertAddEncodedCertificateToSystemStoreA$MH,"CertAddEncodedCertificateToSystemStoreA");
    }
    public static int CertAddEncodedCertificateToSystemStoreA ( Addressable szCertStoreName,  Addressable pbCertEncoded,  int cbCertEncoded) {
        var mh$ = CertAddEncodedCertificateToSystemStoreA$MH();
        try {
            return (int)mh$.invokeExact(szCertStoreName, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddEncodedCertificateToSystemStoreW$MH() {
        return RuntimeHelper.requireNonNull(constants$802.CertAddEncodedCertificateToSystemStoreW$MH,"CertAddEncodedCertificateToSystemStoreW");
    }
    public static int CertAddEncodedCertificateToSystemStoreW ( Addressable szCertStoreName,  Addressable pbCertEncoded,  int cbCertEncoded) {
        var mh$ = CertAddEncodedCertificateToSystemStoreW$MH();
        try {
            return (int)mh$.invokeExact(szCertStoreName, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_CHAIN = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle FindCertsByIssuer$MH() {
        return RuntimeHelper.requireNonNull(constants$802.FindCertsByIssuer$MH,"FindCertsByIssuer");
    }
    public static int FindCertsByIssuer ( Addressable pCertChains,  Addressable pcbCertChains,  Addressable pcCertChains,  Addressable pbEncodedIssuerName,  int cbEncodedIssuerName,  Addressable pwszPurpose,  int dwKeySpec) {
        var mh$ = FindCertsByIssuer$MH();
        try {
            return (int)mh$.invokeExact(pCertChains, pcbCertChains, pcCertChains, pbEncodedIssuerName, cbEncodedIssuerName, pwszPurpose, dwKeySpec);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptQueryObject$MH() {
        return RuntimeHelper.requireNonNull(constants$802.CryptQueryObject$MH,"CryptQueryObject");
    }
    public static int CryptQueryObject ( int dwObjectType,  Addressable pvObject,  int dwExpectedContentTypeFlags,  int dwExpectedFormatTypeFlags,  int dwFlags,  Addressable pdwMsgAndCertEncodingType,  Addressable pdwContentType,  Addressable pdwFormatType,  Addressable phCertStore,  Addressable phMsg,  Addressable ppvContext) {
        var mh$ = CryptQueryObject$MH();
        try {
            return (int)mh$.invokeExact(dwObjectType, pvObject, dwExpectedContentTypeFlags, dwExpectedFormatTypeFlags, dwFlags, pdwMsgAndCertEncodingType, pdwContentType, pdwFormatType, phCertStore, phMsg, ppvContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMemAlloc$MH() {
        return RuntimeHelper.requireNonNull(constants$802.CryptMemAlloc$MH,"CryptMemAlloc");
    }
    public static MemoryAddress CryptMemAlloc ( int cbSize) {
        var mh$ = CryptMemAlloc$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(cbSize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMemRealloc$MH() {
        return RuntimeHelper.requireNonNull(constants$802.CryptMemRealloc$MH,"CryptMemRealloc");
    }
    public static MemoryAddress CryptMemRealloc ( Addressable pv,  int cbSize) {
        var mh$ = CryptMemRealloc$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pv, cbSize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMemFree$MH() {
        return RuntimeHelper.requireNonNull(constants$802.CryptMemFree$MH,"CryptMemFree");
    }
    public static void CryptMemFree ( Addressable pv) {
        var mh$ = CryptMemFree$MH();
        try {
            mh$.invokeExact(pv);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress HCRYPTASYNC = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PHCRYPTASYNC = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptCreateAsyncHandle$MH() {
        return RuntimeHelper.requireNonNull(constants$803.CryptCreateAsyncHandle$MH,"CryptCreateAsyncHandle");
    }
    public static int CryptCreateAsyncHandle ( int dwFlags,  Addressable phAsync) {
        var mh$ = CryptCreateAsyncHandle$MH();
        try {
            return (int)mh$.invokeExact(dwFlags, phAsync);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetAsyncParam$MH() {
        return RuntimeHelper.requireNonNull(constants$803.CryptSetAsyncParam$MH,"CryptSetAsyncParam");
    }
    public static int CryptSetAsyncParam ( Addressable hAsync,  Addressable pszParamOid,  Addressable pvParam,  Addressable pfnFree) {
        var mh$ = CryptSetAsyncParam$MH();
        try {
            return (int)mh$.invokeExact(hAsync, pszParamOid, pvParam, pfnFree);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetAsyncParam$MH() {
        return RuntimeHelper.requireNonNull(constants$803.CryptGetAsyncParam$MH,"CryptGetAsyncParam");
    }
    public static int CryptGetAsyncParam ( Addressable hAsync,  Addressable pszParamOid,  Addressable ppvParam,  Addressable ppfnFree) {
        var mh$ = CryptGetAsyncParam$MH();
        try {
            return (int)mh$.invokeExact(hAsync, pszParamOid, ppvParam, ppfnFree);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptCloseAsyncHandle$MH() {
        return RuntimeHelper.requireNonNull(constants$803.CryptCloseAsyncHandle$MH,"CryptCloseAsyncHandle");
    }
    public static int CryptCloseAsyncHandle ( Addressable hAsync) {
        var mh$ = CryptCloseAsyncHandle$MH();
        try {
            return (int)mh$.invokeExact(hAsync);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_BLOB_ARRAY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CREDENTIALS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PASSWORD_CREDENTIALSA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PASSWORD_CREDENTIALSW = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PASSWORD_CREDENTIALS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPTNET_URL_CACHE_PRE_FETCH_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPTNET_URL_CACHE_FLUSH_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPTNET_URL_CACHE_RESPONSE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_RETRIEVE_AUX_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptRetrieveObjectByUrlA$MH() {
        return RuntimeHelper.requireNonNull(constants$804.CryptRetrieveObjectByUrlA$MH,"CryptRetrieveObjectByUrlA");
    }
    public static int CryptRetrieveObjectByUrlA ( Addressable pszUrl,  Addressable pszObjectOid,  int dwRetrievalFlags,  int dwTimeout,  Addressable ppvObject,  Addressable hAsyncRetrieve,  Addressable pCredentials,  Addressable pvVerify,  Addressable pAuxInfo) {
        var mh$ = CryptRetrieveObjectByUrlA$MH();
        try {
            return (int)mh$.invokeExact(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptRetrieveObjectByUrlW$MH() {
        return RuntimeHelper.requireNonNull(constants$804.CryptRetrieveObjectByUrlW$MH,"CryptRetrieveObjectByUrlW");
    }
    public static int CryptRetrieveObjectByUrlW ( Addressable pszUrl,  Addressable pszObjectOid,  int dwRetrievalFlags,  int dwTimeout,  Addressable ppvObject,  Addressable hAsyncRetrieve,  Addressable pCredentials,  Addressable pvVerify,  Addressable pAuxInfo) {
        var mh$ = CryptRetrieveObjectByUrlW$MH();
        try {
            return (int)mh$.invokeExact(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptInstallCancelRetrieval$MH() {
        return RuntimeHelper.requireNonNull(constants$805.CryptInstallCancelRetrieval$MH,"CryptInstallCancelRetrieval");
    }
    public static int CryptInstallCancelRetrieval ( Addressable pfnCancel,  Addressable pvArg,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CryptInstallCancelRetrieval$MH();
        try {
            return (int)mh$.invokeExact(pfnCancel, pvArg, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUninstallCancelRetrieval$MH() {
        return RuntimeHelper.requireNonNull(constants$805.CryptUninstallCancelRetrieval$MH,"CryptUninstallCancelRetrieval");
    }
    public static int CryptUninstallCancelRetrieval ( int dwFlags,  Addressable pvReserved) {
        var mh$ = CryptUninstallCancelRetrieval$MH();
        try {
            return (int)mh$.invokeExact(dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptCancelAsyncRetrieval$MH() {
        return RuntimeHelper.requireNonNull(constants$805.CryptCancelAsyncRetrieval$MH,"CryptCancelAsyncRetrieval");
    }
    public static int CryptCancelAsyncRetrieval ( Addressable hAsyncRetrieval) {
        var mh$ = CryptCancelAsyncRetrieval$MH();
        try {
            return (int)mh$.invokeExact(hAsyncRetrieval);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_ASYNC_RETRIEVAL_COMPLETION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_URL_ARRAY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_URL_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptGetObjectUrl$MH() {
        return RuntimeHelper.requireNonNull(constants$806.CryptGetObjectUrl$MH,"CryptGetObjectUrl");
    }
    public static int CryptGetObjectUrl ( Addressable pszUrlOid,  Addressable pvPara,  int dwFlags,  Addressable pUrlArray,  Addressable pcbUrlArray,  Addressable pUrlInfo,  Addressable pcbUrlInfo,  Addressable pvReserved) {
        var mh$ = CryptGetObjectUrl$MH();
        try {
            return (int)mh$.invokeExact(pszUrlOid, pvPara, dwFlags, pUrlArray, pcbUrlArray, pUrlInfo, pcbUrlInfo, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_CRL_CONTEXT_PAIR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_CRL_CONTEXT_PAIR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptGetTimeValidObject$MH() {
        return RuntimeHelper.requireNonNull(constants$806.CryptGetTimeValidObject$MH,"CryptGetTimeValidObject");
    }
    public static int CryptGetTimeValidObject ( Addressable pszTimeValidOid,  Addressable pvPara,  Addressable pIssuer,  Addressable pftValidFor,  int dwFlags,  int dwTimeout,  Addressable ppvObject,  Addressable pCredentials,  Addressable pExtraInfo) {
        var mh$ = CryptGetTimeValidObject$MH();
        try {
            return (int)mh$.invokeExact(pszTimeValidOid, pvPara, pIssuer, pftValidFor, dwFlags, dwTimeout, ppvObject, pCredentials, pExtraInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptFlushTimeValidObject$MH() {
        return RuntimeHelper.requireNonNull(constants$806.CryptFlushTimeValidObject$MH,"CryptFlushTimeValidObject");
    }
    public static int CryptFlushTimeValidObject ( Addressable pszFlushTimeValidOid,  Addressable pvPara,  Addressable pIssuer,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CryptFlushTimeValidObject$MH();
        try {
            return (int)mh$.invokeExact(pszFlushTimeValidOid, pvPara, pIssuer, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCreateSelfSignCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$806.CertCreateSelfSignCertificate$MH,"CertCreateSelfSignCertificate");
    }
    public static MemoryAddress CertCreateSelfSignCertificate ( long hCryptProvOrNCryptKey,  Addressable pSubjectIssuerBlob,  int dwFlags,  Addressable pKeyProvInfo,  Addressable pSignatureAlgorithm,  Addressable pStartTime,  Addressable pEndTime,  Addressable pExtensions) {
        var mh$ = CertCreateSelfSignCertificate$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCryptProvOrNCryptKey, pSubjectIssuerBlob, dwFlags, pKeyProvInfo, pSignatureAlgorithm, pStartTime, pEndTime, pExtensions);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetKeyIdentifierProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$806.CryptGetKeyIdentifierProperty$MH,"CryptGetKeyIdentifierProperty");
    }
    public static int CryptGetKeyIdentifierProperty ( Addressable pKeyIdentifier,  int dwPropId,  int dwFlags,  Addressable pwszComputerName,  Addressable pvReserved,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CryptGetKeyIdentifierProperty$MH();
        try {
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetKeyIdentifierProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$807.CryptSetKeyIdentifierProperty$MH,"CryptSetKeyIdentifierProperty");
    }
    public static int CryptSetKeyIdentifierProperty ( Addressable pKeyIdentifier,  int dwPropId,  int dwFlags,  Addressable pwszComputerName,  Addressable pvReserved,  Addressable pvData) {
        var mh$ = CryptSetKeyIdentifierProperty$MH();
        try {
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEnumKeyIdentifierProperties$MH() {
        return RuntimeHelper.requireNonNull(constants$807.CryptEnumKeyIdentifierProperties$MH,"CryptEnumKeyIdentifierProperties");
    }
    public static int CryptEnumKeyIdentifierProperties ( Addressable pKeyIdentifier,  int dwPropId,  int dwFlags,  Addressable pwszComputerName,  Addressable pvReserved,  Addressable pvArg,  Addressable pfnEnum) {
        var mh$ = CryptEnumKeyIdentifierProperties$MH();
        try {
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvArg, pfnEnum);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptCreateKeyIdentifierFromCSP$MH() {
        return RuntimeHelper.requireNonNull(constants$807.CryptCreateKeyIdentifierFromCSP$MH,"CryptCreateKeyIdentifierFromCSP");
    }
    public static int CryptCreateKeyIdentifierFromCSP ( int dwCertEncodingType,  Addressable pszPubKeyOID,  Addressable pPubKeyStruc,  int cbPubKeyStruc,  int dwFlags,  Addressable pvReserved,  Addressable pbHash,  Addressable pcbHash) {
        var mh$ = CryptCreateKeyIdentifierFromCSP$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pszPubKeyOID, pPubKeyStruc, cbPubKeyStruc, dwFlags, pvReserved, pbHash, pcbHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress HCERTCHAINENGINE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_ENGINE_CONFIG = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertCreateCertificateChainEngine$MH() {
        return RuntimeHelper.requireNonNull(constants$807.CertCreateCertificateChainEngine$MH,"CertCreateCertificateChainEngine");
    }
    public static int CertCreateCertificateChainEngine ( Addressable pConfig,  Addressable phChainEngine) {
        var mh$ = CertCreateCertificateChainEngine$MH();
        try {
            return (int)mh$.invokeExact(pConfig, phChainEngine);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCertificateChainEngine$MH() {
        return RuntimeHelper.requireNonNull(constants$808.CertFreeCertificateChainEngine$MH,"CertFreeCertificateChainEngine");
    }
    public static void CertFreeCertificateChainEngine ( Addressable hChainEngine) {
        var mh$ = CertFreeCertificateChainEngine$MH();
        try {
            mh$.invokeExact(hChainEngine);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertResyncCertificateChainEngine$MH() {
        return RuntimeHelper.requireNonNull(constants$808.CertResyncCertificateChainEngine$MH,"CertResyncCertificateChainEngine");
    }
    public static int CertResyncCertificateChainEngine ( Addressable hChainEngine) {
        var mh$ = CertResyncCertificateChainEngine$MH();
        try {
            return (int)mh$.invokeExact(hChainEngine);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_TRUST_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REVOCATION_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_TRUST_LIST_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_ELEMENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_CHAIN_ELEMENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SIMPLE_CHAIN = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_SIMPLE_CHAIN = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_CHAIN_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_USAGE_MATCH = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCTL_USAGE_MATCH = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertGetCertificateChain$MH() {
        return RuntimeHelper.requireNonNull(constants$808.CertGetCertificateChain$MH,"CertGetCertificateChain");
    }
    public static int CertGetCertificateChain ( Addressable hChainEngine,  Addressable pCertContext,  Addressable pTime,  Addressable hAdditionalStore,  Addressable pChainPara,  int dwFlags,  Addressable pvReserved,  Addressable ppChainContext) {
        var mh$ = CertGetCertificateChain$MH();
        try {
            return (int)mh$.invokeExact(hChainEngine, pCertContext, pTime, hAdditionalStore, pChainPara, dwFlags, pvReserved, ppChainContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCertificateChain$MH() {
        return RuntimeHelper.requireNonNull(constants$808.CertFreeCertificateChain$MH,"CertFreeCertificateChain");
    }
    public static void CertFreeCertificateChain ( Addressable pChainContext) {
        var mh$ = CertFreeCertificateChain$MH();
        try {
            mh$.invokeExact(pChainContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDuplicateCertificateChain$MH() {
        return RuntimeHelper.requireNonNull(constants$808.CertDuplicateCertificateChain$MH,"CertDuplicateCertificateChain");
    }
    public static MemoryAddress CertDuplicateCertificateChain ( Addressable pChainContext) {
        var mh$ = CertDuplicateCertificateChain$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pChainContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRL_REVOCATION_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertFindChainInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$808.CertFindChainInStore$MH,"CertFindChainInStore");
    }
    public static MemoryAddress CertFindChainInStore ( Addressable hCertStore,  int dwCertEncodingType,  int dwFindFlags,  int dwFindType,  Addressable pvFindPara,  Addressable pPrevChainContext) {
        var mh$ = CertFindChainInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevChainContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_CHAIN_FIND_ISSUER_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_FIND_BY_ISSUER_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_POLICY_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertVerifyCertificateChainPolicy$MH() {
        return RuntimeHelper.requireNonNull(constants$809.CertVerifyCertificateChainPolicy$MH,"CertVerifyCertificateChainPolicy");
    }
    public static int CertVerifyCertificateChainPolicy ( Addressable pszPolicyOID,  Addressable pChainContext,  Addressable pPolicyPara,  Addressable pPolicyStatus) {
        var mh$ = CertVerifyCertificateChainPolicy$MH();
        try {
            return (int)mh$.invokeExact(pszPolicyOID, pChainContext, pPolicyPara, pPolicyStatus);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PHTTPSPolicyCallbackData = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSSL_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEV_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEV_EXTRA_CERT_CHAIN_POLICY_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptStringToBinaryA$MH() {
        return RuntimeHelper.requireNonNull(constants$809.CryptStringToBinaryA$MH,"CryptStringToBinaryA");
    }
    public static int CryptStringToBinaryA ( Addressable pszString,  int cchString,  int dwFlags,  Addressable pbBinary,  Addressable pcbBinary,  Addressable pdwSkip,  Addressable pdwFlags) {
        var mh$ = CryptStringToBinaryA$MH();
        try {
            return (int)mh$.invokeExact(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptStringToBinaryW$MH() {
        return RuntimeHelper.requireNonNull(constants$809.CryptStringToBinaryW$MH,"CryptStringToBinaryW");
    }
    public static int CryptStringToBinaryW ( Addressable pszString,  int cchString,  int dwFlags,  Addressable pbBinary,  Addressable pcbBinary,  Addressable pdwSkip,  Addressable pdwFlags) {
        var mh$ = CryptStringToBinaryW$MH();
        try {
            return (int)mh$.invokeExact(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptBinaryToStringA$MH() {
        return RuntimeHelper.requireNonNull(constants$809.CryptBinaryToStringA$MH,"CryptBinaryToStringA");
    }
    public static int CryptBinaryToStringA ( Addressable pbBinary,  int cbBinary,  int dwFlags,  Addressable pszString,  Addressable pcchString) {
        var mh$ = CryptBinaryToStringA$MH();
        try {
            return (int)mh$.invokeExact(pbBinary, cbBinary, dwFlags, pszString, pcchString);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptBinaryToStringW$MH() {
        return RuntimeHelper.requireNonNull(constants$810.CryptBinaryToStringW$MH,"CryptBinaryToStringW");
    }
    public static int CryptBinaryToStringW ( Addressable pbBinary,  int cbBinary,  int dwFlags,  Addressable pszString,  Addressable pcchString) {
        var mh$ = CryptBinaryToStringW$MH();
        try {
            return (int)mh$.invokeExact(pbBinary, cbBinary, dwFlags, pszString, pcchString);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle PFXImportCertStore$MH() {
        return RuntimeHelper.requireNonNull(constants$810.PFXImportCertStore$MH,"PFXImportCertStore");
    }
    public static MemoryAddress PFXImportCertStore ( Addressable pPFX,  Addressable szPassword,  int dwFlags) {
        var mh$ = PFXImportCertStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle PFXIsPFXBlob$MH() {
        return RuntimeHelper.requireNonNull(constants$810.PFXIsPFXBlob$MH,"PFXIsPFXBlob");
    }
    public static int PFXIsPFXBlob ( Addressable pPFX) {
        var mh$ = PFXIsPFXBlob$MH();
        try {
            return (int)mh$.invokeExact(pPFX);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle PFXVerifyPassword$MH() {
        return RuntimeHelper.requireNonNull(constants$810.PFXVerifyPassword$MH,"PFXVerifyPassword");
    }
    public static int PFXVerifyPassword ( Addressable pPFX,  Addressable szPassword,  int dwFlags) {
        var mh$ = PFXVerifyPassword$MH();
        try {
            return (int)mh$.invokeExact(pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle PFXExportCertStoreEx$MH() {
        return RuntimeHelper.requireNonNull(constants$810.PFXExportCertStoreEx$MH,"PFXExportCertStoreEx");
    }
    public static int PFXExportCertStoreEx ( Addressable hStore,  Addressable pPFX,  Addressable szPassword,  Addressable pvPara,  int dwFlags) {
        var mh$ = PFXExportCertStoreEx$MH();
        try {
            return (int)mh$.invokeExact(hStore, pPFX, szPassword, pvPara, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PPKCS12_PBES2_EXPORT_PARAMS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle PFXExportCertStore$MH() {
        return RuntimeHelper.requireNonNull(constants$810.PFXExportCertStore$MH,"PFXExportCertStore");
    }
    public static int PFXExportCertStore ( Addressable hStore,  Addressable pPFX,  Addressable szPassword,  int dwFlags) {
        var mh$ = PFXExportCertStore$MH();
        try {
            return (int)mh$.invokeExact(hStore, pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress HCERT_SERVER_OCSP_RESPONSE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SERVER_OCSP_RESPONSE_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_SERVER_OCSP_RESPONSE_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertOpenServerOcspResponse$MH() {
        return RuntimeHelper.requireNonNull(constants$811.CertOpenServerOcspResponse$MH,"CertOpenServerOcspResponse");
    }
    public static MemoryAddress CertOpenServerOcspResponse ( Addressable pChainContext,  int dwFlags,  Addressable pOpenPara) {
        var mh$ = CertOpenServerOcspResponse$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pChainContext, dwFlags, pOpenPara);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddRefServerOcspResponse$MH() {
        return RuntimeHelper.requireNonNull(constants$811.CertAddRefServerOcspResponse$MH,"CertAddRefServerOcspResponse");
    }
    public static void CertAddRefServerOcspResponse ( Addressable hServerOcspResponse) {
        var mh$ = CertAddRefServerOcspResponse$MH();
        try {
            mh$.invokeExact(hServerOcspResponse);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCloseServerOcspResponse$MH() {
        return RuntimeHelper.requireNonNull(constants$811.CertCloseServerOcspResponse$MH,"CertCloseServerOcspResponse");
    }
    public static void CertCloseServerOcspResponse ( Addressable hServerOcspResponse,  int dwFlags) {
        var mh$ = CertCloseServerOcspResponse$MH();
        try {
            mh$.invokeExact(hServerOcspResponse, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetServerOcspResponseContext$MH() {
        return RuntimeHelper.requireNonNull(constants$811.CertGetServerOcspResponseContext$MH,"CertGetServerOcspResponseContext");
    }
    public static MemoryAddress CertGetServerOcspResponseContext ( Addressable hServerOcspResponse,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CertGetServerOcspResponseContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hServerOcspResponse, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddRefServerOcspResponseContext$MH() {
        return RuntimeHelper.requireNonNull(constants$812.CertAddRefServerOcspResponseContext$MH,"CertAddRefServerOcspResponseContext");
    }
    public static void CertAddRefServerOcspResponseContext ( Addressable pServerOcspResponseContext) {
        var mh$ = CertAddRefServerOcspResponseContext$MH();
        try {
            mh$.invokeExact(pServerOcspResponseContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeServerOcspResponseContext$MH() {
        return RuntimeHelper.requireNonNull(constants$812.CertFreeServerOcspResponseContext$MH,"CertFreeServerOcspResponseContext");
    }
    public static void CertFreeServerOcspResponseContext ( Addressable pServerOcspResponseContext) {
        var mh$ = CertFreeServerOcspResponseContext$MH();
        try {
            mh$.invokeExact(pServerOcspResponseContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRetrieveLogoOrBiometricInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$812.CertRetrieveLogoOrBiometricInfo$MH,"CertRetrieveLogoOrBiometricInfo");
    }
    public static int CertRetrieveLogoOrBiometricInfo ( Addressable pCertContext,  Addressable lpszLogoOrBiometricType,  int dwRetrievalFlags,  int dwTimeout,  int dwFlags,  Addressable pvReserved,  Addressable ppbData,  Addressable pcbData,  Addressable ppwszMimeType) {
        var mh$ = CertRetrieveLogoOrBiometricInfo$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, lpszLogoOrBiometricType, dwRetrievalFlags, dwTimeout, dwFlags, pvReserved, ppbData, pcbData, ppwszMimeType);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_SELECT_CHAIN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_SELECT_CHAIN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SELECT_CRITERIA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_SELECT_CRITERIA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertSelectCertificateChains$MH() {
        return RuntimeHelper.requireNonNull(constants$812.CertSelectCertificateChains$MH,"CertSelectCertificateChains");
    }
    public static int CertSelectCertificateChains ( Addressable pSelectionContext,  int dwFlags,  Addressable pChainParameters,  int cCriteria,  Addressable rgpCriteria,  Addressable hStore,  Addressable pcSelection,  Addressable pprgpSelection) {
        var mh$ = CertSelectCertificateChains$MH();
        try {
            return (int)mh$.invokeExact(pSelectionContext, dwFlags, pChainParameters, cCriteria, rgpCriteria, hStore, pcSelection, pprgpSelection);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCertificateChainList$MH() {
        return RuntimeHelper.requireNonNull(constants$812.CertFreeCertificateChainList$MH,"CertFreeCertificateChainList");
    }
    public static void CertFreeCertificateChainList ( Addressable prgpSelection) {
        var mh$ = CertFreeCertificateChainList$MH();
        try {
            mh$.invokeExact(prgpSelection);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_TIMESTAMP_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_TIMESTAMP_RESPONSE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_TIMESTAMP_ACCURACY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_TIMESTAMP_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_TIMESTAMP_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_TIMESTAMP_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptRetrieveTimeStamp$MH() {
        return RuntimeHelper.requireNonNull(constants$812.CryptRetrieveTimeStamp$MH,"CryptRetrieveTimeStamp");
    }
    public static int CryptRetrieveTimeStamp ( Addressable wszUrl,  int dwRetrievalFlags,  int dwTimeout,  Addressable pszHashId,  Addressable pPara,  Addressable pbData,  int cbData,  Addressable ppTsContext,  Addressable ppTsSigner,  Addressable phStore) {
        var mh$ = CryptRetrieveTimeStamp$MH();
        try {
            return (int)mh$.invokeExact(wszUrl, dwRetrievalFlags, dwTimeout, pszHashId, pPara, pbData, cbData, ppTsContext, ppTsSigner, phStore);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyTimeStampSignature$MH() {
        return RuntimeHelper.requireNonNull(constants$813.CryptVerifyTimeStampSignature$MH,"CryptVerifyTimeStampSignature");
    }
    public static int CryptVerifyTimeStampSignature ( Addressable pbTSContentInfo,  int cbTSContentInfo,  Addressable pbData,  int cbData,  Addressable hAdditionalStore,  Addressable ppTsContext,  Addressable ppTsSigner,  Addressable phStore) {
        var mh$ = CryptVerifyTimeStampSignature$MH();
        try {
            return (int)mh$.invokeExact(pbTSContentInfo, cbTSContentInfo, pbData, cbData, hAdditionalStore, ppTsContext, ppTsSigner, phStore);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertIsWeakHash$MH() {
        return RuntimeHelper.requireNonNull(constants$815.CertIsWeakHash$MH,"CertIsWeakHash");
    }
    public static int CertIsWeakHash ( int dwHashUseType,  Addressable pwszCNGHashAlgid,  int dwChainFlags,  Addressable pSignerChainContext,  Addressable pTimeStamp,  Addressable pwszFileName) {
        var mh$ = CertIsWeakHash$MH();
        try {
            return (int)mh$.invokeExact(dwHashUseType, pwszCNGHashAlgid, dwChainFlags, pSignerChainContext, pTimeStamp, pwszFileName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPTPROTECT_PROMPTSTRUCT = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptProtectData$MH() {
        return RuntimeHelper.requireNonNull(constants$816.CryptProtectData$MH,"CryptProtectData");
    }
    public static int CryptProtectData ( Addressable pDataIn,  Addressable szDataDescr,  Addressable pOptionalEntropy,  Addressable pvReserved,  Addressable pPromptStruct,  int dwFlags,  Addressable pDataOut) {
        var mh$ = CryptProtectData$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnprotectData$MH() {
        return RuntimeHelper.requireNonNull(constants$816.CryptUnprotectData$MH,"CryptUnprotectData");
    }
    public static int CryptUnprotectData ( Addressable pDataIn,  Addressable ppszDataDescr,  Addressable pOptionalEntropy,  Addressable pvReserved,  Addressable pPromptStruct,  int dwFlags,  Addressable pDataOut) {
        var mh$ = CryptUnprotectData$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptProtectDataNoUI$MH() {
        return RuntimeHelper.requireNonNull(constants$816.CryptProtectDataNoUI$MH,"CryptProtectDataNoUI");
    }
    public static int CryptProtectDataNoUI ( Addressable pDataIn,  Addressable szDataDescr,  Addressable pOptionalEntropy,  Addressable pvReserved,  Addressable pPromptStruct,  int dwFlags,  Addressable pbOptionalPassword,  int cbOptionalPassword,  Addressable pDataOut) {
        var mh$ = CryptProtectDataNoUI$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnprotectDataNoUI$MH() {
        return RuntimeHelper.requireNonNull(constants$816.CryptUnprotectDataNoUI$MH,"CryptUnprotectDataNoUI");
    }
    public static int CryptUnprotectDataNoUI ( Addressable pDataIn,  Addressable ppszDataDescr,  Addressable pOptionalEntropy,  Addressable pvReserved,  Addressable pPromptStruct,  int dwFlags,  Addressable pbOptionalPassword,  int cbOptionalPassword,  Addressable pDataOut) {
        var mh$ = CryptUnprotectDataNoUI$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUpdateProtectedState$MH() {
        return RuntimeHelper.requireNonNull(constants$816.CryptUpdateProtectedState$MH,"CryptUpdateProtectedState");
    }
    public static int CryptUpdateProtectedState ( Addressable pOldSid,  Addressable pwszOldPassword,  int dwFlags,  Addressable pdwSuccessCount,  Addressable pdwFailureCount) {
        var mh$ = CryptUpdateProtectedState$MH();
        try {
            return (int)mh$.invokeExact(pOldSid, pwszOldPassword, dwFlags, pdwSuccessCount, pdwFailureCount);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptProtectMemory$MH() {
        return RuntimeHelper.requireNonNull(constants$816.CryptProtectMemory$MH,"CryptProtectMemory");
    }
    public static int CryptProtectMemory ( Addressable pDataIn,  int cbDataIn,  int dwFlags) {
        var mh$ = CryptProtectMemory$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, cbDataIn, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnprotectMemory$MH() {
        return RuntimeHelper.requireNonNull(constants$817.CryptUnprotectMemory$MH,"CryptUnprotectMemory");
    }
    public static int CryptUnprotectMemory ( Addressable pDataIn,  int cbDataIn,  int dwFlags) {
        var mh$ = CryptUnprotectMemory$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, cbDataIn, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PEFS_CERTIFICATE_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_HASH_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_RPC_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_PIN_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_KEY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_COMPATIBILITY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_VERSION_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_DECRYPTION_STATUS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_ENCRYPTION_STATUS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_CERTIFICATE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_CERTIFICATE_HASH = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_CERTIFICATE_HASH_LIST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_CERTIFICATE_LIST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTED_FILE_METADATA_SIGNATURE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_PROTECTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_PROTECTOR_LIST = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle QueryUsersOnEncryptedFile$MH() {
        return RuntimeHelper.requireNonNull(constants$817.QueryUsersOnEncryptedFile$MH,"QueryUsersOnEncryptedFile");
    }
    public static int QueryUsersOnEncryptedFile ( Addressable lpFileName,  Addressable pUsers) {
        var mh$ = QueryUsersOnEncryptedFile$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pUsers);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle QueryRecoveryAgentsOnEncryptedFile$MH() {
        return RuntimeHelper.requireNonNull(constants$817.QueryRecoveryAgentsOnEncryptedFile$MH,"QueryRecoveryAgentsOnEncryptedFile");
    }
    public static int QueryRecoveryAgentsOnEncryptedFile ( Addressable lpFileName,  Addressable pRecoveryAgents) {
        var mh$ = QueryRecoveryAgentsOnEncryptedFile$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pRecoveryAgents);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle RemoveUsersFromEncryptedFile$MH() {
        return RuntimeHelper.requireNonNull(constants$817.RemoveUsersFromEncryptedFile$MH,"RemoveUsersFromEncryptedFile");
    }
    public static int RemoveUsersFromEncryptedFile ( Addressable lpFileName,  Addressable pHashes) {
        var mh$ = RemoveUsersFromEncryptedFile$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pHashes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle AddUsersToEncryptedFile$MH() {
        return RuntimeHelper.requireNonNull(constants$817.AddUsersToEncryptedFile$MH,"AddUsersToEncryptedFile");
    }
    public static int AddUsersToEncryptedFile ( Addressable lpFileName,  Addressable pEncryptionCertificates) {
        var mh$ = AddUsersToEncryptedFile$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pEncryptionCertificates);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SetUserFileEncryptionKey$MH() {
        return RuntimeHelper.requireNonNull(constants$817.SetUserFileEncryptionKey$MH,"SetUserFileEncryptionKey");
    }
    public static int SetUserFileEncryptionKey ( Addressable pEncryptionCertificate) {
        var mh$ = SetUserFileEncryptionKey$MH();
        try {
            return (int)mh$.invokeExact(pEncryptionCertificate);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SetUserFileEncryptionKeyEx$MH() {
        return RuntimeHelper.requireNonNull(constants$818.SetUserFileEncryptionKeyEx$MH,"SetUserFileEncryptionKeyEx");
    }
    public static int SetUserFileEncryptionKeyEx ( Addressable pEncryptionCertificate,  int dwCapabilities,  int dwFlags,  Addressable pvReserved) {
        var mh$ = SetUserFileEncryptionKeyEx$MH();
        try {
            return (int)mh$.invokeExact(pEncryptionCertificate, dwCapabilities, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle FreeEncryptionCertificateHashList$MH() {
        return RuntimeHelper.requireNonNull(constants$818.FreeEncryptionCertificateHashList$MH,"FreeEncryptionCertificateHashList");
    }
    public static void FreeEncryptionCertificateHashList ( Addressable pUsers) {
        var mh$ = FreeEncryptionCertificateHashList$MH();
        try {
            mh$.invokeExact(pUsers);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle EncryptionDisable$MH() {
        return RuntimeHelper.requireNonNull(constants$818.EncryptionDisable$MH,"EncryptionDisable");
    }
    public static int EncryptionDisable ( Addressable DirPath,  int Disable) {
        var mh$ = EncryptionDisable$MH();
        try {
            return (int)mh$.invokeExact(DirPath, Disable);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DuplicateEncryptionInfoFile$MH() {
        return RuntimeHelper.requireNonNull(constants$818.DuplicateEncryptionInfoFile$MH,"DuplicateEncryptionInfoFile");
    }
    public static int DuplicateEncryptionInfoFile ( Addressable SrcFileName,  Addressable DstFileName,  int dwCreationDistribution,  int dwAttributes,  Addressable lpSecurityAttributes) {
        var mh$ = DuplicateEncryptionInfoFile$MH();
        try {
            return (int)mh$.invokeExact(SrcFileName, DstFileName, dwCreationDistribution, dwAttributes, lpSecurityAttributes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetEncryptedFileMetadata$MH() {
        return RuntimeHelper.requireNonNull(constants$818.GetEncryptedFileMetadata$MH,"GetEncryptedFileMetadata");
    }
    public static int GetEncryptedFileMetadata ( Addressable lpFileName,  Addressable pcbMetadata,  Addressable ppbMetadata) {
        var mh$ = GetEncryptedFileMetadata$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pcbMetadata, ppbMetadata);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SetEncryptedFileMetadata$MH() {
        return RuntimeHelper.requireNonNull(constants$818.SetEncryptedFileMetadata$MH,"SetEncryptedFileMetadata");
    }
    public static int SetEncryptedFileMetadata ( Addressable lpFileName,  Addressable pbOldMetadata,  Addressable pbNewMetadata,  Addressable pOwnerHash,  int dwOperation,  Addressable pCertificatesAdded) {
        var mh$ = SetEncryptedFileMetadata$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pbOldMetadata, pbNewMetadata, pOwnerHash, dwOperation, pCertificatesAdded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
}


