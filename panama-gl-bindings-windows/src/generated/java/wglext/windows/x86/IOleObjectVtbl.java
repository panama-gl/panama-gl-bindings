// Generated by jextract

package wglext.windows.x86;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class IOleObjectVtbl {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("QueryInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("AddRef"),
        Constants$root.C_POINTER$LAYOUT.withName("Release"),
        Constants$root.C_POINTER$LAYOUT.withName("SetClientSite"),
        Constants$root.C_POINTER$LAYOUT.withName("GetClientSite"),
        Constants$root.C_POINTER$LAYOUT.withName("SetHostNames"),
        Constants$root.C_POINTER$LAYOUT.withName("Close"),
        Constants$root.C_POINTER$LAYOUT.withName("SetMoniker"),
        Constants$root.C_POINTER$LAYOUT.withName("GetMoniker"),
        Constants$root.C_POINTER$LAYOUT.withName("InitFromData"),
        Constants$root.C_POINTER$LAYOUT.withName("GetClipboardData"),
        Constants$root.C_POINTER$LAYOUT.withName("DoVerb"),
        Constants$root.C_POINTER$LAYOUT.withName("EnumVerbs"),
        Constants$root.C_POINTER$LAYOUT.withName("Update"),
        Constants$root.C_POINTER$LAYOUT.withName("IsUpToDate"),
        Constants$root.C_POINTER$LAYOUT.withName("GetUserClassID"),
        Constants$root.C_POINTER$LAYOUT.withName("GetUserType"),
        Constants$root.C_POINTER$LAYOUT.withName("SetExtent"),
        Constants$root.C_POINTER$LAYOUT.withName("GetExtent"),
        Constants$root.C_POINTER$LAYOUT.withName("Advise"),
        Constants$root.C_POINTER$LAYOUT.withName("Unadvise"),
        Constants$root.C_POINTER$LAYOUT.withName("EnumAdvise"),
        Constants$root.C_POINTER$LAYOUT.withName("GetMiscStatus"),
        Constants$root.C_POINTER$LAYOUT.withName("SetColorScheme")
    ).withName("IOleObjectVtbl");
    public static MemoryLayout $LAYOUT() {
        return IOleObjectVtbl.$struct$LAYOUT;
    }
    static final FunctionDescriptor QueryInterface$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.QueryInterface$FUNC
    );
    public interface QueryInterface {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(QueryInterface fi, MemorySession session) {
            return RuntimeHelper.upcallStub(QueryInterface.class, fi, IOleObjectVtbl.QueryInterface$FUNC, session);
        }
        static QueryInterface ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOleObjectVtbl.QueryInterface$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle QueryInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("QueryInterface"));
    public static VarHandle QueryInterface$VH() {
        return IOleObjectVtbl.QueryInterface$VH;
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.QueryInterface$VH.get(seg);
    }
    public static void QueryInterface$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.QueryInterface$VH.set(seg, x);
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.QueryInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void QueryInterface$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.QueryInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static QueryInterface QueryInterface (MemorySegment segment, MemorySession session) {
        return QueryInterface.ofAddress(QueryInterface$get(segment), session);
    }
    static final FunctionDescriptor AddRef$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.AddRef$FUNC
    );
    public interface AddRef {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(AddRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AddRef.class, fi, IOleObjectVtbl.AddRef$FUNC, session);
        }
        static AddRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOleObjectVtbl.AddRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AddRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AddRef"));
    public static VarHandle AddRef$VH() {
        return IOleObjectVtbl.AddRef$VH;
    }
    public static MemoryAddress AddRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.AddRef$VH.get(seg);
    }
    public static void AddRef$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.AddRef$VH.set(seg, x);
    }
    public static MemoryAddress AddRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.AddRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AddRef$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.AddRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AddRef AddRef (MemorySegment segment, MemorySession session) {
        return AddRef.ofAddress(AddRef$get(segment), session);
    }
    static final FunctionDescriptor Release$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.Release$FUNC
    );
    public interface Release {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(Release fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Release.class, fi, IOleObjectVtbl.Release$FUNC, session);
        }
        static Release ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOleObjectVtbl.Release$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Release"));
    public static VarHandle Release$VH() {
        return IOleObjectVtbl.Release$VH;
    }
    public static MemoryAddress Release$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.Release$VH.get(seg);
    }
    public static void Release$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.Release$VH.set(seg, x);
    }
    public static MemoryAddress Release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.Release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Release$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.Release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Release Release (MemorySegment segment, MemorySession session) {
        return Release.ofAddress(Release$get(segment), session);
    }
    static final FunctionDescriptor SetClientSite$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetClientSite$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.SetClientSite$FUNC
    );
    public interface SetClientSite {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(SetClientSite fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetClientSite.class, fi, IOleObjectVtbl.SetClientSite$FUNC, session);
        }
        static SetClientSite ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOleObjectVtbl.SetClientSite$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetClientSite$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetClientSite"));
    public static VarHandle SetClientSite$VH() {
        return IOleObjectVtbl.SetClientSite$VH;
    }
    public static MemoryAddress SetClientSite$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.SetClientSite$VH.get(seg);
    }
    public static void SetClientSite$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.SetClientSite$VH.set(seg, x);
    }
    public static MemoryAddress SetClientSite$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.SetClientSite$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetClientSite$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.SetClientSite$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetClientSite SetClientSite (MemorySegment segment, MemorySession session) {
        return SetClientSite.ofAddress(SetClientSite$get(segment), session);
    }
    static final FunctionDescriptor GetClientSite$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetClientSite$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetClientSite$FUNC
    );
    public interface GetClientSite {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetClientSite fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetClientSite.class, fi, IOleObjectVtbl.GetClientSite$FUNC, session);
        }
        static GetClientSite ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOleObjectVtbl.GetClientSite$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetClientSite$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetClientSite"));
    public static VarHandle GetClientSite$VH() {
        return IOleObjectVtbl.GetClientSite$VH;
    }
    public static MemoryAddress GetClientSite$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetClientSite$VH.get(seg);
    }
    public static void GetClientSite$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetClientSite$VH.set(seg, x);
    }
    public static MemoryAddress GetClientSite$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetClientSite$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetClientSite$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetClientSite$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetClientSite GetClientSite (MemorySegment segment, MemorySession session) {
        return GetClientSite.ofAddress(GetClientSite$get(segment), session);
    }
    static final FunctionDescriptor SetHostNames$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetHostNames$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.SetHostNames$FUNC
    );
    public interface SetHostNames {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(SetHostNames fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetHostNames.class, fi, IOleObjectVtbl.SetHostNames$FUNC, session);
        }
        static SetHostNames ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOleObjectVtbl.SetHostNames$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetHostNames$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetHostNames"));
    public static VarHandle SetHostNames$VH() {
        return IOleObjectVtbl.SetHostNames$VH;
    }
    public static MemoryAddress SetHostNames$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.SetHostNames$VH.get(seg);
    }
    public static void SetHostNames$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.SetHostNames$VH.set(seg, x);
    }
    public static MemoryAddress SetHostNames$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.SetHostNames$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetHostNames$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.SetHostNames$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetHostNames SetHostNames (MemorySegment segment, MemorySession session) {
        return SetHostNames.ofAddress(SetHostNames$get(segment), session);
    }
    static final FunctionDescriptor Close$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle Close$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.Close$FUNC
    );
    public interface Close {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(Close fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Close.class, fi, IOleObjectVtbl.Close$FUNC, session);
        }
        static Close ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (int)IOleObjectVtbl.Close$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Close$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Close"));
    public static VarHandle Close$VH() {
        return IOleObjectVtbl.Close$VH;
    }
    public static MemoryAddress Close$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.Close$VH.get(seg);
    }
    public static void Close$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.Close$VH.set(seg, x);
    }
    public static MemoryAddress Close$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.Close$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Close$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.Close$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Close Close (MemorySegment segment, MemorySession session) {
        return Close.ofAddress(Close$get(segment), session);
    }
    static final FunctionDescriptor SetMoniker$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetMoniker$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.SetMoniker$FUNC
    );
    public interface SetMoniker {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(SetMoniker fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetMoniker.class, fi, IOleObjectVtbl.SetMoniker$FUNC, session);
        }
        static SetMoniker ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOleObjectVtbl.SetMoniker$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetMoniker$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetMoniker"));
    public static VarHandle SetMoniker$VH() {
        return IOleObjectVtbl.SetMoniker$VH;
    }
    public static MemoryAddress SetMoniker$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.SetMoniker$VH.get(seg);
    }
    public static void SetMoniker$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.SetMoniker$VH.set(seg, x);
    }
    public static MemoryAddress SetMoniker$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.SetMoniker$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetMoniker$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.SetMoniker$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetMoniker SetMoniker (MemorySegment segment, MemorySession session) {
        return SetMoniker.ofAddress(SetMoniker$get(segment), session);
    }
    static final FunctionDescriptor GetMoniker$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetMoniker$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetMoniker$FUNC
    );
    public interface GetMoniker {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, int _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(GetMoniker fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetMoniker.class, fi, IOleObjectVtbl.GetMoniker$FUNC, session);
        }
        static GetMoniker ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, int __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)IOleObjectVtbl.GetMoniker$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetMoniker$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetMoniker"));
    public static VarHandle GetMoniker$VH() {
        return IOleObjectVtbl.GetMoniker$VH;
    }
    public static MemoryAddress GetMoniker$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetMoniker$VH.get(seg);
    }
    public static void GetMoniker$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetMoniker$VH.set(seg, x);
    }
    public static MemoryAddress GetMoniker$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetMoniker$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetMoniker$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetMoniker$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetMoniker GetMoniker (MemorySegment segment, MemorySession session) {
        return GetMoniker.ofAddress(GetMoniker$get(segment), session);
    }
    static final FunctionDescriptor InitFromData$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle InitFromData$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.InitFromData$FUNC
    );
    public interface InitFromData {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3);
        static MemorySegment allocate(InitFromData fi, MemorySession session) {
            return RuntimeHelper.upcallStub(InitFromData.class, fi, IOleObjectVtbl.InitFromData$FUNC, session);
        }
        static InitFromData ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3) -> {
                try {
                    return (int)IOleObjectVtbl.InitFromData$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle InitFromData$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("InitFromData"));
    public static VarHandle InitFromData$VH() {
        return IOleObjectVtbl.InitFromData$VH;
    }
    public static MemoryAddress InitFromData$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.InitFromData$VH.get(seg);
    }
    public static void InitFromData$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.InitFromData$VH.set(seg, x);
    }
    public static MemoryAddress InitFromData$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.InitFromData$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void InitFromData$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.InitFromData$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static InitFromData InitFromData (MemorySegment segment, MemorySession session) {
        return InitFromData.ofAddress(InitFromData$get(segment), session);
    }
    static final FunctionDescriptor GetClipboardData$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetClipboardData$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetClipboardData$FUNC
    );
    public interface GetClipboardData {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetClipboardData fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetClipboardData.class, fi, IOleObjectVtbl.GetClipboardData$FUNC, session);
        }
        static GetClipboardData ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetClipboardData$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetClipboardData$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetClipboardData"));
    public static VarHandle GetClipboardData$VH() {
        return IOleObjectVtbl.GetClipboardData$VH;
    }
    public static MemoryAddress GetClipboardData$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetClipboardData$VH.get(seg);
    }
    public static void GetClipboardData$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetClipboardData$VH.set(seg, x);
    }
    public static MemoryAddress GetClipboardData$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetClipboardData$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetClipboardData$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetClipboardData$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetClipboardData GetClipboardData (MemorySegment segment, MemorySession session) {
        return GetClipboardData.ofAddress(GetClipboardData$get(segment), session);
    }
    static final FunctionDescriptor DoVerb$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle DoVerb$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.DoVerb$FUNC
    );
    public interface DoVerb {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, int _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(DoVerb fi, MemorySession session) {
            return RuntimeHelper.upcallStub(DoVerb.class, fi, IOleObjectVtbl.DoVerb$FUNC, session);
        }
        static DoVerb ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, int __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    return (int)IOleObjectVtbl.DoVerb$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, __x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle DoVerb$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DoVerb"));
    public static VarHandle DoVerb$VH() {
        return IOleObjectVtbl.DoVerb$VH;
    }
    public static MemoryAddress DoVerb$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.DoVerb$VH.get(seg);
    }
    public static void DoVerb$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.DoVerb$VH.set(seg, x);
    }
    public static MemoryAddress DoVerb$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.DoVerb$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DoVerb$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.DoVerb$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static DoVerb DoVerb (MemorySegment segment, MemorySession session) {
        return DoVerb.ofAddress(DoVerb$get(segment), session);
    }
    static final FunctionDescriptor EnumVerbs$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle EnumVerbs$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.EnumVerbs$FUNC
    );
    public interface EnumVerbs {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(EnumVerbs fi, MemorySession session) {
            return RuntimeHelper.upcallStub(EnumVerbs.class, fi, IOleObjectVtbl.EnumVerbs$FUNC, session);
        }
        static EnumVerbs ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOleObjectVtbl.EnumVerbs$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle EnumVerbs$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("EnumVerbs"));
    public static VarHandle EnumVerbs$VH() {
        return IOleObjectVtbl.EnumVerbs$VH;
    }
    public static MemoryAddress EnumVerbs$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.EnumVerbs$VH.get(seg);
    }
    public static void EnumVerbs$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.EnumVerbs$VH.set(seg, x);
    }
    public static MemoryAddress EnumVerbs$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.EnumVerbs$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void EnumVerbs$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.EnumVerbs$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static EnumVerbs EnumVerbs (MemorySegment segment, MemorySession session) {
        return EnumVerbs.ofAddress(EnumVerbs$get(segment), session);
    }
    static final FunctionDescriptor Update$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Update$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.Update$FUNC
    );
    public interface Update {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(Update fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Update.class, fi, IOleObjectVtbl.Update$FUNC, session);
        }
        static Update ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOleObjectVtbl.Update$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Update$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Update"));
    public static VarHandle Update$VH() {
        return IOleObjectVtbl.Update$VH;
    }
    public static MemoryAddress Update$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.Update$VH.get(seg);
    }
    public static void Update$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.Update$VH.set(seg, x);
    }
    public static MemoryAddress Update$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.Update$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Update$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.Update$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Update Update (MemorySegment segment, MemorySession session) {
        return Update.ofAddress(Update$get(segment), session);
    }
    static final FunctionDescriptor IsUpToDate$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle IsUpToDate$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.IsUpToDate$FUNC
    );
    public interface IsUpToDate {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(IsUpToDate fi, MemorySession session) {
            return RuntimeHelper.upcallStub(IsUpToDate.class, fi, IOleObjectVtbl.IsUpToDate$FUNC, session);
        }
        static IsUpToDate ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOleObjectVtbl.IsUpToDate$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle IsUpToDate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("IsUpToDate"));
    public static VarHandle IsUpToDate$VH() {
        return IOleObjectVtbl.IsUpToDate$VH;
    }
    public static MemoryAddress IsUpToDate$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.IsUpToDate$VH.get(seg);
    }
    public static void IsUpToDate$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.IsUpToDate$VH.set(seg, x);
    }
    public static MemoryAddress IsUpToDate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.IsUpToDate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IsUpToDate$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.IsUpToDate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static IsUpToDate IsUpToDate (MemorySegment segment, MemorySession session) {
        return IsUpToDate.ofAddress(IsUpToDate$get(segment), session);
    }
    static final FunctionDescriptor GetUserClassID$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetUserClassID$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetUserClassID$FUNC
    );
    public interface GetUserClassID {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetUserClassID fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetUserClassID.class, fi, IOleObjectVtbl.GetUserClassID$FUNC, session);
        }
        static GetUserClassID ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOleObjectVtbl.GetUserClassID$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetUserClassID$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetUserClassID"));
    public static VarHandle GetUserClassID$VH() {
        return IOleObjectVtbl.GetUserClassID$VH;
    }
    public static MemoryAddress GetUserClassID$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetUserClassID$VH.get(seg);
    }
    public static void GetUserClassID$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetUserClassID$VH.set(seg, x);
    }
    public static MemoryAddress GetUserClassID$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetUserClassID$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetUserClassID$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetUserClassID$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetUserClassID GetUserClassID (MemorySegment segment, MemorySession session) {
        return GetUserClassID.ofAddress(GetUserClassID$get(segment), session);
    }
    static final FunctionDescriptor GetUserType$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetUserType$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetUserType$FUNC
    );
    public interface GetUserType {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetUserType fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetUserType.class, fi, IOleObjectVtbl.GetUserType$FUNC, session);
        }
        static GetUserType ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetUserType$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetUserType$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetUserType"));
    public static VarHandle GetUserType$VH() {
        return IOleObjectVtbl.GetUserType$VH;
    }
    public static MemoryAddress GetUserType$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetUserType$VH.get(seg);
    }
    public static void GetUserType$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetUserType$VH.set(seg, x);
    }
    public static MemoryAddress GetUserType$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetUserType$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetUserType$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetUserType$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetUserType GetUserType (MemorySegment segment, MemorySession session) {
        return GetUserType.ofAddress(GetUserType$get(segment), session);
    }
    static final FunctionDescriptor SetExtent$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetExtent$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.SetExtent$FUNC
    );
    public interface SetExtent {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(SetExtent fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetExtent.class, fi, IOleObjectVtbl.SetExtent$FUNC, session);
        }
        static SetExtent ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOleObjectVtbl.SetExtent$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetExtent$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetExtent"));
    public static VarHandle SetExtent$VH() {
        return IOleObjectVtbl.SetExtent$VH;
    }
    public static MemoryAddress SetExtent$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.SetExtent$VH.get(seg);
    }
    public static void SetExtent$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.SetExtent$VH.set(seg, x);
    }
    public static MemoryAddress SetExtent$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.SetExtent$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetExtent$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.SetExtent$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetExtent SetExtent (MemorySegment segment, MemorySession session) {
        return SetExtent.ofAddress(SetExtent$get(segment), session);
    }
    static final FunctionDescriptor GetExtent$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetExtent$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetExtent$FUNC
    );
    public interface GetExtent {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetExtent fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetExtent.class, fi, IOleObjectVtbl.GetExtent$FUNC, session);
        }
        static GetExtent ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetExtent$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetExtent$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetExtent"));
    public static VarHandle GetExtent$VH() {
        return IOleObjectVtbl.GetExtent$VH;
    }
    public static MemoryAddress GetExtent$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetExtent$VH.get(seg);
    }
    public static void GetExtent$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetExtent$VH.set(seg, x);
    }
    public static MemoryAddress GetExtent$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetExtent$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetExtent$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetExtent$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetExtent GetExtent (MemorySegment segment, MemorySession session) {
        return GetExtent.ofAddress(GetExtent$get(segment), session);
    }
    static final FunctionDescriptor Advise$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Advise$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.Advise$FUNC
    );
    public interface Advise {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(Advise fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Advise.class, fi, IOleObjectVtbl.Advise$FUNC, session);
        }
        static Advise ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOleObjectVtbl.Advise$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Advise$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Advise"));
    public static VarHandle Advise$VH() {
        return IOleObjectVtbl.Advise$VH;
    }
    public static MemoryAddress Advise$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.Advise$VH.get(seg);
    }
    public static void Advise$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.Advise$VH.set(seg, x);
    }
    public static MemoryAddress Advise$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.Advise$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Advise$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.Advise$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Advise Advise (MemorySegment segment, MemorySession session) {
        return Advise.ofAddress(Advise$get(segment), session);
    }
    static final FunctionDescriptor Unadvise$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle Unadvise$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.Unadvise$FUNC
    );
    public interface Unadvise {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(Unadvise fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Unadvise.class, fi, IOleObjectVtbl.Unadvise$FUNC, session);
        }
        static Unadvise ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (int)IOleObjectVtbl.Unadvise$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Unadvise$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Unadvise"));
    public static VarHandle Unadvise$VH() {
        return IOleObjectVtbl.Unadvise$VH;
    }
    public static MemoryAddress Unadvise$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.Unadvise$VH.get(seg);
    }
    public static void Unadvise$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.Unadvise$VH.set(seg, x);
    }
    public static MemoryAddress Unadvise$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.Unadvise$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Unadvise$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.Unadvise$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Unadvise Unadvise (MemorySegment segment, MemorySession session) {
        return Unadvise.ofAddress(Unadvise$get(segment), session);
    }
    static final FunctionDescriptor EnumAdvise$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle EnumAdvise$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.EnumAdvise$FUNC
    );
    public interface EnumAdvise {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(EnumAdvise fi, MemorySession session) {
            return RuntimeHelper.upcallStub(EnumAdvise.class, fi, IOleObjectVtbl.EnumAdvise$FUNC, session);
        }
        static EnumAdvise ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOleObjectVtbl.EnumAdvise$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle EnumAdvise$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("EnumAdvise"));
    public static VarHandle EnumAdvise$VH() {
        return IOleObjectVtbl.EnumAdvise$VH;
    }
    public static MemoryAddress EnumAdvise$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.EnumAdvise$VH.get(seg);
    }
    public static void EnumAdvise$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.EnumAdvise$VH.set(seg, x);
    }
    public static MemoryAddress EnumAdvise$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.EnumAdvise$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void EnumAdvise$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.EnumAdvise$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static EnumAdvise EnumAdvise (MemorySegment segment, MemorySession session) {
        return EnumAdvise.ofAddress(EnumAdvise$get(segment), session);
    }
    static final FunctionDescriptor GetMiscStatus$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetMiscStatus$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetMiscStatus$FUNC
    );
    public interface GetMiscStatus {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetMiscStatus fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetMiscStatus.class, fi, IOleObjectVtbl.GetMiscStatus$FUNC, session);
        }
        static GetMiscStatus ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetMiscStatus$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetMiscStatus$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetMiscStatus"));
    public static VarHandle GetMiscStatus$VH() {
        return IOleObjectVtbl.GetMiscStatus$VH;
    }
    public static MemoryAddress GetMiscStatus$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetMiscStatus$VH.get(seg);
    }
    public static void GetMiscStatus$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetMiscStatus$VH.set(seg, x);
    }
    public static MemoryAddress GetMiscStatus$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.GetMiscStatus$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetMiscStatus$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetMiscStatus$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetMiscStatus GetMiscStatus (MemorySegment segment, MemorySession session) {
        return GetMiscStatus.ofAddress(GetMiscStatus$get(segment), session);
    }
    static final FunctionDescriptor SetColorScheme$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetColorScheme$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.SetColorScheme$FUNC
    );
    public interface SetColorScheme {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(SetColorScheme fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetColorScheme.class, fi, IOleObjectVtbl.SetColorScheme$FUNC, session);
        }
        static SetColorScheme ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOleObjectVtbl.SetColorScheme$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetColorScheme$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetColorScheme"));
    public static VarHandle SetColorScheme$VH() {
        return IOleObjectVtbl.SetColorScheme$VH;
    }
    public static MemoryAddress SetColorScheme$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.SetColorScheme$VH.get(seg);
    }
    public static void SetColorScheme$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.SetColorScheme$VH.set(seg, x);
    }
    public static MemoryAddress SetColorScheme$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOleObjectVtbl.SetColorScheme$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetColorScheme$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.SetColorScheme$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetColorScheme SetColorScheme (MemorySegment segment, MemorySession session) {
        return SetColorScheme.ofAddress(SetColorScheme$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


